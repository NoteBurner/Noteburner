{"file_sha256":"12676993f64780e366e30e6940a5ad45a82a870059528c690f78fb9f94d70f14","base_addr":268435456,"functions":{"268442736":{"score":0.6287793,"function_name":"bn_add_words","code":"BN_ULONG bn_add_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b, int n)\n        {\n\tBN_ULLONG ll=0;\n\n\tassert(n \u003e= 0);\n\tif (n \u003c= 0) return((BN_ULONG)0);\n\n#ifndef OPENSSL_SMALL_FOOTPRINT\n\twhile (n\u0026~3)\n\t\t{\n\t\tll+=(BN_ULLONG)a[0]+b[0];\n\t\tr[0]=(BN_ULONG)ll\u0026BN_MASK2;\n\t\tll\u003e\u003e=BN_BITS2;\n\t\tll+=(BN_ULLONG)a[1]+b[1];\n\t\tr[1]=(BN_ULONG)ll\u0026BN_MASK2;\n\t\tll\u003e\u003e=BN_BITS2;\n\t\tll+=(BN_ULLONG)a[2]+b[2];\n\t\tr[2]=(BN_ULONG)ll\u0026BN_MASK2;\n\t\tll\u003e\u003e=BN_BITS2;\n\t\tll+=(BN_ULLONG)a[3]+b[3];\n\t\tr[3]=(BN_ULONG)ll\u0026BN_MASK2;\n\t\tll\u003e\u003e=BN_BITS2;\n\t\ta+=4; b+=4; r+=4; n-=4;\n\t\t}\n#endif\n\twhile (n)\n\t\t{\n\t\tll+=(BN_ULLONG)a[0]+b[0];\n\t\tr[0]=(BN_ULONG)ll\u0026BN_MASK2;\n\t\tll\u003e\u003e=BN_BITS2;\n\t\ta++; b++; r++; n--;\n\t\t}\n\treturn((BN_ULONG)ll);\n\t}","filepath":"crypto/bn/bn_asm.c","line_number":306,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"master-pre-auto-reformat"},"268443984":{"score":0.71008223,"function_name":"bn_add_words","code":"BN_ULONG bn_add_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b, int n)\n        {\n\tBN_ULONG c,l,t;\n\n\tassert(n \u003e= 0);\n\tif (n \u003c= 0) return((BN_ULONG)0);\n\n\tc=0;\n#ifndef OPENSSL_SMALL_FOOTPRINT\n\twhile (n\u0026~3)\n\t\t{\n\t\tt=a[0];\n\t\tt=(t+c)\u0026BN_MASK2;\n\t\tc=(t \u003c c);\n\t\tl=(t+b[0])\u0026BN_MASK2;\n\t\tc+=(l \u003c t);\n\t\tr[0]=l;\n\t\tt=a[1];\n\t\tt=(t+c)\u0026BN_MASK2;\n\t\tc=(t \u003c c);\n\t\tl=(t+b[1])\u0026BN_MASK2;\n\t\tc+=(l \u003c t);\n\t\tr[1]=l;\n\t\tt=a[2];\n\t\tt=(t+c)\u0026BN_MASK2;\n\t\tc=(t \u003c c);\n\t\tl=(t+b[2])\u0026BN_MASK2;\n\t\tc+=(l \u003c t);\n\t\tr[2]=l;\n\t\tt=a[3];\n\t\tt=(t+c)\u0026BN_MASK2;\n\t\tc=(t \u003c c);\n\t\tl=(t+b[3])\u0026BN_MASK2;\n\t\tc+=(l \u003c t);\n\t\tr[3]=l;\n\t\ta+=4; b+=4; r+=4; n-=4;\n\t\t}\n#endif\n\twhile(n)\n\t\t{\n\t\tt=a[0];\n\t\tt=(t+c)\u0026BN_MASK2;\n\t\tc=(t \u003c c);\n\t\tl=(t+b[0])\u0026BN_MASK2;\n\t\tc+=(l \u003c t);\n\t\tr[0]=l;\n\t\ta++; b++; r++; n--;\n\t\t}\n\treturn((BN_ULONG)c);\n\t}","filepath":"crypto/bn/bn_asm.c","line_number":341,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"master-pre-auto-reformat"},"268444432":{"score":0.68734396,"function_name":"bn_sub_words","code":"BN_ULONG bn_sub_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b, int n)\n        {\n\tBN_ULONG t1,t2;\n\tint c=0;\n\n\tassert(n \u003e= 0);\n\tif (n \u003c= 0) return((BN_ULONG)0);\n\n#ifndef OPENSSL_SMALL_FOOTPRINT\n\twhile (n\u0026~3)\n\t\t{\n\t\tt1=a[0]; t2=b[0];\n\t\tr[0]=(t1-t2-c)\u0026BN_MASK2;\n\t\tif (t1 != t2) c=(t1 \u003c t2);\n\t\tt1=a[1]; t2=b[1];\n\t\tr[1]=(t1-t2-c)\u0026BN_MASK2;\n\t\tif (t1 != t2) c=(t1 \u003c t2);\n\t\tt1=a[2]; t2=b[2];\n\t\tr[2]=(t1-t2-c)\u0026BN_MASK2;\n\t\tif (t1 != t2) c=(t1 \u003c t2);\n\t\tt1=a[3]; t2=b[3];\n\t\tr[3]=(t1-t2-c)\u0026BN_MASK2;\n\t\tif (t1 != t2) c=(t1 \u003c t2);\n\t\ta+=4; b+=4; r+=4; n-=4;\n\t\t}\n#endif\n\twhile (n)\n\t\t{\n\t\tt1=a[0]; t2=b[0];\n\t\tr[0]=(t1-t2-c)\u0026BN_MASK2;\n\t\tif (t1 != t2) c=(t1 \u003c t2);\n\t\ta++; b++; r++; n--;\n\t\t}\n\treturn(c);\n\t}","filepath":"crypto/bn/bn_asm.c","line_number":393,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"master-pre-auto-reformat"},"268445888":{"score":0.8931334,"function_name":"bn_mul_comba4","code":"void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n\t{\n\tBN_ULONG c1,c2,c3;\n\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tmul_add_c(a[0],b[0],c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tmul_add_c(a[0],b[1],c2,c3,c1);\n\tmul_add_c(a[1],b[0],c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tmul_add_c(a[2],b[0],c3,c1,c2);\n\tmul_add_c(a[1],b[1],c3,c1,c2);\n\tmul_add_c(a[0],b[2],c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tmul_add_c(a[0],b[3],c1,c2,c3);\n\tmul_add_c(a[1],b[2],c1,c2,c3);\n\tmul_add_c(a[2],b[1],c1,c2,c3);\n\tmul_add_c(a[3],b[0],c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tmul_add_c(a[3],b[1],c2,c3,c1);\n\tmul_add_c(a[2],b[2],c2,c3,c1);\n\tmul_add_c(a[1],b[3],c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tmul_add_c(a[2],b[3],c3,c1,c2);\n\tmul_add_c(a[3],b[2],c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tmul_add_c(a[3],b[3],c1,c2,c3);\n\tr[6]=c1;\n\tr[7]=c2;\n\t}","filepath":"crypto/bn/bn_asm.c","line_number":687,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"master-pre-auto-reformat"},"268447312":{"score":0.7890173,"function_name":"bn_sqr_comba8","code":"void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)\n\t{\n\tBN_ULONG c1,c2,c3;\n\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tsqr_add_c(a,0,c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tsqr_add_c2(a,1,0,c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tsqr_add_c(a,1,c3,c1,c2);\n\tsqr_add_c2(a,2,0,c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tsqr_add_c2(a,3,0,c1,c2,c3);\n\tsqr_add_c2(a,2,1,c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tsqr_add_c(a,2,c2,c3,c1);\n\tsqr_add_c2(a,3,1,c2,c3,c1);\n\tsqr_add_c2(a,4,0,c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tsqr_add_c2(a,5,0,c3,c1,c2);\n\tsqr_add_c2(a,4,1,c3,c1,c2);\n\tsqr_add_c2(a,3,2,c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tsqr_add_c(a,3,c1,c2,c3);\n\tsqr_add_c2(a,4,2,c1,c2,c3);\n\tsqr_add_c2(a,5,1,c1,c2,c3);\n\tsqr_add_c2(a,6,0,c1,c2,c3);\n\tr[6]=c1;\n\tc1=0;\n\tsqr_add_c2(a,7,0,c2,c3,c1);\n\tsqr_add_c2(a,6,1,c2,c3,c1);\n\tsqr_add_c2(a,5,2,c2,c3,c1);\n\tsqr_add_c2(a,4,3,c2,c3,c1);\n\tr[7]=c2;\n\tc2=0;\n\tsqr_add_c(a,4,c3,c1,c2);\n\tsqr_add_c2(a,5,3,c3,c1,c2);\n\tsqr_add_c2(a,6,2,c3,c1,c2);\n\tsqr_add_c2(a,7,1,c3,c1,c2);\n\tr[8]=c3;\n\tc3=0;\n\tsqr_add_c2(a,7,2,c1,c2,c3);\n\tsqr_add_c2(a,6,3,c1,c2,c3);\n\tsqr_add_c2(a,5,4,c1,c2,c3);\n\tr[9]=c1;\n\tc1=0;\n\tsqr_add_c(a,5,c2,c3,c1);\n\tsqr_add_c2(a,6,4,c2,c3,c1);\n\tsqr_add_c2(a,7,3,c2,c3,c1);\n\tr[10]=c2;\n\tc2=0;\n\tsqr_add_c2(a,7,4,c3,c1,c2);\n\tsqr_add_c2(a,6,5,c3,c1,c2);\n\tr[11]=c3;\n\tc3=0;\n\tsqr_add_c(a,6,c1,c2,c3);\n\tsqr_add_c2(a,7,5,c1,c2,c3);\n\tr[12]=c1;\n\tc1=0;\n\tsqr_add_c2(a,7,6,c2,c3,c1);\n\tr[13]=c2;\n\tc2=0;\n\tsqr_add_c(a,7,c3,c1,c2);\n\tr[14]=c3;\n\tr[15]=c1;\n\t}","filepath":"crypto/bn/bn_asm.c","line_number":726,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"master-pre-auto-reformat"},"268448128":{"score":0.7812927,"function_name":"bn_sqr_comba4","code":"void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)\n\t{\n\tBN_ULONG c1,c2,c3;\n\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tsqr_add_c(a,0,c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tsqr_add_c2(a,1,0,c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tsqr_add_c(a,1,c3,c1,c2);\n\tsqr_add_c2(a,2,0,c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tsqr_add_c2(a,3,0,c1,c2,c3);\n\tsqr_add_c2(a,2,1,c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tsqr_add_c(a,2,c2,c3,c1);\n\tsqr_add_c2(a,3,1,c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tsqr_add_c2(a,3,2,c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tsqr_add_c(a,3,c1,c2,c3);\n\tr[6]=c1;\n\tr[7]=c2;\n\t}","filepath":"crypto/bn/bn_asm.c","line_number":801,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"master-pre-auto-reformat"},"268672832":{"score":0.856567,"function_name":"des_encrypt","code":"void des_encrypt(DES_LONG *data, des_key_schedule ks, int enc)\n\t{\n\tregister DES_LONG l,r,t,u;\n#ifdef DES_PTR\n\tregister const unsigned char *des_SP=(const unsigned char *)des_SPtrans;\n#endif\n#ifndef DES_UNROLL\n\tregister int i;\n#endif\n\tregister DES_LONG *s;\n\n\tr=data[0];\n\tl=data[1];\n\n\tIP(r,l);\n\t/* Things have been modified so that the initial rotate is\n\t * done outside the loop.  This required the\n\t * des_SPtrans values in sp.h to be rotated 1 bit to the right.\n\t * One perl script later and things have a 5% speed up on a sparc2.\n\t * Thanks to Richard Outerbridge \u003c71755.204@CompuServe.COM\u003e\n\t * for pointing this out. */\n\t/* clear the top bits on machines with 8byte longs */\n\t/* shift left by 2 */\n\tr=ROTATE(r,29)\u00260xffffffffL;\n\tl=ROTATE(l,29)\u00260xffffffffL;\n\n\ts=(DES_LONG *)ks;\n\t/* I don't know if it is worth the effort of loop unrolling the\n\t * inner loop */\n\tif (enc)\n\t\t{\n#ifdef DES_UNROLL\n\t\tD_ENCRYPT(l,r, 0); /*  1 */\n\t\tD_ENCRYPT(r,l, 2); /*  2 */\n\t\tD_ENCRYPT(l,r, 4); /*  3 */\n\t\tD_ENCRYPT(r,l, 6); /*  4 */\n\t\tD_ENCRYPT(l,r, 8); /*  5 */\n\t\tD_ENCRYPT(r,l,10); /*  6 */\n\t\tD_ENCRYPT(l,r,12); /*  7 */\n\t\tD_ENCRYPT(r,l,14); /*  8 */\n\t\tD_ENCRYPT(l,r,16); /*  9 */\n\t\tD_ENCRYPT(r,l,18); /*  10 */\n\t\tD_ENCRYPT(l,r,20); /*  11 */\n\t\tD_ENCRYPT(r,l,22); /*  12 */\n\t\tD_ENCRYPT(l,r,24); /*  13 */\n\t\tD_ENCRYPT(r,l,26); /*  14 */\n\t\tD_ENCRYPT(l,r,28); /*  15 */\n\t\tD_ENCRYPT(r,l,30); /*  16 */\n#else\n\t\tfor (i=0; i\u003c32; i+=8)\n\t\t\t{\n\t\t\tD_ENCRYPT(l,r,i+0); /*  1 */\n\t\t\tD_ENCRYPT(r,l,i+2); /*  2 */\n\t\t\tD_ENCRYPT(l,r,i+4); /*  3 */\n\t\t\tD_ENCRYPT(r,l,i+6); /*  4 */\n\t\t\t}\n#endif\n\t\t}\n\telse\n\t\t{\n#ifdef DES_UNROLL\n\t\tD_ENCRYPT(l,r,30); /* 16 */\n\t\tD_ENCRYPT(r,l,28); /* 15 */\n\t\tD_ENCRYPT(l,r,26); /* 14 */\n\t\tD_ENCRYPT(r,l,24); /* 13 */\n\t\tD_ENCRYPT(l,r,22); /* 12 */\n\t\tD_ENCRYPT(r,l,20); /* 11 */\n\t\tD_ENCRYPT(l,r,18); /* 10 */\n\t\tD_ENCRYPT(r,l,16); /*  9 */\n\t\tD_ENCRYPT(l,r,14); /*  8 */\n\t\tD_ENCRYPT(r,l,12); /*  7 */\n\t\tD_ENCRYPT(l,r,10); /*  6 */\n\t\tD_ENCRYPT(r,l, 8); /*  5 */\n\t\tD_ENCRYPT(l,r, 6); /*  4 */\n\t\tD_ENCRYPT(r,l, 4); /*  3 */\n\t\tD_ENCRYPT(l,r, 2); /*  2 */\n\t\tD_ENCRYPT(r,l, 0); /*  1 */\n#else\n\t\tfor (i=30; i\u003e0; i-=8)\n\t\t\t{\n\t\t\tD_ENCRYPT(l,r,i-0); /* 16 */\n\t\t\tD_ENCRYPT(r,l,i-2); /* 15 */\n\t\t\tD_ENCRYPT(l,r,i-4); /* 14 */\n\t\t\tD_ENCRYPT(r,l,i-6); /* 13 */\n\t\t\t}\n#endif\n\t\t}\n\n\t/* rotate and clear the top bits on machines with 8byte longs */\n\tl=ROTATE(l,3)\u00260xffffffffL;\n\tr=ROTATE(r,3)\u00260xffffffffL;\n\n\tFP(r,l);\n\tdata[0]=l;\n\tdata[1]=r;\n\tl=r=t=u=0;\n\t}","filepath":"crypto/des/des_enc.c","line_number":61,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_0_9_3beta1"},"268673088":{"score":0.6099925,"function_name":"des_encrypt2","code":"void des_encrypt2(DES_LONG *data, des_key_schedule ks, int enc)\n\t{\n\tregister DES_LONG l,r,t,u;\n#ifdef DES_PTR\n\tregister const unsigned char *des_SP=(const unsigned char *)des_SPtrans;\n#endif\n#ifndef DES_UNROLL\n\tregister int i;\n#endif\n\tregister DES_LONG *s;\n\n\tr=data[0];\n\tl=data[1];\n\n\t/* Things have been modified so that the initial rotate is\n\t * done outside the loop.  This required the\n\t * des_SPtrans values in sp.h to be rotated 1 bit to the right.\n\t * One perl script later and things have a 5% speed up on a sparc2.\n\t * Thanks to Richard Outerbridge \u003c71755.204@CompuServe.COM\u003e\n\t * for pointing this out. */\n\t/* clear the top bits on machines with 8byte longs */\n\tr=ROTATE(r,29)\u00260xffffffffL;\n\tl=ROTATE(l,29)\u00260xffffffffL;\n\n\ts=(DES_LONG *)ks;\n\t/* I don't know if it is worth the effort of loop unrolling the\n\t * inner loop */\n\tif (enc)\n\t\t{\n#ifdef DES_UNROLL\n\t\tD_ENCRYPT(l,r, 0); /*  1 */\n\t\tD_ENCRYPT(r,l, 2); /*  2 */\n\t\tD_ENCRYPT(l,r, 4); /*  3 */\n\t\tD_ENCRYPT(r,l, 6); /*  4 */\n\t\tD_ENCRYPT(l,r, 8); /*  5 */\n\t\tD_ENCRYPT(r,l,10); /*  6 */\n\t\tD_ENCRYPT(l,r,12); /*  7 */\n\t\tD_ENCRYPT(r,l,14); /*  8 */\n\t\tD_ENCRYPT(l,r,16); /*  9 */\n\t\tD_ENCRYPT(r,l,18); /*  10 */\n\t\tD_ENCRYPT(l,r,20); /*  11 */\n\t\tD_ENCRYPT(r,l,22); /*  12 */\n\t\tD_ENCRYPT(l,r,24); /*  13 */\n\t\tD_ENCRYPT(r,l,26); /*  14 */\n\t\tD_ENCRYPT(l,r,28); /*  15 */\n\t\tD_ENCRYPT(r,l,30); /*  16 */\n#else\n\t\tfor (i=0; i\u003c32; i+=8)\n\t\t\t{\n\t\t\tD_ENCRYPT(l,r,i+0); /*  1 */\n\t\t\tD_ENCRYPT(r,l,i+2); /*  2 */\n\t\t\tD_ENCRYPT(l,r,i+4); /*  3 */\n\t\t\tD_ENCRYPT(r,l,i+6); /*  4 */\n\t\t\t}\n#endif\n\t\t}\n\telse\n\t\t{\n#ifdef DES_UNROLL\n\t\tD_ENCRYPT(l,r,30); /* 16 */\n\t\tD_ENCRYPT(r,l,28); /* 15 */\n\t\tD_ENCRYPT(l,r,26); /* 14 */\n\t\tD_ENCRYPT(r,l,24); /* 13 */\n\t\tD_ENCRYPT(l,r,22); /* 12 */\n\t\tD_ENCRYPT(r,l,20); /* 11 */\n\t\tD_ENCRYPT(l,r,18); /* 10 */\n\t\tD_ENCRYPT(r,l,16); /*  9 */\n\t\tD_ENCRYPT(l,r,14); /*  8 */\n\t\tD_ENCRYPT(r,l,12); /*  7 */\n\t\tD_ENCRYPT(l,r,10); /*  6 */\n\t\tD_ENCRYPT(r,l, 8); /*  5 */\n\t\tD_ENCRYPT(l,r, 6); /*  4 */\n\t\tD_ENCRYPT(r,l, 4); /*  3 */\n\t\tD_ENCRYPT(l,r, 2); /*  2 */\n\t\tD_ENCRYPT(r,l, 0); /*  1 */\n#else\n\t\tfor (i=30; i\u003e0; i-=8)\n\t\t\t{\n\t\t\tD_ENCRYPT(l,r,i-0); /* 16 */\n\t\t\tD_ENCRYPT(r,l,i-2); /* 15 */\n\t\t\tD_ENCRYPT(l,r,i-4); /* 14 */\n\t\t\tD_ENCRYPT(r,l,i-6); /* 13 */\n\t\t\t}\n#endif\n\t\t}\n\t/* rotate and clear the top bits on machines with 8byte longs */\n\tdata[0]=ROTATE(l,3)\u00260xffffffffL;\n\tdata[1]=ROTATE(r,3)\u00260xffffffffL;\n\tl=r=t=u=0;\n\t}","filepath":"crypto/des/des_enc.c","line_number":159,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_0_9_3beta1"},"268673184":{"score":0.77927506,"function_name":"des_encrypt3","code":"void des_encrypt3(DES_LONG *data, des_key_schedule ks1, des_key_schedule ks2,\n\t     des_key_schedule ks3)\n\t{\n\tregister DES_LONG l,r;\n\n\tl=data[0];\n\tr=data[1];\n\tIP(l,r);\n\tdata[0]=l;\n\tdata[1]=r;\n\tdes_encrypt2((DES_LONG *)data,ks1,DES_ENCRYPT);\n\tdes_encrypt2((DES_LONG *)data,ks2,DES_DECRYPT);\n\tdes_encrypt2((DES_LONG *)data,ks3,DES_ENCRYPT);\n\tl=data[0];\n\tr=data[1];\n\tFP(r,l);\n\tdata[0]=l;\n\tdata[1]=r;\n\t}","filepath":"crypto/des/des_enc.c","line_number":250,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_0_9_3beta1"},"268673488":{"score":0.7646192,"function_name":"des_decrypt3","code":"void des_decrypt3(DES_LONG *data, des_key_schedule ks1, des_key_schedule ks2,\n\t     des_key_schedule ks3)\n\t{\n\tregister DES_LONG l,r;\n\n\tl=data[0];\n\tr=data[1];\n\tIP(l,r);\n\tdata[0]=l;\n\tdata[1]=r;\n\tdes_encrypt2((DES_LONG *)data,ks3,DES_DECRYPT);\n\tdes_encrypt2((DES_LONG *)data,ks2,DES_ENCRYPT);\n\tdes_encrypt2((DES_LONG *)data,ks1,DES_DECRYPT);\n\tl=data[0];\n\tr=data[1];\n\tFP(r,l);\n\tdata[0]=l;\n\tdata[1]=r;\n\t}","filepath":"crypto/des/des_enc.c","line_number":270,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_0_9_3beta1"},"268673792":{"score":0.87221617,"function_name":"des_ncbc_encrypt","code":"void des_ncbc_encrypt(const unsigned char *in, unsigned char *out, long length,\n\t     des_key_schedule schedule, des_cblock *ivec, int enc)\n\t{\n\tregister DES_LONG tin0,tin1;\n\tregister DES_LONG tout0,tout1,xor0,xor1;\n\tregister long l=length;\n\tDES_LONG tin[2];\n\tunsigned char *iv;\n\n\tiv = \u0026(*ivec)[0];\n\n\tif (enc)\n\t\t{\n\t\tc2l(iv,tout0);\n\t\tc2l(iv,tout1);\n\t\tfor (l-=8; l\u003e=0; l-=8)\n\t\t\t{\n\t\t\tc2l(in,tin0);\n\t\t\tc2l(in,tin1);\n\t\t\ttin0^=tout0; tin[0]=tin0;\n\t\t\ttin1^=tout1; tin[1]=tin1;\n\t\t\tdes_encrypt((DES_LONG *)tin,schedule,DES_ENCRYPT);\n\t\t\ttout0=tin[0]; l2c(tout0,out);\n\t\t\ttout1=tin[1]; l2c(tout1,out);\n\t\t\t}\n\t\tif (l != -8)\n\t\t\t{\n\t\t\tc2ln(in,tin0,tin1,l+8);\n\t\t\ttin0^=tout0; tin[0]=tin0;\n\t\t\ttin1^=tout1; tin[1]=tin1;\n\t\t\tdes_encrypt((DES_LONG *)tin,schedule,DES_ENCRYPT);\n\t\t\ttout0=tin[0]; l2c(tout0,out);\n\t\t\ttout1=tin[1]; l2c(tout1,out);\n\t\t\t}\n\t\tiv = \u0026(*ivec)[0];\n\t\tl2c(tout0,iv);\n\t\tl2c(tout1,iv);\n\t\t}\n\telse\n\t\t{\n\t\tc2l(iv,xor0);\n\t\tc2l(iv,xor1);\n\t\tfor (l-=8; l\u003e=0; l-=8)\n\t\t\t{\n\t\t\tc2l(in,tin0); tin[0]=tin0;\n\t\t\tc2l(in,tin1); tin[1]=tin1;\n\t\t\tdes_encrypt((DES_LONG *)tin,schedule,DES_DECRYPT);\n\t\t\ttout0=tin[0]^xor0;\n\t\t\ttout1=tin[1]^xor1;\n\t\t\tl2c(tout0,out);\n\t\t\tl2c(tout1,out);\n\t\t\txor0=tin0;\n\t\t\txor1=tin1;\n\t\t\t}\n\t\tif (l != -8)\n\t\t\t{\n\t\t\tc2l(in,tin0); tin[0]=tin0;\n\t\t\tc2l(in,tin1); tin[1]=tin1;\n\t\t\tdes_encrypt((DES_LONG *)tin,schedule,DES_DECRYPT);\n\t\t\ttout0=tin[0]^xor0;\n\t\t\ttout1=tin[1]^xor1;\n\t\t\tl2cn(tout0,tout1,out,l+8);\n\t\t\txor0=tin0;\n\t\t\txor1=tin1;\n\t\t\t}\n\n\t\tiv = \u0026(*ivec)[0];\n\t\tl2c(xor0,iv);\n\t\tl2c(xor1,iv);\n\t\t}\n\ttin0=tin1=tout0=tout1=xor0=xor1=0;\n\ttin[0]=tin[1]=0;\n\t}","filepath":"crypto/des/des_enc.c","line_number":292,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_0_9_3beta1"},"268674304":{"score":0.8538791,"function_name":"des_ede3_cbc_encrypt","code":"void des_ede3_cbc_encrypt(const unsigned char *input, unsigned char *output,\n\t     long length, des_key_schedule ks1, des_key_schedule ks2,\n\t     des_key_schedule ks3, des_cblock *ivec, int enc)\n\t{\n\tregister DES_LONG tin0,tin1;\n\tregister DES_LONG tout0,tout1,xor0,xor1;\n\tregister const unsigned char *in;\n\tunsigned char *out;\n\tregister long l=length;\n\tDES_LONG tin[2];\n\tunsigned char *iv;\n\n\tin=input;\n\tout=output;\n\tiv = \u0026(*ivec)[0];\n\n\tif (enc)\n\t\t{\n\t\tc2l(iv,tout0);\n\t\tc2l(iv,tout1);\n\t\tfor (l-=8; l\u003e=0; l-=8)\n\t\t\t{\n\t\t\tc2l(in,tin0);\n\t\t\tc2l(in,tin1);\n\t\t\ttin0^=tout0;\n\t\t\ttin1^=tout1;\n\n\t\t\ttin[0]=tin0;\n\t\t\ttin[1]=tin1;\n\t\t\tdes_encrypt3((DES_LONG *)tin,ks1,ks2,ks3);\n\t\t\ttout0=tin[0];\n\t\t\ttout1=tin[1];\n\n\t\t\tl2c(tout0,out);\n\t\t\tl2c(tout1,out);\n\t\t\t}\n\t\tif (l != -8)\n\t\t\t{\n\t\t\tc2ln(in,tin0,tin1,l+8);\n\t\t\ttin0^=tout0;\n\t\t\ttin1^=tout1;\n\n\t\t\ttin[0]=tin0;\n\t\t\ttin[1]=tin1;\n\t\t\tdes_encrypt3((DES_LONG *)tin,ks1,ks2,ks3);\n\t\t\ttout0=tin[0];\n\t\t\ttout1=tin[1];\n\n\t\t\tl2c(tout0,out);\n\t\t\tl2c(tout1,out);\n\t\t\t}\n\t\tiv = \u0026(*ivec)[0];\n\t\tl2c(tout0,iv);\n\t\tl2c(tout1,iv);\n\t\t}\n\telse\n\t\t{\n\t\tregister DES_LONG t0,t1;\n\n\t\tc2l(iv,xor0);\n\t\tc2l(iv,xor1);\n\t\tfor (l-=8; l\u003e=0; l-=8)\n\t\t\t{\n\t\t\tc2l(in,tin0);\n\t\t\tc2l(in,tin1);\n\n\t\t\tt0=tin0;\n\t\t\tt1=tin1;\n\n\t\t\ttin[0]=tin0;\n\t\t\ttin[1]=tin1;\n\t\t\tdes_decrypt3((DES_LONG *)tin,ks1,ks2,ks3);\n\t\t\ttout0=tin[0];\n\t\t\ttout1=tin[1];\n\n\t\t\ttout0^=xor0;\n\t\t\ttout1^=xor1;\n\t\t\tl2c(tout0,out);\n\t\t\tl2c(tout1,out);\n\t\t\txor0=t0;\n\t\t\txor1=t1;\n\t\t\t}\n\t\tif (l != -8)\n\t\t\t{\n\t\t\tc2l(in,tin0);\n\t\t\tc2l(in,tin1);\n\t\t\t\n\t\t\tt0=tin0;\n\t\t\tt1=tin1;\n\n\t\t\ttin[0]=tin0;\n\t\t\ttin[1]=tin1;\n\t\t\tdes_decrypt3((DES_LONG *)tin,ks1,ks2,ks3);\n\t\t\ttout0=tin[0];\n\t\t\ttout1=tin[1];\n\t\t\n\t\t\ttout0^=xor0;\n\t\t\ttout1^=xor1;\n\t\t\tl2cn(tout0,tout1,out,l+8);\n\t\t\txor0=t0;\n\t\t\txor1=t1;\n\t\t\t}\n\n\t\tiv = \u0026(*ivec)[0];\n\t\tl2c(xor0,iv);\n\t\tl2c(xor1,iv);\n\t\t}\n\ttin0=tin1=tout0=tout1=xor0=xor1=0;\n\ttin[0]=tin[1]=0;\n\t}","filepath":"crypto/des/des_enc.c","line_number":366,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_0_9_3beta1"},"268736720":{"score":0.8714243,"function_name":"Reader::readToken","code":"bool Reader::readToken(Token\u0026 token) {\n  skipSpaces();\n  token.start_ = current_;\n  Char c = getNextChar();\n  bool ok = true;\n  switch (c) {\n  case '{':\n    token.type_ = tokenObjectBegin;\n    break;\n  case '}':\n    token.type_ = tokenObjectEnd;\n    break;\n  case '[':\n    token.type_ = tokenArrayBegin;\n    break;\n  case ']':\n    token.type_ = tokenArrayEnd;\n    break;\n  case '\"':\n    token.type_ = tokenString;\n    ok = readString();\n    break;\n  case '/':\n    token.type_ = tokenComment;\n    ok = readComment();\n    break;\n  case '0':\n  case '1':\n  case '2':\n  case '3':\n  case '4':\n  case '5':\n  case '6':\n  case '7':\n  case '8':\n  case '9':\n  case '-':\n    token.type_ = tokenNumber;\n    readNumber();\n    break;\n  case 't':\n    token.type_ = tokenTrue;\n    ok = match(\"rue\", 3);\n    break;\n  case 'f':\n    token.type_ = tokenFalse;\n    ok = match(\"alse\", 4);\n    break;\n  case 'n':\n    token.type_ = tokenNull;\n    ok = match(\"ull\", 3);\n    break;\n  case ',':\n    token.type_ = tokenArraySeparator;\n    break;\n  case ':':\n    token.type_ = tokenMemberSeparator;\n    break;\n  case 0:\n    token.type_ = tokenEndOfStream;\n    break;\n  default:\n    ok = false;\n    break;\n  }\n  if (!ok)\n    token.type_ = tokenError;\n  token.end_ = current_;\n  return true;\n}","filepath":"src/lib_json/json_reader.cpp","line_number":257,"entry_url":"https://github.com/open-source-parsers/jsoncpp.git","slot_name":"1.7.6"},"268737280":{"score":0.87934935,"function_name":"Reader::match","code":"bool Reader::match(Location pattern, int patternLength) {\n  if (end_ - current_ \u003c patternLength)\n    return false;\n  int index = patternLength;\n  while (index--)\n    if (current_[index] != pattern[index])\n      return false;\n  current_ += patternLength;\n  return true;\n}","filepath":"src/lib_json/json_reader.cpp","line_number":338,"entry_url":"https://github.com/open-source-parsers/jsoncpp.git","slot_name":"1.7.6"},"268737376":{"score":0.7741159,"function_name":"OurReader::readComment","code":"bool OurReader::readComment() {\n  Location commentBegin = current_ - 1;\n  Char c = getNextChar();\n  bool successful = false;\n  if (c == '*')\n    successful = readCStyleComment();\n  else if (c == '/')\n    successful = readCppStyleComment();\n  if (!successful)\n    return false;\n\n  if (collectComments_) {\n    CommentPlacement placement = commentBefore;\n    if (lastValueEnd_ \u0026\u0026 !containsNewLine(lastValueEnd_, commentBegin)) {\n      if (c != '*' || !containsNewLine(commentBegin, current_))\n        placement = commentAfterOnSameLine;\n    }\n\n    addComment(commentBegin, current_, placement);\n  }\n  return true;\n}","filepath":"src/lib_json/json_reader.cpp","line_number":1328,"entry_url":"https://github.com/open-source-parsers/jsoncpp.git","slot_name":"1.7.6"},"268737536":{"score":0.79160905,"function_name":"normalizeEOL","code":"static JSONCPP_STRING normalizeEOL(Reader::Location begin, Reader::Location end) {\n  JSONCPP_STRING normalized;\n  normalized.reserve(static_cast\u003csize_t\u003e(end - begin));\n  Reader::Location current = begin;\n  while (current != end) {\n    char c = *current++;\n    if (c == '\\r') {\n      if (current != end \u0026\u0026 *current == '\\n')\n         // convert dos EOL\n         ++current;\n      // convert Mac EOL\n      normalized += '\\n';\n    } else {\n      normalized += c;\n    }\n  }\n  return normalized;\n}","filepath":"src/lib_json/json_reader.cpp","line_number":372,"entry_url":"https://github.com/open-source-parsers/jsoncpp.git","slot_name":"1.7.6"},"268738224":{"score":0.8403145,"function_name":"OurReader::readCStyleComment","code":"bool OurReader::readCStyleComment() {\n  while ((current_ + 1) \u003c end_) {\n    Char c = getNextChar();\n    if (c == '*' \u0026\u0026 *current_ == '/')\n      break;\n  }\n  return getNextChar() == '/';\n}","filepath":"src/lib_json/json_reader.cpp","line_number":1363,"entry_url":"https://github.com/open-source-parsers/jsoncpp.git","slot_name":"1.7.6"},"268738304":{"score":0.9094106,"function_name":"Reader::readCppStyleComment","code":"bool Reader::readCppStyleComment() {\n  while (current_ != end_) {\n    Char c = getNextChar();\n    if (c == '\\n')\n      break;\n    if (c == '\\r') {\n      // Consume DOS EOL. It will be normalized in addComment.\n      if (current_ != end_ \u0026\u0026 *current_ == '\\n')\n        getNextChar();\n      // Break on Moc OS 9 EOL.\n      break;\n    }\n  }\n  return true;\n}","filepath":"src/lib_json/json_reader.cpp","line_number":412,"entry_url":"https://github.com/open-source-parsers/jsoncpp.git","slot_name":"1.7.6"},"268738368":{"score":0.9027771,"function_name":"Reader::readNumber","code":"void Reader::readNumber() {\n  const char *p = current_;\n  char c = '0'; // stopgap for already consumed character\n  // integral part\n  while (c \u003e= '0' \u0026\u0026 c \u003c= '9')\n    c = (current_ = p) \u003c end_ ? *p++ : '\\0';\n  // fractional part\n  if (c == '.') {\n    c = (current_ = p) \u003c end_ ? *p++ : '\\0';\n    while (c \u003e= '0' \u0026\u0026 c \u003c= '9')\n      c = (current_ = p) \u003c end_ ? *p++ : '\\0';\n  }\n  // exponential part\n  if (c == 'e' || c == 'E') {\n    c = (current_ = p) \u003c end_ ? *p++ : '\\0';\n    if (c == '+' || c == '-')\n      c = (current_ = p) \u003c end_ ? *p++ : '\\0';\n    while (c \u003e= '0' \u0026\u0026 c \u003c= '9')\n      c = (current_ = p) \u003c end_ ? *p++ : '\\0';\n  }\n}","filepath":"src/lib_json/json_reader.cpp","line_number":428,"entry_url":"https://github.com/open-source-parsers/jsoncpp.git","slot_name":"1.7.6"},"268738512":{"score":0.92337364,"function_name":"Reader::readString","code":"bool Reader::readString() {\n  Char c = '\\0';\n  while (current_ != end_) {\n    c = getNextChar();\n    if (c == '\\\\')\n      getNextChar();\n    else if (c == '\"')\n      break;\n  }\n  return c == '\"';\n}","filepath":"src/lib_json/json_reader.cpp","line_number":450,"entry_url":"https://github.com/open-source-parsers/jsoncpp.git","slot_name":"1.7.6"},"268743520":{"score":0.66908807,"function_name":"Reader::decodeString","code":"bool Reader::decodeString(Token\u0026 token, JSONCPP_STRING\u0026 decoded) {\n  decoded.reserve(static_cast\u003csize_t\u003e(token.end_ - token.start_ - 2));\n  Location current = token.start_ + 1; // skip '\"'\n  Location end = token.end_ - 1;       // do not include '\"'\n  while (current != end) {\n    Char c = *current++;\n    if (c == '\"')\n      break;\n    else if (c == '\\\\') {\n      if (current == end)\n        return addError(\"Empty escape sequence in string\", token, current);\n      Char escape = *current++;\n      switch (escape) {\n      case '\"':\n        decoded += '\"';\n        break;\n      case '/':\n        decoded += '/';\n        break;\n      case '\\\\':\n        decoded += '\\\\';\n        break;\n      case 'b':\n        decoded += '\\b';\n        break;\n      case 'f':\n        decoded += '\\f';\n        break;\n      case 'n':\n        decoded += '\\n';\n        break;\n      case 'r':\n        decoded += '\\r';\n        break;\n      case 't':\n        decoded += '\\t';\n        break;\n      case 'u': {\n        unsigned int unicode;\n        if (!decodeUnicodeCodePoint(token, current, end, unicode))\n          return false;\n        decoded += codePointToUTF8(unicode);\n      } break;\n      default:\n        return addError(\"Bad escape sequence in string\", token, current);\n      }\n    } else {\n      decoded += c;\n    }\n  }\n  return true;\n}","filepath":"src/lib_json/json_reader.cpp","line_number":641,"entry_url":"https://github.com/open-source-parsers/jsoncpp.git","slot_name":"1.7.6"},"268744416":{"score":0.7760738,"function_name":"Reader::decodeUnicodeCodePoint","code":"bool Reader::decodeUnicodeCodePoint(Token\u0026 token,\n                                    Location\u0026 current,\n                                    Location end,\n                                    unsigned int\u0026 unicode) {\n\n  if (!decodeUnicodeEscapeSequence(token, current, end, unicode))\n    return false;\n  if (unicode \u003e= 0xD800 \u0026\u0026 unicode \u003c= 0xDBFF) {\n    // surrogate pairs\n    if (end - current \u003c 6)\n      return addError(\n          \"additional six characters expected to parse unicode surrogate pair.\",\n          token,\n          current);\n    unsigned int surrogatePair;\n    if (*(current++) == '\\\\' \u0026\u0026 *(current++) == 'u') {\n      if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {\n        unicode = 0x10000 + ((unicode \u0026 0x3FF) \u003c\u003c 10) + (surrogatePair \u0026 0x3FF);\n      } else\n        return false;\n    } else\n      return addError(\"expecting another \\\\u token to begin the second half of \"\n                      \"a unicode surrogate pair\",\n                      token,\n                      current);\n  }\n  return true;\n}","filepath":"src/lib_json/json_reader.cpp","line_number":694,"entry_url":"https://github.com/open-source-parsers/jsoncpp.git","slot_name":"1.7.6"},"268744784":{"score":0.77794826,"function_name":"Reader::decodeUnicodeEscapeSequence","code":"bool Reader::decodeUnicodeEscapeSequence(Token\u0026 token,\n                                         Location\u0026 current,\n                                         Location end,\n                                         unsigned int\u0026 ret_unicode) {\n  if (end - current \u003c 4)\n    return addError(\n        \"Bad unicode escape sequence in string: four digits expected.\",\n        token,\n        current);\n  int unicode = 0;\n  for (int index = 0; index \u003c 4; ++index) {\n    Char c = *current++;\n    unicode *= 16;\n    if (c \u003e= '0' \u0026\u0026 c \u003c= '9')\n      unicode += c - '0';\n    else if (c \u003e= 'a' \u0026\u0026 c \u003c= 'f')\n      unicode += c - 'a' + 10;\n    else if (c \u003e= 'A' \u0026\u0026 c \u003c= 'F')\n      unicode += c - 'A' + 10;\n    else\n      return addError(\n          \"Bad unicode escape sequence in string: hexadecimal digit expected.\",\n          token,\n          current);\n  }\n  ret_unicode = static_cast\u003cunsigned int\u003e(unicode);\n  return true;\n}","filepath":"src/lib_json/json_reader.cpp","line_number":723,"entry_url":"https://github.com/open-source-parsers/jsoncpp.git","slot_name":"1.7.6"},"268746432":{"score":0.55292684,"function_name":"Reader::readValue","code":"bool Reader::readValue() {\n  // This is a non-reentrant way to support a stackLimit. Terrible!\n  // But this deprecated class has a security problem: Bad input can\n  // cause a seg-fault. This seems like a fair, binary-compatible way\n  // to prevent the problem.\n  if (stackDepth_g \u003e= stackLimit_g) throwRuntimeError(\"Exceeded stackLimit in readValue().\");\n  ++stackDepth_g;\n\n  Token token;\n  skipCommentTokens(token);\n  bool successful = true;\n\n  if (collectComments_ \u0026\u0026 !commentsBefore_.empty()) {\n    currentValue().setComment(commentsBefore_, commentBefore);\n    commentsBefore_ = \"\";\n  }\n\n  switch (token.type_) {\n  case tokenObjectBegin:\n    successful = readObject(token);\n    currentValue().setOffsetLimit(current_ - begin_);\n    break;\n  case tokenArrayBegin:\n    successful = readArray(token);\n    currentValue().setOffsetLimit(current_ - begin_);\n    break;\n  case tokenNumber:\n    successful = decodeNumber(token);\n    break;\n  case tokenString:\n    successful = decodeString(token);\n    break;\n  case tokenTrue:\n    {\n    Value v(true);\n    currentValue().swapPayload(v);\n    currentValue().setOffsetStart(token.start_ - begin_);\n    currentValue().setOffsetLimit(token.end_ - begin_);\n    }\n    break;\n  case tokenFalse:\n    {\n    Value v(false);\n    currentValue().swapPayload(v);\n    currentValue().setOffsetStart(token.start_ - begin_);\n    currentValue().setOffsetLimit(token.end_ - begin_);\n    }\n    break;\n  case tokenNull:\n    {\n    Value v;\n    currentValue().swapPayload(v);\n    currentValue().setOffsetStart(token.start_ - begin_);\n    currentValue().setOffsetLimit(token.end_ - begin_);\n    }\n    break;\n  case tokenArraySeparator:\n  case tokenObjectEnd:\n  case tokenArrayEnd:\n    if (features_.allowDroppedNullPlaceholders_) {\n      // \"Un-read\" the current token and mark the current value as a null\n      // token.\n      current_--;\n      Value v;\n      currentValue().swapPayload(v);\n      currentValue().setOffsetStart(current_ - begin_ - 1);\n      currentValue().setOffsetLimit(current_ - begin_);\n      break;\n    } // Else, fall through...\n  default:\n    currentValue().setOffsetStart(token.start_ - begin_);\n    currentValue().setOffsetLimit(token.end_ - begin_);\n    return addError(\"Syntax error: value, object or array expected.\", token);\n  }\n\n  if (collectComments_) {\n    lastValueEnd_ = current_;\n    lastValue_ = \u0026currentValue();\n  }\n\n  --stackDepth_g;\n  return successful;\n}","filepath":"src/lib_json/json_reader.cpp","line_number":163,"entry_url":"https://github.com/open-source-parsers/jsoncpp.git","slot_name":"1.7.6"},"268748176":{"score":0.87665164,"function_name":"OurReader::readToken","code":"bool OurReader::readToken(Token\u0026 token) {\n  skipSpaces();\n  token.start_ = current_;\n  Char c = getNextChar();\n  bool ok = true;\n  switch (c) {\n  case '{':\n    token.type_ = tokenObjectBegin;\n    break;\n  case '}':\n    token.type_ = tokenObjectEnd;\n    break;\n  case '[':\n    token.type_ = tokenArrayBegin;\n    break;\n  case ']':\n    token.type_ = tokenArrayEnd;\n    break;\n  case '\"':\n    token.type_ = tokenString;\n    ok = readString();\n    break;\n  case '\\'':\n    if (features_.allowSingleQuotes_) {\n    token.type_ = tokenString;\n    ok = readStringSingleQuote();\n    break;\n    } // else continue\n  case '/':\n    token.type_ = tokenComment;\n    ok = readComment();\n    break;\n  case '0':\n  case '1':\n  case '2':\n  case '3':\n  case '4':\n  case '5':\n  case '6':\n  case '7':\n  case '8':\n  case '9':\n    token.type_ = tokenNumber;\n    readNumber(false);\n    break;\n  case '-':\n    if (readNumber(true)) {\n      token.type_ = tokenNumber;\n    } else {\n      token.type_ = tokenNegInf;\n      ok = features_.allowSpecialFloats_ \u0026\u0026 match(\"nfinity\", 7);\n    }\n    break;\n  case 't':\n    token.type_ = tokenTrue;\n    ok = match(\"rue\", 3);\n    break;\n  case 'f':\n    token.type_ = tokenFalse;\n    ok = match(\"alse\", 4);\n    break;\n  case 'n':\n    token.type_ = tokenNull;\n    ok = match(\"ull\", 3);\n    break;\n  case 'N':\n    if (features_.allowSpecialFloats_) {\n      token.type_ = tokenNaN;\n      ok = match(\"aN\", 2);\n    } else {\n      ok = false;\n    }\n    break;\n  case 'I':\n    if (features_.allowSpecialFloats_) {\n      token.type_ = tokenPosInf;\n      ok = match(\"nfinity\", 7);\n    } else {\n      ok = false;\n    }\n    break;\n  case ',':\n    token.type_ = tokenArraySeparator;\n    break;\n  case ':':\n    token.type_ = tokenMemberSeparator;\n    break;\n  case 0:\n    token.type_ = tokenEndOfStream;\n    break;\n  default:\n    ok = false;\n    break;\n  }\n  if (!ok)\n    token.type_ = tokenError;\n  token.end_ = current_;\n  return true;\n}","filepath":"src/lib_json/json_reader.cpp","line_number":1207,"entry_url":"https://github.com/open-source-parsers/jsoncpp.git","slot_name":"1.7.6"},"268749280":{"score":0.952009,"function_name":"OurReader::readNumber","code":"bool OurReader::readNumber(bool checkInf) {\n  const char *p = current_;\n  if (checkInf \u0026\u0026 p != end_ \u0026\u0026 *p == 'I') {\n    current_ = ++p;\n    return false;\n  }\n  char c = '0'; // stopgap for already consumed character\n  // integral part\n  while (c \u003e= '0' \u0026\u0026 c \u003c= '9')\n    c = (current_ = p) \u003c end_ ? *p++ : '\\0';\n  // fractional part\n  if (c == '.') {\n    c = (current_ = p) \u003c end_ ? *p++ : '\\0';\n    while (c \u003e= '0' \u0026\u0026 c \u003c= '9')\n      c = (current_ = p) \u003c end_ ? *p++ : '\\0';\n  }\n  // exponential part\n  if (c == 'e' || c == 'E') {\n    c = (current_ = p) \u003c end_ ? *p++ : '\\0';\n    if (c == '+' || c == '-')\n      c = (current_ = p) \u003c end_ ? *p++ : '\\0';\n    while (c \u003e= '0' \u0026\u0026 c \u003c= '9')\n      c = (current_ = p) \u003c end_ ? *p++ : '\\0';\n  }\n  return true;\n}","filepath":"src/lib_json/json_reader.cpp","line_number":1388,"entry_url":"https://github.com/open-source-parsers/jsoncpp.git","slot_name":"1.7.6"},"268752880":{"score":0.7260183,"function_name":"Reader::decodeNumber","code":"bool Reader::decodeNumber(Token\u0026 token, Value\u0026 decoded) {\n  // Attempts to parse the number as an integer. If the number is\n  // larger than the maximum supported value of an integer then\n  // we decode the number as a double.\n  Location current = token.start_;\n  bool isNegative = *current == '-';\n  if (isNegative)\n    ++current;\n  // TODO: Help the compiler do the div and mod at compile time or get rid of them.\n  Value::LargestUInt maxIntegerValue =\n      isNegative ? Value::LargestUInt(Value::maxLargestInt) + 1\n                 : Value::maxLargestUInt;\n  Value::LargestUInt threshold = maxIntegerValue / 10;\n  Value::LargestUInt value = 0;\n  while (current \u003c token.end_) {\n    Char c = *current++;\n    if (c \u003c '0' || c \u003e '9')\n      return decodeDouble(token, decoded);\n    Value::UInt digit(static_cast\u003cValue::UInt\u003e(c - '0'));\n    if (value \u003e= threshold) {\n      // We've hit or exceeded the max value divided by 10 (rounded down). If\n      // a) we've only just touched the limit, b) this is the last digit, and\n      // c) it's small enough to fit in that rounding delta, we're okay.\n      // Otherwise treat this number as a double to avoid overflow.\n      if (value \u003e threshold || current != token.end_ ||\n          digit \u003e maxIntegerValue % 10) {\n        return decodeDouble(token, decoded);\n      }\n    }\n    value = value * 10 + digit;\n  }\n  if (isNegative \u0026\u0026 value == maxIntegerValue)\n    decoded = Value::minLargestInt;\n  else if (isNegative)\n    decoded = -Value::LargestInt(value);\n  else if (value \u003c= Value::LargestUInt(Value::maxInt))\n    decoded = Value::LargestInt(value);\n  else\n    decoded = value;\n  return true;\n}","filepath":"src/lib_json/json_reader.cpp","line_number":566,"entry_url":"https://github.com/open-source-parsers/jsoncpp.git","slot_name":"1.7.6"},"268753344":{"score":0.6548785,"function_name":"OurReader::decodeDouble","code":"bool OurReader::decodeDouble(Token\u0026 token, Value\u0026 decoded) {\n  double value = 0;\n  const int bufferSize = 32;\n  int count;\n  ptrdiff_t const length = token.end_ - token.start_;\n\n  // Sanity check to avoid buffer overflow exploits.\n  if (length \u003c 0) {\n    return addError(\"Unable to parse token length\", token);\n  }\n  size_t const ulength = static_cast\u003csize_t\u003e(length);\n\n  // Avoid using a string constant for the format control string given to\n  // sscanf, as this can cause hard to debug crashes on OS X. See here for more\n  // info:\n  //\n  //     http://developer.apple.com/library/mac/#DOCUMENTATION/DeveloperTools/gcc-4.0.1/gcc/Incompatibilities.html\n  char format[] = \"%lf\";\n\n  if (length \u003c= bufferSize) {\n    Char buffer[bufferSize + 1];\n    memcpy(buffer, token.start_, ulength);\n    buffer[length] = 0;\n    fixNumericLocaleInput(buffer, buffer + length);\n    count = sscanf(buffer, format, \u0026value);\n  } else {\n    JSONCPP_STRING buffer(token.start_, token.end_);\n    count = sscanf(buffer.c_str(), format, \u0026value);\n  }\n\n  if (count != 1)\n    return addError(\"'\" + JSONCPP_STRING(token.start_, token.end_) +\n                        \"' is not a number.\",\n                    token);\n  decoded = value;\n  return true;\n}","filepath":"src/lib_json/json_reader.cpp","line_number":1599,"entry_url":"https://github.com/open-source-parsers/jsoncpp.git","slot_name":"1.7.6"},"268753968":{"score":0.57451093,"function_name":"Reader::recoverFromError","code":"bool Reader::recoverFromError(TokenType skipUntilToken) {\n  size_t const errorCount = errors_.size();\n  Token skip;\n  for (;;) {\n    if (!readToken(skip))\n      errors_.resize(errorCount); // discard errors caused by recovery\n    if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)\n      break;\n  }\n  errors_.resize(errorCount);\n  return false;\n}","filepath":"src/lib_json/json_reader.cpp","line_number":762,"entry_url":"https://github.com/open-source-parsers/jsoncpp.git","slot_name":"1.7.6"},"268754144":{"score":0.8683085,"function_name":"Reader::getLocationLineAndColumn","code":"void Reader::getLocationLineAndColumn(Location location,\n                                      int\u0026 line,\n                                      int\u0026 column) const {\n  Location current = begin_;\n  Location lastLineStart = current;\n  line = 0;\n  while (current \u003c location \u0026\u0026 current != end_) {\n    Char c = *current++;\n    if (c == '\\r') {\n      if (*current == '\\n')\n        ++current;\n      lastLineStart = current;\n      ++line;\n    } else if (c == '\\n') {\n      lastLineStart = current;\n      ++line;\n    }\n  }\n  // column \u0026 line start at 1\n  column = int(location - lastLineStart) + 1;\n  ++line;\n}","filepath":"src/lib_json/json_reader.cpp","line_number":790,"entry_url":"https://github.com/open-source-parsers/jsoncpp.git","slot_name":"1.7.6"},"268756128":{"score":0.70776117,"function_name":"CharReaderBuilder::newCharReader","code":"CharReader* CharReaderBuilder::newCharReader() const\n{\n  bool collectComments = settings_[\"collectComments\"].asBool();\n  OurFeatures features = OurFeatures::all();\n  features.allowComments_ = settings_[\"allowComments\"].asBool();\n  features.strictRoot_ = settings_[\"strictRoot\"].asBool();\n  features.allowDroppedNullPlaceholders_ = settings_[\"allowDroppedNullPlaceholders\"].asBool();\n  features.allowNumericKeys_ = settings_[\"allowNumericKeys\"].asBool();\n  features.allowSingleQuotes_ = settings_[\"allowSingleQuotes\"].asBool();\n  features.stackLimit_ = settings_[\"stackLimit\"].asInt();\n  features.failIfExtra_ = settings_[\"failIfExtra\"].asBool();\n  features.rejectDupKeys_ = settings_[\"rejectDupKeys\"].asBool();\n  features.allowSpecialFloats_ = settings_[\"allowSpecialFloats\"].asBool();\n  return new OurCharReader(collectComments, features);\n}","filepath":"src/lib_json/json_reader.cpp","line_number":1926,"entry_url":"https://github.com/open-source-parsers/jsoncpp.git","slot_name":"1.7.6"},"268756816":{"score":0.6735085,"function_name":"getValidReaderKeys","code":"static void getValidReaderKeys(std::set\u003cJSONCPP_STRING\u003e* valid_keys)\n{\n  valid_keys-\u003eclear();\n  valid_keys-\u003einsert(\"collectComments\");\n  valid_keys-\u003einsert(\"allowComments\");\n  valid_keys-\u003einsert(\"strictRoot\");\n  valid_keys-\u003einsert(\"allowDroppedNullPlaceholders\");\n  valid_keys-\u003einsert(\"allowNumericKeys\");\n  valid_keys-\u003einsert(\"allowSingleQuotes\");\n  valid_keys-\u003einsert(\"stackLimit\");\n  valid_keys-\u003einsert(\"failIfExtra\");\n  valid_keys-\u003einsert(\"rejectDupKeys\");\n  valid_keys-\u003einsert(\"allowSpecialFloats\");\n}","filepath":"src/lib_json/json_reader.cpp","line_number":1941,"entry_url":"https://github.com/open-source-parsers/jsoncpp.git","slot_name":"1.7.6"},"269178672":{"score":0.6820703,"function_name":"XMLDocument::XMLDocument","code":"XMLDocument::XMLDocument( bool processEntities, Whitespace whitespaceMode ) :\r\n    XMLNode( 0 ),\r\n    _writeBOM( false ),\r\n    _processEntities( processEntities ),\r\n    _errorID(XML_SUCCESS),\r\n    _whitespaceMode( whitespaceMode ),\r\n    _errorStr(),\r\n    _errorLineNum( 0 ),\r\n    _charBuffer( 0 ),\r\n    _parseCurLineNum( 0 ),\r\n\t_parsingDepth(0),\r\n    _unlinked(),\r\n    _elementPool(),\r\n    _attributePool(),\r\n    _textPool(),\r\n    _commentPool()\r\n{\r\n    // avoid VC++ C4355 warning about 'this' in initializer list (C4355 is off by default in VS2012+)\r\n    _document = this;\r\n}","filepath":"tinyxml2.cpp","line_number":2006,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269179248":{"score":0.61733043,"function_name":"XMLPrinter::XMLPrinter","code":"XMLPrinter::XMLPrinter( FILE* file, bool compact, int depth ) :\r\n    _elementJustOpened( false ),\r\n    _stack(),\r\n    _firstElement( true ),\r\n    _fp( file ),\r\n    _depth( depth ),\r\n    _textDepth( -1 ),\r\n    _processEntities( true ),\r\n    _compactMode( compact ),\r\n    _buffer()\r\n{\r\n    for( int i=0; i\u003cENTITY_RANGE; ++i ) {\r\n        _entityFlag[i] = false;\r\n        _restrictedEntityFlag[i] = false;\r\n    }\r\n    for( int i=0; i\u003cNUM_ENTITIES; ++i ) {\r\n        const char entityValue = entities[i].value;\r\n        const unsigned char flagIndex = (unsigned char)entityValue;\r\n        TIXMLASSERT( flagIndex \u003c ENTITY_RANGE );\r\n        _entityFlag[flagIndex] = true;\r\n    }\r\n    _restrictedEntityFlag[(unsigned char)'\u0026'] = true;\r\n    _restrictedEntityFlag[(unsigned char)'\u003c'] = true;\r\n    _restrictedEntityFlag[(unsigned char)'\u003e'] = true;\t// not required, but consistency is nice\r\n    _buffer.Push( 0 );\r\n}","filepath":"tinyxml2.cpp","line_number":2410,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269179648":{"score":0.84937716,"function_name":"StrPair::Reset","code":"void StrPair::Reset()\r\n{\r\n    if ( _flags \u0026 NEEDS_DELETE ) {\r\n        delete [] _start;\r\n    }\r\n    _flags = 0;\r\n    _start = 0;\r\n    _end = 0;\r\n}","filepath":"tinyxml2.cpp","line_number":169,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269181376":{"score":0.7437339,"function_name":"XMLDocument::Accept","code":"bool XMLDocument::Accept( XMLVisitor* visitor ) const\r\n{\r\n    TIXMLASSERT( visitor );\r\n    if ( visitor-\u003eVisitEnter( *this ) ) {\r\n        for ( const XMLNode* node=FirstChild(); node; node=node-\u003eNextSibling() ) {\r\n            if ( !node-\u003eAccept( visitor ) ) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return visitor-\u003eVisitExit( *this );\r\n}","filepath":"tinyxml2.cpp","line_number":726,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269183264":{"score":0.5643374,"function_name":"XMLDocument::Clear","code":"void XMLDocument::Clear()\r\n{\r\n    DeleteChildren();\r\n\twhile( _unlinked.Size()) {\r\n\t\tDeleteNode(_unlinked[0]);\t// Will remove from _unlinked as part of delete.\r\n\t}\r\n\r\n#ifdef TINYXML2_DEBUG\r\n    const bool hadError = Error();\r\n#endif\r\n    ClearError();\r\n\r\n    delete [] _charBuffer;\r\n    _charBuffer = 0;\r\n\t_parsingDepth = 0;\r\n\r\n#if 0\r\n    _textPool.Trace( \"text\" );\r\n    _elementPool.Trace( \"element\" );\r\n    _commentPool.Trace( \"comment\" );\r\n    _attributePool.Trace( \"attribute\" );\r\n#endif\r\n\r\n#ifdef TINYXML2_DEBUG\r\n    if ( !hadError ) {\r\n        TIXMLASSERT( _elementPool.CurrentAllocs()   == _elementPool.Untracked() );\r\n        TIXMLASSERT( _attributePool.CurrentAllocs() == _attributePool.Untracked() );\r\n        TIXMLASSERT( _textPool.CurrentAllocs()      == _textPool.Untracked() );\r\n        TIXMLASSERT( _commentPool.CurrentAllocs()   == _commentPool.Untracked() );\r\n    }\r\n#endif\r\n}","filepath":"tinyxml2.cpp","line_number":2047,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269183584":{"score":0.8428275,"function_name":"XMLPrinter::CloseElement","code":"void XMLPrinter::CloseElement( bool compactMode )\r\n{\r\n    --_depth;\r\n    const char* name = _stack.Pop();\r\n\r\n    if ( _elementJustOpened ) {\r\n        Write( \"/\u003e\" );\r\n    }\r\n    else {\r\n        if ( _textDepth \u003c 0 \u0026\u0026 !compactMode) {\r\n            Putc( '\\n' );\r\n            PrintSpace( _depth );\r\n        }\r\n        Write ( \"\u003c/\" );\r\n        Write ( name );\r\n        Write ( \"\u003e\" );\r\n    }\r\n\r\n    if ( _textDepth == _depth ) {\r\n        _textDepth = -1;\r\n    }\r\n    if ( _depth == 0 \u0026\u0026 !compactMode) {\r\n        Putc( '\\n' );\r\n    }\r\n    _elementJustOpened = false;\r\n}","filepath":"tinyxml2.cpp","line_number":2633,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269183952":{"score":0.78964996,"function_name":"StrPair::CollapseWhitespace","code":"void StrPair::CollapseWhitespace()\r\n{\r\n    // Adjusting _start would cause undefined behavior on delete[]\r\n    TIXMLASSERT( ( _flags \u0026 NEEDS_DELETE ) == 0 );\r\n    // Trim leading space.\r\n    _start = XMLUtil::SkipWhiteSpace( _start, 0 );\r\n\r\n    if ( *_start ) {\r\n        const char* p = _start;\t// the read pointer\r\n        char* q = _start;\t// the write pointer\r\n\r\n        while( *p ) {\r\n            if ( XMLUtil::IsWhiteSpace( *p )) {\r\n                p = XMLUtil::SkipWhiteSpace( p, 0 );\r\n                if ( *p == 0 ) {\r\n                    break;    // don't write to q; this trims the trailing space.\r\n                }\r\n                *q = ' ';\r\n                ++q;\r\n            }\r\n            *q = *p;\r\n            ++q;\r\n            ++p;\r\n        }\r\n        *q = 0;\r\n    }\r\n}","filepath":"tinyxml2.cpp","line_number":238,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269184096":{"score":0.79431105,"function_name":"XMLUtil::ConvertUTF32ToUTF8","code":"void XMLUtil::ConvertUTF32ToUTF8( unsigned long input, char* output, int* length )\r\n{\r\n    const unsigned long BYTE_MASK = 0xBF;\r\n    const unsigned long BYTE_MARK = 0x80;\r\n    const unsigned long FIRST_BYTE_MARK[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };\r\n\r\n    if (input \u003c 0x80) {\r\n        *length = 1;\r\n    }\r\n    else if ( input \u003c 0x800 ) {\r\n        *length = 2;\r\n    }\r\n    else if ( input \u003c 0x10000 ) {\r\n        *length = 3;\r\n    }\r\n    else if ( input \u003c 0x200000 ) {\r\n        *length = 4;\r\n    }\r\n    else {\r\n        *length = 0;    // This code won't convert this correctly anyway.\r\n        return;\r\n    }\r\n\r\n    output += *length;\r\n\r\n    // Scary scary fall throughs are annotated with carefully designed comments\r\n    // to suppress compiler warnings such as -Wimplicit-fallthrough in gcc\r\n    switch (*length) {\r\n        case 4:\r\n            --output;\r\n            *output = (char)((input | BYTE_MARK) \u0026 BYTE_MASK);\r\n            input \u003e\u003e= 6;\r\n            //fall through\r\n        case 3:\r\n            --output;\r\n            *output = (char)((input | BYTE_MARK) \u0026 BYTE_MASK);\r\n            input \u003e\u003e= 6;\r\n            //fall through\r\n        case 2:\r\n            --output;\r\n            *output = (char)((input | BYTE_MARK) \u0026 BYTE_MASK);\r\n            input \u003e\u003e= 6;\r\n            //fall through\r\n        case 1:\r\n            --output;\r\n            *output = (char)(input | FIRST_BYTE_MARK[*length]);\r\n            break;\r\n        default:\r\n            TIXMLASSERT( false );\r\n    }\r\n}","filepath":"tinyxml2.cpp","line_number":403,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269184352":{"score":0.690288,"function_name":"XMLElement::CreateAttribute","code":"XMLAttribute* XMLElement::CreateAttribute()\r\n{\r\n    TIXMLASSERT( sizeof( XMLAttribute ) == _document-\u003e_attributePool.ItemSize() );\r\n    XMLAttribute* attrib = new (_document-\u003e_attributePool.Alloc() ) XMLAttribute();\r\n    TIXMLASSERT( attrib );\r\n    attrib-\u003e_memPool = \u0026_document-\u003e_attributePool;\r\n    attrib-\u003e_memPool-\u003eSetTracked();\r\n    return attrib;\r\n}","filepath":"tinyxml2.cpp","line_number":1884,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269184832":{"score":0.5676795,"function_name":"XMLNode::DeleteNode","code":"void XMLNode::DeleteNode( XMLNode* node )\r\n{\r\n    if ( node == 0 ) {\r\n        return;\r\n    }\r\n\tTIXMLASSERT(node-\u003e_document);\r\n\tif (!node-\u003eToDocument()) {\r\n\t\tnode-\u003e_document-\u003eMarkInUse(node);\r\n\t}\r\n\r\n    MemPool* pool = node-\u003e_memPool;\r\n    node-\u003e~XMLNode();\r\n    pool-\u003eFree( node );\r\n}","filepath":"tinyxml2.cpp","line_number":1102,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269184928":{"score":0.59474796,"function_name":"XMLElement::FindAttribute","code":"const XMLAttribute* XMLElement::FindAttribute( const char* name ) const\r\n{\r\n    for( XMLAttribute* a = _rootAttribute; a; a = a-\u003e_next ) {\r\n        if ( XMLUtil::StringEqual( a-\u003eName(), name ) ) {\r\n            return a;\r\n        }\r\n    }\r\n    return 0;\r\n}","filepath":"tinyxml2.cpp","line_number":1515,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269187088":{"score":0.8957499,"function_name":"XMLUtil::GetCharacterRef","code":"const char* XMLUtil::GetCharacterRef( const char* p, char* value, int* length )\r\n{\r\n    // Presume an entity, and pull it out.\r\n    *length = 0;\r\n\r\n    if ( *(p+1) == '#' \u0026\u0026 *(p+2) ) {\r\n        unsigned long ucs = 0;\r\n        TIXMLASSERT( sizeof( ucs ) \u003e= 4 );\r\n        ptrdiff_t delta = 0;\r\n        unsigned mult = 1;\r\n        static const char SEMICOLON = ';';\r\n\r\n        if ( *(p+2) == 'x' ) {\r\n            // Hexadecimal.\r\n            const char* q = p+3;\r\n            if ( !(*q) ) {\r\n                return 0;\r\n            }\r\n\r\n            q = strchr( q, SEMICOLON );\r\n\r\n            if ( !q ) {\r\n                return 0;\r\n            }\r\n            TIXMLASSERT( *q == SEMICOLON );\r\n\r\n            delta = q-p;\r\n            --q;\r\n\r\n            while ( *q != 'x' ) {\r\n                unsigned int digit = 0;\r\n\r\n                if ( *q \u003e= '0' \u0026\u0026 *q \u003c= '9' ) {\r\n                    digit = *q - '0';\r\n                }\r\n                else if ( *q \u003e= 'a' \u0026\u0026 *q \u003c= 'f' ) {\r\n                    digit = *q - 'a' + 10;\r\n                }\r\n                else if ( *q \u003e= 'A' \u0026\u0026 *q \u003c= 'F' ) {\r\n                    digit = *q - 'A' + 10;\r\n                }\r\n                else {\r\n                    return 0;\r\n                }\r\n                TIXMLASSERT( digit \u003c 16 );\r\n                TIXMLASSERT( digit == 0 || mult \u003c= UINT_MAX / digit );\r\n                const unsigned int digitScaled = mult * digit;\r\n                TIXMLASSERT( ucs \u003c= ULONG_MAX - digitScaled );\r\n                ucs += digitScaled;\r\n                TIXMLASSERT( mult \u003c= UINT_MAX / 16 );\r\n                mult *= 16;\r\n                --q;\r\n            }\r\n        }\r\n        else {\r\n            // Decimal.\r\n            const char* q = p+2;\r\n            if ( !(*q) ) {\r\n                return 0;\r\n            }\r\n\r\n            q = strchr( q, SEMICOLON );\r\n\r\n            if ( !q ) {\r\n                return 0;\r\n            }\r\n            TIXMLASSERT( *q == SEMICOLON );\r\n\r\n            delta = q-p;\r\n            --q;\r\n\r\n            while ( *q != '#' ) {\r\n                if ( *q \u003e= '0' \u0026\u0026 *q \u003c= '9' ) {\r\n                    const unsigned int digit = *q - '0';\r\n                    TIXMLASSERT( digit \u003c 10 );\r\n                    TIXMLASSERT( digit == 0 || mult \u003c= UINT_MAX / digit );\r\n                    const unsigned int digitScaled = mult * digit;\r\n                    TIXMLASSERT( ucs \u003c= ULONG_MAX - digitScaled );\r\n                    ucs += digitScaled;\r\n                }\r\n                else {\r\n                    return 0;\r\n                }\r\n                TIXMLASSERT( mult \u003c= UINT_MAX / 10 );\r\n                mult *= 10;\r\n                --q;\r\n            }\r\n        }\r\n        // convert the UCS to UTF-8\r\n        ConvertUTF32ToUTF8( ucs, value, length );\r\n        return p + delta + 1;\r\n    }\r\n    return p+1;\r\n}","filepath":"tinyxml2.cpp","line_number":456,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269190224":{"score":0.6470776,"function_name":"StrPair::GetStr","code":"const char* StrPair::GetStr()\r\n{\r\n    TIXMLASSERT( _start );\r\n    TIXMLASSERT( _end );\r\n    if ( _flags \u0026 NEEDS_FLUSH ) {\r\n        *_end = 0;\r\n        _flags ^= NEEDS_FLUSH;\r\n\r\n        if ( _flags ) {\r\n            const char* p = _start;\t// the read pointer\r\n            char* q = _start;\t// the write pointer\r\n\r\n            while( p \u003c _end ) {\r\n                if ( (_flags \u0026 NEEDS_NEWLINE_NORMALIZATION) \u0026\u0026 *p == CR ) {\r\n                    // CR-LF pair becomes LF\r\n                    // CR alone becomes LF\r\n                    // LF-CR becomes LF\r\n                    if ( *(p+1) == LF ) {\r\n                        p += 2;\r\n                    }\r\n                    else {\r\n                        ++p;\r\n                    }\r\n                    *q = LF;\r\n                    ++q;\r\n                }\r\n                else if ( (_flags \u0026 NEEDS_NEWLINE_NORMALIZATION) \u0026\u0026 *p == LF ) {\r\n                    if ( *(p+1) == CR ) {\r\n                        p += 2;\r\n                    }\r\n                    else {\r\n                        ++p;\r\n                    }\r\n                    *q = LF;\r\n                    ++q;\r\n                }\r\n                else if ( (_flags \u0026 NEEDS_ENTITY_PROCESSING) \u0026\u0026 *p == '\u0026' ) {\r\n                    // Entities handled by tinyXML2:\r\n                    // - special entities in the entity table [in/out]\r\n                    // - numeric character reference [in]\r\n                    //   \u0026#20013; or \u0026#x4e2d;\r\n\r\n                    if ( *(p+1) == '#' ) {\r\n                        const int buflen = 10;\r\n                        char buf[buflen] = { 0 };\r\n                        int len = 0;\r\n                        char* adjusted = const_cast\u003cchar*\u003e( XMLUtil::GetCharacterRef( p, buf, \u0026len ) );\r\n                        if ( adjusted == 0 ) {\r\n                            *q = *p;\r\n                            ++p;\r\n                            ++q;\r\n                        }\r\n                        else {\r\n                            TIXMLASSERT( 0 \u003c= len \u0026\u0026 len \u003c= buflen );\r\n                            TIXMLASSERT( q + len \u003c= adjusted );\r\n                            p = adjusted;\r\n                            memcpy( q, buf, len );\r\n                            q += len;\r\n                        }\r\n                    }\r\n                    else {\r\n                        bool entityFound = false;\r\n                        for( int i = 0; i \u003c NUM_ENTITIES; ++i ) {\r\n                            const Entity\u0026 entity = entities[i];\r\n                            if ( strncmp( p + 1, entity.pattern, entity.length ) == 0\r\n                                    \u0026\u0026 *( p + entity.length + 1 ) == ';' ) {\r\n                                // Found an entity - convert.\r\n                                *q = entity.value;\r\n                                ++q;\r\n                                p += entity.length + 2;\r\n                                entityFound = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if ( !entityFound ) {\r\n                            // fixme: treat as error?\r\n                            ++p;\r\n                            ++q;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    *q = *p;\r\n                    ++p;\r\n                    ++q;\r\n                }\r\n            }\r\n            *q = 0;\r\n        }\r\n        // The loop below has plenty going on, and this\r\n        // is a less useful mode. Break it out.\r\n        if ( _flags \u0026 NEEDS_WHITESPACE_COLLAPSING ) {\r\n            CollapseWhitespace();\r\n        }\r\n        _flags = (_flags \u0026 NEEDS_DELETE);\r\n    }\r\n    TIXMLASSERT( _start );\r\n    return _start;\r\n}","filepath":"tinyxml2.cpp","line_number":267,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269193904":{"score":0.5953468,"function_name":"XMLElement::QueryInt64Text","code":"XMLError XMLElement::QueryInt64Text(int64_t* ival) const\r\n{\r\n\tif (FirstChild() \u0026\u0026 FirstChild()-\u003eToText()) {\r\n\t\tconst char* t = FirstChild()-\u003eValue();\r\n\t\tif (XMLUtil::ToInt64(t, ival)) {\r\n\t\t\treturn XML_SUCCESS;\r\n\t\t}\r\n\t\treturn XML_CAN_NOT_CONVERT_TEXT;\r\n\t}\r\n\treturn XML_NO_TEXT_NODE;\r\n}","filepath":"tinyxml2.cpp","line_number":1674,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269194048":{"score":0.7902467,"function_name":"XMLDocument::Identify","code":"char* XMLDocument::Identify( char* p, XMLNode** node )\r\n{\r\n    TIXMLASSERT( node );\r\n    TIXMLASSERT( p );\r\n    char* const start = p;\r\n    int const startLine = _parseCurLineNum;\r\n    p = XMLUtil::SkipWhiteSpace( p, \u0026_parseCurLineNum );\r\n    if( !*p ) {\r\n        *node = 0;\r\n        TIXMLASSERT( p );\r\n        return p;\r\n    }\r\n\r\n    // These strings define the matching patterns:\r\n    static const char* xmlHeader\t\t= { \"\u003c?\" };\r\n    static const char* commentHeader\t= { \"\u003c!--\" };\r\n    static const char* cdataHeader\t\t= { \"\u003c![CDATA[\" };\r\n    static const char* dtdHeader\t\t= { \"\u003c!\" };\r\n    static const char* elementHeader\t= { \"\u003c\" };\t// and a header for everything else; check last.\r\n\r\n    static const int xmlHeaderLen\t\t= 2;\r\n    static const int commentHeaderLen\t= 4;\r\n    static const int cdataHeaderLen\t\t= 9;\r\n    static const int dtdHeaderLen\t\t= 2;\r\n    static const int elementHeaderLen\t= 1;\r\n\r\n    TIXMLASSERT( sizeof( XMLComment ) == sizeof( XMLUnknown ) );\t\t// use same memory pool\r\n    TIXMLASSERT( sizeof( XMLComment ) == sizeof( XMLDeclaration ) );\t// use same memory pool\r\n    XMLNode* returnNode = 0;\r\n    if ( XMLUtil::StringEqual( p, xmlHeader, xmlHeaderLen ) ) {\r\n        returnNode = CreateUnlinkedNode\u003cXMLDeclaration\u003e( _commentPool );\r\n        returnNode-\u003e_parseLineNum = _parseCurLineNum;\r\n        p += xmlHeaderLen;\r\n    }\r\n    else if ( XMLUtil::StringEqual( p, commentHeader, commentHeaderLen ) ) {\r\n        returnNode = CreateUnlinkedNode\u003cXMLComment\u003e( _commentPool );\r\n        returnNode-\u003e_parseLineNum = _parseCurLineNum;\r\n        p += commentHeaderLen;\r\n    }\r\n    else if ( XMLUtil::StringEqual( p, cdataHeader, cdataHeaderLen ) ) {\r\n        XMLText* text = CreateUnlinkedNode\u003cXMLText\u003e( _textPool );\r\n        returnNode = text;\r\n        returnNode-\u003e_parseLineNum = _parseCurLineNum;\r\n        p += cdataHeaderLen;\r\n        text-\u003eSetCData( true );\r\n    }\r\n    else if ( XMLUtil::StringEqual( p, dtdHeader, dtdHeaderLen ) ) {\r\n        returnNode = CreateUnlinkedNode\u003cXMLUnknown\u003e( _commentPool );\r\n        returnNode-\u003e_parseLineNum = _parseCurLineNum;\r\n        p += dtdHeaderLen;\r\n    }\r\n    else if ( XMLUtil::StringEqual( p, elementHeader, elementHeaderLen ) ) {\r\n        returnNode =  CreateUnlinkedNode\u003cXMLElement\u003e( _elementPool );\r\n        returnNode-\u003e_parseLineNum = _parseCurLineNum;\r\n        p += elementHeaderLen;\r\n    }\r\n    else {\r\n        returnNode = CreateUnlinkedNode\u003cXMLText\u003e( _textPool );\r\n        returnNode-\u003e_parseLineNum = _parseCurLineNum; // Report line of first non-whitespace character\r\n        p = start;\t// Back it up, all the text counts.\r\n        _parseCurLineNum = startLine;\r\n    }\r\n\r\n    TIXMLASSERT( returnNode );\r\n    TIXMLASSERT( p );\r\n    *node = returnNode;\r\n    return p;\r\n}","filepath":"tinyxml2.cpp","line_number":656,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269194608":{"score":0.91449296,"function_name":"XMLNode::InsertEndChild","code":"XMLNode* XMLNode::InsertEndChild( XMLNode* addThis )\r\n{\r\n    TIXMLASSERT( addThis );\r\n    if ( addThis-\u003e_document != _document ) {\r\n        TIXMLASSERT( false );\r\n        return 0;\r\n    }\r\n    InsertChildPreamble( addThis );\r\n\r\n    if ( _lastChild ) {\r\n        TIXMLASSERT( _firstChild );\r\n        TIXMLASSERT( _lastChild-\u003e_next == 0 );\r\n        _lastChild-\u003e_next = addThis;\r\n        addThis-\u003e_prev = _lastChild;\r\n        _lastChild = addThis;\r\n\r\n        addThis-\u003e_next = 0;\r\n    }\r\n    else {\r\n        TIXMLASSERT( _firstChild == 0 );\r\n        _firstChild = _lastChild = addThis;\r\n\r\n        addThis-\u003e_prev = 0;\r\n        addThis-\u003e_next = 0;\r\n    }\r\n    addThis-\u003e_parent = this;\r\n    return addThis;\r\n}","filepath":"tinyxml2.cpp","line_number":841,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269194976":{"score":0.90932447,"function_name":"XMLDocument::LoadFile","code":"XMLError XMLDocument::LoadFile( FILE* fp )\r\n{\r\n    Clear();\r\n\r\n    fseek( fp, 0, SEEK_SET );\r\n    if ( fgetc( fp ) == EOF \u0026\u0026 ferror( fp ) != 0 ) {\r\n        SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );\r\n        return _errorID;\r\n    }\r\n\r\n    fseek( fp, 0, SEEK_END );\r\n    const long filelength = ftell( fp );\r\n    fseek( fp, 0, SEEK_SET );\r\n    if ( filelength == -1L ) {\r\n        SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );\r\n        return _errorID;\r\n    }\r\n    TIXMLASSERT( filelength \u003e= 0 );\r\n\r\n    if ( !LongFitsIntoSizeTMinusOne\u003c\u003e::Fits( filelength ) ) {\r\n        // Cannot handle files which won't fit in buffer together with null terminator\r\n        SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );\r\n        return _errorID;\r\n    }\r\n\r\n    if ( filelength == 0 ) {\r\n        SetError( XML_ERROR_EMPTY_DOCUMENT, 0, 0 );\r\n        return _errorID;\r\n    }\r\n\r\n    const size_t size = filelength;\r\n    TIXMLASSERT( _charBuffer == 0 );\r\n    _charBuffer = new char[size+1];\r\n    size_t read = fread( _charBuffer, 1, size, fp );\r\n    if ( read != size ) {\r\n        SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );\r\n        return _errorID;\r\n    }\r\n\r\n    _charBuffer[size] = 0;\r\n\r\n    Parse();\r\n    return _errorID;\r\n}","filepath":"tinyxml2.cpp","line_number":2209,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269195184":{"score":0.71916807,"function_name":"XMLDocument::MarkInUse","code":"void XMLDocument::MarkInUse(XMLNode* node)\r\n{\r\n\tTIXMLASSERT(node);\r\n\tTIXMLASSERT(node-\u003e_parent == 0);\r\n\r\n\tfor (int i = 0; i \u003c _unlinked.Size(); ++i) {\r\n\t\tif (node == _unlinked[i]) {\r\n\t\t\t_unlinked.SwapRemove(i);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}","filepath":"tinyxml2.cpp","line_number":2034,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269196352":{"score":0.7843528,"function_name":"XMLPrinter::OpenElement","code":"void XMLPrinter::OpenElement( const char* name, bool compactMode )\r\n{\r\n    SealElementIfJustOpened();\r\n    _stack.Push( name );\r\n\r\n    if ( _textDepth \u003c 0 \u0026\u0026 !_firstElement \u0026\u0026 !compactMode ) {\r\n        Putc( '\\n' );\r\n    }\r\n    if ( !compactMode ) {\r\n        PrintSpace( _depth );\r\n    }\r\n\r\n    Write ( \"\u003c\" );\r\n    Write ( name );\r\n\r\n    _elementJustOpened = true;\r\n    _firstElement = false;\r\n    ++_depth;\r\n}","filepath":"tinyxml2.cpp","line_number":2561,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269196672":{"score":0.75229275,"function_name":"XMLDocument::Parse","code":"void XMLDocument::Parse()\r\n{\r\n    TIXMLASSERT( NoChildren() ); // Clear() must have been called previously\r\n    TIXMLASSERT( _charBuffer );\r\n    _parseCurLineNum = 1;\r\n    _parseLineNum = 1;\r\n    char* p = _charBuffer;\r\n    p = XMLUtil::SkipWhiteSpace( p, \u0026_parseCurLineNum );\r\n    p = const_cast\u003cchar*\u003e( XMLUtil::ReadBOM( p, \u0026_writeBOM ) );\r\n    if ( !*p ) {\r\n        SetError( XML_ERROR_EMPTY_DOCUMENT, 0, 0 );\r\n        return;\r\n    }\r\n    ParseDeep(p, 0, \u0026_parseCurLineNum );\r\n}","filepath":"tinyxml2.cpp","line_number":2380,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269196784":{"score":0.8639818,"function_name":"XMLElement::ParseAttributes","code":"char* XMLElement::ParseAttributes( char* p, int* curLineNumPtr )\r\n{\r\n    XMLAttribute* prevAttribute = 0;\r\n\r\n    // Read the attributes.\r\n    while( p ) {\r\n        p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );\r\n        if ( !(*p) ) {\r\n            _document-\u003eSetError( XML_ERROR_PARSING_ELEMENT, _parseLineNum, \"XMLElement name=%s\", Name() );\r\n            return 0;\r\n        }\r\n\r\n        // attribute.\r\n        if (XMLUtil::IsNameStartChar( *p ) ) {\r\n            XMLAttribute* attrib = CreateAttribute();\r\n            TIXMLASSERT( attrib );\r\n            attrib-\u003e_parseLineNum = _document-\u003e_parseCurLineNum;\r\n\r\n            int attrLineNum = attrib-\u003e_parseLineNum;\r\n\r\n            p = attrib-\u003eParseDeep( p, _document-\u003eProcessEntities(), curLineNumPtr );\r\n            if ( !p || Attribute( attrib-\u003eName() ) ) {\r\n                DeleteAttribute( attrib );\r\n                _document-\u003eSetError( XML_ERROR_PARSING_ATTRIBUTE, attrLineNum, \"XMLElement name=%s\", Name() );\r\n                return 0;\r\n            }\r\n            // There is a minor bug here: if the attribute in the source xml\r\n            // document is duplicated, it will not be detected and the\r\n            // attribute will be doubly added. However, tracking the 'prevAttribute'\r\n            // avoids re-scanning the attribute list. Preferring performance for\r\n            // now, may reconsider in the future.\r\n            if ( prevAttribute ) {\r\n                TIXMLASSERT( prevAttribute-\u003e_next == 0 );\r\n                prevAttribute-\u003e_next = attrib;\r\n            }\r\n            else {\r\n                TIXMLASSERT( _rootAttribute == 0 );\r\n                _rootAttribute = attrib;\r\n            }\r\n            prevAttribute = attrib;\r\n        }\r\n        // end of the tag\r\n        else if ( *p == '\u003e' ) {\r\n            ++p;\r\n            break;\r\n        }\r\n        // end of the tag\r\n        else if ( *p == '/' \u0026\u0026 *(p+1) == '\u003e' ) {\r\n            _closingType = CLOSED;\r\n            return p+2;\t// done; sealed element.\r\n        }\r\n        else {\r\n            _document-\u003eSetError( XML_ERROR_PARSING_ELEMENT, _parseLineNum, 0 );\r\n            return 0;\r\n        }\r\n    }\r\n    return p;\r\n}","filepath":"tinyxml2.cpp","line_number":1815,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269197728":{"score":0.76362455,"function_name":"XMLElement::ParseDeep","code":"char* XMLElement::ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr )\r\n{\r\n    // Read the element name.\r\n    p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );\r\n\r\n    // The closing element is the \u003c/element\u003e form. It is\r\n    // parsed just like a regular element then deleted from\r\n    // the DOM.\r\n    if ( *p == '/' ) {\r\n        _closingType = CLOSING;\r\n        ++p;\r\n    }\r\n\r\n    p = _value.ParseName( p );\r\n    if ( _value.Empty() ) {\r\n        return 0;\r\n    }\r\n\r\n    p = ParseAttributes( p, curLineNumPtr );\r\n    if ( !p || !*p || _closingType != OPEN ) {\r\n        return p;\r\n    }\r\n\r\n    p = XMLNode::ParseDeep( p, parentEndTag, curLineNumPtr );\r\n    return p;\r\n}","filepath":"tinyxml2.cpp","line_number":1898,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269197840":{"score":0.6293249,"function_name":"XMLNode::ParseDeep","code":"char* XMLNode::ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr )\r\n{\r\n    // This is a recursive method, but thinking about it \"at the current level\"\r\n    // it is a pretty simple flat list:\r\n    //\t\t\u003cfoo/\u003e\r\n    //\t\t\u003c!-- comment --\u003e\r\n    //\r\n    // With a special case:\r\n    //\t\t\u003cfoo\u003e\r\n    //\t\t\u003c/foo\u003e\r\n    //\t\t\u003c!-- comment --\u003e\r\n    //\r\n    // Where the closing element (/foo) *must* be the next thing after the opening\r\n    // element, and the names must match. BUT the tricky bit is that the closing\r\n    // element will be read by the child.\r\n    //\r\n    // 'endTag' is the end tag for this node, it is returned by a call to a child.\r\n    // 'parentEnd' is the end tag for the parent, which is filled in and returned.\r\n\r\n\tXMLDocument::DepthTracker tracker(_document);\r\n\tif (_document-\u003eError())\r\n\t\treturn 0;\r\n\r\n\twhile( p \u0026\u0026 *p ) {\r\n        XMLNode* node = 0;\r\n\r\n        p = _document-\u003eIdentify( p, \u0026node );\r\n        TIXMLASSERT( p );\r\n        if ( node == 0 ) {\r\n            break;\r\n        }\r\n\r\n        int initialLineNum = node-\u003e_parseLineNum;\r\n\r\n        StrPair endTag;\r\n        p = node-\u003eParseDeep( p, \u0026endTag, curLineNumPtr );\r\n        if ( !p ) {\r\n            DeleteNode( node );\r\n            if ( !_document-\u003eError() ) {\r\n                _document-\u003eSetError( XML_ERROR_PARSING, initialLineNum, 0);\r\n            }\r\n            break;\r\n        }\r\n\r\n        XMLDeclaration* decl = node-\u003eToDeclaration();\r\n        if ( decl ) {\r\n            // Declarations are only allowed at document level\r\n            //\r\n            // Multiple declarations are allowed but all declarations\r\n            // must occur before anything else. \r\n            //\r\n            // Optimized due to a security test case. If the first node is \r\n            // a declaration, and the last node is a declaration, then only \r\n            // declarations have so far been addded.\r\n            bool wellLocated = false;\r\n\r\n            if (ToDocument()) {\r\n                if (FirstChild()) {\r\n                    wellLocated =\r\n                        FirstChild() \u0026\u0026\r\n                        FirstChild()-\u003eToDeclaration() \u0026\u0026\r\n                        LastChild() \u0026\u0026\r\n                        LastChild()-\u003eToDeclaration();\r\n                }\r\n                else {\r\n                    wellLocated = true;\r\n                }\r\n            }\r\n            if ( !wellLocated ) {\r\n                _document-\u003eSetError( XML_ERROR_PARSING_DECLARATION, initialLineNum, \"XMLDeclaration value=%s\", decl-\u003eValue());\r\n                DeleteNode( node );\r\n                break;\r\n            }\r\n        }\r\n\r\n        XMLElement* ele = node-\u003eToElement();\r\n        if ( ele ) {\r\n            // We read the end tag. Return it to the parent.\r\n            if ( ele-\u003eClosingType() == XMLElement::CLOSING ) {\r\n                if ( parentEndTag ) {\r\n                    ele-\u003e_value.TransferTo( parentEndTag );\r\n                }\r\n                node-\u003e_memPool-\u003eSetTracked();   // created and then immediately deleted.\r\n                DeleteNode( node );\r\n                return p;\r\n            }\r\n\r\n            // Handle an end tag returned to this level.\r\n            // And handle a bunch of annoying errors.\r\n            bool mismatch = false;\r\n            if ( endTag.Empty() ) {\r\n                if ( ele-\u003eClosingType() == XMLElement::OPEN ) {\r\n                    mismatch = true;\r\n                }\r\n            }\r\n            else {\r\n                if ( ele-\u003eClosingType() != XMLElement::OPEN ) {\r\n                    mismatch = true;\r\n                }\r\n                else if ( !XMLUtil::StringEqual( endTag.GetStr(), ele-\u003eName() ) ) {\r\n                    mismatch = true;\r\n                }\r\n            }\r\n            if ( mismatch ) {\r\n                _document-\u003eSetError( XML_ERROR_MISMATCHED_ELEMENT, initialLineNum, \"XMLElement name=%s\", ele-\u003eName());\r\n                DeleteNode( node );\r\n                break;\r\n            }\r\n        }\r\n        InsertEndChild( node );\r\n    }\r\n    return 0;\r\n}","filepath":"tinyxml2.cpp","line_number":988,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269198608":{"score":0.8040958,"function_name":"XMLText::ParseDeep","code":"char* XMLText::ParseDeep( char* p, StrPair*, int* curLineNumPtr )\r\n{\r\n    if ( this-\u003eCData() ) {\r\n        p = _value.ParseText( p, \"]]\u003e\", StrPair::NEEDS_NEWLINE_NORMALIZATION, curLineNumPtr );\r\n        if ( !p ) {\r\n            _document-\u003eSetError( XML_ERROR_PARSING_CDATA, _parseLineNum, 0 );\r\n        }\r\n        return p;\r\n    }\r\n    else {\r\n        int flags = _document-\u003eProcessEntities() ? StrPair::TEXT_ELEMENT : StrPair::TEXT_ELEMENT_LEAVE_ENTITIES;\r\n        if ( _document-\u003eWhitespaceMode() == COLLAPSE_WHITESPACE ) {\r\n            flags |= StrPair::NEEDS_WHITESPACE_COLLAPSING;\r\n        }\r\n\r\n        p = _value.ParseText( p, \"\u003c\", flags, curLineNumPtr );\r\n        if ( p \u0026\u0026 *p ) {\r\n            return p-1;\r\n        }\r\n        if ( !p ) {\r\n            _document-\u003eSetError( XML_ERROR_PARSING_TEXT, _parseLineNum, 0 );\r\n        }\r\n    }\r\n    return 0;\r\n}","filepath":"tinyxml2.cpp","line_number":1147,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269198768":{"score":0.76684177,"function_name":"XMLComment::ParseDeep","code":"char* XMLComment::ParseDeep( char* p, StrPair*, int* curLineNumPtr )\r\n{\r\n    // Comment parses as text.\r\n    p = _value.ParseText( p, \"--\u003e\", StrPair::COMMENT, curLineNumPtr );\r\n    if ( p == 0 ) {\r\n        _document-\u003eSetError( XML_ERROR_PARSING_COMMENT, _parseLineNum, 0 );\r\n    }\r\n    return p;\r\n}","filepath":"tinyxml2.cpp","line_number":1212,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269198832":{"score":0.69169366,"function_name":"StrPair::ParseName","code":"char* StrPair::ParseName( char* p )\r\n{\r\n    if ( !p || !(*p) ) {\r\n        return 0;\r\n    }\r\n    if ( !XMLUtil::IsNameStartChar( *p ) ) {\r\n        return 0;\r\n    }\r\n\r\n    char* const start = p;\r\n    ++p;\r\n    while ( *p \u0026\u0026 XMLUtil::IsNameChar( *p ) ) {\r\n        ++p;\r\n    }\r\n\r\n    Set( start, p, 0 );\r\n    return p;\r\n}","filepath":"tinyxml2.cpp","line_number":218,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269199056":{"score":0.80252874,"function_name":"StrPair::ParseText","code":"char* StrPair::ParseText( char* p, const char* endTag, int strFlags, int* curLineNumPtr )\r\n{\r\n    TIXMLASSERT( p );\r\n    TIXMLASSERT( endTag \u0026\u0026 *endTag );\r\n\tTIXMLASSERT(curLineNumPtr);\r\n\r\n    char* start = p;\r\n    char  endChar = *endTag;\r\n    size_t length = strlen( endTag );\r\n\r\n    // Inner loop of text parsing.\r\n    while ( *p ) {\r\n        if ( *p == endChar \u0026\u0026 strncmp( p, endTag, length ) == 0 ) {\r\n            Set( start, p, strFlags );\r\n            return p + length;\r\n        } else if (*p == '\\n') {\r\n            ++(*curLineNumPtr);\r\n        }\r\n        ++p;\r\n        TIXMLASSERT( p );\r\n    }\r\n    return 0;\r\n}","filepath":"tinyxml2.cpp","line_number":193,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269199216":{"score":0.5572958,"function_name":"XMLDocument::Print","code":"void XMLDocument::Print( XMLPrinter* streamer ) const\r\n{\r\n    if ( streamer ) {\r\n        Accept( streamer );\r\n    }\r\n    else {\r\n        XMLPrinter stdoutStreamer( stdout );\r\n        Accept( \u0026stdoutStreamer );\r\n    }\r\n}","filepath":"tinyxml2.cpp","line_number":2316,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269199616":{"score":0.83136755,"function_name":"XMLPrinter::PrintString","code":"void XMLPrinter::PrintString( const char* p, bool restricted )\r\n{\r\n    // Look for runs of bytes between entities to print.\r\n    const char* q = p;\r\n\r\n    if ( _processEntities ) {\r\n        const bool* flag = restricted ? _restrictedEntityFlag : _entityFlag;\r\n        while ( *q ) {\r\n            TIXMLASSERT( p \u003c= q );\r\n            // Remember, char is sometimes signed. (How many times has that bitten me?)\r\n            if ( *q \u003e 0 \u0026\u0026 *q \u003c ENTITY_RANGE ) {\r\n                // Check for entities. If one is found, flush\r\n                // the stream up until the entity, write the\r\n                // entity, and keep looking.\r\n                if ( flag[(unsigned char)(*q)] ) {\r\n                    while ( p \u003c q ) {\r\n                        const size_t delta = q - p;\r\n                        const int toPrint = ( INT_MAX \u003c delta ) ? INT_MAX : (int)delta;\r\n                        Write( p, toPrint );\r\n                        p += toPrint;\r\n                    }\r\n                    bool entityPatternPrinted = false;\r\n                    for( int i=0; i\u003cNUM_ENTITIES; ++i ) {\r\n                        if ( entities[i].value == *q ) {\r\n                            Putc( '\u0026' );\r\n                            Write( entities[i].pattern, entities[i].length );\r\n                            Putc( ';' );\r\n                            entityPatternPrinted = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if ( !entityPatternPrinted ) {\r\n                        // TIXMLASSERT( entityPatternPrinted ) causes gcc -Wunused-but-set-variable in release\r\n                        TIXMLASSERT( false );\r\n                    }\r\n                    ++p;\r\n                }\r\n            }\r\n            ++q;\r\n            TIXMLASSERT( p \u003c= q );\r\n        }\r\n        // Flush the remaining string. This will be the entire\r\n        // string if an entity wasn't found.\r\n        if ( p \u003c q ) {\r\n            const size_t delta = q - p;\r\n            const int toPrint = ( INT_MAX \u003c delta ) ? INT_MAX : (int)delta;\r\n            Write( p, toPrint );\r\n        }\r\n    }\r\n    else {\r\n        Write( p );\r\n    }\r\n}","filepath":"tinyxml2.cpp","line_number":2494,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269200464":{"score":0.61689156,"function_name":"XMLPrinter::PushAttribute","code":"void XMLPrinter::PushAttribute( const char* name, const char* value )\r\n{\r\n    TIXMLASSERT( _elementJustOpened );\r\n    Putc ( ' ' );\r\n    Write( name );\r\n    Write( \"=\\\"\" );\r\n    PrintString( value, false );\r\n    Putc ( '\\\"' );\r\n}","filepath":"tinyxml2.cpp","line_number":2582,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269201056":{"score":0.7968571,"function_name":"XMLPrinter::PushDeclaration","code":"void XMLPrinter::PushDeclaration( const char* value )\r\n{\r\n    SealElementIfJustOpened();\r\n    if ( _textDepth \u003c 0 \u0026\u0026 !_firstElement \u0026\u0026 !_compactMode) {\r\n        Putc( '\\n' );\r\n        PrintSpace( _depth );\r\n    }\r\n    _firstElement = false;\r\n\r\n    Write( \"\u003c?\" );\r\n    Write( value );\r\n    Write( \"?\u003e\" );\r\n}","filepath":"tinyxml2.cpp","line_number":2748,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269201408":{"score":0.7872942,"function_name":"XMLPrinter::PushHeader","code":"void XMLPrinter::PushHeader( bool writeBOM, bool writeDec )\r\n{\r\n    if ( writeBOM ) {\r\n        static const unsigned char bom[] = { TIXML_UTF_LEAD_0, TIXML_UTF_LEAD_1, TIXML_UTF_LEAD_2, 0 };\r\n        Write( reinterpret_cast\u003c const char* \u003e( bom ) );\r\n    }\r\n    if ( writeDec ) {\r\n        PushDeclaration( \"xml version=\\\"1.0\\\"\" );\r\n    }\r\n}","filepath":"tinyxml2.cpp","line_number":2549,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269201680":{"score":0.7537511,"function_name":"XMLPrinter::PushText","code":"void XMLPrinter::PushText( const char* text, bool cdata )\r\n{\r\n    _textDepth = _depth-1;\r\n\r\n    SealElementIfJustOpened();\r\n    if ( cdata ) {\r\n        Write( \"\u003c![CDATA[\" );\r\n        Write( text );\r\n        Write( \"]]\u003e\" );\r\n    }\r\n    else {\r\n        PrintString( text, true );\r\n    }\r\n}","filepath":"tinyxml2.cpp","line_number":2671,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269202240":{"score":0.63362426,"function_name":"XMLUtil::ToInt64","code":"bool XMLUtil::ToInt64(const char* str, int64_t* value)\r\n{\r\n\tlong long v = 0;\t// horrible syntax trick to make the compiler happy about %lld\r\n\tif (TIXML_SSCANF(str, \"%lld\", \u0026v) == 1) {\r\n\t\t*value = (int64_t)v;\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}","filepath":"tinyxml2.cpp","line_number":645,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269204160":{"score":0.5709079,"function_name":"XMLNode::PreviousSiblingElement","code":"const XMLElement* XMLNode::PreviousSiblingElement( const char* name ) const\r\n{\r\n    for( const XMLNode* node = _prev; node; node = node-\u003e_prev ) {\r\n        const XMLElement* element = node-\u003eToElementWithName( name );\r\n        if ( element ) {\r\n            return element;\r\n        }\r\n    }\r\n    return 0;\r\n}","filepath":"tinyxml2.cpp","line_number":976,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269204848":{"score":0.80874157,"function_name":"XMLDocument::SetError","code":"void XMLDocument::SetError( XMLError error, int lineNum, const char* format, ... )\r\n{\r\n    TIXMLASSERT( error \u003e= 0 \u0026\u0026 error \u003c XML_ERROR_COUNT );\r\n    _errorID = error;\r\n    _errorLineNum = lineNum;\r\n\t_errorStr.Reset();\r\n\r\n    size_t BUFFER_SIZE = 1000;\r\n    char* buffer = new char[BUFFER_SIZE];\r\n\r\n    TIXMLASSERT(sizeof(error) \u003c= sizeof(int));\r\n    TIXML_SNPRINTF(buffer, BUFFER_SIZE, \"Error=%s ErrorID=%d (0x%x) Line number=%d\", ErrorIDToName(error), int(error), int(error), lineNum);\r\n\r\n\tif (format) {\r\n\t\tsize_t len = strlen(buffer);\r\n\t\tTIXML_SNPRINTF(buffer + len, BUFFER_SIZE - len, \": \");\r\n\t\tlen = strlen(buffer);\r\n\r\n\t\tva_list va;\r\n\t\tva_start(va, format);\r\n\t\tTIXML_VSNPRINTF(buffer + len, BUFFER_SIZE - len, format, va);\r\n\t\tva_end(va);\r\n\t}\r\n\t_errorStr.SetStr(buffer);\r\n\tdelete[] buffer;\r\n}","filepath":"tinyxml2.cpp","line_number":2328,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269205088":{"score":0.7913234,"function_name":"StrPair::SetStr","code":"void StrPair::SetStr( const char* str, int flags )\r\n{\r\n    TIXMLASSERT( str );\r\n    Reset();\r\n    size_t len = strlen( str );\r\n    TIXMLASSERT( _start == 0 );\r\n    _start = new char[ len+1 ];\r\n    memcpy( _start, str, len+1 );\r\n    _end = _start + len;\r\n    _flags = flags | NEEDS_DELETE;\r\n}","filepath":"tinyxml2.cpp","line_number":180,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269205680":{"score":0.58383167,"function_name":"XMLElement::ShallowClone","code":"XMLNode* XMLElement::ShallowClone( XMLDocument* doc ) const\r\n{\r\n    if ( !doc ) {\r\n        doc = _document;\r\n    }\r\n    XMLElement* element = doc-\u003eNewElement( Value() );\t\t\t\t\t// fixme: this will always allocate memory. Intern?\r\n    for( const XMLAttribute* a=FirstAttribute(); a; a=a-\u003eNext() ) {\r\n        element-\u003eSetAttribute( a-\u003eName(), a-\u003eValue() );\t\t\t\t\t// fixme: this will always allocate memory. Intern?\r\n    }\r\n    return element;\r\n}","filepath":"tinyxml2.cpp","line_number":1927,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269205936":{"score":0.67815936,"function_name":"XMLText::ShallowClone","code":"XMLNode* XMLText::ShallowClone( XMLDocument* doc ) const\r\n{\r\n    if ( !doc ) {\r\n        doc = _document;\r\n    }\r\n    XMLText* text = doc-\u003eNewText( Value() );\t// fixme: this will always allocate memory. Intern?\r\n    text-\u003eSetCData( this-\u003eCData() );\r\n    return text;\r\n}","filepath":"tinyxml2.cpp","line_number":1174,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269206368":{"score":0.81336796,"function_name":"XMLElement::ShallowEqual","code":"bool XMLElement::ShallowEqual( const XMLNode* compare ) const\r\n{\r\n    TIXMLASSERT( compare );\r\n    const XMLElement* other = compare-\u003eToElement();\r\n    if ( other \u0026\u0026 XMLUtil::StringEqual( other-\u003eName(), Name() )) {\r\n\r\n        const XMLAttribute* a=FirstAttribute();\r\n        const XMLAttribute* b=other-\u003eFirstAttribute();\r\n\r\n        while ( a \u0026\u0026 b ) {\r\n            if ( !XMLUtil::StringEqual( a-\u003eValue(), b-\u003eValue() ) ) {\r\n                return false;\r\n            }\r\n            a = a-\u003eNext();\r\n            b = b-\u003eNext();\r\n        }\r\n        if ( a || b ) {\r\n            // different count\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}","filepath":"tinyxml2.cpp","line_number":1940,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269207008":{"score":0.8132392,"function_name":"StrPair::TransferTo","code":"void StrPair::TransferTo( StrPair* other )\r\n{\r\n    if ( this == other ) {\r\n        return;\r\n    }\r\n    // This in effect implements the assignment operator by \"moving\"\r\n    // ownership (as in auto_ptr).\r\n\r\n    TIXMLASSERT( other != 0 );\r\n    TIXMLASSERT( other-\u003e_flags == 0 );\r\n    TIXMLASSERT( other-\u003e_start == 0 );\r\n    TIXMLASSERT( other-\u003e_end == 0 );\r\n\r\n    other-\u003eReset();\r\n\r\n    other-\u003e_flags = _flags;\r\n    other-\u003e_start = _start;\r\n    other-\u003e_end = _end;\r\n\r\n    _flags = 0;\r\n    _start = 0;\r\n    _end = 0;\r\n}","filepath":"tinyxml2.cpp","line_number":144,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269207552":{"score":0.73668754,"function_name":"XMLPrinter::VisitEnter","code":"bool XMLPrinter::VisitEnter( const XMLElement\u0026 element, const XMLAttribute* attribute )\r\n{\r\n    const XMLElement* parentElem = 0;\r\n    if ( element.Parent() ) {\r\n        parentElem = element.Parent()-\u003eToElement();\r\n    }\r\n    const bool compactMode = parentElem ? CompactMode( *parentElem ) : _compactMode;\r\n    OpenElement( element.Name(), compactMode );\r\n    while ( attribute ) {\r\n        PushAttribute( attribute-\u003eName(), attribute-\u003eValue() );\r\n        attribute = attribute-\u003eNext();\r\n    }\r\n    return true;\r\n}","filepath":"tinyxml2.cpp","line_number":2788,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269207728":{"score":0.55621386,"function_name":"XMLPrinter::Write","code":"void XMLPrinter::Write( const char* data, size_t size )\r\n{\r\n    if ( _fp ) {\r\n        fwrite ( data , sizeof(char), size, _fp);\r\n    }\r\n    else {\r\n        char* p = _buffer.PushArr( static_cast\u003cint\u003e(size) ) - 1;   // back up over the null terminator.\r\n        memcpy( p, data, size );\r\n        p[size] = 0;\r\n    }\r\n}","filepath":"tinyxml2.cpp","line_number":2460,"entry_url":"https://github.com/leethomason/tinyxml2.git","slot_name":"7.0.0"},"269324448":{"score":0.8263811,"function_name":"AP4_StdcFileByteStream::Create","code":"AP4_Result\nAP4_StdcFileByteStream::Create(AP4_FileByteStream*      delegator,\n                               const char*              name, \n                               AP4_FileByteStream::Mode mode, \n                               AP4_ByteStream*\u0026         stream)\n{\n    // default value\n    stream = NULL;\n    \n    // check arguments\n    if (name == NULL) return AP4_ERROR_INVALID_PARAMETERS;\n    \n    // open the file\n    FILE* file = NULL;\n    AP4_Position size = 0;\n    if (!strcmp(name, \"-stdin\")) {\n        file = stdin;\n    } else if (!strcmp(name, \"-stdout\")) {\n        file = stdout;\n    } else if (!strcmp(name, \"-stderr\")) {\n        file = stderr;\n    } else {\n        int open_result;\n        switch (mode) {\n          case AP4_FileByteStream::STREAM_MODE_READ:\n            open_result = fopen_s(\u0026file, name, \"rb\");\n            break;\n\n          case AP4_FileByteStream::STREAM_MODE_WRITE:\n            open_result = fopen_s(\u0026file, name, \"wb+\");\n            break;\n\n          case AP4_FileByteStream::STREAM_MODE_READ_WRITE:\n              open_result = fopen_s(\u0026file, name, \"r+b\");\n              break;                                  \n\n          default:\n            return AP4_ERROR_INVALID_PARAMETERS;\n        }\n    \n        if (open_result != 0) {\n            if (open_result == ENOENT) {\n                return AP4_ERROR_NO_SUCH_FILE;\n            } else if (open_result == EACCES) {\n                return AP4_ERROR_PERMISSION_DENIED;\n            } else {\n                return AP4_ERROR_CANNOT_OPEN_FILE;\n            }\n        }\n\n        // get the size\n        if (AP4_fseek(file, 0, SEEK_END) \u003e= 0) {\n            size = AP4_ftell(file);\n            AP4_fseek(file, 0, SEEK_SET);\n        }\n        \n    }\n\n    stream = new AP4_StdcFileByteStream(delegator, file, size);\n    return AP4_SUCCESS;\n}","filepath":"Source/C++/System/StdC/Ap4StdCFileByteStream.cpp","line_number":117,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-612"},"269325024":{"score":0.9134819,"function_name":"AP4_StdcFileByteStream::ReadPartial","code":"AP4_Result\nAP4_StdcFileByteStream::ReadPartial(void*     buffer, \n                                    AP4_Size  bytesToRead, \n                                    AP4_Size\u0026 bytesRead)\n{\n    size_t nbRead;\n\n    nbRead = fread(buffer, 1, bytesToRead, m_File);\n\n    if (nbRead \u003e 0) {\n        bytesRead = (AP4_Size)nbRead;\n        m_Position += nbRead;\n        return AP4_SUCCESS;\n    } else if (feof(m_File)) {\n        bytesRead = 0;\n        return AP4_ERROR_EOS;\n    } else {\n        bytesRead = 0;\n        return AP4_ERROR_READ_FAILED;\n    }\n}","filepath":"Source/C++/System/StdC/Ap4StdCFileByteStream.cpp","line_number":230,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-612"},"269325120":{"score":0.8289567,"function_name":"AP4_StdcFileByteStream::Release","code":"void\nAP4_StdcFileByteStream::Release()\n{\n    if (--m_ReferenceCount == 0) {\n        if (m_Delegator) {\n            delete m_Delegator;\n        } else {\n            delete this;\n        }\n    }\n}","filepath":"Source/C++/System/StdC/Ap4StdCFileByteStream.cpp","line_number":215,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-612"},"269325152":{"score":0.6968638,"function_name":"AP4_StdcFileByteStream::Seek","code":"AP4_Result\nAP4_StdcFileByteStream::Seek(AP4_Position position)\n{\n    // shortcut\n    if (position == m_Position) return AP4_SUCCESS;\n    \n    size_t result;\n    result = AP4_fseek(m_File, position, SEEK_SET);\n    if (result == 0) {\n        m_Position = position;\n        return AP4_SUCCESS;\n    } else {\n        return AP4_FAILURE;\n    }\n}","filepath":"Source/C++/System/StdC/Ap4StdCFileByteStream.cpp","line_number":278,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-612"},"269325232":{"score":0.87924284,"function_name":"AP4_StdcFileByteStream::WritePartial","code":"AP4_Result\nAP4_StdcFileByteStream::WritePartial(const void* buffer, \n                                     AP4_Size    bytesToWrite, \n                                     AP4_Size\u0026   bytesWritten)\n{\n    size_t nbWritten;\n\n    if (bytesToWrite == 0) return AP4_SUCCESS;\n    nbWritten = fwrite(buffer, 1, bytesToWrite, m_File);\n    \n    if (nbWritten \u003e 0) {\n        bytesWritten = (AP4_Size)nbWritten;\n        m_Position += nbWritten;\n        return AP4_SUCCESS;\n    } else {\n        bytesWritten = 0;\n        return AP4_ERROR_WRITE_FAILED;\n    }\n}","filepath":"Source/C++/System/StdC/Ap4StdCFileByteStream.cpp","line_number":255,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-612"},"269572928":{"score":0.6747792,"function_name":"down_heap","code":"void down_heap(std::size_t index)\n  {\n    std::size_t child = index * 2 + 1;\n    while (child \u003c heap_.size())\n    {\n      std::size_t min_child = (child + 1 == heap_.size()\n          || Time_Traits::less_than(\n            heap_[child].time_, heap_[child + 1].time_))\n        ? child : child + 1;\n      if (Time_Traits::less_than(heap_[index].time_, heap_[min_child].time_))\n        break;\n      swap_heap(index, min_child);\n      index = min_child;\n      child = index * 2 + 1;\n    }\n  }","filepath":"include/boost/asio/detail/timer_queue.hpp","line_number":222,"entry_url":"https://github.com/boostorg/asio.git","slot_name":"boost-1.47.0-beta1"},"269573344":{"score":0.789378,"function_name":"enqueue_timer","code":"bool enqueue_timer(const time_type\u0026 time, per_timer_data\u0026 timer, timer_op* op)\n  {\n    // Enqueue the timer object.\n    if (timer.prev_ == 0 \u0026\u0026 \u0026timer != timers_)\n    {\n      if (this-\u003eis_positive_infinity(time))\n      {\n        // No heap entry is required for timers that never expire.\n        timer.heap_index_ = (std::numeric_limits\u003cstd::size_t\u003e::max)();\n      }\n      else\n      {\n        // Put the new timer at the correct position in the heap. This is done\n        // first since push_back() can throw due to allocation failure.\n        timer.heap_index_ = heap_.size();\n        heap_entry entry = { time, \u0026timer };\n        heap_.push_back(entry);\n        up_heap(heap_.size() - 1);\n      }\n\n      // Insert the new timer into the linked list of active timers.\n      timer.next_ = timers_;\n      timer.prev_ = 0;\n      if (timers_)\n        timers_-\u003eprev_ = \u0026timer;\n      timers_ = \u0026timer;\n    }\n\n    // Enqueue the individual timer operation.\n    timer.op_queue_.push(op);\n\n    // Interrupt reactor only if newly added timer is first to expire.\n    return timer.heap_index_ == 0 \u0026\u0026 timer.op_queue_.front() == op;\n  }","filepath":"include/boost/asio/detail/timer_queue.hpp","line_number":80,"entry_url":"https://github.com/boostorg/asio.git","slot_name":"boost-1.47.0-beta1"},"269576256":{"score":0.68956184,"function_name":"get_all_timers","code":"virtual void get_all_timers(op_queue\u003coperation\u003e\u0026 ops)\n  {\n    while (timers_)\n    {\n      per_timer_data* timer = timers_;\n      timers_ = timers_-\u003enext_;\n      ops.push(timer-\u003eop_queue_);\n      timer-\u003enext_ = 0;\n      timer-\u003eprev_ = 0;\n    }\n\n    heap_.clear();\n  }","filepath":"include/boost/asio/detail/timer_queue.hpp","line_number":172,"entry_url":"https://github.com/boostorg/asio.git","slot_name":"boost-1.47.0-beta1"},"269614032":{"score":0.8486344,"function_name":"md5_append","code":"void\nmd5_append(md5_state_t *pms, const md5_byte_t *data, int nbytes)\n{\n    const md5_byte_t *p = data;\n    int left = nbytes;\n    int offset = (pms-\u003ecount[0] \u003e\u003e 3) \u0026 63;\n    md5_word_t nbits = (md5_word_t)(nbytes \u003c\u003c 3);\n\n    if (nbytes \u003c= 0)\n\treturn;\n\n    /* Update the message length. */\n    pms-\u003ecount[1] += nbytes \u003e\u003e 29;\n    pms-\u003ecount[0] += nbits;\n    if (pms-\u003ecount[0] \u003c nbits)\n\tpms-\u003ecount[1]++;\n\n    /* Process an initial partial block. */\n    if (offset) {\n\tint copy = (offset + nbytes \u003e 64 ? 64 - offset : nbytes);\n\n\tmemcpy(pms-\u003ebuf + offset, p, copy);\n\tif (offset + copy \u003c 64)\n\t    return;\n\tp += copy;\n\tleft -= copy;\n\tmd5_process(pms, pms-\u003ebuf);\n    }\n\n    /* Process full blocks. */\n    for (; left \u003e= 64; p += 64, left -= 64)\n\tmd5_process(pms, p);\n\n    /* Process a final partial block. */\n    if (left)\n\tmemcpy(pms-\u003ebuf, p, left);\n}","filepath":"src/plugins/lan/md5.c","line_number":322,"entry_url":"https://qa.debian.org/watch/sf.php/ipmitool/","slot_name":"1.5.4"},"269614240":{"score":0.7334883,"function_name":"md5_finish","code":"void\nmd5_finish(md5_state_t *pms, md5_byte_t digest[16])\n{\n    static const md5_byte_t pad[64] = {\n\t0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n    };\n    md5_byte_t data[8];\n    int i;\n\n    /* Save the length before padding. */\n    for (i = 0; i \u003c 8; ++i)\n\tdata[i] = (md5_byte_t)(pms-\u003ecount[i \u003e\u003e 2] \u003e\u003e ((i \u0026 3) \u003c\u003c 3));\n    /* Pad to 56 bytes mod 64. */\n    md5_append(pms, pad, ((55 - (pms-\u003ecount[0] \u003e\u003e 3)) \u0026 63) + 1);\n    /* Append the length. */\n    md5_append(pms, data, 8);\n    for (i = 0; i \u003c 16; ++i)\n\tdigest[i] = (md5_byte_t)(pms-\u003eabcd[i \u003e\u003e 2] \u003e\u003e ((i \u0026 3) \u003c\u003c 3));\n}","filepath":"src/plugins/lan/md5.c","line_number":360,"entry_url":"https://qa.debian.org/watch/sf.php/ipmitool/","slot_name":"1.5.4"},"269614880":{"score":0.8293847,"function_name":"md5_process","code":"static void\nmd5_process(md5_state_t *pms, const md5_byte_t *data /*[64]*/)\n{\n    md5_word_t\n\ta = pms-\u003eabcd[0], b = pms-\u003eabcd[1],\n\tc = pms-\u003eabcd[2], d = pms-\u003eabcd[3];\n    md5_word_t t;\n#if BYTE_ORDER \u003e 0\n    /* Define storage only for big-endian CPUs. */\n    md5_word_t X[16];\n#else\n    /* Define storage for little-endian or both types of CPUs. */\n    md5_word_t xbuf[16];\n    const md5_word_t *X;\n#endif\n\n    {\n#if BYTE_ORDER == 0\n\t/*\n\t * Determine dynamically whether this is a big-endian or\n\t * little-endian machine, since we can use a more efficient\n\t * algorithm on the latter.\n\t */\n\tstatic const int w = 1;\n\n\tif (*((const md5_byte_t *)\u0026w)) /* dynamic little-endian */\n#endif\n#if BYTE_ORDER \u003c= 0\t\t/* little-endian */\n\t{\n\t    /*\n\t     * On little-endian machines, we can process properly aligned\n\t     * data without copying it.\n\t     */\n\t    if (!((data - (const md5_byte_t *)0) \u0026 3)) {\n\t\t/* data are properly aligned */\n\t\tX = (const md5_word_t *)data;\n\t    } else {\n\t\t/* not aligned */\n\t\tmemcpy(xbuf, data, 64);\n\t\tX = xbuf;\n\t    }\n\t}\n#endif\n#if BYTE_ORDER == 0\n\telse\t\t\t/* dynamic big-endian */\n#endif\n#if BYTE_ORDER \u003e= 0\t\t/* big-endian */\n\t{\n\t    /*\n\t     * On big-endian machines, we must arrange the bytes in the\n\t     * right order.\n\t     */\n\t    const md5_byte_t *xp = data;\n\t    int i;\n\n#  if BYTE_ORDER == 0\n\t    X = xbuf;\t\t/* (dynamic only) */\n#  else\n#    define xbuf X\t\t/* (static only) */\n#  endif\n\t    for (i = 0; i \u003c 16; ++i, xp += 4)\n\t\txbuf[i] = xp[0] + (xp[1] \u003c\u003c 8) + (xp[2] \u003c\u003c 16) + (xp[3] \u003c\u003c 24);\n\t}\n#endif\n    }\n\n#define ROTATE_LEFT(x, n) (((x) \u003c\u003c (n)) | ((x) \u003e\u003e (32 - (n))))\n\n    /* Round 1. */\n    /* Let [abcd k s i] denote the operation\n       a = b + ((a + F(b,c,d) + X[k] + T[i]) \u003c\u003c\u003c s). */\n#define F(x, y, z) (((x) \u0026 (y)) | (~(x) \u0026 (z)))\n#define SET(a, b, c, d, k, s, Ti)\\\n  t = a + F(b,c,d) + X[k] + Ti;\\\n  a = ROTATE_LEFT(t, s) + b\n    /* Do the following 16 operations. */\n    SET(a, b, c, d,  0,  7,  T1);\n    SET(d, a, b, c,  1, 12,  T2);\n    SET(c, d, a, b,  2, 17,  T3);\n    SET(b, c, d, a,  3, 22,  T4);\n    SET(a, b, c, d,  4,  7,  T5);\n    SET(d, a, b, c,  5, 12,  T6);\n    SET(c, d, a, b,  6, 17,  T7);\n    SET(b, c, d, a,  7, 22,  T8);\n    SET(a, b, c, d,  8,  7,  T9);\n    SET(d, a, b, c,  9, 12, T10);\n    SET(c, d, a, b, 10, 17, T11);\n    SET(b, c, d, a, 11, 22, T12);\n    SET(a, b, c, d, 12,  7, T13);\n    SET(d, a, b, c, 13, 12, T14);\n    SET(c, d, a, b, 14, 17, T15);\n    SET(b, c, d, a, 15, 22, T16);\n#undef SET\n\n     /* Round 2. */\n     /* Let [abcd k s i] denote the operation\n          a = b + ((a + G(b,c,d) + X[k] + T[i]) \u003c\u003c\u003c s). */\n#define G(x, y, z) (((x) \u0026 (z)) | ((y) \u0026 ~(z)))\n#define SET(a, b, c, d, k, s, Ti)\\\n  t = a + G(b,c,d) + X[k] + Ti;\\\n  a = ROTATE_LEFT(t, s) + b\n     /* Do the following 16 operations. */\n    SET(a, b, c, d,  1,  5, T17);\n    SET(d, a, b, c,  6,  9, T18);\n    SET(c, d, a, b, 11, 14, T19);\n    SET(b, c, d, a,  0, 20, T20);\n    SET(a, b, c, d,  5,  5, T21);\n    SET(d, a, b, c, 10,  9, T22);\n    SET(c, d, a, b, 15, 14, T23);\n    SET(b, c, d, a,  4, 20, T24);\n    SET(a, b, c, d,  9,  5, T25);\n    SET(d, a, b, c, 14,  9, T26);\n    SET(c, d, a, b,  3, 14, T27);\n    SET(b, c, d, a,  8, 20, T28);\n    SET(a, b, c, d, 13,  5, T29);\n    SET(d, a, b, c,  2,  9, T30);\n    SET(c, d, a, b,  7, 14, T31);\n    SET(b, c, d, a, 12, 20, T32);\n#undef SET\n\n     /* Round 3. */\n     /* Let [abcd k s t] denote the operation\n          a = b + ((a + H(b,c,d) + X[k] + T[i]) \u003c\u003c\u003c s). */\n#define H(x, y, z) ((x) ^ (y) ^ (z))\n#define SET(a, b, c, d, k, s, Ti)\\\n  t = a + H(b,c,d) + X[k] + Ti;\\\n  a = ROTATE_LEFT(t, s) + b\n     /* Do the following 16 operations. */\n    SET(a, b, c, d,  5,  4, T33);\n    SET(d, a, b, c,  8, 11, T34);\n    SET(c, d, a, b, 11, 16, T35);\n    SET(b, c, d, a, 14, 23, T36);\n    SET(a, b, c, d,  1,  4, T37);\n    SET(d, a, b, c,  4, 11, T38);\n    SET(c, d, a, b,  7, 16, T39);\n    SET(b, c, d, a, 10, 23, T40);\n    SET(a, b, c, d, 13,  4, T41);\n    SET(d, a, b, c,  0, 11, T42);\n    SET(c, d, a, b,  3, 16, T43);\n    SET(b, c, d, a,  6, 23, T44);\n    SET(a, b, c, d,  9,  4, T45);\n    SET(d, a, b, c, 12, 11, T46);\n    SET(c, d, a, b, 15, 16, T47);\n    SET(b, c, d, a,  2, 23, T48);\n#undef SET\n\n     /* Round 4. */\n     /* Let [abcd k s t] denote the operation\n          a = b + ((a + I(b,c,d) + X[k] + T[i]) \u003c\u003c\u003c s). */\n#define I(x, y, z) ((y) ^ ((x) | ~(z)))\n#define SET(a, b, c, d, k, s, Ti)\\\n  t = a + I(b,c,d) + X[k] + Ti;\\\n  a = ROTATE_LEFT(t, s) + b\n     /* Do the following 16 operations. */\n    SET(a, b, c, d,  0,  6, T49);\n    SET(d, a, b, c,  7, 10, T50);\n    SET(c, d, a, b, 14, 15, T51);\n    SET(b, c, d, a,  5, 21, T52);\n    SET(a, b, c, d, 12,  6, T53);\n    SET(d, a, b, c,  3, 10, T54);\n    SET(c, d, a, b, 10, 15, T55);\n    SET(b, c, d, a,  1, 21, T56);\n    SET(a, b, c, d,  8,  6, T57);\n    SET(d, a, b, c, 15, 10, T58);\n    SET(c, d, a, b,  6, 15, T59);\n    SET(b, c, d, a, 13, 21, T60);\n    SET(a, b, c, d,  4,  6, T61);\n    SET(d, a, b, c, 11, 10, T62);\n    SET(c, d, a, b,  2, 15, T63);\n    SET(b, c, d, a,  9, 21, T64);\n#undef SET\n\n     /* Then perform the following additions. (That is increment each\n        of the four registers by the value it had before this block\n        was started.) */\n    pms-\u003eabcd[0] += a;\n    pms-\u003eabcd[1] += b;\n    pms-\u003eabcd[2] += c;\n    pms-\u003eabcd[3] += d;\n}","filepath":"src/plugins/lan/md5.c","line_number":131,"entry_url":"https://qa.debian.org/watch/sf.php/ipmitool/","slot_name":"1.5.4"},"269681504":{"score":0.7375125,"function_name":"AP4_DataBuffer::AP4_DataBuffer","code":"AP4_DataBuffer::AP4_DataBuffer(const AP4_DataBuffer\u0026 other) :\n    m_BufferIsLocal(true),\n    m_Buffer(NULL),\n    m_BufferSize(other.m_DataSize),\n    m_DataSize(other.m_DataSize)\n{\n    m_Buffer = new AP4_Byte[m_BufferSize];\n    AP4_CopyMemory(m_Buffer, other.m_Buffer, m_BufferSize);\n}","filepath":"Source/C++/Core/Ap4DataBuffer.cpp","line_number":76,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.4.3-596"},"269681584":{"score":0.6787901,"function_name":"AP4_DataBuffer::AP4_DataBuffer","code":"AP4_DataBuffer::AP4_DataBuffer(AP4_Size buffer_size) :\n    m_BufferIsLocal(true),\n    m_Buffer(NULL),\n    m_BufferSize(buffer_size),\n    m_DataSize(0)\n{\n    m_Buffer = new AP4_Byte[buffer_size];\n}","filepath":"Source/C++/Core/Ap4DataBuffer.cpp","line_number":49,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.4.3-596"},"269681648":{"score":0.78719604,"function_name":"AP4_DataBuffer::AP4_DataBuffer","code":"AP4_DataBuffer::AP4_DataBuffer(const void* data, AP4_Size data_size) :\n    m_BufferIsLocal(true),\n    m_Buffer(NULL),\n    m_BufferSize(data_size),\n    m_DataSize(data_size)\n{\n    if (data \u0026\u0026 data_size) {\n        m_Buffer = new AP4_Byte[data_size];\n        AP4_CopyMemory(m_Buffer, data, data_size);\n    }\n}","filepath":"Source/C++/Core/Ap4DataBuffer.cpp","line_number":61,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.4.3-596"},"269681872":{"score":0.7642939,"function_name":"AP4_DataBuffer::AppendData","code":"AP4_Result\nAP4_DataBuffer::AppendData(const AP4_Byte* data, AP4_Size data_size)\n{\n    if (data == NULL || data_size == 0) {\n        return AP4_SUCCESS;\n    }\n    \n    AP4_Size existing_size = m_DataSize;\n    AP4_Result result = SetDataSize(existing_size+data_size);\n    if (AP4_FAILED(result)) {\n        return result;\n    }\n    AP4_CopyMemory(m_Buffer+existing_size, data, data_size);\n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4DataBuffer.cpp","line_number":184,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.4.3-596"},"269681984":{"score":0.87137246,"function_name":"AP4_DataBuffer::ReallocateBuffer","code":"AP4_Result\nAP4_DataBuffer::ReallocateBuffer(AP4_Size size)\n{\n    // check that the existing data fits\n    if (m_DataSize \u003e size) return AP4_FAILURE;\n\n    // allocate a new buffer\n    AP4_Byte* new_buffer = new AP4_Byte[size];\n\n    // copy the contents of the previous buffer ,is any\n\tif (m_Buffer \u0026\u0026 m_DataSize) {\n\t\tAP4_CopyMemory(new_buffer, m_Buffer, m_DataSize);\n\t}\n\n    // destroy the previous buffer\n    delete[] m_Buffer;\n\n    // use the new buffer\n    m_Buffer = new_buffer;\n    m_BufferSize = size;\n\n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4DataBuffer.cpp","line_number":203,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.4.3-596"},"269682144":{"score":0.8595307,"function_name":"AP4_DataBuffer::SetData","code":"AP4_Result\nAP4_DataBuffer::SetData(const AP4_Byte* data, AP4_Size size)\n{\n    if (size \u003e m_BufferSize) {\n        if (m_BufferIsLocal) {\n            AP4_Result result = ReallocateBuffer(size);\n            if (AP4_FAILED(result)) return result;\n        } else {\n            return AP4_FAILURE;\n        }\n    }\n    AP4_CopyMemory(m_Buffer, data, size);\n    m_DataSize = size;\n\n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4DataBuffer.cpp","line_number":164,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.4.3-596"},"269682224":{"score":0.8298055,"function_name":"AP4_DataBuffer::SetDataSize","code":"AP4_Result\nAP4_DataBuffer::SetDataSize(AP4_Size size)\n{\n    if (size \u003e m_BufferSize) {\n        if (m_BufferIsLocal) {\n            AP4_Result result = ReallocateBuffer(size);\n            if (AP4_FAILED(result)) return result;\n        } else { \n            return AP4_FAILURE;\n        }\n    }\n    m_DataSize = size;\n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4DataBuffer.cpp","line_number":146,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.4.3-596"},"269685792":{"score":0.5693176,"function_name":"AP4_String::operator=","code":"const AP4_String\u0026\nAP4_String::operator=(const AP4_String\u0026 s)\n{\n    if (\u0026s == this) return *this;\n    if (m_Chars != \u0026EmptyString) delete[] m_Chars;\n    m_Length = s.m_Length;\n    m_Chars = new char[m_Length+1];\n    AP4_CopyMemory(m_Chars, s.m_Chars, m_Length+1);\n\n    return *this;\n}","filepath":"Source/C++/Core/Ap4String.cpp","line_number":100,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.1-628"},"269685984":{"score":0.73448753,"function_name":"AP4_String::AP4_String","code":"AP4_String::AP4_String(const char* s) {\n    if (s == NULL) {\n        m_Chars = \u0026EmptyString;\n        m_Length = 0;\n        return;\n    }\n    m_Length = (AP4_Size)AP4_StringLength(s);\n    m_Chars = new char[m_Length+1];\n    AP4_CopyMemory(m_Chars, s, m_Length+1);\n}","filepath":"Source/C++/Core/Ap4String.cpp","line_number":49,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.1-628"},"269686176":{"score":0.6840234,"function_name":"AP4_String::operator=","code":"const AP4_String\u0026\nAP4_String::operator=(const char* s)\n{\n    if (s == NULL) {\n        if (m_Chars != \u0026EmptyString) delete[] m_Chars;\n        m_Chars = \u0026EmptyString;\n        m_Length = 0;\n    } else {\n        Assign(s, (AP4_Size)AP4_StringLength(s));\n    }\n\n    return *this;\n}","filepath":"Source/C++/Core/Ap4String.cpp","line_number":115,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.1-628"},"269686320":{"score":0.8430878,"function_name":"AP4_String::Assign","code":"void\nAP4_String::Assign(const char* s, AP4_Size size)\n{\n    if (m_Chars != \u0026EmptyString) delete[] m_Chars;\n    m_Length = size;\n    m_Chars = new char[m_Length+1];\n    AP4_CopyMemory(m_Chars, s, m_Length);\n    m_Chars[size] = '\\0';\n}","filepath":"Source/C++/Core/Ap4String.cpp","line_number":160,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.1-628"},"269688032":{"score":0.59398586,"function_name":"AP4_MpegAudioSampleDescription::AP4_MpegAudioSampleDescription","code":"AP4_MpegAudioSampleDescription::AP4_MpegAudioSampleDescription(\n    AP4_UI32  sample_rate,\n    AP4_UI16  sample_size,\n    AP4_UI16  channel_count,\n    AP4_EsdsAtom* esds) :\n    AP4_MpegSampleDescription(AP4_ATOM_TYPE_MP4A, esds),\n    AP4_AudioSampleDescription(sample_rate, sample_size, channel_count)\n{\n}","filepath":"Source/C++/Core/Ap4SampleDescription.cpp","line_number":679,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-610"},"269688112":{"score":0.61964834,"function_name":"AP4_MpegSampleDescription::AP4_MpegSampleDescription","code":"AP4_MpegSampleDescription::AP4_MpegSampleDescription(AP4_UI32      format,\n                                                     AP4_EsdsAtom* esds) :\n    AP4_SampleDescription(TYPE_MPEG, format, NULL),\n    m_StreamType(0),\n    m_ObjectTypeId(0),\n    m_BufferSize(0),\n    m_MaxBitrate(0),\n    m_AvgBitrate(0)\n{\n    if (esds) {\n        // get the es descriptor\n        const AP4_EsDescriptor* es_desc = esds-\u003eGetEsDescriptor();\n        if (es_desc == NULL) return;\n\n        // get the decoder config descriptor\n        const AP4_DecoderConfigDescriptor* dc_desc =\n            es_desc-\u003eGetDecoderConfigDescriptor();\n        if (dc_desc) {\n            m_StreamType   = dc_desc-\u003eGetStreamType();\n            m_ObjectTypeId = dc_desc-\u003eGetObjectTypeIndication();\n            m_BufferSize   = dc_desc-\u003eGetBufferSize();\n            m_MaxBitrate   = dc_desc-\u003eGetMaxBitrate();\n            m_AvgBitrate   = dc_desc-\u003eGetAvgBitrate();\n            const AP4_DecoderSpecificInfoDescriptor* dsi_desc =\n                dc_desc-\u003eGetDecoderSpecificInfoDescriptor();\n            if (dsi_desc != NULL) {\n                m_DecoderInfo.SetData(dsi_desc-\u003eGetDecoderSpecificInfo().GetData(),\n                                      dsi_desc-\u003eGetDecoderSpecificInfo().GetDataSize());\n            }\n        }\n    }\n}","filepath":"Source/C++/Core/Ap4SampleDescription.cpp","line_number":555,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-610"},"269689840":{"score":0.96453124,"function_name":"AP4_GetFormatName","code":"char*\nAP4_GetFormatName(AP4_UI32 format)\n{\n    switch (format) {\n        case AP4_SAMPLE_FORMAT_MP4A: return \"MPEG-4 Audio\";\n        case AP4_SAMPLE_FORMAT_MP4V: return \"MPEG-4 Video\";\n        case AP4_SAMPLE_FORMAT_MP4S: return \"MPEG-4 Systems\";\n        case AP4_SAMPLE_FORMAT_ALAC: return \"Apple Lossless Audio\";\n        case AP4_SAMPLE_FORMAT_AVC1: return \"H.264\";\n        case AP4_SAMPLE_FORMAT_AVC2: return \"H.264\";\n        case AP4_SAMPLE_FORMAT_AVC3: return \"H.264\";\n        case AP4_SAMPLE_FORMAT_AVC4: return \"H.264\";\n        case AP4_SAMPLE_FORMAT_DVAV: return \"Dolby Vision (H.264)\";\n        case AP4_SAMPLE_FORMAT_DVA1: return \"Dolby Vision (H.264)\";\n        case AP4_SAMPLE_FORMAT_HEV1: return \"H.265\";\n        case AP4_SAMPLE_FORMAT_HVC1: return \"H.265\";\n        case AP4_SAMPLE_FORMAT_DVH1: return \"Dolby Vision (H.265)\";\n        case AP4_SAMPLE_FORMAT_DVHE: return \"Dolby Vision (H.265)\";\n        case AP4_SAMPLE_FORMAT_OVC1: return \"VC-1\";\n        case AP4_SAMPLE_FORMAT_OWMA: return \"WMA\";\n        case AP4_SAMPLE_FORMAT_AC_3: return \"Dolby Digital (AC-3)\";\n        case AP4_SAMPLE_FORMAT_EC_3: return \"Dolby Digital Plus (Enhanced AC-3)\";\n        case AP4_SAMPLE_FORMAT_DTSC: return \"DTS\";\n        case AP4_SAMPLE_FORMAT_DTSH: return \"DTS-HD\";\n        case AP4_SAMPLE_FORMAT_DTSL: return \"DTS-HD Lossless\";\n        case AP4_SAMPLE_FORMAT_DTSE: return \"DTS Low Bitrate\";\n        case AP4_SAMPLE_FORMAT_AVCP: return \"Advanced Video Coding Parameters\";\n        case AP4_SAMPLE_FORMAT_DRAC: return \"Dirac\";\n        case AP4_SAMPLE_FORMAT_DRA1: return \"DRA Audio\";\n        case AP4_SAMPLE_FORMAT_G726: return \"G726\";\n        case AP4_SAMPLE_FORMAT_MJP2: return \"Motion JPEG 2000\";\n        case AP4_SAMPLE_FORMAT_OKSD: return \"OMA Keys\";\n        case AP4_SAMPLE_FORMAT_RAW_: return \"Uncompressed Audio\";\n        case AP4_SAMPLE_FORMAT_RTP_: return \"RTP Hints\";\n        case AP4_SAMPLE_FORMAT_S263: return \"H.263\";\n        case AP4_SAMPLE_FORMAT_SAMR: return \"Narrowband AMR\";\n        case AP4_SAMPLE_FORMAT_SAWB: return \"Wideband AMR\";\n        case AP4_SAMPLE_FORMAT_SAWP: return \"Extended AMR\";\n        case AP4_SAMPLE_FORMAT_SEVC: return \"EVRC Voice\";\n        case AP4_SAMPLE_FORMAT_SQCP: return \"13K Voice\";\n        case AP4_SAMPLE_FORMAT_SRTP: return \"SRTP Hints\";\n        case AP4_SAMPLE_FORMAT_SSMV: return \"SMV Voice\";\n        case AP4_SAMPLE_FORMAT_TEXT: return \"Textual Metadata\";\n        case AP4_SAMPLE_FORMAT_TWOS: return \"Uncompressed 16-bit Audio\";\n        case AP4_SAMPLE_FORMAT_TX3G: return \"Timed Text\";\n        case AP4_SAMPLE_FORMAT_VC_1: return \"SMPTE VC-1\";\n        case AP4_SAMPLE_FORMAT_XML_: return \"XML Metadata\";\n        case AP4_SAMPLE_FORMAT_STPP: return \"Timed Text\";\n        default: return NULL;\n    }\n}","filepath":"Source/C++/Core/Ap4SampleDescription.cpp","line_number":61,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-610"},"269690512":{"score":0.7015747,"function_name":"AP4_SampleDescription::Clone","code":"AP4_SampleDescription*\nAP4_SampleDescription::Clone(AP4_Result* result)\n{\n    if (result) *result = AP4_SUCCESS;\n    AP4_Atom* atom = ToAtom();\n    if (atom == NULL) {\n        if (result) *result = AP4_FAILURE;\n        return NULL;\n    }\n    \n    // serialize the atom to a buffer\n    AP4_MemoryByteStream* mbs = new AP4_MemoryByteStream((AP4_UI32)atom-\u003eGetSize());\n    atom-\u003eWrite(*mbs);\n    delete atom;\n    atom = NULL;\n    \n    // parse the buffer back to an atom\n    mbs-\u003eSeek(0);\n    AP4_AtomFactory* factory = new AP4_AtomFactory();\n    factory-\u003ePushContext(AP4_ATOM_TYPE_STSD);\n    AP4_Atom* atom_clone = NULL;\n    AP4_Result lresult = factory-\u003eCreateAtomFromStream(*mbs, atom_clone);\n    factory-\u003ePopContext();\n    delete factory;\n    if (result) *result = lresult;\n    mbs-\u003eRelease();\n    if (AP4_FAILED(lresult)) return NULL;\n    \n    // convert the atom clone to a sample description\n    AP4_SampleEntry* sample_entry = AP4_DYNAMIC_CAST(AP4_SampleEntry, atom_clone);\n    if (sample_entry == NULL) {\n        if (result) *result = AP4_ERROR_INTERNAL;\n        delete atom_clone;\n        return NULL;\n    }\n    \n    AP4_SampleDescription* clone = sample_entry-\u003eToSampleDescription();\n    if (clone == NULL) {\n        if (result) *result = AP4_ERROR_INTERNAL;\n    }\n    \n    delete atom_clone;\n    return clone;\n}","filepath":"Source/C++/Core/Ap4SampleDescription.cpp","line_number":137,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-610"},"269691024":{"score":0.603837,"function_name":"AP4_SubtitleSampleDescription::Clone","code":"AP4_SampleDescription*\nAP4_SubtitleSampleDescription::Clone(AP4_Result* result)\n{\n    if (result) *result = AP4_SUCCESS;\n    return new AP4_SubtitleSampleDescription(m_Format,\n                                             m_Namespace.GetChars(),\n                                             m_SchemaLocation.GetChars(),\n                                             m_ImageMimeType.GetChars());\n}","filepath":"Source/C++/Core/Ap4SampleDescription.cpp","line_number":960,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-610"},"269691168":{"score":0.65458035,"function_name":"AP4_UnknownSampleDescription::Clone","code":"AP4_SampleDescription*\nAP4_UnknownSampleDescription::Clone(AP4_Result* result)\n{\n    AP4_Atom* atom_clone = NULL;\n    if (m_Atom) {\n        atom_clone = m_Atom-\u003eClone();\n        if (atom_clone == NULL) {\n            if (result) *result = AP4_FAILURE;\n            return NULL;\n        }\n    }\n    if (result) *result = AP4_SUCCESS;\n    return new AP4_UnknownSampleDescription(atom_clone);\n}","filepath":"Source/C++/Core/Ap4SampleDescription.cpp","line_number":223,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-610"},"269691328":{"score":0.61977535,"function_name":"AP4_MpegSampleDescription::CreateEsDescriptor","code":"AP4_EsDescriptor* \nAP4_MpegSampleDescription::CreateEsDescriptor() const\n{\n    AP4_EsDescriptor* desc = new AP4_EsDescriptor(0);\n    AP4_DecoderSpecificInfoDescriptor* dsi_desc;\n    if (m_DecoderInfo.GetDataSize() != 0) {\n        dsi_desc = new AP4_DecoderSpecificInfoDescriptor(m_DecoderInfo);\n    } else {\n        dsi_desc = NULL;\n    }\n    AP4_DecoderConfigDescriptor* decoder_config = \n        new AP4_DecoderConfigDescriptor(m_StreamType,\n        m_ObjectTypeId,\n        m_BufferSize,\n        m_MaxBitrate,\n        m_AvgBitrate,\n        dsi_desc);\n    desc-\u003eAddSubDescriptor(decoder_config);\n    \n    // add a fixed SL Config\n    desc-\u003eAddSubDescriptor(new AP4_SLConfigDescriptor());\n    \n    return desc;\n}","filepath":"Source/C++/Core/Ap4SampleDescription.cpp","line_number":614,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-610"},"269691632":{"score":0.62040496,"function_name":"AP4_AvcSampleDescription::GetCodecString","code":"AP4_Result\nAP4_AvcSampleDescription::GetCodecString(AP4_String\u0026 codec) {\n    char coding[5];\n    AP4_FormatFourChars(coding, GetFormat());\n    char workspace[64];\n    AP4_FormatString(workspace,\n                     sizeof(workspace),\n                     \"%s.%02X%02X%02X\",\n                     coding,\n                     GetProfile(),\n                     GetProfileCompatibility(),\n                     GetLevel());\n    codec = workspace;\n    \n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4SampleDescription.cpp","line_number":364,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-610"},"269691744":{"score":0.5709183,"function_name":"AP4_HevcSampleDescription::GetCodecString","code":"AP4_Result\nAP4_HevcSampleDescription::GetCodecString(AP4_String\u0026 codec) {\n    char coding[5];\n    AP4_FormatFourChars(coding, GetFormat());\n    char profile_space[2] = {0,0};\n    if (GetGeneralProfileSpace() \u003e 0 \u0026\u0026 GetGeneralProfileSpace() \u003c= 3) {\n        profile_space[0] = 'A'+GetGeneralProfileSpace()-1;\n    }\n    AP4_UI64 constraints = GetGeneralConstraintIndicatorFlags();\n    while (constraints \u0026\u0026 ((constraints \u0026 0xFF) == 0)) {\n        constraints \u003e\u003e= 8;\n    }\n    char workspace[64];\n    AP4_FormatString(workspace,\n                     sizeof(workspace),\n                     \"%s.%s%d.%X.%c%d.%llx\",\n                     coding,\n                     profile_space,\n                     GetGeneralProfile(),\n                     ReverseBits(GetGeneralProfileCompatibilityFlags()),\n                     GetGeneralTierFlag()?'H':'L',\n                     GetGeneralLevel(),\n                     constraints);\n    codec = workspace;\n    \n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4SampleDescription.cpp","line_number":510,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-610"},"269692016":{"score":0.6720916,"function_name":"AP4_MpegAudioSampleDescription::GetCodecString","code":"AP4_Result\nAP4_MpegAudioSampleDescription::GetCodecString(AP4_String\u0026 codec)\n{\n    char coding[5];\n    AP4_FormatFourChars(coding, GetFormat());\n    char workspace[64];\n    workspace[0] = 0;\n    if (GetFormat() == AP4_SAMPLE_FORMAT_MP4A) {\n        if (GetObjectTypeId() == AP4_OTI_MPEG4_AUDIO) {\n            Mpeg4AudioObjectType object_type = GetMpeg4AudioObjectType();\n            if (object_type == AP4_MPEG4_AUDIO_OBJECT_TYPE_AAC_LC) {\n                const AP4_DataBuffer\u0026 dsi = GetDecoderInfo();\n                if (dsi.GetDataSize()) {\n                    AP4_Mp4AudioDecoderConfig dec_config;\n                    AP4_Result result = dec_config.Parse(dsi.GetData(), dsi.GetDataSize());\n                    if (AP4_SUCCEEDED(result)) {\n                        if (dec_config.m_Extension.m_PsPresent) {\n                            object_type = AP4_MPEG4_AUDIO_OBJECT_TYPE_PS;\n                        } else if (dec_config.m_Extension.m_SbrPresent) {\n                            object_type = AP4_MPEG4_AUDIO_OBJECT_TYPE_SBR;\n                        }\n                    }\n                }\n            }\n            AP4_FormatString(workspace, sizeof(workspace), \"%s.%02X.%d\", coding, (int)GetObjectTypeId(), object_type);\n        } else {\n            AP4_FormatString(workspace, sizeof(workspace), \"%s.%02X\", coding, (int)GetObjectTypeId());\n        }\n    }\n    \n    codec = workspace;\n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4SampleDescription.cpp","line_number":725,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-610"},"269692336":{"score":0.75394595,"function_name":"AP4_MpegAudioSampleDescription::GetMpeg4AudioObjectType","code":"AP4_MpegAudioSampleDescription::Mpeg4AudioObjectType\nAP4_MpegAudioSampleDescription::GetMpeg4AudioObjectType() const\n{\n    if (m_ObjectTypeId == AP4_OTI_MPEG4_AUDIO \u0026\u0026\n        m_DecoderInfo.GetDataSize() \u003e= 1) {\n        AP4_UI08 type = m_DecoderInfo.GetData()[0]\u003e\u003e3;\n        if (type == 31) {\n            if (m_DecoderInfo.GetDataSize() \u003c 2) return 0;\n            type = 32+(((m_DecoderInfo.GetData()[0]\u00260x07)\u003c\u003c3) |\n                       ((m_DecoderInfo.GetData()[1]\u00260xE0)\u003e\u003e5));\n        }\n        return type;\n    } else {\n        return 0;\n    }\n}","filepath":"Source/C++/Core/Ap4SampleDescription.cpp","line_number":762,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-610"},"269695264":{"score":0.63041705,"function_name":"AP4_LinearReader::Advance","code":"AP4_Result\nAP4_LinearReader::Advance(bool read_data)\n{\n    // first, check if we have space to advance\n    if (m_BufferFullness \u003e= m_MaxBufferFullness) {\n        return AP4_ERROR_NOT_ENOUGH_SPACE;\n    }\n    \n    AP4_UI64 min_offset = (AP4_UI64)(-1);\n    Tracker* next_tracker = NULL;\n    for (;;) {\n        for (unsigned int i=0; i\u003cm_Trackers.ItemCount(); i++) {\n            Tracker* tracker = m_Trackers[i];\n            if (tracker-\u003em_Eos) continue;\n            if (tracker-\u003em_SampleTable == NULL) continue;\n            \n            // get the next sample unless we have it already\n            if (tracker-\u003em_NextSample == NULL) {\n                if (tracker-\u003em_NextSampleIndex \u003e= tracker-\u003em_SampleTable-\u003eGetSampleCount()) {\n                    if (!m_HasFragments) tracker-\u003em_Eos = true;\n                    if (tracker-\u003em_SampleTableIsOwned) {\n                        delete tracker-\u003em_SampleTable;\n                        tracker-\u003em_SampleTable = NULL;\n                    }\n                    continue;\n                }\n                tracker-\u003em_NextSample = new AP4_Sample();\n                AP4_Result result = tracker-\u003em_SampleTable-\u003eGetSample(tracker-\u003em_NextSampleIndex, *tracker-\u003em_NextSample);\n                if (AP4_FAILED(result)) {\n                    tracker-\u003em_Eos = true;\n                    delete tracker-\u003em_NextSample;\n                    tracker-\u003em_NextSample = NULL;\n                    continue;\n                }\n                tracker-\u003em_NextDts += tracker-\u003em_NextSample-\u003eGetDuration();\n            }\n            assert(tracker-\u003em_NextSample);\n            \n            AP4_UI64 offset = tracker-\u003em_NextSample-\u003eGetOffset();\n            if (offset \u003c min_offset) {\n                min_offset = offset;\n                next_tracker = tracker;\n            }\n        }\n        \n        if (next_tracker) break;\n        if (m_HasFragments) {\n            AP4_Result result = AdvanceFragment();\n            if (AP4_FAILED(result)) return result;\n        } else {\n            break;\n        }\n    }\n \n    if (next_tracker) {\n        // read the sample into a buffer\n        assert(next_tracker-\u003em_NextSample);\n        SampleBuffer* buffer = new SampleBuffer(next_tracker-\u003em_NextSample);\n        AP4_Result result;\n        if (read_data) {\n            if (next_tracker-\u003em_Reader) {\n                result = next_tracker-\u003em_Reader-\u003eReadSampleData(*buffer-\u003em_Sample, buffer-\u003em_Data);\n            } else {\n                result = buffer-\u003em_Sample-\u003eReadData(buffer-\u003em_Data);\n            }\n            if (AP4_FAILED(result)) {\n                delete buffer;\n                return result;\n            }\n\n            // detach the sample from its source now that we've read its data\n            buffer-\u003em_Sample-\u003eDetach();\n        }\n        \n        // add the buffer to the queue\n        next_tracker-\u003em_Samples.Add(buffer);\n        m_BufferFullness += buffer-\u003em_Data.GetDataSize();\n        if (m_BufferFullness \u003e m_BufferFullnessPeak) {\n            m_BufferFullnessPeak = m_BufferFullness;\n        }\n        next_tracker-\u003em_NextSample = NULL;\n        next_tracker-\u003em_NextSampleIndex++;\n        return AP4_SUCCESS;\n    } \n    \n    return AP4_ERROR_EOS;   \n}","filepath":"Source/C++/Core/Ap4LinearReader.cpp","line_number":404,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.1-621"},"269696528":{"score":0.69269985,"function_name":"AP4_LinearReader::EnableTrack","code":"AP4_Result \nAP4_LinearReader::EnableTrack(AP4_UI32 track_id)\n{\n    // check if we don't already have this\n    if (FindTracker(track_id)) return AP4_SUCCESS;\n\n    // find the track in the movie\n    AP4_Track* track = m_Movie.GetTrack(track_id);\n    if (track == NULL) return AP4_ERROR_NO_SUCH_ITEM;\n    \n    // process this track\n    return ProcessTrack(track);\n}","filepath":"Source/C++/Core/Ap4LinearReader.cpp","line_number":80,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.1-621"},"269696768":{"score":0.6903723,"function_name":"AP4_LinearReader::FindTracker","code":"AP4_LinearReader::Tracker*\nAP4_LinearReader::FindTracker(AP4_UI32 track_id)\n{\n    for (unsigned int i=0; i\u003cm_Trackers.ItemCount(); i++) {\n        if (m_Trackers[i]-\u003em_Track-\u003eGetId() == track_id) return m_Trackers[i];\n    }\n    \n    // not found\n    return NULL;\n}","filepath":"Source/C++/Core/Ap4LinearReader.cpp","line_number":614,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.1-621"},"269697648":{"score":0.69741654,"function_name":"AP4_LinearReader::ReadNextSample","code":"AP4_Result \nAP4_LinearReader::ReadNextSample(AP4_UI32        track_id,\n                                 AP4_Sample\u0026     sample,\n                                 AP4_DataBuffer\u0026 sample_data)\n{\n    if (m_Trackers.ItemCount() == 0) {\n        return AP4_ERROR_NO_SUCH_ITEM;\n    }\n    \n    // look for a sample from a specific track\n    Tracker* tracker = FindTracker(track_id);\n    if (tracker == NULL) return AP4_ERROR_INVALID_PARAMETERS;\n    for(;;) {\n        // pop a sample if we can\n        if (PopSample(tracker, sample, \u0026sample_data)) return AP4_SUCCESS;\n\n        // don't continue if we've reached the end of that tracker\n        if (tracker-\u003em_Eos) return AP4_ERROR_EOS;\n\n        AP4_Result result = Advance();\n        if (AP4_FAILED(result)) return result;\n    }\n        \n    // unreachable - return AP4_ERROR_EOS;\n}","filepath":"Source/C++/Core/Ap4LinearReader.cpp","line_number":519,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.1-621"},"269697776":{"score":0.8102718,"function_name":"AP4_BytesFromUInt64BE","code":"void\nAP4_BytesFromUInt64BE(unsigned char* bytes, AP4_UI64 value)\n{\n    bytes[0] = (unsigned char)((value \u003e\u003e 56) \u0026 0xFF);\n    bytes[1] = (unsigned char)((value \u003e\u003e 48) \u0026 0xFF);\n    bytes[2] = (unsigned char)((value \u003e\u003e 40) \u0026 0xFF);\n    bytes[3] = (unsigned char)((value \u003e\u003e 32) \u0026 0xFF);\n    bytes[4] = (unsigned char)((value \u003e\u003e 24) \u0026 0xFF);\n    bytes[5] = (unsigned char)((value \u003e\u003e 16) \u0026 0xFF);\n    bytes[6] = (unsigned char)((value \u003e\u003e  8) \u0026 0xFF);\n    bytes[7] = (unsigned char)((value      ) \u0026 0xFF);\n}","filepath":"Source/C++/Core/Ap4Utils.cpp","line_number":158,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.6.0-638"},"269697904":{"score":0.87657017,"function_name":"AP4_BytesToUInt64BE","code":"AP4_UI64\nAP4_BytesToUInt64BE(const unsigned char* bytes)\n{\n    return\n        ( ((AP4_UI64)bytes[0])\u003c\u003c56 ) |\n        ( ((AP4_UI64)bytes[1])\u003c\u003c48 ) |\n        ( ((AP4_UI64)bytes[2])\u003c\u003c40 ) |\n        ( ((AP4_UI64)bytes[3])\u003c\u003c32 ) |\n        ( ((AP4_UI64)bytes[4])\u003c\u003c24 ) |\n        ( ((AP4_UI64)bytes[5])\u003c\u003c16 ) |\n        ( ((AP4_UI64)bytes[6])\u003c\u003c8  ) |\n        ( ((AP4_UI64)bytes[7])     );\n}","filepath":"Source/C++/Core/Ap4Utils.cpp","line_number":129,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.6.0-638"},"269698048":{"score":0.6578453,"function_name":"AP4_ConvertTime","code":"AP4_UI64\nAP4_ConvertTime(AP4_UI64 time_value,\n                AP4_UI32 from_time_scale,\n                AP4_UI32 to_time_scale)\n{\n    if (from_time_scale == 0) return 0;\n    double ratio = (double)to_time_scale/(double)from_time_scale;\n    return ((AP4_UI64)(0.5+(double)time_value*ratio));\n}","filepath":"Source/C++/Core/Ap4Utils.cpp","line_number":199,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.6.0-638"},"269698240":{"score":0.97652733,"function_name":"AP4_FormatFourChars","code":"void\nAP4_FormatFourChars(char* str, AP4_UI32 value) {\n    str[0] = (value \u003e\u003e 24) \u0026 0xFF;\n    str[1] = (value \u003e\u003e 16) \u0026 0xFF;\n    str[2] = (value \u003e\u003e  8) \u0026 0xFF;\n    str[3] = (value      ) \u0026 0xFF;\n    str[4] = '\\0';\n}","filepath":"Source/C++/Core/Ap4Utils.cpp","line_number":212,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.6.0-638"},"269698288":{"score":0.74328,"function_name":"AP4_FormatFourCharsPrintable","code":"void\nAP4_FormatFourCharsPrintable(char* str, AP4_UI32 value) {\n    AP4_FormatFourChars(str, value);\n    for (int i=0; i\u003c4; i++) {\n        if (str[i]\u003c' ' || str[i] \u003e= 127) {\n            str[i] = '.';\n        }\n    }\n}","filepath":"Source/C++/Core/Ap4Utils.cpp","line_number":224,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.6.0-638"},"269698368":{"score":0.7972747,"function_name":"AP4_NibbleHex","code":"char\nAP4_NibbleHex(unsigned int nibble)\n{\n    if (nibble \u003c 10) {\n        return (char)('0'+nibble);\n    } else if (nibble \u003c 16) {\n        return (char)('A'+(nibble-10));\n    } else {\n        return ' ';\n    }\n}","filepath":"Source/C++/Core/Ap4Utils.cpp","line_number":295,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.6.0-638"},"269698400":{"score":0.78929156,"function_name":"AP4_ParseHex","code":"AP4_Result\nAP4_ParseHex(const char* hex, unsigned char* bytes, unsigned int count)\n{\n    if (AP4_StringLength(hex) \u003c 2*count) return AP4_ERROR_INVALID_PARAMETERS;\n    for (unsigned int i=0; i\u003ccount; i++) {\n        bytes[i] = (AP4_HexNibble(hex[2*i]) \u003c\u003c 4) | (AP4_HexNibble(hex[2*i+1]));\n    }\n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4Utils.cpp","line_number":310,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.6.0-638"},"269698928":{"score":0.8994752,"function_name":"AP4_BitWriter::Write","code":"void\nAP4_BitWriter::Write(AP4_UI32 bits, unsigned int bit_count)\n{\n    unsigned char* data = m_Data;\n    if (m_BitCount+bit_count \u003e m_DataSize*8) return;\n    data += m_BitCount/8;\n    unsigned int space = 8-(m_BitCount%8);\n    while (bit_count) {\n        unsigned int mask = bit_count==32 ? 0xFFFFFFFF : ((1\u003c\u003cbit_count)-1);\n        if (bit_count \u003c= space) {\n            *data |= ((bits\u0026mask) \u003c\u003c (space-bit_count));\n            m_BitCount += bit_count;\n            return;\n        } else {\n            *data |= ((bits\u0026mask) \u003e\u003e (bit_count-space));\n            ++data;\n            m_BitCount += space;\n            bit_count  -= space;\n            space       = 8;\n        }\n    }\n}","filepath":"Source/C++/Core/Ap4Utils.cpp","line_number":337,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.6.0-638"},"269699056":{"score":0.8009765,"function_name":"AP4_Atom::AP4_Atom","code":"AP4_Atom::AP4_Atom(Type type, AP4_UI32 size /* = AP4_ATOM_HEADER_SIZE */) : \n    m_Type(type),\n    m_Size32(size),\n    m_Size64(0),\n    m_IsFull(false),\n    m_Version(0),\n    m_Flags(0),\n    m_Parent(NULL)\n{\n}","filepath":"Source/C++/Core/Ap4Atom.cpp","line_number":69,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-614"},"269699120":{"score":0.7661537,"function_name":"AP4_Atom::AP4_Atom","code":"AP4_Atom::AP4_Atom(Type     type, \n                   AP4_UI32 size, \n                   AP4_UI08 version, \n                   AP4_UI32 flags) :\n    m_Type(type),\n    m_Size32(size),\n    m_Size64(0),\n    m_IsFull(true),\n    m_Version(version),\n    m_Flags(flags),\n    m_Parent(NULL)\n{\n}","filepath":"Source/C++/Core/Ap4Atom.cpp","line_number":98,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-614"},"269699312":{"score":0.6605942,"function_name":"AP4_Atom::AP4_Atom","code":"AP4_Atom::AP4_Atom(Type     type, \n                   AP4_UI64 size,\n                   bool     force_64,\n                   AP4_UI08 version, \n                   AP4_UI32 flags) :\n    m_Type(type),\n    m_Size32(0),\n    m_Size64(0),\n    m_IsFull(true),\n    m_Version(version),\n    m_Flags(flags),\n    m_Parent(NULL)\n{\n    SetSize(size, force_64);\n}","filepath":"Source/C++/Core/Ap4Atom.cpp","line_number":115,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-614"},"269700896":{"score":0.75448555,"function_name":"AP4_AtomParent::AddChild","code":"AP4_Result\nAP4_AtomParent::AddChild(AP4_Atom* child, int position)\n{\n    // check that the child does not already have a parent\n    if (child-\u003eGetParent() != NULL) return AP4_ERROR_INVALID_PARAMETERS;\n\n    // attach the child\n    AP4_Result result;\n    if (position == -1) {\n        // insert at the tail\n        result = m_Children.Add(child);\n    } else if (position == 0) {\n        // insert at the head\n        result = m_Children.Insert(NULL, child);\n    } else {\n        // insert after \u003cn-1\u003e\n        AP4_List\u003cAP4_Atom\u003e::Item* insertion_point = m_Children.FirstItem();\n        unsigned int count = position;\n        while (insertion_point \u0026\u0026 --count) {\n            insertion_point = insertion_point-\u003eGetNext();\n        }\n        if (insertion_point) {\n            result = m_Children.Insert(insertion_point, child);\n        } else {\n            result = AP4_ERROR_OUT_OF_RANGE;\n        }\n    }\n    if (AP4_FAILED(result)) return result;\n\n    // notify the child of its parent\n    child-\u003eSetParent(this);\n\n    // get a chance to update\n    OnChildAdded(child);\n\n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4Atom.cpp","line_number":518,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-614"},"269701472":{"score":0.63170296,"function_name":"AP4_AtomParent::DeleteChild","code":"AP4_Result\nAP4_AtomParent::DeleteChild(AP4_Atom::Type type, AP4_Ordinal index /* = 0 */)\n{\n    // find the child\n    AP4_Atom* child = GetChild(type, index);\n    if (child == NULL) return AP4_FAILURE;\n\n    // remove the child\n    AP4_Result result = RemoveChild(child);\n    if (AP4_FAILED(result)) return result;\n\n    // delete the child\n    delete child;\n\n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4Atom.cpp","line_number":581,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-614"},"269701648":{"score":0.6799238,"function_name":"AP4_AtomParent::FindChild","code":"AP4_Atom*\nAP4_AtomParent::FindChild(const char* path, \n                          bool        auto_create,\n                          bool        auto_create_full)\n{\n    // start from here\n    AP4_AtomParent* parent = this;\n\n    // walk the path\n    while (path[0] \u0026\u0026 path[1] \u0026\u0026 path[2] \u0026\u0026 path[3]) {\n        // we have 4 valid chars\n        const char* tail;\n        int         index = 0;\n        if (path[4] == '\\0') {\n            tail = NULL;\n        } else if (path[4] == '/') {\n            // separator\n            tail = \u0026path[5];\n        } else if (path[4] == '[') {\n            const char* x = \u0026path[5];\n            while (*x \u003e= '0' \u0026\u0026 *x \u003c= '9') {\n                index = 10*index+(*x++ - '0');\n            }\n            if (x[0] == ']') {\n                if (x[1] == '\\0') {\n                    tail = NULL;\n                } else {\n                    tail = x+2;\n                }\n            } else {\n                // malformed path\n                return NULL;\n            }\n        } else {\n            // malformed path\n            return NULL;\n        }\n\n        // look for this atom in the current list\n        AP4_Atom::Type type = AP4_ATOM_TYPE(path[0], path[1], path[2], path[3]); \n        AP4_Atom* atom = parent-\u003eGetChild(type, index);\n        if (atom == NULL) {\n            // not found\n            if (auto_create \u0026\u0026 (index == 0)) {\n                if (auto_create_full) {\n                    atom = new AP4_ContainerAtom(type, (AP4_UI32)0, (AP4_UI32)0);\n                } else {\n                    atom = new AP4_ContainerAtom(type);\n                }\n                parent-\u003eAddChild(atom);\n            } else {\n                return NULL;\n            }\n        }\n\n        if (tail) {\n            path = tail;\n            // if this atom is an atom parent, recurse\n            parent = AP4_DYNAMIC_CAST(AP4_ContainerAtom, atom);\n            if (parent == NULL) return NULL;\n        } else {\n            return atom;\n        }\n    }\n\n    // not found\n    return NULL;\n}","filepath":"Source/C++/Core/Ap4Atom.cpp","line_number":637,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-614"},"269702304":{"score":0.7863401,"function_name":"AP4_AtomParent::GetChild","code":"AP4_Atom*\nAP4_AtomParent::GetChild(const AP4_UI08* uuid, AP4_Ordinal index /* = 0 */) const\n{\n    for (AP4_List\u003cAP4_Atom\u003e::Item* item = m_Children.FirstItem();\n                                   item;\n                                   item = item-\u003eGetNext()) {\n        AP4_Atom* atom = item-\u003eGetData();\n        if (atom-\u003eGetType() == AP4_ATOM_TYPE_UUID) {\n            AP4_UuidAtom* uuid_atom = AP4_DYNAMIC_CAST(AP4_UuidAtom, atom);\n            if (AP4_CompareMemory(uuid_atom-\u003eGetUuid(), uuid, 16) == 0) {\n                if (index == 0) return atom;\n                --index;\n            }\n        }\n    }\n    return NULL;\n}","filepath":"Source/C++/Core/Ap4Atom.cpp","line_number":616,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-614"},"269702992":{"score":0.6892218,"function_name":"AP4_AtomParent::RemoveChild","code":"AP4_Result\nAP4_AtomParent::RemoveChild(AP4_Atom* child)\n{\n    // check that this is our child\n    if (child-\u003eGetParent() != this) return AP4_ERROR_INVALID_PARAMETERS;\n\n    // remove the child\n    AP4_Result result = m_Children.Remove(child);\n    if (AP4_FAILED(result)) return result;\n\n    // notify that child that it is orphaned\n    child-\u003eSetParent(NULL);\n\n    // get a chance to update\n    OnChildRemoved(child);\n\n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4Atom.cpp","line_number":559,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-614"},"269703200":{"score":0.7797427,"function_name":"AP4_Atom::SetSize","code":"void\nAP4_Atom::SetSize(AP4_UI64 size, bool force_64)\n{\n    if (!force_64) {\n        // see if we need to implicitely force 64-bit encoding\n        if (m_Size32 == 1 \u0026\u0026 m_Size64 \u003c= 0xFFFFFFFF) {\n            // we have a forced 64-bit encoding\n            force_64 = true;\n        }\n    }\n    if ((size \u003e\u003e 32) == 0 \u0026\u0026 !force_64) {\n        m_Size32 = (AP4_UI32)size;\n        m_Size64 = 0;\n    } else {\n        m_Size32 = 1;\n        m_Size64 = size;\n    }\n}","filepath":"Source/C++/Core/Ap4Atom.cpp","line_number":150,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-614"},"269703392":{"score":0.6452057,"function_name":"AP4_NullTerminatedStringAtom::WriteFields","code":"AP4_Result\nAP4_NullTerminatedStringAtom::WriteFields(AP4_ByteStream\u0026 stream)\n{\n    if (m_Size32 \u003e AP4_ATOM_HEADER_SIZE) {\n        AP4_Result result = stream.Write(m_Value.GetChars(), m_Value.GetLength()+1);\n        if (AP4_FAILED(result)) return result;\n\n        // pad with zeros if necessary\n        AP4_Size padding = m_Size32-(AP4_ATOM_HEADER_SIZE+m_Value.GetLength()+1);\n        while (padding--) stream.WriteUI08(0);\n    }\n\n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4Atom.cpp","line_number":481,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-614"},"269703472":{"score":0.6962154,"function_name":"AP4_UnknownAtom::WriteFields","code":"AP4_Result\nAP4_UnknownAtom::WriteFields(AP4_ByteStream\u0026 stream)\n{\n    AP4_Result result;\n\n    // if we don't have a source, write from the buffered payload\n    if (m_SourceStream == NULL) {\n        return stream.Write(m_Payload.GetData(), m_Payload.GetDataSize());\n    }\n    \n    // remember the source position\n    AP4_Position position;\n    m_SourceStream-\u003eTell(position);\n\n    // seek into the source at the stored offset\n    result = m_SourceStream-\u003eSeek(m_SourcePosition);\n    if (AP4_FAILED(result)) return result;\n\n    // copy the source stream to the output\n    AP4_UI64 payload_size = GetSize()-GetHeaderSize();\n    result = m_SourceStream-\u003eCopyTo(stream, payload_size);\n    if (AP4_FAILED(result)) return result;\n\n    // restore the original stream position\n    m_SourceStream-\u003eSeek(position);\n\n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4Atom.cpp","line_number":415,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-614"},"269711296":{"score":0.5839191,"function_name":"AP4_MovieFragment::CreateSampleTable","code":"AP4_Result         \nAP4_MovieFragment::CreateSampleTable(AP4_MoovAtom*             moov,\n                                     AP4_UI32                  track_id, \n                                     AP4_ByteStream*           sample_stream,\n                                     AP4_Position              moof_offset,\n                                     AP4_Position              mdat_payload_offset,\n                                     AP4_UI64                  dts_origin,\n                                     AP4_FragmentSampleTable*\u0026 sample_table)\n{\n    // default value\n    sample_table = NULL;\n    \n    // find a trex for this track, if any\n    AP4_ContainerAtom* mvex = NULL;\n    AP4_TrexAtom*      trex = NULL;\n    if (moov) {\n        mvex = AP4_DYNAMIC_CAST(AP4_ContainerAtom, moov-\u003eGetChild(AP4_ATOM_TYPE_MVEX));\n    }\n    if (mvex) {\n        for (AP4_List\u003cAP4_Atom\u003e::Item* item = mvex-\u003eGetChildren().FirstItem();\n                                       item;\n                                       item = item-\u003eGetNext()) {\n            AP4_Atom* atom = item-\u003eGetData();\n            if (atom-\u003eGetType() == AP4_ATOM_TYPE_TREX) {\n                trex = AP4_DYNAMIC_CAST(AP4_TrexAtom, atom);\n                if (trex \u0026\u0026 trex-\u003eGetTrackId() == track_id) break;\n                trex = NULL;\n            }\n        }\n    }\n    AP4_ContainerAtom* traf = NULL;\n    if (AP4_SUCCEEDED(GetTrafAtom(track_id, traf))) {\n        sample_table = new AP4_FragmentSampleTable(traf, \n                                                   trex, \n                                                   sample_stream,\n                                                   moof_offset,\n                                                   mdat_payload_offset,\n                                                   dts_origin);\n        return AP4_SUCCESS;\n    }\n    \n    return AP4_ERROR_NO_SUCH_ITEM;\n}","filepath":"Source/C++/Core/Ap4MovieFragment.cpp","line_number":124,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.4.2-584"},"269711632":{"score":0.56109905,"function_name":"AP4_MovieFragment::CreateSampleTable","code":"AP4_Result         \nAP4_MovieFragment::CreateSampleTable(AP4_Movie*                movie,\n                                     AP4_UI32                  track_id, \n                                     AP4_ByteStream*           sample_stream,\n                                     AP4_Position              moof_offset,\n                                     AP4_Position              mdat_payload_offset,\n                                     AP4_UI64                  dts_origin,\n                                     AP4_FragmentSampleTable*\u0026 sample_table)\n{\n    AP4_MoovAtom* moov = movie?movie-\u003eGetMoovAtom():NULL;\n    return CreateSampleTable(moov, track_id, sample_stream, moof_offset, mdat_payload_offset, dts_origin, sample_table);\n}","filepath":"Source/C++/Core/Ap4MovieFragment.cpp","line_number":171,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.4.2-584"},"269711696":{"score":0.65551436,"function_name":"AP4_MovieFragment::GetTrackIds","code":"AP4_Result\nAP4_MovieFragment::GetTrackIds(AP4_Array\u003cAP4_UI32\u003e\u0026 ids)\n{\n    ids.Clear();\n    ids.EnsureCapacity(m_MoofAtom-\u003eGetChildren().ItemCount());\n    \n    for (AP4_List\u003cAP4_Atom\u003e::Item* item = m_MoofAtom-\u003eGetChildren().FirstItem();\n                                   item;\n                                   item = item-\u003eGetNext()) {\n        AP4_Atom* atom = item-\u003eGetData();\n        if (atom-\u003eGetType() == AP4_ATOM_TYPE_TRAF) {\n            AP4_ContainerAtom* traf = AP4_DYNAMIC_CAST(AP4_ContainerAtom, atom);\n            if (traf) {\n                AP4_TfhdAtom* tfhd = AP4_DYNAMIC_CAST(AP4_TfhdAtom, traf-\u003eGetChild(AP4_ATOM_TYPE_TFHD));\n                if (tfhd) ids.Append(tfhd-\u003eGetTrackId());\n            }\n        }\n    }\n    \n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4MovieFragment.cpp","line_number":73,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.4.2-584"},"269711920":{"score":0.7629276,"function_name":"AP4_MovieFragment::GetTrafAtom","code":"AP4_Result         \nAP4_MovieFragment::GetTrafAtom(AP4_UI32 track_id, AP4_ContainerAtom*\u0026 traf)\n{\n    for (AP4_List\u003cAP4_Atom\u003e::Item* item = m_MoofAtom-\u003eGetChildren().FirstItem();\n                                   item;\n                                   item = item-\u003eGetNext()) {\n        AP4_Atom* atom = item-\u003eGetData();\n        if (atom-\u003eGetType() == AP4_ATOM_TYPE_TRAF) {\n            traf = AP4_DYNAMIC_CAST(AP4_ContainerAtom, atom);\n            if (traf) {\n                AP4_TfhdAtom* tfhd = AP4_DYNAMIC_CAST(AP4_TfhdAtom, traf-\u003eGetChild(AP4_ATOM_TYPE_TFHD));\n                if (tfhd \u0026\u0026 tfhd-\u003eGetTrackId() == track_id) {\n                    return AP4_SUCCESS;\n                }\n            }\n        }\n    }\n    \n    // not found\n    traf = NULL;\n    return AP4_ERROR_NO_SUCH_ITEM;\n}","filepath":"Source/C++/Core/Ap4MovieFragment.cpp","line_number":98,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.4.2-584"},"269718816":{"score":0.8349734,"function_name":"AP4_AtomSampleTable::GetChunkForSample","code":"AP4_Result \nAP4_AtomSampleTable::GetChunkForSample(AP4_Ordinal  sample_index,\n                                       AP4_Ordinal\u0026 chunk_index,\n                                       AP4_Ordinal\u0026 position_in_chunk,\n                                       AP4_Ordinal\u0026 sample_description_index)\n{\n    // default values\n    chunk_index              = 0;\n    position_in_chunk        = 0;\n    sample_description_index = 0;\n\n    // check that we an stsc atom\n    if (m_StscAtom == NULL) return AP4_ERROR_INVALID_STATE;\n    \n    // get the chunk info from the stsc atom\n    AP4_Ordinal chunk = 0;\n    AP4_Result result = m_StscAtom-\u003eGetChunkForSample(sample_index+1, // the atom API is 1-based \n                                                      chunk, \n                                                      position_in_chunk, \n                                                      sample_description_index);\n    if (AP4_FAILED(result)) return result;\n    if (chunk == 0) return AP4_ERROR_INTERNAL;\n\n    // the atom sample and chunk indexes are 1-based, so we need to translate\n    chunk_index = chunk-1;\n    \n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4AtomSampleTable.cpp","line_number":239,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-616"},"269718928":{"score":0.63328916,"function_name":"AP4_AtomSampleTable::GetChunkOffset","code":"AP4_Result \nAP4_AtomSampleTable::GetChunkOffset(AP4_Ordinal   chunk_index, \n                                    AP4_Position\u0026 offset)\n{\n    if (m_StcoAtom) {\n        AP4_UI32 offset_32;\n        AP4_Result result = m_StcoAtom-\u003eGetChunkOffset(chunk_index+1, offset_32);\n        if (AP4_SUCCEEDED(result)) {\n            offset = offset_32;\n        } else {\n            offset = 0;\n        }\n        return result;\n    } else if (m_Co64Atom) {\n        return m_Co64Atom-\u003eGetChunkOffset(chunk_index+1, offset);\n    } else {\n        offset = 0;\n        return AP4_FAILURE;\n    }\n}","filepath":"Source/C++/Core/Ap4AtomSampleTable.cpp","line_number":271,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-616"},"269719056":{"score":0.8715974,"function_name":"AP4_AtomSampleTable::GetNearestSyncSampleIndex","code":"AP4_Ordinal  \nAP4_AtomSampleTable::GetNearestSyncSampleIndex(AP4_Ordinal sample_index, bool before)\n{\n    // if we don't have an stss table, all samples match\n    if (m_StssAtom == NULL) return sample_index;\n    \n    sample_index += 1; // the table is 1-based\n    AP4_Cardinal entry_count = m_StssAtom-\u003eGetEntries().ItemCount();\n    if (before) {\n        AP4_Ordinal cursor = 0;    \n        for (unsigned int i=0; i\u003centry_count; i++) {\n            if (m_StssAtom-\u003eGetEntries()[i] \u003e= sample_index) return cursor;\n            if (m_StssAtom-\u003eGetEntries()[i]) cursor = m_StssAtom-\u003eGetEntries()[i]-1;\n        }\n\n        // not found?\n        return cursor;\n    } else {\n        for (unsigned int i=0; i\u003centry_count; i++) {\n            if (m_StssAtom-\u003eGetEntries()[i] \u003e= sample_index) {\n                return m_StssAtom-\u003eGetEntries()[i]?m_StssAtom-\u003eGetEntries()[i]-1:sample_index-1;\n            }\n        }\n\n        // not found?\n        return GetSampleCount();\n    }\n}","filepath":"Source/C++/Core/Ap4AtomSampleTable.cpp","line_number":338,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-616"},"269719200":{"score":0.6582017,"function_name":"AP4_AtomSampleTable::GetSample","code":"AP4_Result\nAP4_AtomSampleTable::GetSample(AP4_Ordinal index, \n                               AP4_Sample\u0026 sample)\n{\n    AP4_Result result;\n\n    // check that we have an stsc atom\n    if (!m_StscAtom) {\n        return AP4_ERROR_INVALID_FORMAT;\n    }\n    \n    // check that we have a chunk offset table\n    if (m_StcoAtom == NULL \u0026\u0026 m_Co64Atom == NULL) {\n        return AP4_ERROR_INVALID_FORMAT;\n    }\n\n    // MP4 uses 1-based indexes internally, so adjust by one\n    index++;\n\n    // find out in which chunk this sample is located\n    AP4_Ordinal chunk, skip, desc;\n    result = m_StscAtom-\u003eGetChunkForSample(index, chunk, skip, desc);\n    if (AP4_FAILED(result)) return result;\n    \n    // check that the result is within bounds\n    if (skip \u003e index) return AP4_ERROR_INTERNAL;\n\n    // get the atom offset for this chunk\n    AP4_UI64 offset;\n    if (m_StcoAtom) {\n        AP4_UI32 offset_32;\n        result = m_StcoAtom-\u003eGetChunkOffset(chunk, offset_32);\n        offset = offset_32;\n    } else {\n        result = m_Co64Atom-\u003eGetChunkOffset(chunk, offset);\n    }\n    if (AP4_FAILED(result)) return result;\n    \n    // compute the additional offset inside the chunk\n    for (unsigned int i = index-skip; i \u003c index; i++) {\n        AP4_Size size = 0;\n        if (m_StszAtom) {\n            result = m_StszAtom-\u003eGetSampleSize(i, size); \n        } else if (m_Stz2Atom) {\n            result = m_Stz2Atom-\u003eGetSampleSize(i, size); \n        } else {\n            result = AP4_ERROR_INVALID_FORMAT;\n        }\n        if (AP4_FAILED(result)) return result;\n        offset += size;\n    }\n\n    // set the description index\n    sample.SetDescriptionIndex(desc-1); // adjust for 0-based indexes\n\n    // set the dts and cts\n    AP4_UI32 cts_offset = 0;\n    AP4_UI64 dts        = 0;\n    AP4_UI32 duration   = 0;\n    result = m_SttsAtom-\u003eGetDts(index, dts, \u0026duration);\n    if (AP4_FAILED(result)) return result;\n    sample.SetDuration(duration);\n    sample.SetDts(dts);\n    if (m_CttsAtom == NULL) {\n        sample.SetCts(dts);\n    } else {\n        result = m_CttsAtom-\u003eGetCtsOffset(index, cts_offset); \n\t    if (AP4_FAILED(result)) return result;\n        sample.SetCtsDelta(cts_offset);\n    }     \n\n    // set the size\n    AP4_Size sample_size = 0;\n    if (m_StszAtom) {\n        result = m_StszAtom-\u003eGetSampleSize(index, sample_size); \n    } else if (m_Stz2Atom) {\n        result = m_Stz2Atom-\u003eGetSampleSize(index, sample_size); \n    } else {\n        result = AP4_ERROR_INVALID_FORMAT;\n    }\n    if (AP4_FAILED(result)) return result;\n    sample.SetSize(sample_size);\n\n    // set the sync flag\n    if (m_StssAtom == NULL) {\n        sample.SetSync(true);\n    } else {\n        sample.SetSync(m_StssAtom-\u003eIsSampleSync(index));\n    }\n\n    // set the offset\n    sample.SetOffset(offset);\n\n    // set the data stream\n    sample.SetDataStream(m_SampleStream);\n\n\n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4AtomSampleTable.cpp","line_number":84,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-616"},"269719648":{"score":0.8465609,"function_name":"AP4_AtomSampleTable::GetSampleChunkPosition","code":"AP4_Result   \nAP4_AtomSampleTable::GetSampleChunkPosition(AP4_Ordinal  sample_index, \n                                            AP4_Ordinal\u0026 chunk_index,\n                                            AP4_Ordinal\u0026 position_in_chunk)\n{\n    // default values\n    chunk_index       = 0;\n    position_in_chunk = 0;\n    \n    AP4_Ordinal sample_description_index;\n    return GetChunkForSample(sample_index, \n                             chunk_index, \n                             position_in_chunk, \n                             sample_description_index);\n}","filepath":"Source/C++/Core/Ap4AtomSampleTable.cpp","line_number":220,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-616"},"269719696":{"score":0.8268795,"function_name":"AP4_AtomSampleTable::GetSampleCount","code":"AP4_Cardinal\nAP4_AtomSampleTable::GetSampleCount()\n{\n    if (m_StszAtom) {\n        return m_StszAtom-\u003eGetSampleCount();\n    } else if (m_Stz2Atom) {\n        return m_Stz2Atom-\u003eGetSampleCount();\n    } else {\n        return 0;\n    }\n}","filepath":"Source/C++/Core/Ap4AtomSampleTable.cpp","line_number":187,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-616"},"269719824":{"score":0.65505934,"function_name":"AP4_AtomSampleTable::SetChunkOffset","code":"AP4_Result \nAP4_AtomSampleTable::SetChunkOffset(AP4_Ordinal  chunk_index, \n                                    AP4_Position offset)\n{\n    if (m_StcoAtom) {\n        if ((offset \u003e\u003e 32) != 0) return AP4_ERROR_OUT_OF_RANGE;\n        return m_StcoAtom-\u003eSetChunkOffset(chunk_index+1, (AP4_UI32)offset);\n    } else if (m_Co64Atom) {\n        return m_Co64Atom-\u003eSetChunkOffset(chunk_index+1, offset);\n    } else {\n        return AP4_FAILURE;\n    }\n}","filepath":"Source/C++/Core/Ap4AtomSampleTable.cpp","line_number":295,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-616"},"269719904":{"score":0.8901155,"function_name":"AP4_AtomSampleTable::SetSampleSize","code":"AP4_Result \nAP4_AtomSampleTable::SetSampleSize(AP4_Ordinal sample_index, AP4_Size size)\n{\n    if (m_StszAtom) {\n        return m_StszAtom-\u003eSetSampleSize(sample_index+1, size);\n    } else if (m_Stz2Atom) {\n        return m_Stz2Atom-\u003eSetSampleSize(sample_index+1, size);\n    } else {    \n        return AP4_FAILURE;\n    }\n}","filepath":"Source/C++/Core/Ap4AtomSampleTable.cpp","line_number":312,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-616"},"269724048":{"score":0.6754026,"function_name":"AP4_EsDescriptor::Inspect","code":"AP4_Result\nAP4_EsDescriptor::Inspect(AP4_AtomInspector\u0026 inspector)\n{\n    inspector.StartDescriptor(\"ESDescriptor\", GetHeaderSize(), GetSize());\n    inspector.AddField(\"es_id\", m_EsId);\n    inspector.AddField(\"stream_priority\", m_StreamPriority);\n\n    // inspect children\n    m_SubDescriptors.Apply(AP4_DescriptorListInspector(inspector));\n\n    inspector.EndDescriptor();\n\n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4EsDescriptor.cpp","line_number":171,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.1-629"},"269724256":{"score":0.84491193,"function_name":"AP4_EsIdIncDescriptor::Inspect","code":"AP4_Result\nAP4_EsIdIncDescriptor::Inspect(AP4_AtomInspector\u0026 inspector)\n{\n    inspector.StartDescriptor(\"ES_ID_Inc\", GetHeaderSize(), GetSize());\n    inspector.AddField(\"track_id\", m_TrackId);\n    inspector.EndDescriptor();\n    \n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4EsDescriptor.cpp","line_number":253,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.1-629"},"269724336":{"score":0.83000356,"function_name":"AP4_EsIdRefDescriptor::Inspect","code":"AP4_Result\nAP4_EsIdRefDescriptor::Inspect(AP4_AtomInspector\u0026 inspector)\n{\n    inspector.StartDescriptor(\"ES_ID_Ref\", GetHeaderSize(), GetSize());\n    inspector.AddField(\"ref_index\", m_RefIndex);\n    inspector.EndDescriptor();\n    \n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4EsDescriptor.cpp","line_number":298,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.1-629"},"269726368":{"score":0.8166767,"function_name":"AP4_AvccAtom::GetProfileName","code":"char*\nAP4_AvccAtom::GetProfileName(AP4_UI08 profile)\n{\n    switch (profile) {\n        case AP4_AVC_PROFILE_BASELINE: return \"Baseline\";   \n        case AP4_AVC_PROFILE_MAIN:     return \"Main\";\n        case AP4_AVC_PROFILE_EXTENDED: return \"Extended\";\n        case AP4_AVC_PROFILE_HIGH:     return \"High\";\n        case AP4_AVC_PROFILE_HIGH_10:  return \"High 10\";\n        case AP4_AVC_PROFILE_HIGH_422: return \"High 4:2:2\";\n        case AP4_AVC_PROFILE_HIGH_444: return \"High 4:4:4\";\n    }\n\n    return NULL;\n}","filepath":"Source/C++/Core/Ap4AvccAtom.cpp","line_number":45,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-619"},"269726576":{"score":0.8290882,"function_name":"AP4_AvccAtom::InspectFields","code":"AP4_Result\nAP4_AvccAtom::InspectFields(AP4_AtomInspector\u0026 inspector)\n{\n    inspector.AddField(\"Configuration Version\", m_ConfigurationVersion);\n    const char* profile_name = GetProfileName(m_Profile);\n    if (profile_name) {\n        inspector.AddField(\"Profile\", profile_name);\n    } else {\n        inspector.AddField(\"Profile\", m_Profile);\n    }\n    inspector.AddField(\"Profile Compatibility\", m_ProfileCompatibility, AP4_AtomInspector::HINT_HEX);\n    inspector.AddField(\"Level\", m_Level);\n    inspector.AddField(\"NALU Length Size\", m_NaluLengthSize);\n    for (unsigned int i=0; i\u003cm_SequenceParameters.ItemCount(); i++) {\n        inspector.AddField(\"Sequence Parameter\", m_SequenceParameters[i].GetData(), m_SequenceParameters[i].GetDataSize());\n    }\n    for (unsigned int i=0; i\u003cm_PictureParameters.ItemCount(); i++) {\n        inspector.AddField(\"Picture Parameter\", m_PictureParameters[i].GetData(), m_PictureParameters[i].GetDataSize());\n    }\n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4AvccAtom.cpp","line_number":267,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-619"},"269726864":{"score":0.80124366,"function_name":"AP4_AvccAtom::UpdateRawBytes","code":"void\nAP4_AvccAtom::UpdateRawBytes()\n{\n    // compute the payload size\n    unsigned int payload_size = 6;    \n    for (unsigned int i=0; i\u003cm_SequenceParameters.ItemCount(); i++) {\n        payload_size += 2+m_SequenceParameters[i].GetDataSize();\n    }\n    ++payload_size;\n    for (unsigned int i=0; i\u003cm_PictureParameters.ItemCount(); i++) {\n        payload_size += 2+m_PictureParameters[i].GetDataSize();\n    }\n    m_RawBytes.SetDataSize(payload_size);\n    AP4_UI08* payload = m_RawBytes.UseData();\n\n    payload[0] = m_ConfigurationVersion;\n    payload[1] = m_Profile;\n    payload[2] = m_ProfileCompatibility;\n    payload[3] = m_Level;\n    payload[4] = 0xFC | (m_NaluLengthSize-1);\n    payload[5] = 0xE0 | (AP4_UI08)m_SequenceParameters.ItemCount();\n    unsigned int cursor = 6;\n    for (unsigned int i=0; i\u003cm_SequenceParameters.ItemCount(); i++) {\n        AP4_UI16 param_length = (AP4_UI16)m_SequenceParameters[i].GetDataSize();\n        AP4_BytesFromUInt16BE(\u0026payload[cursor], param_length);\n        cursor += 2;\n        AP4_CopyMemory(\u0026payload[cursor], m_SequenceParameters[i].GetData(), param_length);\n        cursor += param_length;\n    }\n    payload[cursor++] = (AP4_UI08)m_PictureParameters.ItemCount();\n    for (unsigned int i=0; i\u003cm_PictureParameters.ItemCount(); i++) {\n        AP4_UI16 param_length = (AP4_UI16)m_PictureParameters[i].GetDataSize();\n        AP4_BytesFromUInt16BE(\u0026payload[cursor], param_length);\n        cursor += 2;\n        AP4_CopyMemory(\u0026payload[cursor], m_PictureParameters[i].GetData(), param_length);\n        cursor += param_length;\n    }\n}","filepath":"Source/C++/Core/Ap4AvccAtom.cpp","line_number":216,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-619"},"269740384":{"score":0.72387075,"function_name":"AP4_Mp4AudioDecoderConfig::Reset","code":"void\nAP4_Mp4AudioDecoderConfig::Reset()\n{\n    m_ObjectType             = 0;\n    m_SamplingFrequencyIndex = 0;\n    m_SamplingFrequency      = 0;\n    m_ChannelCount           = 0;\n    m_ChannelConfiguration   = CHANNEL_CONFIG_NONE;\n    m_FrameLengthFlag        = false;\n    m_DependsOnCoreCoder     = false;\n    m_CoreCoderDelay         = 0;\n    m_Extension.m_SbrPresent = false;\n    m_Extension.m_PsPresent  = false;\n    m_Extension.m_ObjectType = 0;\n    m_Extension.m_SamplingFrequencyIndex = 0;\n    m_Extension.m_SamplingFrequency      = 0;\n}","filepath":"Source/C++/Codecs/Ap4Mp4AudioInfo.cpp","line_number":91,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.6.0-638"},"269740464":{"score":0.6713557,"function_name":"AP4_Mp4AudioDecoderConfig::Parse","code":"AP4_Result\nAP4_Mp4AudioDecoderConfig::Parse(const unsigned char* data, \n                                 AP4_Size             data_size)\n{\n    AP4_Result            result;\n    AP4_Mp4AudioDsiParser bits(data, data_size);\n\n    // default config\n    Reset();\n    \n    // parse the audio object type\n\tresult = ParseAudioObjectType(bits, m_ObjectType);\n    if (AP4_FAILED(result)) return result;\n\n    // parse the sampling frequency\n    result = ParseSamplingFrequency(bits, \n                                    m_SamplingFrequencyIndex, \n                                    m_SamplingFrequency);\n    if (AP4_FAILED(result)) return result;\n\n    if (bits.BitsLeft() \u003c 4) {\n        return AP4_ERROR_INVALID_FORMAT;\n    }\n\tm_ChannelConfiguration = (ChannelConfiguration)bits.ReadBits(4);\n    m_ChannelCount = (unsigned int)m_ChannelConfiguration;\n    if (m_ChannelCount == 7) {\n        m_ChannelCount = 8;\n    } else if (m_ChannelCount \u003e 7) {\n        m_ChannelCount = 0;\n    }\n    \n\tif (m_ObjectType == AP4_MPEG4_AUDIO_OBJECT_TYPE_SBR ||\n        m_ObjectType == AP4_MPEG4_AUDIO_OBJECT_TYPE_PS) {\n\t\tm_Extension.m_ObjectType = AP4_MPEG4_AUDIO_OBJECT_TYPE_SBR;\n\t\tm_Extension.m_SbrPresent = true;\n        m_Extension.m_PsPresent  = m_ObjectType == AP4_MPEG4_AUDIO_OBJECT_TYPE_PS;\n        result = ParseSamplingFrequency(bits, \n                                        m_Extension.m_SamplingFrequencyIndex, \n                                        m_Extension.m_SamplingFrequency);\n        if (AP4_FAILED(result)) return result;\n\t\tresult = ParseAudioObjectType(bits, m_ObjectType);\n        if (AP4_FAILED(result)) return result;\n        if (m_ObjectType == AP4_MPEG4_AUDIO_OBJECT_TYPE_ER_BSAC) {\n            if (bits.BitsLeft() \u003c 4) return AP4_ERROR_INVALID_FORMAT;\n            bits.ReadBits(4); // extensionChannelConfiguration (4)\n        }\n\t} else {\n        m_Extension.m_ObjectType             = 0;\n        m_Extension.m_SamplingFrequency      = 0;\n        m_Extension.m_SamplingFrequencyIndex = 0;\n        m_Extension.m_SbrPresent             = false;\n        m_Extension.m_PsPresent              = false;\n    }\n    \n\tswitch (m_ObjectType) {\n        case AP4_MPEG4_AUDIO_OBJECT_TYPE_AAC_MAIN:\n        case AP4_MPEG4_AUDIO_OBJECT_TYPE_AAC_LC:\n        case AP4_MPEG4_AUDIO_OBJECT_TYPE_AAC_SSR:\n        case AP4_MPEG4_AUDIO_OBJECT_TYPE_AAC_LTP:\n        case AP4_MPEG4_AUDIO_OBJECT_TYPE_AAC_SCALABLE:\n        case AP4_MPEG4_AUDIO_OBJECT_TYPE_TWINVQ:\n        case AP4_MPEG4_AUDIO_OBJECT_TYPE_ER_AAC_LC:\n        case AP4_MPEG4_AUDIO_OBJECT_TYPE_ER_AAC_LTP:\n        case AP4_MPEG4_AUDIO_OBJECT_TYPE_ER_AAC_SCALABLE:\n        case AP4_MPEG4_AUDIO_OBJECT_TYPE_ER_AAC_LD:\n        case AP4_MPEG4_AUDIO_OBJECT_TYPE_ER_TWINVQ:\n        case AP4_MPEG4_AUDIO_OBJECT_TYPE_ER_BSAC:\n        case AP4_MPEG4_AUDIO_OBJECT_TYPE_USAC:\n            result = ParseGASpecificInfo(bits);\n            if (result == AP4_SUCCESS) {\n                if (m_Extension.m_ObjectType !=  AP4_MPEG4_AUDIO_OBJECT_TYPE_SBR \u0026\u0026\n                    bits.BitsLeft() \u003e= 16) {\n                    result = ParseExtension(bits);\n                }\n            }\n            if (result == AP4_ERROR_NOT_SUPPORTED) {\n                // not a fatal error\n                result = AP4_SUCCESS;\n            }\n            if (result != AP4_SUCCESS) return result;\n            break;\n\n        default:\n            return AP4_ERROR_NOT_SUPPORTED;\n    }\n\n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Codecs/Ap4Mp4AudioInfo.cpp","line_number":243,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.6.0-638"},"269741040":{"score":0.78662026,"function_name":"AP4_Mp4AudioDecoderConfig::ParseAudioObjectType","code":"AP4_Result\nAP4_Mp4AudioDecoderConfig::ParseAudioObjectType(AP4_Mp4AudioDsiParser\u0026 parser, AP4_UI08\u0026 object_type)\n{\n    if (parser.BitsLeft() \u003c 5) return AP4_ERROR_INVALID_FORMAT;\n    object_type = (AP4_UI08)parser.ReadBits(5);\n\tif ((int)object_type == 31) {\n        if (parser.BitsLeft() \u003c 6) return AP4_ERROR_INVALID_FORMAT;\n\t\tobject_type = (AP4_UI08)(32 + parser.ReadBits(6));\n\t}\n\treturn AP4_SUCCESS;\n}","filepath":"Source/C++/Codecs/Ap4Mp4AudioInfo.cpp","line_number":112,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.6.0-638"},"269741136":{"score":0.7587996,"function_name":"AP4_Mp4AudioDecoderConfig::ParseExtension","code":"AP4_Result\nAP4_Mp4AudioDecoderConfig::ParseExtension(AP4_Mp4AudioDsiParser\u0026 parser)\n{\n    if (parser.BitsLeft() \u003c 16) return AP4_ERROR_INVALID_FORMAT;\n    unsigned int sync_extension_type = parser.ReadBits(11);\n    if (sync_extension_type == 0x2b7) {\n        AP4_Result result = ParseAudioObjectType(parser, m_Extension.m_ObjectType);\n        if (AP4_FAILED(result)) return result;\n        if (m_Extension.m_ObjectType == AP4_MPEG4_AUDIO_OBJECT_TYPE_SBR) {\n            m_Extension.m_SbrPresent = (parser.ReadBits(1) == 1);\n            if (m_Extension.m_SbrPresent) {\n                result = ParseSamplingFrequency(parser, \n                                                m_Extension.m_SamplingFrequencyIndex,\n                                                m_Extension.m_SamplingFrequency);\n                if (AP4_FAILED(result)) return result;\n                if (parser.BitsLeft() \u003e= 12) {\n                    sync_extension_type = parser.ReadBits(11);\n                    if (sync_extension_type == 0x548) {\n                        m_Extension.m_PsPresent = (parser.ReadBits(1) == 1);\n                    }\n                }\n            }\n        } else if (m_Extension.m_ObjectType == AP4_MPEG4_AUDIO_OBJECT_TYPE_ER_BSAC) {\n            m_Extension.m_SbrPresent = (parser.ReadBits(1) == 1);\n            if (m_Extension.m_SbrPresent) {\n                result = ParseSamplingFrequency(parser, \n                                                m_Extension.m_SamplingFrequencyIndex,\n                                                m_Extension.m_SamplingFrequency);\n                if (AP4_FAILED(result)) return result;\n            } \n            parser.ReadBits(4); // extensionChannelConfiguration           \n        }\n    }\n\treturn AP4_SUCCESS;\n}","filepath":"Source/C++/Codecs/Ap4Mp4AudioInfo.cpp","line_number":127,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.6.0-638"},"269741392":{"score":0.7523937,"function_name":"AP4_Mp4AudioDecoderConfig::ParseGASpecificInfo","code":"AP4_Result\nAP4_Mp4AudioDecoderConfig::ParseGASpecificInfo(AP4_Mp4AudioDsiParser\u0026 parser)\n{\n    if (parser.BitsLeft() \u003c 2) return AP4_ERROR_INVALID_FORMAT;\n\tm_FrameLengthFlag = (parser.ReadBits(1) == 1);\n\tm_DependsOnCoreCoder = (parser.ReadBits(1) == 1);\n\tif (m_DependsOnCoreCoder) {\t\t\n        if (parser.BitsLeft() \u003c 14) return AP4_ERROR_INVALID_FORMAT;\n\t\tm_CoreCoderDelay = parser.ReadBits(14);\n    } else {\n        m_CoreCoderDelay = 0;\n    }\n    if (parser.BitsLeft() \u003c 1) return AP4_ERROR_INVALID_FORMAT;\n\tunsigned int extensionFlag = parser.ReadBits(1);\n\tif (m_ChannelConfiguration == CHANNEL_CONFIG_NONE) {\t\t\n\t\t/*program_config_element (); */\n        return AP4_ERROR_NOT_SUPPORTED;\n\t}\t\t\n    if (m_ObjectType == AP4_MPEG4_AUDIO_OBJECT_TYPE_AAC_SCALABLE ||\n        m_ObjectType == AP4_MPEG4_AUDIO_OBJECT_TYPE_ER_AAC_SCALABLE) {\n        if (parser.BitsLeft() \u003c 3) return AP4_ERROR_INVALID_FORMAT;\n        parser.ReadBits(3); // layerNr\n    }\n    if (extensionFlag) {\n        if (m_ObjectType == AP4_MPEG4_AUDIO_OBJECT_TYPE_ER_BSAC) {\n            if (parser.BitsLeft() \u003c 16) return AP4_ERROR_INVALID_FORMAT;\n            parser.ReadBits(16); // numOfSubFrame (5); layer_length (11)\n        }\n        if (m_ObjectType == AP4_MPEG4_AUDIO_OBJECT_TYPE_ER_AAC_LC       ||\n            m_ObjectType == AP4_MPEG4_AUDIO_OBJECT_TYPE_ER_AAC_SCALABLE ||\n            m_ObjectType == AP4_MPEG4_AUDIO_OBJECT_TYPE_ER_AAC_LD) {\n            if (parser.BitsLeft() \u003c 3) return AP4_ERROR_INVALID_FORMAT;\n            parser.ReadBits(3); // aacSectionDataResilienceFlag (1)\n                                // aacScalefactorDataResilienceFlag (1)\n                                // aacSpectralDataResilienceFlag (1)\n        }\n        if (parser.BitsLeft() \u003c 1) return AP4_ERROR_INVALID_FORMAT;\n        unsigned int extensionFlag3 = parser.ReadBits(1);\n        if (extensionFlag3) {\n            return AP4_ERROR_NOT_SUPPORTED;\n        }\n    }\n    \n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Codecs/Ap4Mp4AudioInfo.cpp","line_number":166,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.6.0-638"},"269741712":{"score":0.718682,"function_name":"AP4_Mp4AudioDecoderConfig::ParseSamplingFrequency","code":"AP4_Result\nAP4_Mp4AudioDecoderConfig::ParseSamplingFrequency(AP4_Mp4AudioDsiParser\u0026 parser, \n                                                  unsigned int\u0026          sampling_frequency_index,\n                                                  unsigned int\u0026          sampling_frequency)\n{\n    if (parser.BitsLeft() \u003c 4) {\n        return AP4_ERROR_INVALID_FORMAT;\n    }\n\n    sampling_frequency_index = parser.ReadBits(4);\n    if (sampling_frequency_index == 0xF) {\n        if (parser.BitsLeft() \u003c 24) {\n            return AP4_ERROR_INVALID_FORMAT;\n        }\n        sampling_frequency = parser.ReadBits(24);\n    } else if (sampling_frequency_index \u003c= AP4_AAC_MAX_SAMPLING_FREQUENCY_INDEX) {\n        sampling_frequency = AP4_AacSamplingFreqTable[sampling_frequency_index];\n    } else {\n        sampling_frequency = 0;\n        return AP4_ERROR_INVALID_FORMAT;\n    }\n\n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Codecs/Ap4Mp4AudioInfo.cpp","line_number":215,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.6.0-638"},"269741840":{"score":0.88969123,"function_name":"ReadBits","code":"AP4_UI32 ReadBits(unsigned int n) {\n        AP4_UI32 result = 0;\n        const AP4_UI08* data = m_Data.GetData();\n        while (n) {\n            unsigned int bits_avail = 8-(m_Position%8);\n            unsigned int chunk_size = bits_avail \u003e= n ? n : bits_avail;\n            unsigned int chunk_bits = (((unsigned int)(data[m_Position/8]))\u003e\u003e(bits_avail-chunk_size))\u0026((1\u003c\u003cchunk_size)-1);\n            result = (result \u003c\u003c chunk_size) | chunk_bits;\n            n -= chunk_size;\n            m_Position += chunk_size;\n        }\n    \n        return result;\n    }","filepath":"Source/C++/Codecs/Ap4Mp4AudioInfo.cpp","line_number":60,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.6.0-638"},"269764800":{"score":0.5717088,"function_name":"AP4_StsdAtom::AP4_StsdAtom","code":"AP4_StsdAtom::AP4_StsdAtom(AP4_SampleTable* sample_table) :\n    AP4_ContainerAtom(AP4_ATOM_TYPE_STSD, (AP4_UI32)0, (AP4_UI32)0)\n{\n    m_Size32 += 4;\n    AP4_Cardinal sample_description_count = sample_table-\u003eGetSampleDescriptionCount();\n    m_SampleDescriptions.EnsureCapacity(sample_description_count);\n    for (AP4_Ordinal i=0; i\u003csample_description_count; i++) {\n        // clear the cache entry\n        m_SampleDescriptions.Append(NULL);\n\n        // create an entry for the description\n        AP4_SampleDescription* sample_description = sample_table-\u003eGetSampleDescription(i);\n        AP4_Atom* entry = sample_description-\u003eToAtom();\n        AddChild(entry);\n    }\n}","filepath":"Source/C++/Core/Ap4StsdAtom.cpp","line_number":63,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.1-626"},"269765360":{"score":0.6025888,"function_name":"AP4_StsdAtom::Create","code":"AP4_StsdAtom*\nAP4_StsdAtom::Create(AP4_Size         size, \n                     AP4_ByteStream\u0026  stream, \n                     AP4_AtomFactory\u0026 atom_factory)\n{\n    AP4_UI08 version;\n    AP4_UI32 flags;\n    if (size \u003c AP4_FULL_ATOM_HEADER_SIZE) return NULL;\n    if (AP4_FAILED(AP4_Atom::ReadFullHeader(stream, version, flags))) return NULL;\n    if (version \u003e 1) return NULL;\n    return new AP4_StsdAtom(size, version, flags, stream, atom_factory);\n}","filepath":"Source/C++/Core/Ap4StsdAtom.cpp","line_number":47,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.1-626"},"269765520":{"score":0.59953254,"function_name":"AP4_StsdAtom::GetSampleDescription","code":"AP4_SampleDescription*\nAP4_StsdAtom::GetSampleDescription(AP4_Ordinal index)\n{\n    // check index\n    if (index \u003e= m_Children.ItemCount()) return NULL;\n\n    // return the description if we already have it in the internal table\n    if (m_SampleDescriptions[index]) return m_SampleDescriptions[index];\n\n    // create and cache a sample description for this entry\n    AP4_Atom* entry;\n    m_Children.Get(index, entry);\n    AP4_SampleEntry* sample_entry = AP4_DYNAMIC_CAST(AP4_SampleEntry, entry);\n    if (sample_entry == NULL) {\n        m_SampleDescriptions[index] = new AP4_UnknownSampleDescription(entry);\n    } else {\n        m_SampleDescriptions[index] = sample_entry-\u003eToSampleDescription();\n    }\n    return m_SampleDescriptions[index];\n}","filepath":"Source/C++/Core/Ap4StsdAtom.cpp","line_number":165,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.1-626"},"269766912":{"score":0.74780935,"function_name":"AP4_StscAtom::AddEntry","code":"AP4_Result \nAP4_StscAtom::AddEntry(AP4_Cardinal chunk_count,\n                       AP4_Cardinal samples_per_chunk,\n                       AP4_Ordinal  sample_description_index)\n{\n    AP4_Ordinal first_chunk;\n    AP4_Ordinal first_sample;\n    AP4_Cardinal entry_count = m_Entries.ItemCount();\n    if (entry_count == 0) {\n        // first entry\n        first_chunk = 1;\n        first_sample = 1;\n    } else {\n        first_chunk = m_Entries[entry_count-1].m_FirstChunk+\n                      m_Entries[entry_count-1].m_ChunkCount;\n        first_sample = m_Entries[entry_count-1].m_FirstSample+\n                       m_Entries[entry_count-1].m_ChunkCount*\n                       m_Entries[entry_count-1].m_SamplesPerChunk;\n    }\n    m_Entries.Append(AP4_StscTableEntry(first_chunk, first_sample, chunk_count, samples_per_chunk, sample_description_index));\n\n    // update the atom size\n    m_Size32 += 12;\n\n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4StscAtom.cpp","line_number":129,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.4.2-584"},"269767248":{"score":0.8258475,"function_name":"AP4_StscAtom::GetChunkForSample","code":"AP4_Result\nAP4_StscAtom::GetChunkForSample(AP4_Ordinal  sample,\n                                AP4_Ordinal\u0026 chunk,\n                                AP4_Ordinal\u0026 skip,\n                                AP4_Ordinal\u0026 sample_description_index)\n{\n    // preconditions\n    AP4_ASSERT(sample \u003e 0);\n\n    // decide whether to start the search from the cached index\n    // or from the start\n    AP4_Ordinal group;\n    if (m_CachedChunkGroup \u003c m_Entries.ItemCount() \u0026\u0026\n        m_Entries[m_CachedChunkGroup].m_FirstSample \u003c= sample) {\n        group = m_CachedChunkGroup;\n    } else {\n        group = 0;\n    }\n\n    // find which group of chunk contains this one\n    while (group \u003c m_Entries.ItemCount()) {\n        AP4_Cardinal sample_count = \n            m_Entries[group].m_ChunkCount*m_Entries[group].m_SamplesPerChunk;\n        if (sample_count == 0) {\n            // unlimited samples in this group (last group)\n            if (m_Entries[group].m_FirstSample \u003e sample) {\n                // something is wrong\n                return AP4_ERROR_INVALID_FORMAT;\n            }\n        } else {\n            // normal group\n            if (m_Entries[group].m_FirstSample + sample_count \u003c= sample) {\n                // the sample is not in this group\n                group++;\n                continue;\n            }\n        }\n\n        // the sample is in this group\n        if (m_Entries[group].m_SamplesPerChunk == 0) {\n            // something is wrong\n            return AP4_ERROR_INVALID_FORMAT;\n        }\n        unsigned int chunk_offset = \n            ((sample-m_Entries[group].m_FirstSample) / \n            m_Entries[group].m_SamplesPerChunk);\n        chunk = m_Entries[group].m_FirstChunk + chunk_offset;\n        skip = sample -\n            (m_Entries[group].m_FirstSample +\n             m_Entries[group].m_SamplesPerChunk*chunk_offset);\n        sample_description_index = m_Entries[group].m_SampleDescriptionIndex;\n\n        // cache the result (to accelerate finding the right group\n        // next time around)\n        m_CachedChunkGroup = group;\n\n        return AP4_SUCCESS;\n    }\n\n    // chunk not found\n    chunk = 0;\n    skip = 0;\n    sample_description_index = 0;\n    return AP4_ERROR_OUT_OF_RANGE;\n}","filepath":"Source/C++/Core/Ap4StscAtom.cpp","line_number":159,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.4.2-584"},"269767504":{"score":0.78626597,"function_name":"AP4_StscAtom::InspectFields","code":"AP4_Result\nAP4_StscAtom::InspectFields(AP4_AtomInspector\u0026 inspector)\n{\n    inspector.AddField(\"entry_count\", m_Entries.ItemCount());\n\n    // dump table entries\n    if (inspector.GetVerbosity() \u003e= 1) {\n        char header[32];\n        char value[256];\n        for (unsigned int i=0; i\u003cm_Entries.ItemCount(); i++) {\n            AP4_FormatString(header, sizeof(header), \"entry %8d\", i);  \n            AP4_FormatString(value, sizeof(value), \n                    \"first_chunk=%d, first_sample=%d, chunk_count=%d, samples_per_chunk=%d, sample_desc_index=%d\", \n                    m_Entries[i].m_FirstChunk,\n                    m_Entries[i].m_FirstSample,\n                    m_Entries[i].m_ChunkCount,\n                    m_Entries[i].m_SamplesPerChunk,\n                    m_Entries[i].m_SampleDescriptionIndex);\n            inspector.AddField(header, value);\n        }\n    }\n    \n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4StscAtom.cpp","line_number":228,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.4.2-584"},"269767840":{"score":0.56320983,"function_name":"AP4_StscAtom::WriteFields","code":"AP4_Result\nAP4_StscAtom::WriteFields(AP4_ByteStream\u0026 stream)\n{\n    AP4_Result result;\n\n    // entry count\n    AP4_Cardinal entry_count = m_Entries.ItemCount();\n    result = stream.WriteUI32(entry_count);\n\n    // entries\n    for (AP4_Ordinal i=0; i\u003centry_count; i++) {\n        stream.WriteUI32(m_Entries[i].m_FirstChunk);\n        if (AP4_FAILED(result)) return result;\n        stream.WriteUI32(m_Entries[i].m_SamplesPerChunk);\n        if (AP4_FAILED(result)) return result;\n        stream.WriteUI32(m_Entries[i].m_SampleDescriptionIndex);\n        if (AP4_FAILED(result)) return result;\n    }\n\n    return result;\n}","filepath":"Source/C++/Core/Ap4StscAtom.cpp","line_number":104,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.4.2-584"},"269770304":{"score":0.7446637,"function_name":"AP4_StszAtom::AddEntry","code":"AP4_Result \nAP4_StszAtom::AddEntry(AP4_UI32 size)\n{\n    m_Entries.Append(size);\n    m_SampleCount++;\n    m_Size32 += 4;\n\n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4StszAtom.cpp","line_number":183,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.4.2-584"},"269770560":{"score":0.8328714,"function_name":"AP4_StszAtom::GetSampleSize","code":"AP4_Result\nAP4_StszAtom::GetSampleSize(AP4_Ordinal sample, AP4_Size\u0026 sample_size)\n{\n    // check the sample index\n    if (sample \u003e m_SampleCount || sample == 0) {\n        sample_size = 0;\n        return AP4_ERROR_OUT_OF_RANGE;\n    } else {\n        // find the size\n        if (m_SampleSize != 0) { // constant size\n            sample_size = m_SampleSize;\n        } else {\n            sample_size = m_Entries[sample - 1];\n        }\n        return AP4_SUCCESS;\n    }\n}","filepath":"Source/C++/Core/Ap4StszAtom.cpp","line_number":130,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.4.2-584"},"269770640":{"score":0.7236276,"function_name":"AP4_StszAtom::InspectFields","code":"AP4_Result\nAP4_StszAtom::InspectFields(AP4_AtomInspector\u0026 inspector)\n{\n    inspector.AddField(\"sample_size\", m_SampleSize);\n    inspector.AddField(\"sample_count\", m_Entries.ItemCount());\n\n    if (inspector.GetVerbosity() \u003e= 2) {\n        char header[32];\n        for (AP4_Ordinal i=0; i\u003cm_Entries.ItemCount(); i++) {\n            AP4_FormatString(header, sizeof(header), \"entry %8d\", i);\n            inspector.AddField(header, m_Entries[i]);\n        }\n    }\n\n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4StszAtom.cpp","line_number":196,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.4.2-584"},"269770816":{"score":0.848539,"function_name":"AP4_StszAtom::SetSampleSize","code":"AP4_Result\nAP4_StszAtom::SetSampleSize(AP4_Ordinal sample, AP4_Size sample_size)\n{\n    // check the sample index\n    if (sample \u003e m_SampleCount || sample == 0) {\n        return AP4_ERROR_OUT_OF_RANGE;\n    } else {\n        if (m_Entries.ItemCount() == 0) {\n            // all samples must have the same size\n            if (sample_size != m_SampleSize) {\n                // not the same\n                if (sample == 1) {\n                    // if this is the first sample, update the global size\n                    m_SampleSize = sample_size;\n                    return AP4_SUCCESS;\n                } else {\n                    // can't have different sizes\n                    return AP4_ERROR_INVALID_PARAMETERS;\n                }\n            }\n        } else {\n            // each sample has a different size\n            m_Entries[sample - 1] = sample_size;\n        }\n\n        return AP4_SUCCESS;\n    }\n}","filepath":"Source/C++/Core/Ap4StszAtom.cpp","line_number":151,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.4.2-584"},"269771440":{"score":0.7926663,"function_name":"AP4_Stz2Atom::AddEntry","code":"AP4_Result \nAP4_Stz2Atom::AddEntry(AP4_UI32 size)\n{\n    m_Entries.Append(size);\n    m_SampleCount++;\n    if (m_FieldSize == 4) {\n        if ((m_SampleCount%2) == 1) {\n            m_Size32++;\n        }\n    } else {\n        m_Size32 += m_FieldSize/8;\n    }\n\n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4Stz2Atom.cpp","line_number":220,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-618"},"269771744":{"score":0.83240616,"function_name":"AP4_Stz2Atom::GetSampleSize","code":"AP4_Result\nAP4_Stz2Atom::GetSampleSize(AP4_Ordinal sample, AP4_Size\u0026 sample_size)\n{\n    // check the sample index\n    if (sample \u003e m_SampleCount || sample == 0) {\n        sample_size = 0;\n        return AP4_ERROR_OUT_OF_RANGE;\n    } else {\n        sample_size = m_Entries[sample - 1];\n        return AP4_SUCCESS;\n    }\n}","filepath":"Source/C++/Core/Ap4Stz2Atom.cpp","line_number":189,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-618"},"269771808":{"score":0.72433305,"function_name":"AP4_Stz2Atom::InspectFields","code":"AP4_Result\nAP4_Stz2Atom::InspectFields(AP4_AtomInspector\u0026 inspector)\n{\n    inspector.AddField(\"field_size\", m_FieldSize);\n    inspector.AddField(\"sample_count\", m_Entries.ItemCount());\n\n    if (inspector.GetVerbosity() \u003e= 2) {\n        char header[32];\n        for (AP4_Ordinal i=0; i\u003cm_Entries.ItemCount(); i++) {\n            AP4_FormatString(header, sizeof(header), \"entry %8d\", i);\n            inspector.AddField(header, m_Entries[i]);\n        }\n    }\n\n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4Stz2Atom.cpp","line_number":239,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-618"},"269771968":{"score":0.8235358,"function_name":"AP4_Stz2Atom::SetSampleSize","code":"AP4_Result\nAP4_Stz2Atom::SetSampleSize(AP4_Ordinal sample, AP4_Size sample_size)\n{\n    // check the sample index\n    if (sample \u003e m_SampleCount || sample == 0) {\n        return AP4_ERROR_OUT_OF_RANGE;\n    } else {\n        m_Entries[sample - 1] = sample_size;\n        return AP4_SUCCESS;\n    }\n}","filepath":"Source/C++/Core/Ap4Stz2Atom.cpp","line_number":205,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-618"},"269773520":{"score":0.84677833,"function_name":"AP4_SttsAtom::GetDts","code":"AP4_Result\nAP4_SttsAtom::GetDts(AP4_Ordinal sample, AP4_UI64\u0026 dts, AP4_UI32* duration)\n{\n    // default value\n    dts = 0;\n    if (duration) *duration = 0;\n    \n    // sample indexes start at 1\n    if (sample == 0) return AP4_ERROR_OUT_OF_RANGE;\n\n    // check the lookup cache\n    AP4_Ordinal lookup_start = 0;\n    AP4_Ordinal sample_start = 0;\n    AP4_UI64    dts_start    = 0;\n    if (sample \u003e= m_LookupCache.sample) {\n        // start from the cached entry\n        lookup_start = m_LookupCache.entry_index;\n        sample_start = m_LookupCache.sample;\n        dts_start    = m_LookupCache.dts;\n    }\n\n    // look from the last known point\n    for (AP4_Ordinal i = lookup_start; i \u003c m_Entries.ItemCount(); i++) {\n        AP4_SttsTableEntry\u0026 entry = m_Entries[i];\n\n        // check if we have reached the sample\n        if (sample \u003c= sample_start+entry.m_SampleCount) {\n            // we are within the sample range for the current entry\n            dts = dts_start + (AP4_UI64)(sample-1 - sample_start) * (AP4_UI64)entry.m_SampleDuration;\n            if (duration) *duration = entry.m_SampleDuration;\n            \n            // update the lookup cache\n            m_LookupCache.entry_index = i;\n            m_LookupCache.sample      = sample_start;\n            m_LookupCache.dts         = dts_start;\n            \n            return AP4_SUCCESS;\n        }\n \n        // update the sample and dts bases\n        sample_start += entry.m_SampleCount;\n        dts_start    += entry.m_SampleCount*entry.m_SampleDuration;\n    }\n\n    // sample is greater than the number of samples\n    return AP4_ERROR_OUT_OF_RANGE;\n}"},"269773776":{"score":0.7872188,"function_name":"AP4_SttsAtom::GetSampleIndexForTimeStamp","code":"AP4_Result\nAP4_SttsAtom::GetSampleIndexForTimeStamp(AP4_UI64      ts, \n                                         AP4_Ordinal\u0026  sample_index)\n{\n    // init\n    AP4_Cardinal entry_count = m_Entries.ItemCount();\n    AP4_UI64 accumulated = 0;\n    sample_index = 0;\n    \n    for (AP4_Ordinal i=0; i\u003centry_count; i++) {\n        AP4_UI64 next_accumulated = \n            accumulated +\n            (AP4_UI64)m_Entries[i].m_SampleCount * \n            (AP4_UI64)m_Entries[i].m_SampleDuration;\n        \n        // check if the ts is in the range of this entry\n        if (ts \u003c next_accumulated) {\n            sample_index += (AP4_UI32)((ts - accumulated) / m_Entries[i].m_SampleDuration);\n            return AP4_SUCCESS;\n        }\n\n        // update accumulated and sample\n        accumulated = next_accumulated;\n        sample_index += m_Entries[i].m_SampleCount;\n    }\n\n    // ts not in range of the table\n    return AP4_FAILURE;\n}","filepath":"Source/C++/Core/Ap4SttsAtom.cpp","line_number":184,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.4.2-584"},"269773936":{"score":0.7909686,"function_name":"AP4_SttsAtom::InspectFields","code":"AP4_Result\nAP4_SttsAtom::InspectFields(AP4_AtomInspector\u0026 inspector)\n{\n    inspector.AddField(\"entry_count\", m_Entries.ItemCount());\n\n    if (inspector.GetVerbosity() \u003e= 1) {\n        char header[32];\n        char value[256];\n        for (AP4_Ordinal i=0; i\u003cm_Entries.ItemCount(); i++) {\n            AP4_FormatString(header, sizeof(header), \"entry %8d\", i);\n            AP4_FormatString(value, sizeof(value), \n                             \"sample_count=%d, sample_duration=%d\", \n                            m_Entries[i].m_SampleCount,\n                            m_Entries[i].m_SampleDuration);\n            inspector.AddField(header, value);\n        }\n    }\n\n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4SttsAtom.cpp","line_number":217,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.4.2-584"},"269779712":{"score":0.5517168,"function_name":"AP4_SchmAtom::AP4_SchmAtom","code":"AP4_SchmAtom::AP4_SchmAtom(AP4_UI32    scheme_type,\n                           AP4_UI32    scheme_version,\n                           const char* scheme_uri,\n                           bool        short_form) :\n    AP4_Atom(AP4_ATOM_TYPE_SCHM, AP4_FULL_ATOM_HEADER_SIZE+4+(short_form?2:4), 0, 0),\n    m_AtomHasShortForm(short_form),\n    m_SchemeType(scheme_type),\n    m_SchemeVersion(scheme_version)\n{\n    if (scheme_uri) {\n        m_SchemeUri = scheme_uri;\n        m_Flags = 1;\n        m_Size32 += m_SchemeUri.GetLength()+1;\n    }\n}","filepath":"Source/C++/Core/Ap4SchmAtom.cpp","line_number":73,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-618"},"269779936":{"score":0.64119333,"function_name":"AP4_SchmAtom::Create","code":"AP4_SchmAtom*\nAP4_SchmAtom::Create(AP4_Size                   size, \n                     AP4_Array\u003cAP4_Atom::Type\u003e* context,\n                     AP4_ByteStream\u0026            stream)\n{\n    AP4_UI08 version;\n    AP4_UI32 flags;\n    if (size \u003c AP4_FULL_ATOM_HEADER_SIZE) return NULL;\n    if (AP4_FAILED(AP4_Atom::ReadFullHeader(stream, version, flags))) return NULL;\n    if (version != 0) return NULL;\n    if (size \u003c AP4_FULL_ATOM_HEADER_SIZE+6) return NULL;\n    \n    // check the context to see if this is a short form atom or not\n    bool short_form = false;\n    if (size \u003c AP4_FULL_ATOM_HEADER_SIZE+8) short_form = true;\n    if (context) {\n        AP4_Size context_depth = context-\u003eItemCount();\n        if (context_depth \u003e= 2 \u0026\u0026\n            (*context)[context_depth-2] == AP4_ATOM_TYPE('m','r','l','n')) {\n            short_form = true;\n        }\n    }\n    \n    return new AP4_SchmAtom(size, version, flags, short_form, stream);\n}","filepath":"Source/C++/Core/Ap4SchmAtom.cpp","line_number":44,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-618"},"269780304":{"score":0.5745391,"function_name":"AP4_SchmAtom::WriteFields","code":"AP4_Result\nAP4_SchmAtom::WriteFields(AP4_ByteStream\u0026 stream)\n{\n    AP4_Result result;\n\n    // scheme type\n    result = stream.WriteUI32(m_SchemeType);\n    if (AP4_FAILED(result)) return result;\n\n    // scheme version\n    if (m_AtomHasShortForm) {\n        result = stream.WriteUI16((AP4_UI16)m_SchemeVersion);\n        if (AP4_FAILED(result)) return result;\n    } else {\n        result = stream.WriteUI32(m_SchemeVersion);\n        if (AP4_FAILED(result)) return result;\n    }\n    \n    // uri if needed\n    if (m_Flags \u0026 1) {\n        result = stream.Write(m_SchemeUri.GetChars(), m_SchemeUri.GetLength()+1);\n        if (AP4_FAILED(result)) return result;\n\n        // pad with zeros if necessary\n        AP4_Size fields_size = 4+(m_AtomHasShortForm?2:4);\n        AP4_Size padding = m_Size32-(AP4_FULL_ATOM_HEADER_SIZE+fields_size+m_SchemeUri.GetLength()+1);\n        while (padding--) stream.WriteUI08(0);\n    }\n\n    return result;\n}","filepath":"Source/C++/Core/Ap4SchmAtom.cpp","line_number":123,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-618"},"269793872":{"score":0.5767882,"function_name":"AP4_TfraAtom::Create","code":"AP4_TfraAtom* \nAP4_TfraAtom::Create(AP4_Size size, AP4_ByteStream\u0026 stream)\n{\n    AP4_UI08 version = 0;\n    AP4_UI32 flags   = 0;\n    if (size \u003c AP4_FULL_ATOM_HEADER_SIZE) return NULL;\n    AP4_Result result = ReadFullHeader(stream, version, flags);\n    if (AP4_FAILED(result)) return NULL;\n    if (version \u003e 1) return NULL;\n    return new AP4_TfraAtom(size, version, flags, stream);\n}","filepath":"Source/C++/Core/Ap4TfraAtom.cpp","line_number":44,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-618"},"269794176":{"score":0.7762218,"function_name":"AP4_TfraAtom::InspectFields","code":"AP4_Result\nAP4_TfraAtom::InspectFields(AP4_AtomInspector\u0026 inspector)\n{\n    inspector.AddField(\"track_ID\", m_TrackId);\n    inspector.AddField(\"length_size_of_traf_num\",   m_LengthSizeOfTrafNumber);\n    inspector.AddField(\"length_size_of_trun_num\",   m_LengthSizeOfTrunNumber);\n    inspector.AddField(\"length_size_of_sample_num\", m_LengthSizeOfSampleNumber);\n    if (inspector.GetVerbosity() \u003e= 1) {\n        for (unsigned int i=0; i\u003cm_Entries.ItemCount(); i++) {\n            char name[16];\n            char value[256];\n            AP4_FormatString(name, sizeof(name), \"entry %04d\", i);\n            AP4_FormatString(value, sizeof(value), \n                             \"time=%lld, moof_offset=%lld, traf_number=%d, trun_number=%d, sample_number=%d\",\n                             m_Entries[i].m_Time,\n                             m_Entries[i].m_MoofOffset,\n                             m_Entries[i].m_TrafNumber,\n                             m_Entries[i].m_TrunNumber,\n                             m_Entries[i].m_SampleNumber);\n            inspector.AddField(name, value);\n        }\n    }\n    \n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4TfraAtom.cpp","line_number":310,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-618"},"269794592":{"score":0.560777,"function_name":"AP4_TfraAtom::WriteFields","code":"AP4_Result\nAP4_TfraAtom::WriteFields(AP4_ByteStream\u0026 stream)\n{\n    AP4_Result result;\n\n    result = stream.WriteUI32(m_TrackId);\n    if (AP4_FAILED(result)) return result;\n    AP4_UI32 fields = (m_LengthSizeOfTrafNumber\u003c\u003c4)|\n                      (m_LengthSizeOfTrunNumber\u003c\u003c2)|\n                      (m_LengthSizeOfSampleNumber );\n    result = stream.WriteUI32(fields);\n    if (AP4_FAILED(result)) return result;\n    result = stream.WriteUI32(m_Entries.ItemCount());\n    if (AP4_FAILED(result)) return result;\n    for (unsigned int i=0; i\u003cm_Entries.ItemCount(); i++) {\n        if (m_Version == 1) {\n            result = stream.WriteUI64(m_Entries[i].m_Time);\n            if (AP4_FAILED(result)) return result;\n            result = stream.WriteUI64(m_Entries[i].m_MoofOffset);\n            if (AP4_FAILED(result)) return result;\n        } else {\n            result = stream.WriteUI32((AP4_UI32)m_Entries[i].m_Time);\n            if (AP4_FAILED(result)) return result;\n            result = stream.WriteUI32((AP4_UI32)m_Entries[i].m_MoofOffset);\n            if (AP4_FAILED(result)) return result;\n        }\n\n        switch (m_LengthSizeOfTrafNumber) {\n            case 0: \n                result = stream.WriteUI08((AP4_UI08)m_Entries[i].m_TrafNumber);\n                if (AP4_FAILED(result)) return result;\n                break;\n\n            case 1: \n                result = stream.WriteUI16((AP4_UI16)m_Entries[i].m_TrafNumber);\n                if (AP4_FAILED(result)) return result;\n                break;\n\n            case 2: \n                result = stream.WriteUI24(m_Entries[i].m_TrafNumber);\n                if (AP4_FAILED(result)) return result;\n                break;\n\n            case 3:\n                result = stream.WriteUI32(m_Entries[i].m_TrafNumber);\n                if (AP4_FAILED(result)) return result;\n                break;\n        }\n        \n        switch (m_LengthSizeOfTrunNumber) {\n            case 0: \n                result = stream.WriteUI08((AP4_UI08)m_Entries[i].m_TrunNumber);\n                if (AP4_FAILED(result)) return result;\n                break;\n\n            case 1: \n                result = stream.WriteUI16((AP4_UI16)m_Entries[i].m_TrunNumber);\n                if (AP4_FAILED(result)) return result;\n                break;\n\n            case 2: \n                result = stream.WriteUI24(m_Entries[i].m_TrunNumber);\n                if (AP4_FAILED(result)) return result;\n                break;\n\n            case 3:\n                result = stream.WriteUI32(m_Entries[i].m_TrunNumber);\n                if (AP4_FAILED(result)) return result;\n                break;\n        }\n\n        switch (m_LengthSizeOfSampleNumber) {\n            case 0: \n                result = stream.WriteUI08((AP4_UI08)m_Entries[i].m_SampleNumber);\n                if (AP4_FAILED(result)) return result;\n                break;\n\n            case 1: \n                result = stream.WriteUI16((AP4_UI16)m_Entries[i].m_SampleNumber);\n                if (AP4_FAILED(result)) return result;\n                break;\n\n            case 2: \n                result = stream.WriteUI24(m_Entries[i].m_SampleNumber);\n                if (AP4_FAILED(result)) return result;\n                break;\n\n            case 3:\n                result = stream.WriteUI32(m_Entries[i].m_SampleNumber);\n                if (AP4_FAILED(result)) return result;\n                break;\n        }\n    }\n    \n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4TfraAtom.cpp","line_number":187,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-618"},"269798448":{"score":0.8549088,"function_name":"AP4_SaizAtom::GetSampleInfoSize","code":"AP4_Result\nAP4_SaizAtom::GetSampleInfoSize(AP4_Ordinal sample, AP4_UI08\u0026 sample_info_size)\n{\n    if (m_DefaultSampleInfoSize) {\n        sample_info_size = m_DefaultSampleInfoSize;\n    } else {\n        // check the sample index\n        if (sample \u003e= m_SampleCount) {\n            sample_info_size = 0;\n            return AP4_ERROR_OUT_OF_RANGE;\n        } else {\n            sample_info_size = m_Entries[sample];\n        }\n    }\n    \n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4SaizAtom.cpp","line_number":144,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-618"},"269798512":{"score":0.7454082,"function_name":"AP4_SaizAtom::InspectFields","code":"AP4_Result\nAP4_SaizAtom::InspectFields(AP4_AtomInspector\u0026 inspector)\n{\n    if (m_Flags\u00261) {\n        inspector.AddField(\"aux info type\", m_AuxInfoType, AP4_AtomInspector::HINT_HEX);\n        inspector.AddField(\"aux info type parameter\", m_AuxInfoTypeParameter, AP4_AtomInspector::HINT_HEX);\n    }\n    inspector.AddField(\"default sample info size\", m_DefaultSampleInfoSize);\n    inspector.AddField(\"sample count\", m_SampleCount);\n\n    if (inspector.GetVerbosity() \u003e= 2) {\n        char header[32];\n        for (AP4_Ordinal i=0; i\u003cm_Entries.ItemCount(); i++) {\n            AP4_FormatString(header, sizeof(header), \"entry %8d\", i);\n            inspector.AddField(header, m_Entries[i]);\n        }\n    }\n\n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4SaizAtom.cpp","line_number":214,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-618"},"269798736":{"score":0.61174977,"function_name":"AP4_SaizAtom::WriteFields","code":"AP4_Result\nAP4_SaizAtom::WriteFields(AP4_ByteStream\u0026 stream)\n{\n    AP4_Result result;\n    if (m_Flags\u00261) {\n        result = stream.WriteUI32(m_AuxInfoType);\n        if (AP4_FAILED(result)) return result;\n        result = stream.WriteUI32(m_AuxInfoTypeParameter);\n        if (AP4_FAILED(result)) return result;\n    }\n    result = stream.WriteUI08(m_DefaultSampleInfoSize);\n    if (AP4_FAILED(result)) return result;\n    result = stream.WriteUI32(m_SampleCount);\n    if (AP4_FAILED(result)) return result;\n    \n    if (m_DefaultSampleInfoSize == 0) {\n        for (AP4_UI32 i=0; i\u003cm_SampleCount; i++) {\n            result = stream.WriteUI08(m_Entries[i]);\n            if (AP4_FAILED(result)) return result;\n        }\n    }\n    \n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4SaizAtom.cpp","line_number":186,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-618"},"269810240":{"score":0.83901906,"function_name":"AP4_AesBlockCipher::Create","code":"AP4_Result\nAP4_AesBlockCipher::Create(const AP4_UI08*      key, \n                           CipherDirection      direction,\n                           CipherMode           mode,\n                           const void*          mode_params,\n                           AP4_AesBlockCipher*\u0026 cipher)\n{\n    cipher = NULL;\n\n    aes_ctx* context = new aes_ctx();\n    \n    switch (mode) {\n        case AP4_BlockCipher::CBC:\n            if (direction == AP4_BlockCipher::ENCRYPT) {\n                aes_enc_key(key, AP4_AES_KEY_LENGTH, context);\n            } else {\n                aes_dec_key(key, AP4_AES_KEY_LENGTH, context);\n            }\n            cipher = new AP4_AesCbcBlockCipher(direction, context);\n            break;\n            \n        case AP4_BlockCipher::CTR: {\n            aes_enc_key(key, AP4_AES_KEY_LENGTH, context);\n            const AP4_BlockCipher::CtrParams* ctr_params = (const AP4_BlockCipher::CtrParams*)mode_params;\n            unsigned int counter_size = 16;\n            if (ctr_params) {\n                counter_size = ctr_params-\u003ecounter_size;\n            }\n            cipher = new AP4_AesCtrBlockCipher(direction, counter_size, context);\n            break;\n        }\n            \n        default:\n            return AP4_ERROR_INVALID_PARAMETERS;\n    }\n\n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Crypto/Ap4AesBlockCipher.cpp","line_number":1969,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-618"},"269810464":{"score":0.7689402,"function_name":"AP4_AesCbcBlockCipher::Process","code":"AP4_Result \nAP4_AesCbcBlockCipher::Process(const AP4_UI08* input, \n                               AP4_Size        input_size,\n                               AP4_UI08*       output,\n                               const AP4_UI08* iv)\n{\n    // check the parameters\n    if (input_size%AP4_AES_BLOCK_SIZE) {\n        return AP4_ERROR_INVALID_PARAMETERS;\n    }\n    \n    // setup the chaining block from the IV\n    AP4_UI08 chaining_block[AP4_AES_BLOCK_SIZE];\n    if (iv) {\n        AP4_CopyMemory(chaining_block, iv, AP4_AES_BLOCK_SIZE);\n    } else {\n        AP4_SetMemory(chaining_block, 0, AP4_AES_BLOCK_SIZE);\n    }\n    \n    // process all blocks\n    unsigned int block_count = input_size/AP4_AES_BLOCK_SIZE;\n    if (m_Direction == ENCRYPT) {\n        for (unsigned int i=0; i\u003cblock_count; i++) {\n            AP4_UI08 block[AP4_AES_BLOCK_SIZE];\n            for (unsigned int j=0; j\u003cAP4_AES_BLOCK_SIZE; j++) {\n                block[j] = input[j] ^ chaining_block[j];\n            }\n            aes_enc_blk(block, output, m_Context);\n            AP4_CopyMemory(chaining_block, output, AP4_AES_BLOCK_SIZE);\n            input  += AP4_AES_BLOCK_SIZE;\n            output += AP4_AES_BLOCK_SIZE;\n        }\n    } else {        \n        for (unsigned int i=0; i\u003cblock_count; i++) {\n            aes_dec_blk(input, output, m_Context);\n            for (unsigned int j=0; j\u003cAP4_AES_BLOCK_SIZE; j++) {\n                output[j] ^= chaining_block[j];\n            }\n            AP4_CopyMemory(chaining_block, input, AP4_AES_BLOCK_SIZE);\n            input  += AP4_AES_BLOCK_SIZE;\n            output += AP4_AES_BLOCK_SIZE;\n        }\n    }\n    \n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Crypto/Ap4AesBlockCipher.cpp","line_number":1851,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-618"},"269810816":{"score":0.64745104,"function_name":"AP4_AesCtrBlockCipher::Process","code":"AP4_Result \nAP4_AesCtrBlockCipher::Process(const AP4_UI08* input, \n                               AP4_Size        input_size,\n                               AP4_UI08*       output,\n                               const AP4_UI08* iv)\n{\n    // copy the iv into the counter\n    AP4_UI08 counter[AP4_AES_BLOCK_SIZE];\n    if (iv) {\n        AP4_CopyMemory(counter, iv, AP4_AES_BLOCK_SIZE);\n    } else {\n        AP4_SetMemory(counter, 0, AP4_AES_BLOCK_SIZE);\n    }\n    \n    // process all blocks\n    while (input_size) {\n        AP4_UI08 block[AP4_AES_BLOCK_SIZE];\n        aes_enc_blk(counter, block, m_Context);\n        unsigned int chunk = input_size\u003e=AP4_AES_BLOCK_SIZE?AP4_AES_BLOCK_SIZE:input_size;\n        for (unsigned int j=0; j\u003cchunk; j++) {\n            output[j] = input[j]^block[j];\n        }\n        input_size -= chunk;\n        if (input_size) {\n            // increment the counter\n            for (int x=AP4_AES_BLOCK_SIZE-1; x; --x) {\n                if (counter[x] == 255) {\n                    counter[x] = 0;\n                    continue;\n                } else {\n                    ++counter[x];\n                    break;\n                }\n            }\n            \n            // move to the next block\n            input  += AP4_AES_BLOCK_SIZE;\n            output += AP4_AES_BLOCK_SIZE;\n        }\n    }\n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Crypto/Ap4AesBlockCipher.cpp","line_number":1923,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-618"},"269814864":{"score":0.8095778,"function_name":"aes_enc_key","code":"static aes_rval aes_enc_key(const unsigned char in_key[], unsigned int klen, aes_ctx cx[1])\n{   aes_32t    ss[8]; \n\n#if !defined(FIXED_TABLES)\n    if(!tab_init) gen_tabs();\n#endif\n\n#if !defined(BLOCK_SIZE)\n    if(!cx-\u003en_blk) cx-\u003en_blk = 16;\n#else\n    cx-\u003en_blk = BLOCK_SIZE;\n#endif\n    \n    cx-\u003en_blk = (cx-\u003en_blk \u0026 ~3) | 1;\n\n    cx-\u003ek_sch[0] = ss[0] = word_in(in_key     );\n    cx-\u003ek_sch[1] = ss[1] = word_in(in_key +  4);\n    cx-\u003ek_sch[2] = ss[2] = word_in(in_key +  8);\n    cx-\u003ek_sch[3] = ss[3] = word_in(in_key + 12);\n\n#if (BLOCK_SIZE == 16) \u0026\u0026 (ENC_UNROLL != NONE)\n\n    switch(klen)\n    {\n    case 16:    ke4(cx-\u003ek_sch, 0); ke4(cx-\u003ek_sch, 1); \n                ke4(cx-\u003ek_sch, 2); ke4(cx-\u003ek_sch, 3);\n                ke4(cx-\u003ek_sch, 4); ke4(cx-\u003ek_sch, 5); \n                ke4(cx-\u003ek_sch, 6); ke4(cx-\u003ek_sch, 7);\n                ke4(cx-\u003ek_sch, 8); kel4(cx-\u003ek_sch, 9); \n                cx-\u003en_rnd = 10; break;\n    case 24:    cx-\u003ek_sch[4] = ss[4] = word_in(in_key + 16);\n                cx-\u003ek_sch[5] = ss[5] = word_in(in_key + 20);\n                ke6(cx-\u003ek_sch, 0); ke6(cx-\u003ek_sch, 1); \n                ke6(cx-\u003ek_sch, 2); ke6(cx-\u003ek_sch, 3);\n                ke6(cx-\u003ek_sch, 4); ke6(cx-\u003ek_sch, 5); \n                ke6(cx-\u003ek_sch, 6); kel6(cx-\u003ek_sch, 7); \n                cx-\u003en_rnd = 12; break;\n    case 32:    cx-\u003ek_sch[4] = ss[4] = word_in(in_key + 16);\n                cx-\u003ek_sch[5] = ss[5] = word_in(in_key + 20);\n                cx-\u003ek_sch[6] = ss[6] = word_in(in_key + 24);\n                cx-\u003ek_sch[7] = ss[7] = word_in(in_key + 28);\n                ke8(cx-\u003ek_sch, 0); ke8(cx-\u003ek_sch, 1); \n                ke8(cx-\u003ek_sch, 2); ke8(cx-\u003ek_sch, 3);\n                ke8(cx-\u003ek_sch, 4); ke8(cx-\u003ek_sch, 5); \n                kel8(cx-\u003ek_sch, 6); \n                cx-\u003en_rnd = 14; break;\n    default:    cx-\u003en_rnd = 0; return aes_bad; \n    }\n#else\n    {   aes_32t i, l;\n        cx-\u003en_rnd = ((klen \u003e\u003e 2) \u003e nc ? (klen \u003e\u003e 2) : nc) + 6;\n        l = (nc * cx-\u003en_rnd + nc - 1) / (klen \u003e\u003e 2);\n\n        switch(klen)\n        {\n        case 16:    for(i = 0; i \u003c l; ++i)\n                        ke4(cx-\u003ek_sch, i);\n                    break;\n        case 24:    cx-\u003ek_sch[4] = ss[4] = word_in(in_key + 16);\n                    cx-\u003ek_sch[5] = ss[5] = word_in(in_key + 20);\n                    for(i = 0; i \u003c l; ++i)\n                        ke6(cx-\u003ek_sch, i);\n                    break;\n        case 32:    cx-\u003ek_sch[4] = ss[4] = word_in(in_key + 16);\n                    cx-\u003ek_sch[5] = ss[5] = word_in(in_key + 20);\n                    cx-\u003ek_sch[6] = ss[6] = word_in(in_key + 24);\n                    cx-\u003ek_sch[7] = ss[7] = word_in(in_key + 28);\n                    for(i = 0; i \u003c l; ++i)\n                        ke8(cx-\u003ek_sch,  i);\n                    break;\n        default:    cx-\u003en_rnd = 0; return aes_bad; \n        }\n    }\n#endif\n\n    return aes_good;\n}","filepath":"Source/C++/Crypto/Ap4AesBlockCipher.cpp","line_number":1192,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.5.0-618"},"269819184":{"score":0.8409714,"function_name":"AP4_IpmpDescriptor::Inspect","code":"AP4_Result\nAP4_IpmpDescriptor::Inspect(AP4_AtomInspector\u0026 inspector)\n{\n    inspector.StartDescriptor(\"IPMP_Descriptor\", GetHeaderSize(), GetSize());\n    inspector.AddField(\"IPMP_DescriptorID\", m_DescriptorId);\n    inspector.AddField(\"IPMPS_Type\", m_IpmpsType, AP4_AtomInspector::HINT_HEX);\n    if (m_DescriptorId == 0xFF \u0026\u0026 m_IpmpsType == 0xFFFF) {\n        inspector.AddField(\"IPMP_DescriptorIDEx\", m_DescriptorIdEx);\n        inspector.AddField(\"IPMP_ToolID\", (const unsigned char*)(\u0026m_ToolId[0]), 16, AP4_AtomInspector::HINT_HEX);\n        inspector.AddField(\"controlPointCode\", m_ControlPointCode);\n        if (m_ControlPointCode \u003e 0) {\n            inspector.AddField(\"sequenceCode\", m_SequenceCode);\n        }\n    } else if (m_IpmpsType == 0) {\n        inspector.AddField(\"URL\", m_Url.GetChars());\n    } else {\n        inspector.AddField(\"data size\", m_Data.GetDataSize());\n    }\n\n    inspector.EndDescriptor();\n\n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4Ipmp.cpp","line_number":199,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.4.2-584"},"269819456":{"score":0.8488633,"function_name":"AP4_IpmpDescriptorPointer::Inspect","code":"AP4_Result\nAP4_IpmpDescriptorPointer::Inspect(AP4_AtomInspector\u0026 inspector)\n{\n    inspector.StartDescriptor(\"IPMP_DescriptorPointer\", GetHeaderSize(), GetSize());\n    inspector.AddField(\"IPMP_DescriptorID\", m_DescriptorId);\n    if (m_DescriptorId == 0xFF) {\n        inspector.AddField(\"IPMP_DescriptorIDEx\", m_DescriptorIdEx);\n        inspector.AddField(\"IPMP_ES_ID\",          m_EsId);\n    }\n\n    inspector.EndDescriptor();\n\n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4Ipmp.cpp","line_number":86,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.4.2-584"},"269819584":{"score":0.71094865,"function_name":"AP4_IpmpDescriptor::WriteFields","code":"AP4_Result\nAP4_IpmpDescriptor::WriteFields(AP4_ByteStream\u0026 stream)\n{\n    stream.WriteUI08(m_DescriptorId);\n    stream.WriteUI16(m_IpmpsType);\n    if (m_DescriptorId == 0xFF \u0026\u0026 m_IpmpsType == 0xFFFF) {\n        stream.WriteUI16(m_DescriptorIdEx);\n        stream.Write(m_ToolId, 16);\n        stream.WriteUI08(m_ControlPointCode);\n        if (m_ControlPointCode \u003e 0) {\n            stream.WriteUI08(m_SequenceCode);\n        }\n        if (m_Data.GetDataSize()) {\n            stream.Write(m_Data.GetData(), m_Data.GetDataSize());\n        }\n    } else if (m_IpmpsType == 0) {\n        stream.Write(m_Url.GetChars(), m_Url.GetLength()+1);\n    } else {\n        stream.Write(m_Data.GetData(), m_Data.GetDataSize());\n    }\n    \n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4Ipmp.cpp","line_number":172,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.4.2-584"},"269819776":{"score":0.7326611,"function_name":"AP4_IpmpDescriptorPointer::WriteFields","code":"AP4_Result\nAP4_IpmpDescriptorPointer::WriteFields(AP4_ByteStream\u0026 stream)\n{\n    stream.WriteUI08(m_DescriptorId);\n    if (m_DescriptorId == 0xFF) {\n        stream.WriteUI16(m_DescriptorIdEx);\n        stream.WriteUI16(m_EsId);\n    }\n    return AP4_SUCCESS;\n}","filepath":"Source/C++/Core/Ap4Ipmp.cpp","line_number":72,"entry_url":"https://github.com/axiomatic-systems/Bento4.git","slot_name":"v1.4.2-584"},"269824736":{"score":0.9161978,"function_name":"BIO_ctrl","code":"long BIO_ctrl(BIO *b, int cmd, long larg, void *parg)\n{\n    long ret;\n\n    if (b == NULL)\n        return 0;\n\n    if ((b-\u003emethod == NULL) || (b-\u003emethod-\u003ectrl == NULL)) {\n        BIOerr(BIO_F_BIO_CTRL, BIO_R_UNSUPPORTED_METHOD);\n        return -2;\n    }\n\n    if (b-\u003ecallback != NULL || b-\u003ecallback_ex != NULL) {\n        ret = bio_call_callback(b, BIO_CB_CTRL, parg, 0, cmd, larg, 1L, NULL);\n        if (ret \u003c= 0)\n            return ret;\n    }\n\n    ret = b-\u003emethod-\u003ectrl(b, cmd, larg, parg);\n\n    if (b-\u003ecallback != NULL || b-\u003ecallback_ex != NULL)\n        ret = bio_call_callback(b, BIO_CB_CTRL | BIO_CB_RETURN, parg, 0, cmd,\n                                larg, ret, NULL);\n\n    return ret;\n}","filepath":"crypto/bio/bio_lib.c","line_number":510,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269824960":{"score":0.9522364,"function_name":"BIO_find_type","code":"BIO *BIO_find_type(BIO *bio, int type)\n{\n    int mt, mask;\n\n    if (bio == NULL)\n        return NULL;\n    mask = type \u0026 0xff;\n    do {\n        if (bio-\u003emethod != NULL) {\n            mt = bio-\u003emethod-\u003etype;\n\n            if (!mask) {\n                if (mt \u0026 type)\n                    return bio;\n            } else if (mt == type)\n                return bio;\n        }\n        bio = bio-\u003enext_bio;\n    } while (bio != NULL);\n    return NULL;\n}","filepath":"crypto/bio/bio_lib.c","line_number":648,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269825024":{"score":0.9156216,"function_name":"BIO_free","code":"int BIO_free(BIO *a)\n{\n    int ret;\n\n    if (a == NULL)\n        return 0;\n\n    if (CRYPTO_DOWN_REF(\u0026a-\u003ereferences, \u0026ret, a-\u003elock) \u003c= 0)\n        return 0;\n\n    REF_PRINT_COUNT(\"BIO\", a);\n    if (ret \u003e 0)\n        return 1;\n    REF_ASSERT_ISNT(ret \u003c 0);\n\n    if (a-\u003ecallback != NULL || a-\u003ecallback_ex != NULL) {\n        ret = (int)bio_call_callback(a, BIO_CB_FREE, NULL, 0, 0, 0L, 1L, NULL);\n        if (ret \u003c= 0)\n            return ret;\n    }\n\n    if ((a-\u003emethod != NULL) \u0026\u0026 (a-\u003emethod-\u003edestroy != NULL))\n        a-\u003emethod-\u003edestroy(a);\n\n    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_BIO, a, \u0026a-\u003eex_data);\n\n    CRYPTO_THREAD_lock_free(a-\u003elock);\n\n    OPENSSL_free(a);\n\n    return 1;\n}","filepath":"crypto/bio/bio_lib.c","line_number":110,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269825360":{"score":0.9343421,"function_name":"BIO_gets","code":"int BIO_gets(BIO *b, char *buf, int size)\n{\n    int ret;\n    size_t readbytes = 0;\n\n    if ((b == NULL) || (b-\u003emethod == NULL) || (b-\u003emethod-\u003ebgets == NULL)) {\n        BIOerr(BIO_F_BIO_GETS, BIO_R_UNSUPPORTED_METHOD);\n        return -2;\n    }\n\n    if (size \u003c 0) {\n        BIOerr(BIO_F_BIO_GETS, BIO_R_INVALID_ARGUMENT);\n        return 0;\n    }\n\n    if (b-\u003ecallback != NULL || b-\u003ecallback_ex != NULL) {\n        ret = (int)bio_call_callback(b, BIO_CB_GETS, buf, size, 0, 0L, 1, NULL);\n        if (ret \u003c= 0)\n            return ret;\n    }\n\n    if (!b-\u003einit) {\n        BIOerr(BIO_F_BIO_GETS, BIO_R_UNINITIALIZED);\n        return -2;\n    }\n\n    ret = b-\u003emethod-\u003ebgets(b, buf, size);\n\n    if (ret \u003e 0) {\n        readbytes = ret;\n        ret = 1;\n    }\n\n    if (b-\u003ecallback != NULL || b-\u003ecallback_ex != NULL)\n        ret = (int)bio_call_callback(b, BIO_CB_GETS | BIO_CB_RETURN, buf, size,\n                                     0, 0L, ret, \u0026readbytes);\n\n    if (ret \u003e 0) {\n        /* Shouldn't happen */\n        if (readbytes \u003e (size_t)size)\n            ret = -1;\n        else\n            ret = (int)readbytes;\n    }\n\n    return ret;\n}","filepath":"crypto/bio/bio_lib.c","line_number":432,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269825776":{"score":0.76306003,"function_name":"BIO_indent","code":"int BIO_indent(BIO *b, int indent, int max)\n{\n    if (indent \u003c 0)\n        indent = 0;\n    if (indent \u003e max)\n        indent = max;\n    while (indent--)\n        if (BIO_puts(b, \" \") != 1)\n            return 0;\n    return 1;\n}","filepath":"crypto/bio/bio_lib.c","line_number":480,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269826272":{"score":0.92164457,"function_name":"BIO_new","code":"BIO *BIO_new(const BIO_METHOD *method)\n{\n    BIO *bio = OPENSSL_zalloc(sizeof(*bio));\n\n    if (bio == NULL) {\n        BIOerr(BIO_F_BIO_NEW, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    bio-\u003emethod = method;\n    bio-\u003eshutdown = 1;\n    bio-\u003ereferences = 1;\n\n    if (!CRYPTO_new_ex_data(CRYPTO_EX_INDEX_BIO, bio, \u0026bio-\u003eex_data))\n        goto err;\n\n    bio-\u003elock = CRYPTO_THREAD_lock_new();\n    if (bio-\u003elock == NULL) {\n        BIOerr(BIO_F_BIO_NEW, ERR_R_MALLOC_FAILURE);\n        CRYPTO_free_ex_data(CRYPTO_EX_INDEX_BIO, bio, \u0026bio-\u003eex_data);\n        goto err;\n    }\n\n    if (method-\u003ecreate != NULL \u0026\u0026 !method-\u003ecreate(bio)) {\n        BIOerr(BIO_F_BIO_NEW, ERR_R_INIT_FAIL);\n        CRYPTO_free_ex_data(CRYPTO_EX_INDEX_BIO, bio, \u0026bio-\u003eex_data);\n        CRYPTO_THREAD_lock_free(bio-\u003elock);\n        goto err;\n    }\n    if (method-\u003ecreate == NULL)\n        bio-\u003einit = 1;\n\n    return bio;\n\nerr:\n    OPENSSL_free(bio);\n    return NULL;\n}","filepath":"crypto/bio/bio_lib.c","line_number":71,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269826528":{"score":0.8920957,"function_name":"BIO_push","code":"BIO *BIO_push(BIO *b, BIO *bio)\n{\n    BIO *lb;\n\n    if (b == NULL)\n        return bio;\n    lb = b;\n    while (lb-\u003enext_bio != NULL)\n        lb = lb-\u003enext_bio;\n    lb-\u003enext_bio = bio;\n    if (bio != NULL)\n        bio-\u003eprev_bio = lb;\n    /* called to do internal processing */\n    BIO_ctrl(b, BIO_CTRL_PUSH, 0, lb);\n    return b;\n}","filepath":"crypto/bio/bio_lib.c","line_number":582,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269826608":{"score":0.893803,"function_name":"BIO_puts","code":"int BIO_puts(BIO *b, const char *buf)\n{\n    int ret;\n    size_t written = 0;\n\n    if ((b == NULL) || (b-\u003emethod == NULL) || (b-\u003emethod-\u003ebputs == NULL)) {\n        BIOerr(BIO_F_BIO_PUTS, BIO_R_UNSUPPORTED_METHOD);\n        return -2;\n    }\n\n    if (b-\u003ecallback != NULL || b-\u003ecallback_ex != NULL) {\n        ret = (int)bio_call_callback(b, BIO_CB_PUTS, buf, 0, 0, 0L, 1L, NULL);\n        if (ret \u003c= 0)\n            return ret;\n    }\n\n    if (!b-\u003einit) {\n        BIOerr(BIO_F_BIO_PUTS, BIO_R_UNINITIALIZED);\n        return -2;\n    }\n\n    ret = b-\u003emethod-\u003ebputs(b, buf);\n\n    if (ret \u003e 0) {\n        b-\u003enum_write += (uint64_t)ret;\n        written = ret;\n        ret = 1;\n    }\n\n    if (b-\u003ecallback != NULL || b-\u003ecallback_ex != NULL)\n        ret = (int)bio_call_callback(b, BIO_CB_PUTS | BIO_CB_RETURN, buf, 0, 0,\n                                     0L, ret, \u0026written);\n\n    if (ret \u003e 0) {\n        if (written \u003e INT_MAX) {\n            BIOerr(BIO_F_BIO_PUTS, BIO_R_LENGTH_TOO_LONG);\n            ret = -1;\n        } else {\n            ret = (int)written;\n        }\n    }\n\n    return ret;\n}","filepath":"crypto/bio/bio_lib.c","line_number":387,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269826976":{"score":0.8497657,"function_name":"BIO_read","code":"int BIO_read(BIO *b, void *data, int dlen)\n{\n    size_t readbytes;\n    int ret;\n\n    if (dlen \u003c 0)\n        return 0;\n\n    ret = bio_read_intern(b, data, (size_t)dlen, \u0026readbytes);\n\n    if (ret \u003e 0) {\n        /* *readbytes should always be \u003c= dlen */\n        ret = (int)readbytes;\n    }\n\n    return ret;\n}","filepath":"crypto/bio/bio_lib.c","line_number":288,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269827088":{"score":0.86008257,"function_name":"BIO_write","code":"int BIO_write(BIO *b, const void *data, int dlen)\n{\n    size_t written;\n    int ret;\n\n    if (dlen \u003c 0)\n        return 0;\n\n    ret = bio_write_intern(b, data, (size_t)dlen, \u0026written);\n\n    if (ret \u003e 0) {\n        /* *written should always be \u003c= dlen */\n        ret = (int)written;\n    }\n\n    return ret;\n}","filepath":"crypto/bio/bio_lib.c","line_number":355,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269827136":{"score":0.85992575,"function_name":"bio_call_callback","code":"static long bio_call_callback(BIO *b, int oper, const char *argp, size_t len,\n                              int argi, long argl, long inret, size_t *processed)\n{\n    long ret;\n    int bareoper;\n\n    if (b-\u003ecallback_ex != NULL)\n        return b-\u003ecallback_ex(b, oper, argp, len, argi, argl, inret, processed);\n\n    /* Strip off any BIO_CB_RETURN flag */\n    bareoper = oper \u0026 ~BIO_CB_RETURN;\n\n    /*\n     * We have an old style callback, so we will have to do nasty casts and\n     * check for overflows.\n     */\n    if (HAS_LEN_OPER(bareoper)) {\n        /* In this case |len| is set, and should be used instead of |argi| */\n        if (len \u003e INT_MAX)\n            return -1;\n\n        argi = (int)len;\n    }\n\n    if (inret \u003e 0 \u0026\u0026 (oper \u0026 BIO_CB_RETURN) \u0026\u0026 bareoper != BIO_CB_CTRL) {\n        if (*processed \u003e INT_MAX)\n            return -1;\n        inret = *processed;\n    }\n\n    ret = b-\u003ecallback(b, oper, argp, argi, argl, inret);\n\n    if (ret \u003e 0 \u0026\u0026 (oper \u0026 BIO_CB_RETURN) \u0026\u0026 bareoper != BIO_CB_CTRL) {\n        *processed = (size_t)ret;\n        ret = 1;\n    }\n\n    return ret;\n}","filepath":"crypto/bio/bio_lib.c","line_number":31,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269827360":{"score":0.87133306,"function_name":"bio_read_intern","code":"static int bio_read_intern(BIO *b, void *data, size_t dlen, size_t *readbytes)\n{\n    int ret;\n\n    if ((b == NULL) || (b-\u003emethod == NULL) || (b-\u003emethod-\u003ebread == NULL)) {\n        BIOerr(BIO_F_BIO_READ_INTERN, BIO_R_UNSUPPORTED_METHOD);\n        return -2;\n    }\n\n    if ((b-\u003ecallback != NULL || b-\u003ecallback_ex != NULL) \u0026\u0026\n        ((ret = (int)bio_call_callback(b, BIO_CB_READ, data, dlen, 0, 0L, 1L,\n                                       NULL)) \u003c= 0))\n        return ret;\n\n    if (!b-\u003einit) {\n        BIOerr(BIO_F_BIO_READ_INTERN, BIO_R_UNINITIALIZED);\n        return -2;\n    }\n\n    ret = b-\u003emethod-\u003ebread(b, data, dlen, readbytes);\n\n    if (ret \u003e 0)\n        b-\u003enum_read += (uint64_t)*readbytes;\n\n    if (b-\u003ecallback != NULL || b-\u003ecallback_ex != NULL)\n        ret = (int)bio_call_callback(b, BIO_CB_READ | BIO_CB_RETURN, data,\n                                     dlen, 0, 0L, ret, readbytes);\n\n    /* Shouldn't happen */\n    if (ret \u003e 0 \u0026\u0026 *readbytes \u003e dlen) {\n        BIOerr(BIO_F_BIO_READ_INTERN, ERR_R_INTERNAL_ERROR);\n        return -1;\n    }\n\n    return ret;\n}","filepath":"crypto/bio/bio_lib.c","line_number":251,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269827680":{"score":0.87537056,"function_name":"bio_write_intern","code":"static int bio_write_intern(BIO *b, const void *data, size_t dlen,\n                            size_t *written)\n{\n    int ret;\n\n    if (b == NULL)\n        return 0;\n\n    if ((b-\u003emethod == NULL) || (b-\u003emethod-\u003ebwrite == NULL)) {\n        BIOerr(BIO_F_BIO_WRITE_INTERN, BIO_R_UNSUPPORTED_METHOD);\n        return -2;\n    }\n\n    if ((b-\u003ecallback != NULL || b-\u003ecallback_ex != NULL) \u0026\u0026\n        ((ret = (int)bio_call_callback(b, BIO_CB_WRITE, data, dlen, 0, 0L, 1L,\n                                       NULL)) \u003c= 0))\n        return ret;\n\n    if (!b-\u003einit) {\n        BIOerr(BIO_F_BIO_WRITE_INTERN, BIO_R_UNINITIALIZED);\n        return -2;\n    }\n\n    ret = b-\u003emethod-\u003ebwrite(b, data, dlen, written);\n\n    if (ret \u003e 0)\n        b-\u003enum_write += (uint64_t)*written;\n\n    if (b-\u003ecallback != NULL || b-\u003ecallback_ex != NULL)\n        ret = (int)bio_call_callback(b, BIO_CB_WRITE | BIO_CB_RETURN, data,\n                                     dlen, 0, 0L, ret, written);\n\n    return ret;\n}","filepath":"crypto/bio/bio_lib.c","line_number":320,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269827952":{"score":0.86115885,"function_name":"mem_write","code":"static int mem_write(BIO *b, const char *in, int inl)\n{\n    int ret = -1;\n    int blen;\n    BIO_BUF_MEM *bbm = (BIO_BUF_MEM *)b-\u003eptr;\n\n    if (in == NULL) {\n        BIOerr(BIO_F_MEM_WRITE, BIO_R_NULL_PARAMETER);\n        goto end;\n    }\n    if (b-\u003eflags \u0026 BIO_FLAGS_MEM_RDONLY) {\n        BIOerr(BIO_F_MEM_WRITE, BIO_R_WRITE_TO_READ_ONLY_BIO);\n        goto end;\n    }\n    BIO_clear_retry_flags(b);\n    if (inl == 0)\n        return 0;\n    blen = bbm-\u003ereadp-\u003elength;\n    mem_buf_sync(b);\n    if (BUF_MEM_grow_clean(bbm-\u003ebuf, blen + inl) == 0)\n        goto end;\n    memcpy(bbm-\u003ebuf-\u003edata + blen, in, inl);\n    *bbm-\u003ereadp = *bbm-\u003ebuf;\n    ret = inl;\n end:\n    return ret;\n}","filepath":"crypto/bio/bss_mem.c","line_number":217,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1d"},"269828688":{"score":0.8989079,"function_name":"mem_ctrl","code":"static long mem_ctrl(BIO *b, int cmd, long num, void *ptr)\n{\n    long ret = 1;\n    char **pptr;\n    BIO_BUF_MEM *bbm = (BIO_BUF_MEM *)b-\u003eptr;\n    BUF_MEM *bm;\n\n    if (b-\u003eflags \u0026 BIO_FLAGS_MEM_RDONLY)\n        bm = bbm-\u003ebuf;\n    else\n        bm = bbm-\u003ereadp;\n\n    switch (cmd) {\n    case BIO_CTRL_RESET:\n        bm = bbm-\u003ebuf;\n        if (bm-\u003edata != NULL) {\n            if (!(b-\u003eflags \u0026 BIO_FLAGS_MEM_RDONLY)) {\n                if (!(b-\u003eflags \u0026 BIO_FLAGS_NONCLEAR_RST)) {\n                    memset(bm-\u003edata, 0, bm-\u003emax);\n                    bm-\u003elength = 0;\n                }\n                *bbm-\u003ereadp = *bbm-\u003ebuf;\n            } else {\n                /* For read only case just reset to the start again */\n                *bbm-\u003ebuf = *bbm-\u003ereadp;\n            }\n        }\n        break;\n    case BIO_CTRL_EOF:\n        ret = (long)(bm-\u003elength == 0);\n        break;\n    case BIO_C_SET_BUF_MEM_EOF_RETURN:\n        b-\u003enum = (int)num;\n        break;\n    case BIO_CTRL_INFO:\n        ret = (long)bm-\u003elength;\n        if (ptr != NULL) {\n            pptr = (char **)ptr;\n            *pptr = (char *)\u0026(bm-\u003edata[0]);\n        }\n        break;\n    case BIO_C_SET_BUF_MEM:\n        mem_buf_free(b);\n        b-\u003eshutdown = (int)num;\n        bbm-\u003ebuf = ptr;\n        *bbm-\u003ereadp = *bbm-\u003ebuf;\n        break;\n    case BIO_C_GET_BUF_MEM_PTR:\n        if (ptr != NULL) {\n            if (!(b-\u003eflags \u0026 BIO_FLAGS_MEM_RDONLY))\n                mem_buf_sync(b);\n            bm = bbm-\u003ebuf;\n            pptr = (char **)ptr;\n            *pptr = (char *)bm;\n        }\n        break;\n    case BIO_CTRL_GET_CLOSE:\n        ret = (long)b-\u003eshutdown;\n        break;\n    case BIO_CTRL_SET_CLOSE:\n        b-\u003eshutdown = (int)num;\n        break;\n    case BIO_CTRL_WPENDING:\n        ret = 0L;\n        break;\n    case BIO_CTRL_PENDING:\n        ret = (long)bm-\u003elength;\n        break;\n    case BIO_CTRL_DUP:\n    case BIO_CTRL_FLUSH:\n        ret = 1;\n        break;\n    case BIO_CTRL_PUSH:\n    case BIO_CTRL_POP:\n    default:\n        ret = 0;\n        break;\n    }\n    return ret;\n}","filepath":"crypto/bio/bss_mem.c","line_number":245,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1d"},"269829328":{"score":0.893622,"function_name":"BIO_new_mem_buf","code":"BIO *BIO_new_mem_buf(const void *buf, int len)\n{\n    BIO *ret;\n    BUF_MEM *b;\n    BIO_BUF_MEM *bb;\n    size_t sz;\n\n    if (buf == NULL) {\n        BIOerr(BIO_F_BIO_NEW_MEM_BUF, BIO_R_NULL_PARAMETER);\n        return NULL;\n    }\n    sz = (len \u003c 0) ? strlen(buf) : (size_t)len;\n    if ((ret = BIO_new(BIO_s_mem())) == NULL)\n        return NULL;\n    bb = (BIO_BUF_MEM *)ret-\u003eptr;\n    b = bb-\u003ebuf;\n    /* Cast away const and trust in the MEM_RDONLY flag. */\n    b-\u003edata = (void *)buf;\n    b-\u003elength = sz;\n    b-\u003emax = sz;\n    *bb-\u003ereadp = *bb-\u003ebuf;\n    ret-\u003eflags |= BIO_FLAGS_MEM_RDONLY;\n    /* Since this is static data retrying won't help */\n    ret-\u003enum = 0;\n    return ret;\n}","filepath":"crypto/bio/bss_mem.c","line_number":86,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1d"},"269829488":{"score":0.93198174,"function_name":"mem_buf_free","code":"static int mem_buf_free(BIO *a)\n{\n    if (a == NULL)\n        return 0;\n\n    if (a-\u003eshutdown \u0026\u0026 a-\u003einit \u0026\u0026 a-\u003eptr != NULL) {\n        BIO_BUF_MEM *bb = (BIO_BUF_MEM *)a-\u003eptr;\n        BUF_MEM *b = bb-\u003ebuf;\n\n        if (a-\u003eflags \u0026 BIO_FLAGS_MEM_RDONLY)\n            b-\u003edata = NULL;\n        BUF_MEM_free(b);\n    }\n    return 1;\n}","filepath":"crypto/bio/bss_mem.c","line_number":161,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1d"},"269829552":{"score":0.9232449,"function_name":"mem_buf_sync","code":"static int mem_buf_sync(BIO *b)\n{\n    if (b != NULL \u0026\u0026 b-\u003einit != 0 \u0026\u0026 b-\u003eptr != NULL) {\n        BIO_BUF_MEM *bbm = (BIO_BUF_MEM *)b-\u003eptr;\n\n        if (bbm-\u003ereadp-\u003edata != bbm-\u003ebuf-\u003edata) {\n            memmove(bbm-\u003ebuf-\u003edata, bbm-\u003ereadp-\u003edata, bbm-\u003ereadp-\u003elength);\n            bbm-\u003ebuf-\u003elength = bbm-\u003ereadp-\u003elength;\n            bbm-\u003ereadp-\u003edata = bbm-\u003ebuf-\u003edata;\n        }\n    }\n    return 0;\n}","filepath":"crypto/bio/bss_mem.c","line_number":180,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1d"},"269829632":{"score":0.9248439,"function_name":"mem_init","code":"static int mem_init(BIO *bi, unsigned long flags)\n{\n    BIO_BUF_MEM *bb = OPENSSL_zalloc(sizeof(*bb));\n\n    if (bb == NULL)\n        return 0;\n    if ((bb-\u003ebuf = BUF_MEM_new_ex(flags)) == NULL) {\n        OPENSSL_free(bb);\n        return 0;\n    }\n    if ((bb-\u003ereadp = OPENSSL_zalloc(sizeof(*bb-\u003ereadp))) == NULL) {\n        BUF_MEM_free(bb-\u003ebuf);\n        OPENSSL_free(bb);\n        return 0;\n    }\n    *bb-\u003ereadp = *bb-\u003ebuf;\n    bi-\u003eshutdown = 1;\n    bi-\u003einit = 1;\n    bi-\u003enum = -1;\n    bi-\u003eptr = (char *)bb;\n    return 1;\n}","filepath":"crypto/bio/bss_mem.c","line_number":113,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1d"},"269835760":{"score":0.9498866,"function_name":"CRYPTO_THREAD_get_local","code":"void *CRYPTO_THREAD_get_local(CRYPTO_THREAD_LOCAL *key)\n{\n    DWORD last_error;\n    void *ret;\n\n    /*\n     * TlsGetValue clears the last error even on success, so that callers may\n     * distinguish it successfully returning NULL or failing. It is documented\n     * to never fail if the argument is a valid index from TlsAlloc, so we do\n     * not need to handle this.\n     *\n     * However, this error-mangling behavior interferes with the caller's use of\n     * GetLastError. In particular SSL_get_error queries the error queue to\n     * determine whether the caller should look at the OS's errors. To avoid\n     * destroying state, save and restore the Windows error.\n     *\n     * https://msdn.microsoft.com/en-us/library/windows/desktop/ms686812(v=vs.85).aspx\n     */\n    last_error = GetLastError();\n    ret = TlsGetValue(*key);\n    SetLastError(last_error);\n    return ret;\n}","filepath":"libs-ext/openssl/crypto/threads_win.c","line_number":106,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269835840":{"score":0.79666626,"function_name":"CRYPTO_THREAD_lock_free","code":"void CRYPTO_THREAD_lock_free(CRYPTO_RWLOCK *lock)\n{\n    if (lock == NULL)\n        return;\n\n    DeleteCriticalSection(lock);\n    OPENSSL_free(lock);\n\n    return;\n}","filepath":"libs-ext/openssl/crypto/threads_win.c","line_number":58,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269835888":{"score":0.8926017,"function_name":"CRYPTO_THREAD_lock_new","code":"CRYPTO_RWLOCK *CRYPTO_THREAD_lock_new(void)\n{\n    CRYPTO_RWLOCK *lock;\n\n    if ((lock = OPENSSL_zalloc(sizeof(CRITICAL_SECTION))) == NULL) {\n        /* Don't set error, to avoid recursion blowup. */\n        return NULL;\n    }\n\n# if !defined(_WIN32_WCE)\n    /* 0x400 is the spin count value suggested in the documentation */\n    if (!InitializeCriticalSectionAndSpinCount(lock, 0x400)) {\n        OPENSSL_free(lock);\n        return NULL;\n    }\n# else\n    InitializeCriticalSection(lock);\n# endif\n\n    return lock;\n}","filepath":"libs-ext/openssl/crypto/threads_win.c","line_number":18,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269835968":{"score":0.910454,"function_name":"CRYPTO_THREAD_run_once","code":"int CRYPTO_THREAD_run_once(CRYPTO_ONCE *once, void (*init)(void))\n{\n    LONG volatile *lock = (LONG *)once;\n    LONG result;\n\n    if (*lock == ONCE_DONE)\n        return 1;\n\n    do {\n        result = InterlockedCompareExchange(lock, ONCE_ININIT, ONCE_UNINITED);\n        if (result == ONCE_UNINITED) {\n            init();\n            *lock = ONCE_DONE;\n            return 1;\n        }\n    } while (result == ONCE_ININIT);\n\n    return (*lock == ONCE_DONE);\n}","filepath":"libs-ext/openssl/crypto/threads_win.c","line_number":77,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269836128":{"score":0.83333427,"function_name":"CRYPTO_dup_ex_data","code":"int CRYPTO_dup_ex_data(int class_index, CRYPTO_EX_DATA *to,\n                       const CRYPTO_EX_DATA *from)\n{\n    int mx, j, i;\n    char *ptr;\n    EX_CALLBACK *stack[10];\n    EX_CALLBACK **storage = NULL;\n    EX_CALLBACKS *ip;\n\n    if (from-\u003esk == NULL)\n        /* Nothing to copy over */\n        return 1;\n    if ((ip = get_and_lock(class_index)) == NULL)\n        return 0;\n\n    mx = sk_EX_CALLBACK_num(ip-\u003emeth);\n    j = sk_void_num(from-\u003esk);\n    if (j \u003c mx)\n        mx = j;\n    if (mx \u003e 0) {\n        if (mx \u003c (int)OSSL_NELEM(stack))\n            storage = stack;\n        else\n            storage = OPENSSL_malloc(sizeof(*storage) * mx);\n        if (storage != NULL)\n            for (i = 0; i \u003c mx; i++)\n                storage[i] = sk_EX_CALLBACK_value(ip-\u003emeth, i);\n    }\n    CRYPTO_THREAD_unlock(ex_data_lock);\n\n    if (mx \u003e 0 \u0026\u0026 storage == NULL) {\n        CRYPTOerr(CRYPTO_F_CRYPTO_DUP_EX_DATA, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n\n    for (i = 0; i \u003c mx; i++) {\n        ptr = CRYPTO_get_ex_data(from, i);\n        if (storage[i] \u0026\u0026 storage[i]-\u003edup_func)\n            storage[i]-\u003edup_func(to, from, \u0026ptr, i,\n                                 storage[i]-\u003eargl, storage[i]-\u003eargp);\n        CRYPTO_set_ex_data(to, i, ptr);\n    }\n    if (storage != stack)\n        OPENSSL_free(storage);\n    return 1;\n}","filepath":"crypto/ex_data.c","line_number":253,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0e"},"269836640":{"score":0.91971016,"function_name":"CRYPTO_free_ex_data","code":"void CRYPTO_free_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)\n{\n    int mx, i;\n    EX_CALLBACKS *ip;\n    void *ptr;\n    EX_CALLBACK *f;\n    EX_CALLBACK *stack[10];\n    EX_CALLBACK **storage = NULL;\n\n    if ((ip = get_and_lock(class_index)) == NULL)\n        goto err;\n\n    mx = sk_EX_CALLBACK_num(ip-\u003emeth);\n    if (mx \u003e 0) {\n        if (mx \u003c (int)OSSL_NELEM(stack))\n            storage = stack;\n        else\n            storage = OPENSSL_malloc(sizeof(*storage) * mx);\n        if (storage != NULL)\n            for (i = 0; i \u003c mx; i++)\n                storage[i] = sk_EX_CALLBACK_value(ip-\u003emeth, i);\n    }\n    CRYPTO_THREAD_unlock(ex_data_lock);\n\n    for (i = 0; i \u003c mx; i++) {\n        if (storage != NULL)\n            f = storage[i];\n        else {\n            CRYPTO_THREAD_write_lock(ex_data_lock);\n            f = sk_EX_CALLBACK_value(ip-\u003emeth, i);\n            CRYPTO_THREAD_unlock(ex_data_lock);\n        }\n        if (f != NULL \u0026\u0026 f-\u003efree_func != NULL) {\n            ptr = CRYPTO_get_ex_data(ad, i);\n            f-\u003efree_func(obj, ptr, ad, i, f-\u003eargl, f-\u003eargp);\n        }\n    }\n\n    if (storage != stack)\n        OPENSSL_free(storage);\n err:\n    sk_void_free(ad-\u003esk);\n    ad-\u003esk = NULL;\n}","filepath":"crypto/ex_data.c","line_number":305,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0e"},"269837088":{"score":0.850397,"function_name":"CRYPTO_get_ex_new_index","code":"int CRYPTO_get_ex_new_index(int class_index, long argl, void *argp,\n                            CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,\n                            CRYPTO_EX_free *free_func)\n{\n    int toret = -1;\n    EX_CALLBACK *a;\n    EX_CALLBACKS *ip = get_and_lock(class_index);\n\n    if (ip == NULL)\n        return -1;\n\n    if (ip-\u003emeth == NULL) {\n        ip-\u003emeth = sk_EX_CALLBACK_new_null();\n        /* We push an initial value on the stack because the SSL\n         * \"app_data\" routines use ex_data index zero.  See RT 3710. */\n        if (ip-\u003emeth == NULL\n            || !sk_EX_CALLBACK_push(ip-\u003emeth, NULL)) {\n            CRYPTOerr(CRYPTO_F_CRYPTO_GET_EX_NEW_INDEX, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n    }\n\n    a = (EX_CALLBACK *)OPENSSL_malloc(sizeof(*a));\n    if (a == NULL) {\n        CRYPTOerr(CRYPTO_F_CRYPTO_GET_EX_NEW_INDEX, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    a-\u003eargl = argl;\n    a-\u003eargp = argp;\n    a-\u003enew_func = new_func;\n    a-\u003edup_func = dup_func;\n    a-\u003efree_func = free_func;\n\n    if (!sk_EX_CALLBACK_push(ip-\u003emeth, NULL)) {\n        CRYPTOerr(CRYPTO_F_CRYPTO_GET_EX_NEW_INDEX, ERR_R_MALLOC_FAILURE);\n        OPENSSL_free(a);\n        goto err;\n    }\n    toret = sk_EX_CALLBACK_num(ip-\u003emeth) - 1;\n    (void)sk_EX_CALLBACK_set(ip-\u003emeth, toret, a);\n\n err:\n    CRYPTO_THREAD_unlock(ex_data_lock);\n    return toret;\n}","filepath":"crypto/ex_data.c","line_number":155,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0e"},"269837424":{"score":0.80130285,"function_name":"CRYPTO_new_ex_data","code":"int CRYPTO_new_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)\n{\n    int mx, i;\n    void *ptr;\n    EX_CALLBACK **storage = NULL;\n    EX_CALLBACK *stack[10];\n    EX_CALLBACKS *ip = get_and_lock(class_index);\n\n    if (ip == NULL)\n        return 0;\n\n    ad-\u003esk = NULL;\n\n    mx = sk_EX_CALLBACK_num(ip-\u003emeth);\n    if (mx \u003e 0) {\n        if (mx \u003c (int)OSSL_NELEM(stack))\n            storage = stack;\n        else\n            storage = OPENSSL_malloc(sizeof(*storage) * mx);\n        if (storage != NULL)\n            for (i = 0; i \u003c mx; i++)\n                storage[i] = sk_EX_CALLBACK_value(ip-\u003emeth, i);\n    }\n    CRYPTO_THREAD_unlock(ex_data_lock);\n\n    if (mx \u003e 0 \u0026\u0026 storage == NULL) {\n        CRYPTOerr(CRYPTO_F_CRYPTO_NEW_EX_DATA, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n    for (i = 0; i \u003c mx; i++) {\n        if (storage[i] \u0026\u0026 storage[i]-\u003enew_func) {\n            ptr = CRYPTO_get_ex_data(ad, i);\n            storage[i]-\u003enew_func(obj, ptr, ad, i,\n                                 storage[i]-\u003eargl, storage[i]-\u003eargp);\n        }\n    }\n    if (storage != stack)\n        OPENSSL_free(storage);\n    return 1;\n}","filepath":"crypto/ex_data.c","line_number":208,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0e"},"269837824":{"score":0.91316915,"function_name":"CRYPTO_set_ex_data","code":"int CRYPTO_set_ex_data(CRYPTO_EX_DATA *ad, int idx, void *val)\n{\n    int i;\n\n    if (ad-\u003esk == NULL) {\n        if ((ad-\u003esk = sk_void_new_null()) == NULL) {\n            CRYPTOerr(CRYPTO_F_CRYPTO_SET_EX_DATA, ERR_R_MALLOC_FAILURE);\n            return 0;\n        }\n    }\n\n    for (i = sk_void_num(ad-\u003esk); i \u003c= idx; ++i) {\n        if (!sk_void_push(ad-\u003esk, NULL)) {\n            CRYPTOerr(CRYPTO_F_CRYPTO_SET_EX_DATA, ERR_R_MALLOC_FAILURE);\n            return 0;\n        }\n    }\n    sk_void_set(ad-\u003esk, idx, val);\n    return 1;\n}","filepath":"crypto/ex_data.c","line_number":354,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0e"},"269838016":{"score":0.8701729,"function_name":"crypto_cleanup_all_ex_data_int","code":"void crypto_cleanup_all_ex_data_int(void)\n{\n    int i;\n\n    for (i = 0; i \u003c CRYPTO_EX_INDEX__COUNT; ++i) {\n        EX_CALLBACKS *ip = \u0026ex_data[i];\n\n        sk_EX_CALLBACK_pop_free(ip-\u003emeth, cleanup_cb);\n        ip-\u003emeth = NULL;\n    }\n\n    CRYPTO_THREAD_lock_free(ex_data_lock);\n    ex_data_lock = NULL;\n}","filepath":"crypto/ex_data.c","line_number":93,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0e"},"269838144":{"score":0.87364507,"function_name":"get_and_lock","code":"static EX_CALLBACKS *get_and_lock(int class_index)\n{\n    EX_CALLBACKS *ip;\n\n    if (class_index \u003c 0 || class_index \u003e= CRYPTO_EX_INDEX__COUNT) {\n        CRYPTOerr(CRYPTO_F_GET_AND_LOCK, ERR_R_PASSED_INVALID_ARGUMENT);\n        return NULL;\n    }\n\n    if (!RUN_ONCE(\u0026ex_data_init, do_ex_data_init)) {\n        CRYPTOerr(CRYPTO_F_GET_AND_LOCK, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    if (ex_data_lock == NULL) {\n        /*\n         * This can happen in normal operation when using CRYPTO_mem_leaks().\n         * The CRYPTO_mem_leaks() function calls OPENSSL_cleanup() which cleans\n         * up the locks. Subsequently the BIO that CRYPTO_mem_leaks() uses gets\n         * freed, which also attempts to free the ex_data. However\n         * CRYPTO_mem_leaks() ensures that the ex_data is freed early (i.e.\n         * before OPENSSL_cleanup() is called), so if we get here we can safely\n         * ignore this operation. We just treat it as an error.\n         */\n         return NULL;\n    }\n\n    ip = \u0026ex_data[class_index];\n    CRYPTO_THREAD_write_lock(ex_data_lock);\n    return ip;\n}","filepath":"crypto/ex_data.c","line_number":50,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0e"},"269838272":{"score":0.6969991,"function_name":"CRYPTO_malloc","code":"void *CRYPTO_malloc(size_t num, const char *file, int line)\n{\n    void *ret = NULL;\n\n    if (malloc_impl != NULL \u0026\u0026 malloc_impl != CRYPTO_malloc)\n        return malloc_impl(num, file, line);\n\n    if (num \u003c= 0)\n        return NULL;\n\n    allow_customize = 0;\n#ifndef OPENSSL_NO_CRYPTO_MDEBUG\n    if (call_malloc_debug) {\n        CRYPTO_mem_debug_malloc(NULL, num, 0, file, line);\n        ret = malloc(num);\n        CRYPTO_mem_debug_malloc(ret, num, 1, file, line);\n    } else {\n        ret = malloc(num);\n    }\n#else\n    osslargused(file); osslargused(line);\n    ret = malloc(num);\n#endif\n\n    return ret;\n}","filepath":"crypto/mem.c","line_number":71,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre6"},"269838320":{"score":0.76399755,"function_name":"CRYPTO_free","code":"void CRYPTO_free(void *str, const char *file, int line)\n{\n    if (free_impl != NULL \u0026\u0026 free_impl != \u0026CRYPTO_free) {\n        free_impl(str, file, line);\n        return;\n    }\n\n#ifndef OPENSSL_NO_CRYPTO_MDEBUG\n    if (call_malloc_debug) {\n        CRYPTO_mem_debug_free(str, 0, file, line);\n        free(str);\n        CRYPTO_mem_debug_free(str, 1, file, line);\n    } else {\n        free(str);\n    }\n#else\n    free(str);\n#endif\n}","filepath":"crypto/mem.c","line_number":163,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre6"},"269838352":{"score":0.8868838,"function_name":"CRYPTO_realloc","code":"void *CRYPTO_realloc(void *str, size_t num, const char *file, int line)\n{\n    if (realloc_impl != NULL \u0026\u0026 realloc_impl != \u0026CRYPTO_realloc)\n        return realloc_impl(str, num, file, line);\n\n    if (str == NULL)\n        return CRYPTO_malloc(num, file, line);\n\n    if (num == 0) {\n        CRYPTO_free(str, file, line);\n        return NULL;\n    }\n\n    allow_customize = 0;\n#ifndef OPENSSL_NO_CRYPTO_MDEBUG\n    if (call_malloc_debug) {\n        void *ret;\n        CRYPTO_mem_debug_realloc(str, NULL, num, 0, file, line);\n        ret = realloc(str, num);\n        CRYPTO_mem_debug_realloc(str, ret, num, 1, file, line);\n        return ret;\n    }\n#else\n    osslargused(file); osslargused(line);\n#endif\n    return realloc(str, num);\n\n}","filepath":"crypto/mem.c","line_number":107,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre6"},"269838512":{"score":0.6211964,"function_name":"CRYPTO_clear_free","code":"void CRYPTO_clear_free(void *str, size_t num, const char *file, int line)\n{\n    if (str == NULL)\n        return;\n    if (num)\n        OPENSSL_cleanse(str, num);\n    CRYPTO_free(str, file, line);\n}","filepath":"crypto/mem.c","line_number":183,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre6"},"269838592":{"score":0.83649695,"function_name":"CRYPTO_clear_realloc","code":"void *CRYPTO_clear_realloc(void *str, size_t old_len, size_t num,\n                           const char *file, int line)\n{\n    void *ret = NULL;\n\n    if (str == NULL)\n        return CRYPTO_malloc(num, file, line);\n\n    if (num == 0) {\n        CRYPTO_clear_free(str, old_len, file, line);\n        return NULL;\n    }\n\n    /* Can't shrink the buffer since memcpy below copies |old_len| bytes. */\n    if (num \u003c old_len) {\n        OPENSSL_cleanse((char*)str + num, old_len - num);\n        return str;\n    }\n\n    ret = CRYPTO_malloc(num, file, line);\n    if (ret != NULL) {\n        memcpy(ret, str, old_len);\n        CRYPTO_clear_free(str, old_len, file, line);\n    }\n    return ret;\n}","filepath":"crypto/mem.c","line_number":136,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre6"},"269838784":{"score":0.8757934,"function_name":"CRYPTO_get_mem_functions","code":"void CRYPTO_get_mem_functions(\n        void *(**m)(size_t, const char *, int),\n        void *(**r)(void *, size_t, const char *, int),\n        void (**f)(void *, const char *, int))\n{\n    if (m != NULL)\n        *m = malloc_impl;\n    if (r != NULL)\n        *r = realloc_impl;\n    if (f != NULL)\n        *f = free_impl;\n}","filepath":"crypto/mem.c","line_number":58,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre6"},"269838928":{"score":0.70416594,"function_name":"ERR_STATE_free","code":"static void ERR_STATE_free(ERR_STATE *s)\n{\n    int i;\n\n    if (s == NULL)\n        return;\n    for (i = 0; i \u003c ERR_NUM_ERRORS; i++) {\n        err_clear_data(s, i);\n    }\n    OPENSSL_free(s);\n}","filepath":"crypto/err/err.c","line_number":289,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1o"},"269839312":{"score":0.8049283,"function_name":"ERR_clear_error","code":"void ERR_clear_error(void)\n{\n    int i;\n    ERR_STATE *es;\n\n    es = ERR_get_state();\n    if (es == NULL)\n        return;\n\n    for (i = 0; i \u003c ERR_NUM_ERRORS; i++) {\n        err_clear(es, i);\n    }\n    es-\u003etop = es-\u003ebottom = 0;\n}","filepath":"crypto/err/err.c","line_number":460,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1o"},"269839456":{"score":0.8168553,"function_name":"ERR_error_string_n","code":"void ERR_error_string_n(unsigned long e, char *buf, size_t len)\n{\n    char lsbuf[64], fsbuf[64], rsbuf[64];\n    const char *ls, *fs, *rs;\n    unsigned long l, f, r;\n\n    if (len == 0)\n        return;\n\n    l = ERR_GET_LIB(e);\n    ls = ERR_lib_error_string(e);\n    if (ls == NULL) {\n        BIO_snprintf(lsbuf, sizeof(lsbuf), \"lib(%lu)\", l);\n        ls = lsbuf;\n    }\n\n    fs = ERR_func_error_string(e);\n    f = ERR_GET_FUNC(e);\n    if (fs == NULL) {\n        BIO_snprintf(fsbuf, sizeof(fsbuf), \"func(%lu)\", f);\n        fs = fsbuf;\n    }\n\n    rs = ERR_reason_error_string(e);\n    r = ERR_GET_REASON(e);\n    if (rs == NULL) {\n        BIO_snprintf(rsbuf, sizeof(rsbuf), \"reason(%lu)\", r);\n        rs = rsbuf;\n    }\n\n    BIO_snprintf(buf, len, \"error:%08lX:%s:%s:%s\", e, ls, fs, rs);\n    if (strlen(buf) == len - 1) {\n        /* Didn't fit; use a minimal format. */\n        BIO_snprintf(buf, len, \"err:%lx:%lx:%lx:%lx\", e, l, f, r);\n    }\n}","filepath":"crypto/err/err.c","line_number":605,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1o"},"269840112":{"score":0.64833677,"function_name":"ERR_lib_error_string","code":"const char *ERR_lib_error_string(unsigned long e)\n{\n#ifndef OPENSSL_NO_ERR\n    ERR_STRING_DATA d, *p;\n    unsigned long l;\n\n    if (!RUN_ONCE(\u0026err_string_init, do_err_strings_init)) {\n        return NULL;\n    }\n\n    l = ERR_GET_LIB(e);\n    d.error = ERR_PACK(l, 0, 0);\n    p = int_err_get_item(\u0026d);\n    return ((p == NULL) ? NULL : p-\u003estring);\n#else\n    return NULL;\n#endif\n}","filepath":"crypto/err/err.c","line_number":656,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1o"},"269840288":{"score":0.814284,"function_name":"ERR_get_state","code":"ERR_STATE *ERR_get_state(void)\n{\n    ERR_STATE *state;\n    int saveerrno = get_last_sys_error();\n\n    if (!OPENSSL_init_crypto(OPENSSL_INIT_BASE_ONLY, NULL))\n        return NULL;\n\n    if (!RUN_ONCE(\u0026err_init, err_do_init))\n        return NULL;\n\n    state = CRYPTO_THREAD_get_local(\u0026err_thread_local);\n    if (state == (ERR_STATE*)-1)\n        return NULL;\n\n    if (state == NULL) {\n        if (!CRYPTO_THREAD_set_local(\u0026err_thread_local, (ERR_STATE*)-1))\n            return NULL;\n\n        if ((state = OPENSSL_zalloc(sizeof(*state))) == NULL) {\n            CRYPTO_THREAD_set_local(\u0026err_thread_local, NULL);\n            return NULL;\n        }\n\n        if (!ossl_init_thread_start(OPENSSL_INIT_THREAD_ERR_STATE)\n                || !CRYPTO_THREAD_set_local(\u0026err_thread_local, state)) {\n            ERR_STATE_free(state);\n            CRYPTO_THREAD_set_local(\u0026err_thread_local, NULL);\n            return NULL;\n        }\n\n        /* Ignore failures from these */\n        OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL);\n    }\n\n    set_sys_error(saveerrno);\n    return state;\n}","filepath":"crypto/err/err.c","line_number":747,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1o"},"269840528":{"score":0.6832867,"function_name":"ERR_load_ERR_strings","code":"int ERR_load_ERR_strings(void)\n{\n#ifndef OPENSSL_NO_ERR\n    if (!RUN_ONCE(\u0026err_string_init, do_err_strings_init))\n        return 0;\n\n    err_load_strings(ERR_str_libraries);\n    err_load_strings(ERR_str_reasons);\n    err_patch(ERR_LIB_SYS, ERR_str_functs);\n    err_load_strings(ERR_str_functs);\n    build_SYS_str_reasons();\n#endif\n    return 1;\n}","filepath":"crypto/err/err.c","line_number":358,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1o"},"269840944":{"score":0.7604772,"function_name":"ERR_load_strings_const","code":"int ERR_load_strings_const(const ERR_STRING_DATA *str)\n{\n#ifndef OPENSSL_NO_ERR\n    if (ERR_load_ERR_strings() == 0)\n        return 0;\n    err_load_strings(str);\n#endif\n\n    return 1;\n}","filepath":"crypto/err/err.c","line_number":386,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1o"},"269841040":{"score":0.8383646,"function_name":"ERR_pop_to_mark","code":"int ERR_pop_to_mark(void)\n{\n    ERR_STATE *es;\n\n    es = ERR_get_state();\n    if (es == NULL)\n        return 0;\n\n    while (es-\u003ebottom != es-\u003etop\n           \u0026\u0026 (es-\u003eerr_flags[es-\u003etop] \u0026 ERR_FLAG_MARK) == 0) {\n        err_clear(es, es-\u003etop);\n        es-\u003etop = es-\u003etop \u003e 0 ? es-\u003etop - 1 : ERR_NUM_ERRORS - 1;\n    }\n\n    if (es-\u003ebottom == es-\u003etop)\n        return 0;\n    es-\u003eerr_flags[es-\u003etop] \u0026= ~ERR_FLAG_MARK;\n    return 1;\n}","filepath":"crypto/err/err.c","line_number":925,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1o"},"269841280":{"score":0.764898,"function_name":"ERR_put_error","code":"void ERR_put_error(int lib, int func, int reason, const char *file, int line)\n{\n    ERR_STATE *es;\n\n#ifdef _OSD_POSIX\n    /*\n     * In the BS2000-OSD POSIX subsystem, the compiler generates path names\n     * in the form \"*POSIX(/etc/passwd)\". This dirty hack strips them to\n     * something sensible. @@@ We shouldn't modify a const string, though.\n     */\n    if (strncmp(file, \"*POSIX(\", sizeof(\"*POSIX(\") - 1) == 0) {\n        char *end;\n\n        /* Skip the \"*POSIX(\" prefix */\n        file += sizeof(\"*POSIX(\") - 1;\n        end = \u0026file[strlen(file) - 1];\n        if (*end == ')')\n            *end = '\\0';\n        /* Optional: use the basename of the path only. */\n        if ((end = strrchr(file, '/')) != NULL)\n            file = \u0026end[1];\n    }\n#endif\n    es = ERR_get_state();\n    if (es == NULL)\n        return;\n\n    es-\u003etop = (es-\u003etop + 1) % ERR_NUM_ERRORS;\n    if (es-\u003etop == es-\u003ebottom)\n        es-\u003ebottom = (es-\u003ebottom + 1) % ERR_NUM_ERRORS;\n    es-\u003eerr_flags[es-\u003etop] = 0;\n    es-\u003eerr_buffer[es-\u003etop] = ERR_PACK(lib, func, reason);\n    es-\u003eerr_file[es-\u003etop] = file;\n    es-\u003eerr_line[es-\u003etop] = line;\n    err_clear_data(es, es-\u003etop);\n}","filepath":"crypto/err/err.c","line_number":423,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1o"},"269841520":{"score":0.9472923,"function_name":"ERR_set_mark","code":"int ERR_set_mark(void)\n{\n    ERR_STATE *es;\n\n    es = ERR_get_state();\n    if (es == NULL)\n        return 0;\n\n    if (es-\u003ebottom == es-\u003etop)\n        return 0;\n    es-\u003eerr_flags[es-\u003etop] |= ERR_FLAG_MARK;\n    return 1;\n}","filepath":"crypto/err/err.c","line_number":911,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1o"},"269841680":{"score":0.907772,"function_name":"err_cleanup","code":"void err_cleanup(void)\n{\n    if (set_err_thread_local != 0)\n        CRYPTO_THREAD_cleanup_local(\u0026err_thread_local);\n    CRYPTO_THREAD_lock_free(err_string_lock);\n    err_string_lock = NULL;\n#ifndef OPENSSL_NO_ERR\n    lh_ERR_STRING_DATA_free(int_error_hash);\n    int_error_hash = NULL;\n#endif\n}","filepath":"crypto/err/err.c","line_number":320,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1o"},"269841760":{"score":0.78044844,"function_name":"err_clear_last_constant_time","code":"void err_clear_last_constant_time(int clear)\n{\n    ERR_STATE *es;\n    int top;\n\n    es = ERR_get_state();\n    if (es == NULL)\n        return;\n\n    top = es-\u003etop;\n\n    /*\n     * Flag error as cleared but remove it elsewhere to avoid two errors\n     * accessing the same error stack location, revealing timing information.\n     */\n    clear = constant_time_select_int(constant_time_eq_int(clear, 0),\n                                     0, ERR_FLAG_CLEAR);\n    es-\u003eerr_flags[top] |= clear;\n}","filepath":"crypto/err/err.c","line_number":966,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1o"},"269841840":{"score":0.8523449,"function_name":"err_delete_thread_state","code":"void err_delete_thread_state(void)\n{\n    ERR_STATE *state = CRYPTO_THREAD_get_local(\u0026err_thread_local);\n    if (state == NULL)\n        return;\n\n    CRYPTO_THREAD_set_local(\u0026err_thread_local, NULL);\n    ERR_STATE_free(state);\n}","filepath":"crypto/err/err.c","line_number":719,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1o"},"269841952":{"score":0.88662523,"function_name":"err_load_strings","code":"static int err_load_strings(const ERR_STRING_DATA *str)\n{\n    CRYPTO_THREAD_write_lock(err_string_lock);\n    for (; str-\u003eerror; str++)\n        (void)lh_ERR_STRING_DATA_insert(int_error_hash,\n                                       (ERR_STRING_DATA *)str);\n    CRYPTO_THREAD_unlock(err_string_lock);\n    return 1;\n}","filepath":"crypto/err/err.c","line_number":347,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1o"},"269842128":{"score":0.89146835,"function_name":"get_error_values","code":"static unsigned long get_error_values(int inc, int top, const char **file,\n                                      int *line, const char **data,\n                                      int *flags)\n{\n    int i = 0;\n    ERR_STATE *es;\n    unsigned long ret;\n\n    es = ERR_get_state();\n    if (es == NULL)\n        return 0;\n\n    if (inc \u0026\u0026 top) {\n        if (file)\n            *file = \"\";\n        if (line)\n            *line = 0;\n        if (data)\n            *data = \"\";\n        if (flags)\n            *flags = 0;\n\n        return ERR_R_INTERNAL_ERROR;\n    }\n\n    while (es-\u003ebottom != es-\u003etop) {\n        if (es-\u003eerr_flags[es-\u003etop] \u0026 ERR_FLAG_CLEAR) {\n            err_clear(es, es-\u003etop);\n            es-\u003etop = es-\u003etop \u003e 0 ? es-\u003etop - 1 : ERR_NUM_ERRORS - 1;\n            continue;\n        }\n        i = (es-\u003ebottom + 1) % ERR_NUM_ERRORS;\n        if (es-\u003eerr_flags[i] \u0026 ERR_FLAG_CLEAR) {\n            es-\u003ebottom = i;\n            err_clear(es, es-\u003ebottom);\n            continue;\n        }\n        break;\n    }\n\n    if (es-\u003ebottom == es-\u003etop)\n        return 0;\n\n    if (top)\n        i = es-\u003etop;            /* last error */\n    else\n        i = (es-\u003ebottom + 1) % ERR_NUM_ERRORS; /* first error */\n\n    ret = es-\u003eerr_buffer[i];\n    if (inc) {\n        es-\u003ebottom = i;\n        es-\u003eerr_buffer[i] = 0;\n    }\n\n    if (file != NULL \u0026\u0026 line != NULL) {\n        if (es-\u003eerr_file[i] == NULL) {\n            *file = \"NA\";\n            *line = 0;\n        } else {\n            *file = es-\u003eerr_file[i];\n            *line = es-\u003eerr_line[i];\n        }\n    }\n\n    if (data == NULL) {\n        if (inc) {\n            err_clear_data(es, i);\n        }\n    } else {\n        if (es-\u003eerr_data[i] == NULL) {\n            *data = \"\";\n            if (flags != NULL)\n                *flags = 0;\n        } else {\n            *data = es-\u003eerr_data[i];\n            if (flags != NULL)\n                *flags = es-\u003eerr_data_flags[i];\n        }\n    }\n    return ret;\n}","filepath":"crypto/err/err.c","line_number":523,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1o"},"269843056":{"score":0.89558554,"function_name":"BUF_MEM_free","code":"void BUF_MEM_free(BUF_MEM *a)\n{\n    if (a == NULL)\n        return;\n\n    if (a-\u003edata != NULL) {\n        if (a-\u003eflags \u0026 BUF_MEM_FLAG_SECURE)\n            OPENSSL_secure_clear_free(a-\u003edata, a-\u003emax);\n        else\n            OPENSSL_clear_free(a-\u003edata, a-\u003emax);\n    }\n    OPENSSL_free(a);\n}"},"269843360":{"score":0.8510771,"function_name":"BUF_MEM_grow_clean","code":"size_t BUF_MEM_grow_clean(BUF_MEM *str, size_t len)\n{\n    char *ret;\n    size_t n;\n\n    if (str-\u003elength \u003e= len) {\n        if (str-\u003edata != NULL)\n            memset(\u0026str-\u003edata[len], 0, str-\u003elength - len);\n        str-\u003elength = len;\n        return len;\n    }\n    if (str-\u003emax \u003e= len) {\n        memset(\u0026str-\u003edata[str-\u003elength], 0, len - str-\u003elength);\n        str-\u003elength = len;\n        return len;\n    }\n    /* This limit is sufficient to ensure (len+3)/3*4 \u003c 2**31 */\n    if (len \u003e LIMIT_BEFORE_EXPANSION) {\n        BUFerr(BUF_F_BUF_MEM_GROW_CLEAN, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n    n = (len + 3) / 3 * 4;\n    if ((str-\u003eflags \u0026 BUF_MEM_FLAG_SECURE))\n        ret = sec_alloc_realloc(str, n);\n    else\n        ret = OPENSSL_clear_realloc(str-\u003edata, str-\u003emax, n);\n    if (ret == NULL) {\n        BUFerr(BUF_F_BUF_MEM_GROW_CLEAN, ERR_R_MALLOC_FAILURE);\n        len = 0;\n    } else {\n        str-\u003edata = ret;\n        str-\u003emax = n;\n        memset(\u0026str-\u003edata[str-\u003elength], 0, len - str-\u003elength);\n        str-\u003elength = len;\n    }\n    return len;\n}","filepath":"crypto/buffer/buffer.c","line_number":110,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"269843616":{"score":0.8752768,"function_name":"BUF_MEM_new","code":"BUF_MEM *BUF_MEM_new(void)\n{\n    BUF_MEM *ret;\n\n    ret = OPENSSL_zalloc(sizeof(*ret));\n    if (ret == NULL) {\n        BUFerr(BUF_F_BUF_MEM_NEW, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    return ret;\n}","filepath":"crypto/buffer/buffer.c","line_number":31,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"269843728":{"score":0.8537419,"function_name":"BUF_reverse","code":"void BUF_reverse(unsigned char *out, const unsigned char *in, size_t size)\n{\n    size_t i;\n    if (in) {\n        out += size - 1;\n        for (i = 0; i \u003c size; i++)\n            *out-- = *in++;\n    } else {\n        unsigned char *q;\n        char c;\n        q = out + size - 1;\n        for (i = 0; i \u003c size / 2; i++) {\n            c = *q;\n            *q-- = *out;\n            *out++ = c;\n        }\n    }\n}","filepath":"crypto/buffer/buffer.c","line_number":148,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"269843808":{"score":0.9022158,"function_name":"sec_alloc_realloc","code":"static char *sec_alloc_realloc(BUF_MEM *str, size_t len)\n{\n    char *ret;\n\n    ret = OPENSSL_secure_malloc(len);\n    if (str-\u003edata != NULL) {\n        if (ret != NULL) {\n            memcpy(ret, str-\u003edata, str-\u003elength);\n            OPENSSL_secure_clear_free(str-\u003edata, str-\u003elength);\n            str-\u003edata = NULL;\n        }\n    }\n    return ret;\n}","filepath":"crypto/buffer/buffer.c","line_number":58,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"269843888":{"score":0.8392876,"function_name":"OPENSSL_cpuid_setup","code":"void OPENSSL_cpuid_setup(void)\n{\n    static int trigger = 0;\n    IA32CAP OPENSSL_ia32_cpuid(unsigned int *);\n    IA32CAP vec;\n    const variant_char *env;\n\n    if (trigger)\n        return;\n\n    trigger = 1;\n    if ((env = ossl_getenv(\"OPENSSL_ia32cap\")) != NULL) {\n        int off = (env[0] == '~') ? 1 : 0;\n\n        vec = ossl_strtouint64(env + off);\n\n        if (off) {\n            IA32CAP mask = vec;\n            vec = OPENSSL_ia32_cpuid(OPENSSL_ia32cap_P) \u0026 ~mask;\n            if (mask \u0026 (1\u003c\u003c24)) {\n                /*\n                 * User disables FXSR bit, mask even other capabilities\n                 * that operate exclusively on XMM, so we don't have to\n                 * double-check all the time. We mask PCLMULQDQ, AMD XOP,\n                 * AES-NI and AVX. Formally speaking we don't have to\n                 * do it in x86_64 case, but we can safely assume that\n                 * x86_64 users won't actually flip this flag.\n                 */\n                vec \u0026= ~((IA32CAP)(1\u003c\u003c1|1\u003c\u003c11|1\u003c\u003c25|1\u003c\u003c28) \u003c\u003c 32);\n            }\n        } else if (env[0] == ':') {\n            vec = OPENSSL_ia32_cpuid(OPENSSL_ia32cap_P);\n        }\n\n        if ((env = ossl_strchr(env, ':')) != NULL) {\n            IA32CAP vecx;\n\n            env++;\n            off = (env[0] == '~') ? 1 : 0;\n            vecx = ossl_strtouint64(env + off);\n            if (off) {\n                OPENSSL_ia32cap_P[2] \u0026= ~(unsigned int)vecx;\n            } else {\n                OPENSSL_ia32cap_P[2] = (unsigned int)vecx;\n            }\n        } else {\n            OPENSSL_ia32cap_P[2] = 0;\n        }\n    } else {\n        vec = OPENSSL_ia32_cpuid(OPENSSL_ia32cap_P);\n    }\n\n    /*\n     * |(1\u003c\u003c10) sets a reserved bit to signal that variable\n     * was initialized already... This is to avoid interference\n     * with cpuid snippets in ELF .init segment.\n     */\n    OPENSSL_ia32cap_P[0] = (unsigned int)vec | (1 \u003c\u003c 10);\n    OPENSSL_ia32cap_P[1] = (unsigned int)(vec \u003e\u003e 32);\n}","filepath":"crypto/cryptlib.c","line_number":101,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0j"},"269844560":{"score":0.5682764,"function_name":"OPENSSL_showfatal","code":"void OPENSSL_showfatal(const char *fmta, ...)\n{\n    va_list ap;\n    TCHAR buf[256];\n    const TCHAR *fmt;\n# ifdef STD_ERROR_HANDLE        /* what a dirty trick! */\n    HANDLE h;\n\n    if ((h = GetStdHandle(STD_ERROR_HANDLE)) != NULL \u0026\u0026\n        GetFileType(h) != FILE_TYPE_UNKNOWN) {\n        /* must be console application */\n        int len;\n        DWORD out;\n\n        va_start(ap, fmta);\n        len = _vsnprintf((char *)buf, sizeof(buf), fmta, ap);\n        WriteFile(h, buf, len \u003c 0 ? sizeof(buf) : (DWORD) len, \u0026out, NULL);\n        va_end(ap);\n        return;\n    }\n# endif\n\n    if (sizeof(TCHAR) == sizeof(char))\n        fmt = (const TCHAR *)fmta;\n    else\n        do {\n            int keepgoing;\n            size_t len_0 = strlen(fmta) + 1, i;\n            WCHAR *fmtw;\n\n            fmtw = (WCHAR *)alloca(len_0 * sizeof(WCHAR));\n            if (fmtw == NULL) {\n                fmt = (const TCHAR *)L\"no stack?\";\n                break;\n            }\n            if (!MultiByteToWideChar(CP_ACP, 0, fmta, len_0, fmtw, len_0))\n                for (i = 0; i \u003c len_0; i++)\n                    fmtw[i] = (WCHAR)fmta[i];\n            for (i = 0; i \u003c len_0; i++) {\n                if (fmtw[i] == L'%')\n                    do {\n                        keepgoing = 0;\n                        switch (fmtw[i + 1]) {\n                        case L'0':\n                        case L'1':\n                        case L'2':\n                        case L'3':\n                        case L'4':\n                        case L'5':\n                        case L'6':\n                        case L'7':\n                        case L'8':\n                        case L'9':\n                        case L'.':\n                        case L'*':\n                        case L'-':\n                            i++;\n                            keepgoing = 1;\n                            break;\n                        case L's':\n                            fmtw[i + 1] = L'S';\n                            break;\n                        case L'S':\n                            fmtw[i + 1] = L's';\n                            break;\n                        case L'c':\n                            fmtw[i + 1] = L'C';\n                            break;\n                        case L'C':\n                            fmtw[i + 1] = L'c';\n                            break;\n                        }\n                    } while (keepgoing);\n            }\n            fmt = (const TCHAR *)fmtw;\n        } while (0);\n\n    va_start(ap, fmta);\n    _vsntprintf(buf, OSSL_NELEM(buf) - 1, fmt, ap);\n    buf[OSSL_NELEM(buf) - 1] = _T('\\0');\n    va_end(ap);\n\n# if defined(_WIN32_WINNT) \u0026\u0026 _WIN32_WINNT\u003e=0x0333\n    /* this -------------v--- guards NT-specific calls */\n    if (check_winnt() \u0026\u0026 OPENSSL_isservice() \u003e 0) {\n        HANDLE hEventLog = RegisterEventSource(NULL, _T(\"OpenSSL\"));\n\n        if (hEventLog != NULL) {\n            const TCHAR *pmsg = buf;\n\n            if (!ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE, 0, 0, NULL,\n                             1, 0, \u0026pmsg, NULL)) {\n#if defined(DEBUG)\n                /*\n                 * We are in a situation where we tried to report a critical\n                 * error and this failed for some reason. As a last resort,\n                 * in debug builds, send output to the debugger or any other\n                 * tool like DebugView which can monitor the output.\n                 */\n                OutputDebugString(pmsg);\n#endif\n            }\n\n            (void)DeregisterEventSource(hEventLog);\n        }\n    } else\n# endif\n        MessageBox(NULL, buf, _T(\"OpenSSL: FATAL\"), MB_OK | MB_ICONERROR);\n}","filepath":"crypto/cryptlib.c","line_number":254,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0j"},"269845296":{"score":0.81773967,"function_name":"ossl_strtouint64","code":"static uint64_t ossl_strtouint64(const variant_char *str)\n{\n    uint64_t ret = 0;\n    unsigned int digit, base = 10;\n\n    if (*str == '0') {\n        base = 8, str++;\n        if (*str == 'x' || *str == 'X')\n            base = 16, str++;\n    }\n\n    while((digit = todigit(*str++)) \u003c base)\n        ret = ret * base + digit;\n\n    return ret;\n}","filepath":"crypto/cryptlib.c","line_number":69,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0j"},"269845520":{"score":0.9425644,"function_name":"EVP_DecodeFinal","code":"int EVP_DecodeFinal(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl)\n{\n    int i;\n\n    *outl = 0;\n    if (ctx-\u003enum != 0) {\n        i = evp_decodeblock_int(ctx, out, ctx-\u003eenc_data, ctx-\u003enum);\n        if (i \u003c 0)\n            return -1;\n        ctx-\u003enum = 0;\n        *outl = i;\n        return 1;\n    } else\n        return 1;\n}","filepath":"crypto/evp/encode.c","line_number":464,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre5"},"269845632":{"score":0.8802755,"function_name":"EVP_DecodeUpdate","code":"int EVP_DecodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl,\n                     const unsigned char *in, int inl)\n{\n    int seof = 0, eof = 0, rv = -1, ret = 0, i, v, tmp, n, decoded_len;\n    unsigned char *d;\n    const unsigned char *table;\n\n    n = ctx-\u003enum;\n    d = ctx-\u003eenc_data;\n\n    if (n \u003e 0 \u0026\u0026 d[n - 1] == '=') {\n        eof++;\n        if (n \u003e 1 \u0026\u0026 d[n - 2] == '=')\n            eof++;\n    }\n\n     /* Legacy behaviour: an empty input chunk signals end of input. */\n    if (inl == 0) {\n        rv = 0;\n        goto end;\n    }\n\n    if ((ctx-\u003eflags \u0026 EVP_ENCODE_CTX_USE_SRP_ALPHABET) != 0)\n        table = srpdata_ascii2bin;\n    else\n        table = data_ascii2bin;\n\n    for (i = 0; i \u003c inl; i++) {\n        tmp = *(in++);\n        v = conv_ascii2bin(tmp, table);\n        if (v == B64_ERROR) {\n            rv = -1;\n            goto end;\n        }\n\n        if (tmp == '=') {\n            eof++;\n        } else if (eof \u003e 0 \u0026\u0026 B64_BASE64(v)) {\n            /* More data after padding. */\n            rv = -1;\n            goto end;\n        }\n\n        if (eof \u003e 2) {\n            rv = -1;\n            goto end;\n        }\n\n        if (v == B64_EOF) {\n            seof = 1;\n            goto tail;\n        }\n\n        /* Only save valid base64 characters. */\n        if (B64_BASE64(v)) {\n            if (n \u003e= 64) {\n                /*\n                 * We increment n once per loop, and empty the buffer as soon as\n                 * we reach 64 characters, so this can only happen if someone's\n                 * manually messed with the ctx. Refuse to write any more data.\n                 */\n                rv = -1;\n                goto end;\n            }\n            OPENSSL_assert(n \u003c (int)sizeof(ctx-\u003eenc_data));\n            d[n++] = tmp;\n        }\n\n        if (n == 64) {\n            decoded_len = evp_decodeblock_int(ctx, out, d, n);\n            n = 0;\n            if (decoded_len \u003c 0 || eof \u003e decoded_len) {\n                rv = -1;\n                goto end;\n            }\n            ret += decoded_len - eof;\n            out += decoded_len - eof;\n        }\n    }\n\n    /*\n     * Legacy behaviour: if the current line is a full base64-block (i.e., has\n     * 0 mod 4 base64 characters), it is processed immediately. We keep this\n     * behaviour as applications may not be calling EVP_DecodeFinal properly.\n     */\ntail:\n    if (n \u003e 0) {\n        if ((n \u0026 3) == 0) {\n            decoded_len = evp_decodeblock_int(ctx, out, d, n);\n            n = 0;\n            if (decoded_len \u003c 0 || eof \u003e decoded_len) {\n                rv = -1;\n                goto end;\n            }\n            ret += (decoded_len - eof);\n        } else if (seof) {\n            /* EOF in the middle of a base64 block. */\n            rv = -1;\n            goto end;\n        }\n    }\n\n    rv = seof || (n == 0 \u0026\u0026 eof) ? 0 : 1;\nend:\n    /* Legacy behaviour. This should probably rather be zeroed on error. */\n    *outl = ret;\n    ctx-\u003enum = n;\n    return rv;\n}","filepath":"crypto/evp/encode.c","line_number":303,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre5"},"269846208":{"score":0.85839605,"function_name":"EVP_EncodeFinal","code":"void EVP_EncodeFinal(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl)\n{\n    unsigned int ret = 0;\n\n    if (ctx-\u003enum != 0) {\n        ret = evp_encodeblock_int(ctx, out, ctx-\u003eenc_data, ctx-\u003enum);\n        if ((ctx-\u003eflags \u0026 EVP_ENCODE_CTX_NO_NEWLINES) == 0)\n            out[ret++] = '\\n';\n        out[ret] = '\\0';\n        ctx-\u003enum = 0;\n    }\n    *outl = ret;\n}","filepath":"crypto/evp/encode.c","line_number":217,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre5"},"269846320":{"score":0.91677856,"function_name":"EVP_EncodeUpdate","code":"int EVP_EncodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl,\n                      const unsigned char *in, int inl)\n{\n    int i, j;\n    size_t total = 0;\n\n    *outl = 0;\n    if (inl \u003c= 0)\n        return 0;\n    OPENSSL_assert(ctx-\u003elength \u003c= (int)sizeof(ctx-\u003eenc_data));\n    if (ctx-\u003elength - ctx-\u003enum \u003e inl) {\n        memcpy(\u0026(ctx-\u003eenc_data[ctx-\u003enum]), in, inl);\n        ctx-\u003enum += inl;\n        return 1;\n    }\n    if (ctx-\u003enum != 0) {\n        i = ctx-\u003elength - ctx-\u003enum;\n        memcpy(\u0026(ctx-\u003eenc_data[ctx-\u003enum]), in, i);\n        in += i;\n        inl -= i;\n        j = evp_encodeblock_int(ctx, out, ctx-\u003eenc_data, ctx-\u003elength);\n        ctx-\u003enum = 0;\n        out += j;\n        total = j;\n        if ((ctx-\u003eflags \u0026 EVP_ENCODE_CTX_NO_NEWLINES) == 0) {\n            *(out++) = '\\n';\n            total++;\n        }\n        *out = '\\0';\n    }\n    while (inl \u003e= ctx-\u003elength \u0026\u0026 total \u003c= INT_MAX) {\n        j = evp_encodeblock_int(ctx, out, in, ctx-\u003elength);\n        in += ctx-\u003elength;\n        inl -= ctx-\u003elength;\n        out += j;\n        total += j;\n        if ((ctx-\u003eflags \u0026 EVP_ENCODE_CTX_NO_NEWLINES) == 0) {\n            *(out++) = '\\n';\n            total++;\n        }\n        *out = '\\0';\n    }\n    if (total \u003e INT_MAX) {\n        /* Too much output data! */\n        *outl = 0;\n        return 0;\n    }\n    if (inl != 0)\n        memcpy(\u0026(ctx-\u003eenc_data[0]), in, inl);\n    ctx-\u003enum = inl;\n    *outl = total;\n\n    return 1;\n}","filepath":"crypto/evp/encode.c","line_number":162,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre5"},"269846656":{"score":0.8623849,"function_name":"evp_decodeblock_int","code":"static int evp_decodeblock_int(EVP_ENCODE_CTX *ctx, unsigned char *t,\n                               const unsigned char *f, int n)\n{\n    int i, ret = 0, a, b, c, d;\n    unsigned long l;\n    const unsigned char *table;\n\n    if (ctx != NULL \u0026\u0026 (ctx-\u003eflags \u0026 EVP_ENCODE_CTX_USE_SRP_ALPHABET) != 0)\n        table = srpdata_ascii2bin;\n    else\n        table = data_ascii2bin;\n\n    /* trim white space from the start of the line. */\n    while ((conv_ascii2bin(*f, table) == B64_WS) \u0026\u0026 (n \u003e 0)) {\n        f++;\n        n--;\n    }\n\n    /*\n     * strip off stuff at the end of the line ascii2bin values B64_WS,\n     * B64_EOLN, B64_EOLN and B64_EOF\n     */\n    while ((n \u003e 3) \u0026\u0026 (B64_NOT_BASE64(conv_ascii2bin(f[n - 1], table))))\n        n--;\n\n    if (n % 4 != 0)\n        return -1;\n\n    for (i = 0; i \u003c n; i += 4) {\n        a = conv_ascii2bin(*(f++), table);\n        b = conv_ascii2bin(*(f++), table);\n        c = conv_ascii2bin(*(f++), table);\n        d = conv_ascii2bin(*(f++), table);\n        if ((a \u0026 0x80) || (b \u0026 0x80) || (c \u0026 0x80) || (d \u0026 0x80))\n            return -1;\n        l = ((((unsigned long)a) \u003c\u003c 18L) |\n             (((unsigned long)b) \u003c\u003c 12L) |\n             (((unsigned long)c) \u003c\u003c 6L) | (((unsigned long)d)));\n        *(t++) = (unsigned char)(l \u003e\u003e 16L) \u0026 0xff;\n        *(t++) = (unsigned char)(l \u003e\u003e 8L) \u0026 0xff;\n        *(t++) = (unsigned char)(l) \u0026 0xff;\n        ret += 3;\n    }\n    return ret;\n}","filepath":"crypto/evp/encode.c","line_number":413,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre5"},"269847040":{"score":0.91295475,"function_name":"evp_encodeblock_int","code":"static int evp_encodeblock_int(EVP_ENCODE_CTX *ctx, unsigned char *t,\n                               const unsigned char *f, int dlen)\n{\n    int i, ret = 0;\n    unsigned long l;\n    const unsigned char *table;\n\n    if (ctx != NULL \u0026\u0026 (ctx-\u003eflags \u0026 EVP_ENCODE_CTX_USE_SRP_ALPHABET) != 0)\n        table = srpdata_bin2ascii;\n    else\n        table = data_bin2ascii;\n\n    for (i = dlen; i \u003e 0; i -= 3) {\n        if (i \u003e= 3) {\n            l = (((unsigned long)f[0]) \u003c\u003c 16L) |\n                (((unsigned long)f[1]) \u003c\u003c 8L) | f[2];\n            *(t++) = conv_bin2ascii(l \u003e\u003e 18L, table);\n            *(t++) = conv_bin2ascii(l \u003e\u003e 12L, table);\n            *(t++) = conv_bin2ascii(l \u003e\u003e 6L, table);\n            *(t++) = conv_bin2ascii(l, table);\n        } else {\n            l = ((unsigned long)f[0]) \u003c\u003c 16L;\n            if (i == 2)\n                l |= ((unsigned long)f[1] \u003c\u003c 8L);\n\n            *(t++) = conv_bin2ascii(l \u003e\u003e 18L, table);\n            *(t++) = conv_bin2ascii(l \u003e\u003e 12L, table);\n            *(t++) = (i == 1) ? '=' : conv_bin2ascii(l \u003e\u003e 6L, table);\n            *(t++) = '=';\n        }\n        ret += 4;\n        f += 3;\n    }\n\n    *t = '\\0';\n    return ret;\n}","filepath":"crypto/evp/encode.c","line_number":231,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre5"},"269847328":{"score":0.8739867,"function_name":"BN_GENCB_new","code":"BN_GENCB *BN_GENCB_new(void)\n{\n    BN_GENCB *ret;\n\n    if ((ret = OPENSSL_malloc(sizeof(*ret))) == NULL) {\n        BNerr(BN_F_BN_GENCB_NEW, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    return ret;\n}","filepath":"libs-ext/openssl/crypto/bn/bn_lib.c","line_number":947,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269847472":{"score":0.8413011,"function_name":"BN_bin2bn","code":"BIGNUM *BN_bin2bn(const unsigned char *s, int len, BIGNUM *ret)\n{\n    unsigned int i, m;\n    unsigned int n;\n    BN_ULONG l;\n    BIGNUM *bn = NULL;\n\n    if (ret == NULL)\n        ret = bn = BN_new();\n    if (ret == NULL)\n        return NULL;\n    bn_check_top(ret);\n    /* Skip leading zero's. */\n    for ( ; len \u003e 0 \u0026\u0026 *s == 0; s++, len--)\n        continue;\n    n = len;\n    if (n == 0) {\n        ret-\u003etop = 0;\n        return ret;\n    }\n    i = ((n - 1) / BN_BYTES) + 1;\n    m = ((n - 1) % (BN_BYTES));\n    if (bn_wexpand(ret, (int)i) == NULL) {\n        BN_free(bn);\n        return NULL;\n    }\n    ret-\u003etop = i;\n    ret-\u003eneg = 0;\n    l = 0;\n    while (n--) {\n        l = (l \u003c\u003c 8L) | *(s++);\n        if (m-- == 0) {\n            ret-\u003ed[--i] = l;\n            l = 0;\n            m = BN_BYTES - 1;\n        }\n    }\n    /*\n     * need to call this due to clear byte at top if avoiding having the top\n     * bit set (-ve number)\n     */\n    bn_correct_top(ret);\n    return ret;\n}","filepath":"libs-ext/openssl/crypto/bn/bn_lib.c","line_number":416,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269847856":{"score":0.8510431,"function_name":"BN_clear_bit","code":"int BN_clear_bit(BIGNUM *a, int n)\n{\n    int i, j;\n\n    bn_check_top(a);\n    if (n \u003c 0)\n        return 0;\n\n    i = n / BN_BITS2;\n    j = n % BN_BITS2;\n    if (a-\u003etop \u003c= i)\n        return 0;\n\n    a-\u003ed[i] \u0026= (~(((BN_ULONG)1) \u003c\u003c j));\n    bn_correct_top(a);\n    return 1;\n}","filepath":"libs-ext/openssl/crypto/bn/bn_lib.c","line_number":690,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269847968":{"score":0.78066087,"function_name":"BN_clear_free","code":"void BN_clear_free(BIGNUM *a)\n{\n    if (a == NULL)\n        return;\n    if (a-\u003ed != NULL \u0026\u0026 !BN_get_flags(a, BN_FLG_STATIC_DATA))\n        bn_free_d(a, 1);\n    if (BN_get_flags(a, BN_FLG_MALLOCED)) {\n        OPENSSL_cleanse(a, sizeof(*a));\n        OPENSSL_free(a);\n    }\n}","filepath":"libs-ext/openssl/crypto/bn/bn_lib.c","line_number":200,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269848080":{"score":0.8929461,"function_name":"BN_cmp","code":"int BN_cmp(const BIGNUM *a, const BIGNUM *b)\n{\n    int i;\n    int gt, lt;\n    BN_ULONG t1, t2;\n\n    if ((a == NULL) || (b == NULL)) {\n        if (a != NULL)\n            return -1;\n        else if (b != NULL)\n            return 1;\n        else\n            return 0;\n    }\n\n    bn_check_top(a);\n    bn_check_top(b);\n\n    if (a-\u003eneg != b-\u003eneg) {\n        if (a-\u003eneg)\n            return -1;\n        else\n            return 1;\n    }\n    if (a-\u003eneg == 0) {\n        gt = 1;\n        lt = -1;\n    } else {\n        gt = -1;\n        lt = 1;\n    }\n\n    if (a-\u003etop \u003e b-\u003etop)\n        return gt;\n    if (a-\u003etop \u003c b-\u003etop)\n        return lt;\n    for (i = a-\u003etop - 1; i \u003e= 0; i--) {\n        t1 = a-\u003ed[i];\n        t2 = b-\u003ed[i];\n        if (t1 \u003e t2)\n            return gt;\n        if (t1 \u003c t2)\n            return lt;\n    }\n    return 0;\n}","filepath":"libs-ext/openssl/crypto/bn/bn_lib.c","line_number":620,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269848240":{"score":0.8940209,"function_name":"BN_consttime_swap","code":"void BN_consttime_swap(BN_ULONG condition, BIGNUM *a, BIGNUM *b, int nwords)\n{\n    BN_ULONG t;\n    int i;\n\n    if (a == b)\n        return;\n\n    bn_wcheck_size(a, nwords);\n    bn_wcheck_size(b, nwords);\n\n    condition = ((~condition \u0026 ((condition - 1))) \u003e\u003e (BN_BITS2 - 1)) - 1;\n\n    t = (a-\u003etop ^ b-\u003etop) \u0026 condition;\n    a-\u003etop ^= t;\n    b-\u003etop ^= t;\n\n    t = (a-\u003eneg ^ b-\u003eneg) \u0026 condition;\n    a-\u003eneg ^= t;\n    b-\u003eneg ^= t;\n\n    /*-\n     * BN_FLG_STATIC_DATA: indicates that data may not be written to. Intention\n     * is actually to treat it as it's read-only data, and some (if not most)\n     * of it does reside in read-only segment. In other words observation of\n     * BN_FLG_STATIC_DATA in BN_consttime_swap should be treated as fatal\n     * condition. It would either cause SEGV or effectively cause data\n     * corruption.\n     *\n     * BN_FLG_MALLOCED: refers to BN structure itself, and hence must be\n     * preserved.\n     *\n     * BN_FLG_SECURE: must be preserved, because it determines how x-\u003ed was\n     * allocated and hence how to free it.\n     *\n     * BN_FLG_CONSTTIME: sufficient to mask and swap\n     *\n     * BN_FLG_FIXED_TOP: indicates that we haven't called bn_correct_top() on\n     * the data, so the d array may be padded with additional 0 values (i.e.\n     * top could be greater than the minimal value that it could be). We should\n     * be swapping it\n     */\n\n#define BN_CONSTTIME_SWAP_FLAGS (BN_FLG_CONSTTIME | BN_FLG_FIXED_TOP)\n\n    t = ((a-\u003eflags ^ b-\u003eflags) \u0026 BN_CONSTTIME_SWAP_FLAGS) \u0026 condition;\n    a-\u003eflags ^= t;\n    b-\u003eflags ^= t;\n\n    /* conditionally swap the data */\n    for (i = 0; i \u003c nwords; i++) {\n        t = (a-\u003ed[i] ^ b-\u003ed[i]) \u0026 condition;\n        a-\u003ed[i] ^= t;\n        b-\u003ed[i] ^= t;\n    }\n}","filepath":"libs-ext/openssl/crypto/bn/bn_lib.c","line_number":809,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269848560":{"score":0.79889524,"function_name":"BN_copy","code":"BIGNUM *BN_copy(BIGNUM *a, const BIGNUM *b)\n{\n    bn_check_top(b);\n\n    if (a == b)\n        return a;\n    if (bn_wexpand(a, b-\u003etop) == NULL)\n        return NULL;\n\n    if (b-\u003etop \u003e 0)\n        memcpy(a-\u003ed, b-\u003ed, sizeof(b-\u003ed[0]) * b-\u003etop);\n\n    a-\u003eneg = b-\u003eneg;\n    a-\u003etop = b-\u003etop;\n    a-\u003eflags |= b-\u003eflags \u0026 BN_FLG_FIXED_TOP;\n    bn_check_top(a);\n    return a;\n}","filepath":"libs-ext/openssl/crypto/bn/bn_lib.c","line_number":323,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269848832":{"score":0.71752775,"function_name":"BN_free","code":"void BN_free(BIGNUM *a)\n{\n    if (a == NULL)\n        return;\n    if (!BN_get_flags(a, BN_FLG_STATIC_DATA))\n        bn_free_d(a, 0);\n    if (a-\u003eflags \u0026 BN_FLG_MALLOCED)\n        OPENSSL_free(a);\n}","filepath":"libs-ext/openssl/crypto/bn/bn_lib.c","line_number":212,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269848944":{"score":0.78102374,"function_name":"BN_get_word","code":"BN_ULONG BN_get_word(const BIGNUM *a)\n{\n    if (a-\u003etop \u003e 1)\n        return BN_MASK2;\n    else if (a-\u003etop == 1)\n        return a-\u003ed[0];\n    /* a-\u003etop == 0 */\n    return 0;\n}","filepath":"libs-ext/openssl/crypto/bn/bn_lib.c","line_number":393,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269848976":{"score":0.91734755,"function_name":"BN_is_bit_set","code":"int BN_is_bit_set(const BIGNUM *a, int n)\n{\n    int i, j;\n\n    bn_check_top(a);\n    if (n \u003c 0)\n        return 0;\n    i = n / BN_BITS2;\n    j = n % BN_BITS2;\n    if (a-\u003etop \u003c= i)\n        return 0;\n    return (int)(((a-\u003ed[i]) \u003e\u003e j) \u0026 ((BN_ULONG)1));\n}","filepath":"libs-ext/openssl/crypto/bn/bn_lib.c","line_number":708,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269849184":{"score":0.8635261,"function_name":"BN_mask_bits","code":"int BN_mask_bits(BIGNUM *a, int n)\n{\n    int b, w;\n\n    bn_check_top(a);\n    if (n \u003c 0)\n        return 0;\n\n    w = n / BN_BITS2;\n    b = n % BN_BITS2;\n    if (w \u003e= a-\u003etop)\n        return 0;\n    if (b == 0)\n        a-\u003etop = w;\n    else {\n        a-\u003etop = w + 1;\n        a-\u003ed[w] \u0026= ~(BN_MASK2 \u003c\u003c b);\n    }\n    bn_correct_top(a);\n    return 1;\n}","filepath":"libs-ext/openssl/crypto/bn/bn_lib.c","line_number":722,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269849376":{"score":0.77206767,"function_name":"bn_num_bits_consttime","code":"static ossl_inline\nint bn_num_bits_consttime(const BIGNUM *a)\n{\n    int j, ret;\n    unsigned int mask, past_i;\n    int i = a-\u003etop - 1;\n    bn_check_top(a);\n\n    for (j = 0, past_i = 0, ret = 0; j \u003c a-\u003edmax; j++) {\n        mask = constant_time_eq_int(i, j); /* 0xff..ff if i==j, 0x0 otherwise */\n\n        ret += BN_BITS2 \u0026 (~mask \u0026 ~past_i);\n        ret += BN_num_bits_word(a-\u003ed[j]) \u0026 mask;\n\n        past_i |= mask; /* past_i will become 0xff..ff after i==j */\n    }\n\n    /*\n     * if BN_is_zero(a) =\u003e i is -1 and ret contains garbage, so we mask the\n     * final result.\n     */\n    mask = ~(constant_time_eq_int(i, ((int)-1)));\n\n    return ret \u0026 mask;\n}","filepath":"libs-ext/openssl/crypto/bn/bn_lib.c","line_number":139,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269849584":{"score":0.7736171,"function_name":"BN_num_bits_word","code":"int BN_num_bits_word(BN_ULONG l)\n{\n    BN_ULONG x, mask;\n    int bits = (l != 0);\n\n#if BN_BITS2 \u003e 32\n    x = l \u003e\u003e 32;\n    mask = (0 - x) \u0026 BN_MASK2;\n    mask = (0 - (mask \u003e\u003e (BN_BITS2 - 1)));\n    bits += 32 \u0026 mask;\n    l ^= (x ^ l) \u0026 mask;\n#endif\n\n    x = l \u003e\u003e 16;\n    mask = (0 - x) \u0026 BN_MASK2;\n    mask = (0 - (mask \u003e\u003e (BN_BITS2 - 1)));\n    bits += 16 \u0026 mask;\n    l ^= (x ^ l) \u0026 mask;\n\n    x = l \u003e\u003e 8;\n    mask = (0 - x) \u0026 BN_MASK2;\n    mask = (0 - (mask \u003e\u003e (BN_BITS2 - 1)));\n    bits += 8 \u0026 mask;\n    l ^= (x ^ l) \u0026 mask;\n\n    x = l \u003e\u003e 4;\n    mask = (0 - x) \u0026 BN_MASK2;\n    mask = (0 - (mask \u003e\u003e (BN_BITS2 - 1)));\n    bits += 4 \u0026 mask;\n    l ^= (x ^ l) \u0026 mask;\n\n    x = l \u003e\u003e 2;\n    mask = (0 - x) \u0026 BN_MASK2;\n    mask = (0 - (mask \u003e\u003e (BN_BITS2 - 1)));\n    bits += 2 \u0026 mask;\n    l ^= (x ^ l) \u0026 mask;\n\n    x = l \u003e\u003e 1;\n    mask = (0 - x) \u0026 BN_MASK2;\n    mask = (0 - (mask \u003e\u003e (BN_BITS2 - 1)));\n    bits += 1 \u0026 mask;\n\n    return bits;\n}","filepath":"libs-ext/openssl/crypto/bn/bn_lib.c","line_number":90,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269849728":{"score":0.916176,"function_name":"BN_new","code":"BIGNUM *BN_new(void)\n{\n    BIGNUM *ret;\n\n    if ((ret = OPENSSL_zalloc(sizeof(*ret))) == NULL) {\n        BNerr(BN_F_BN_NEW, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    ret-\u003eflags = BN_FLG_MALLOCED;\n    bn_check_top(ret);\n    return ret;\n}","filepath":"libs-ext/openssl/crypto/bn/bn_lib.c","line_number":230,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269849792":{"score":0.9356017,"function_name":"BN_security_bits","code":"int BN_security_bits(int L, int N)\n{\n    int secbits, bits;\n    if (L \u003e= 15360)\n        secbits = 256;\n    else if (L \u003e= 7680)\n        secbits = 192;\n    else if (L \u003e= 3072)\n        secbits = 128;\n    else if (L \u003e= 2048)\n        secbits = 112;\n    else if (L \u003e= 1024)\n        secbits = 80;\n    else\n        return 0;\n    if (N == -1)\n        return secbits;\n    bits = N / 2;\n    if (bits \u003c 80)\n        return 0;\n    return bits \u003e= secbits ? secbits : bits;\n}","filepath":"libs-ext/openssl/crypto/bn/bn_lib.c","line_number":870,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269849904":{"score":0.94204265,"function_name":"BN_set_bit","code":"int BN_set_bit(BIGNUM *a, int n)\n{\n    int i, j, k;\n\n    if (n \u003c 0)\n        return 0;\n\n    i = n / BN_BITS2;\n    j = n % BN_BITS2;\n    if (a-\u003etop \u003c= i) {\n        if (bn_wexpand(a, i + 1) == NULL)\n            return 0;\n        for (k = a-\u003etop; k \u003c i + 1; k++)\n            a-\u003ed[k] = 0;\n        a-\u003etop = i + 1;\n        a-\u003eflags \u0026= ~BN_FLG_FIXED_TOP;\n    }\n\n    a-\u003ed[i] |= (((BN_ULONG)1) \u003c\u003c j);\n    bn_check_top(a);\n    return 1;\n}","filepath":"libs-ext/openssl/crypto/bn/bn_lib.c","line_number":667,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269850096":{"score":0.7337791,"function_name":"BN_set_word","code":"int BN_set_word(BIGNUM *a, BN_ULONG w)\n{\n    bn_check_top(a);\n    if (bn_expand(a, (int)sizeof(BN_ULONG) * 8) == NULL)\n        return 0;\n    a-\u003eneg = 0;\n    a-\u003ed[0] = w;\n    a-\u003etop = (w ? 1 : 0);\n    a-\u003eflags \u0026= ~BN_FLG_FIXED_TOP;\n    bn_check_top(a);\n    return 1;\n}","filepath":"libs-ext/openssl/crypto/bn/bn_lib.c","line_number":403,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269850192":{"score":0.88710386,"function_name":"BN_ucmp","code":"int BN_ucmp(const BIGNUM *a, const BIGNUM *b)\n{\n    int i;\n    BN_ULONG t1, t2, *ap, *bp;\n\n    bn_check_top(a);\n    bn_check_top(b);\n\n    i = a-\u003etop - b-\u003etop;\n    if (i != 0)\n        return i;\n    ap = a-\u003ed;\n    bp = b-\u003ed;\n    for (i = a-\u003etop - 1; i \u003e= 0; i--) {\n        t1 = ap[i];\n        t2 = bp[i];\n        if (t1 != t2)\n            return ((t1 \u003e t2) ? 1 : -1);\n    }\n    return 0;\n}","filepath":"libs-ext/openssl/crypto/bn/bn_lib.c","line_number":598,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269850288":{"score":0.87107,"function_name":"BN_with_flags","code":"void BN_with_flags(BIGNUM *dest, const BIGNUM *b, int flags)\n{\n    dest-\u003ed = b-\u003ed;\n    dest-\u003etop = b-\u003etop;\n    dest-\u003edmax = b-\u003edmax;\n    dest-\u003eneg = b-\u003eneg;\n    dest-\u003eflags = ((dest-\u003eflags \u0026 BN_FLG_MALLOCED)\n                   | (b-\u003eflags \u0026 ~BN_FLG_MALLOCED)\n                   | BN_FLG_STATIC_DATA | flags);\n}","filepath":"libs-ext/openssl/crypto/bn/bn_lib.c","line_number":936,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269850352":{"score":0.8781094,"function_name":"bn2binpad","code":"static\nint bn2binpad(const BIGNUM *a, unsigned char *to, int tolen, endianess_t endianess)\n{\n    int n;\n    size_t i, lasti, j, atop, mask;\n    BN_ULONG l;\n\n    /*\n     * In case |a| is fixed-top, BN_num_bytes can return bogus length,\n     * but it's assumed that fixed-top inputs ought to be \"nominated\"\n     * even for padded output, so it works out...\n     */\n    n = BN_num_bytes(a);\n    if (tolen == -1) {\n        tolen = n;\n    } else if (tolen \u003c n) {     /* uncommon/unlike case */\n        BIGNUM temp = *a;\n\n        bn_correct_top(\u0026temp);\n        n = BN_num_bytes(\u0026temp);\n        if (tolen \u003c n)\n            return -1;\n    }\n\n    /* Swipe through whole available data and don't give away padded zero. */\n    atop = a-\u003edmax * BN_BYTES;\n    if (atop == 0) {\n        OPENSSL_cleanse(to, tolen);\n        return tolen;\n    }\n\n    lasti = atop - 1;\n    atop = a-\u003etop * BN_BYTES;\n    if (endianess == big)\n        to += tolen; /* start from the end of the buffer */\n    for (i = 0, j = 0; j \u003c (size_t)tolen; j++) {\n        unsigned char val;\n        l = a-\u003ed[i / BN_BYTES];\n        mask = 0 - ((j - atop) \u003e\u003e (8 * sizeof(i) - 1));\n        val = (unsigned char)(l \u003e\u003e (8 * (i % BN_BYTES)) \u0026 mask);\n        if (endianess == big)\n            *--to = val;\n        else\n            *to++ = val;\n        i += (i - lasti) \u003e\u003e (8 * sizeof(i) - 1); /* stay on last limb */\n    }\n\n    return tolen;\n}","filepath":"libs-ext/openssl/crypto/bn/bn_lib.c","line_number":464,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269850752":{"score":0.8866703,"function_name":"bn_cmp_part_words","code":"int bn_cmp_part_words(const BN_ULONG *a, const BN_ULONG *b, int cl, int dl)\n{\n    int n, i;\n    n = cl - 1;\n\n    if (dl \u003c 0) {\n        for (i = dl; i \u003c 0; i++) {\n            if (b[n - i] != 0)\n                return -1;      /* a \u003c b */\n        }\n    }\n    if (dl \u003e 0) {\n        for (i = dl; i \u003e 0; i--) {\n            if (a[n + i] != 0)\n                return 1;       /* a \u003e b */\n        }\n    }\n    return bn_cmp_words(a, b, cl);\n}","filepath":"libs-ext/openssl/crypto/bn/bn_lib.c","line_number":782,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269850912":{"score":0.88306713,"function_name":"bn_cmp_words","code":"int bn_cmp_words(const BN_ULONG *a, const BN_ULONG *b, int n)\n{\n    int i;\n    BN_ULONG aa, bb;\n\n    if (n == 0)\n        return 0;\n\n    aa = a[n - 1];\n    bb = b[n - 1];\n    if (aa != bb)\n        return ((aa \u003e bb) ? 1 : -1);\n    for (i = n - 2; i \u003e= 0; i--) {\n        aa = a[i];\n        bb = b[i];\n        if (aa != bb)\n            return ((aa \u003e bb) ? 1 : -1);\n    }\n    return 0;\n}","filepath":"libs-ext/openssl/crypto/bn/bn_lib.c","line_number":752,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269850992":{"score":0.7174644,"function_name":"bn_correct_top","code":"void bn_correct_top(BIGNUM *a)\n{\n    BN_ULONG *ftl;\n    int tmp_top = a-\u003etop;\n\n    if (tmp_top \u003e 0) {\n        for (ftl = \u0026(a-\u003ed[tmp_top]); tmp_top \u003e 0; tmp_top--) {\n            ftl--;\n            if (*ftl != 0)\n                break;\n        }\n        a-\u003etop = tmp_top;\n    }\n    if (a-\u003etop == 0)\n        a-\u003eneg = 0;\n    a-\u003eflags \u0026= ~BN_FLG_FIXED_TOP;\n    bn_pollute(a);\n}","filepath":"libs-ext/openssl/crypto/bn/bn_lib.c","line_number":1006,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269851360":{"score":0.6951245,"function_name":"BN_CTX_end","code":"void BN_CTX_end(BN_CTX *ctx)\n{\n    CTXDBG_ENTRY(\"BN_CTX_end\", ctx);\n    if (ctx-\u003eerr_stack)\n        ctx-\u003eerr_stack--;\n    else {\n        unsigned int fp = BN_STACK_pop(\u0026ctx-\u003estack);\n        /* Does this stack frame have anything to release? */\n        if (fp \u003c ctx-\u003eused)\n            BN_POOL_release(\u0026ctx-\u003epool, ctx-\u003eused - fp);\n        ctx-\u003eused = fp;\n        /* Unjam \"too_many\" in case \"get\" had failed */\n        ctx-\u003etoo_many = 0;\n    }\n    CTXDBG_EXIT(ctx);\n}","filepath":"crypto/bn/bn_ctx.c","line_number":268,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_0_2r"},"269851616":{"score":0.82227683,"function_name":"BN_CTX_get","code":"BIGNUM *BN_CTX_get(BN_CTX *ctx)\n{\n    BIGNUM *ret;\n    CTXDBG_ENTRY(\"BN_CTX_get\", ctx);\n    if (ctx-\u003eerr_stack || ctx-\u003etoo_many)\n        return NULL;\n    if ((ret = BN_POOL_get(\u0026ctx-\u003epool)) == NULL) {\n        /*\n         * Setting too_many prevents repeated \"get\" attempts from cluttering\n         * the error stack.\n         */\n        ctx-\u003etoo_many = 1;\n        BNerr(BN_F_BN_CTX_GET, BN_R_TOO_MANY_TEMPORARY_VARIABLES);\n        return NULL;\n    }\n    /* OK, make sure the returned bignum is \"zero\" */\n    BN_zero(ret);\n    /* clear BN_FLG_CONSTTIME if leaked from previous frames */\n    ret-\u003eflags \u0026= (~BN_FLG_CONSTTIME);\n    ctx-\u003eused++;\n    CTXDBG_RET(ctx, ret);\n    return ret;\n}","filepath":"crypto/bn/bn_ctx.c","line_number":285,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_0_2r"},"269851968":{"score":0.9022052,"function_name":"BN_CTX_new","code":"BN_CTX *BN_CTX_new(void)\n{\n    BN_CTX *ret = OPENSSL_malloc(sizeof(BN_CTX));\n    if (!ret) {\n        BNerr(BN_F_BN_CTX_NEW, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    /* Initialise the structure */\n    BN_POOL_init(\u0026ret-\u003epool);\n    BN_STACK_init(\u0026ret-\u003estack);\n    ret-\u003eused = 0;\n    ret-\u003eerr_stack = 0;\n    ret-\u003etoo_many = 0;\n    return ret;\n}","filepath":"crypto/bn/bn_ctx.c","line_number":214,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_0_2r"},"269852208":{"score":0.73610127,"function_name":"BN_CTX_start","code":"void BN_CTX_start(BN_CTX *ctx)\n{\n    CTXDBG_ENTRY(\"BN_CTX_start\", ctx);\n    /* If we're already overflowing ... */\n    if (ctx-\u003eerr_stack || ctx-\u003etoo_many)\n        ctx-\u003eerr_stack++;\n    /* (Try to) get a new frame pointer */\n    else if (!BN_STACK_push(\u0026ctx-\u003estack, ctx-\u003eused)) {\n        BNerr(BN_F_BN_CTX_START, BN_R_TOO_MANY_TEMPORARY_VARIABLES);\n        ctx-\u003eerr_stack++;\n    }\n    CTXDBG_EXIT(ctx);\n}","filepath":"crypto/bn/bn_ctx.c","line_number":254,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_0_2r"},"269852576":{"score":0.91255957,"function_name":"BN_add","code":"int BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)\n{\n    int ret, r_neg, cmp_res;\n\n    bn_check_top(a);\n    bn_check_top(b);\n\n    if (a-\u003eneg == b-\u003eneg) {\n        r_neg = a-\u003eneg;\n        ret = BN_uadd(r, a, b);\n    } else {\n        cmp_res = BN_ucmp(a, b);\n        if (cmp_res \u003e 0) {\n            r_neg = a-\u003eneg;\n            ret = BN_usub(r, a, b);\n        } else if (cmp_res \u003c 0) {\n            r_neg = b-\u003eneg;\n            ret = BN_usub(r, b, a);\n        } else {\n            r_neg = 0;\n            BN_zero(r);\n            ret = 1;\n        }\n    }\n\n    r-\u003eneg = r_neg;\n    bn_check_top(r);\n    return ret;\n}","filepath":"crypto/bn/bn_add.c","line_number":14,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre6"},"269852720":{"score":0.9263807,"function_name":"BN_uadd","code":"int BN_uadd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)\n{\n    int max, min, dif;\n    const BN_ULONG *ap, *bp;\n    BN_ULONG *rp, carry, t1, t2;\n\n    bn_check_top(a);\n    bn_check_top(b);\n\n    if (a-\u003etop \u003c b-\u003etop) {\n        const BIGNUM *tmp;\n\n        tmp = a;\n        a = b;\n        b = tmp;\n    }\n    max = a-\u003etop;\n    min = b-\u003etop;\n    dif = max - min;\n\n    if (bn_wexpand(r, max + 1) == NULL)\n        return 0;\n\n    r-\u003etop = max;\n\n    ap = a-\u003ed;\n    bp = b-\u003ed;\n    rp = r-\u003ed;\n\n    carry = bn_add_words(rp, ap, bp, min);\n    rp += min;\n    ap += min;\n\n    while (dif) {\n        dif--;\n        t1 = *(ap++);\n        t2 = (t1 + carry) \u0026 BN_MASK2;\n        *(rp++) = t2;\n        carry \u0026= (t2 == 0);\n    }\n    *rp = carry;\n    r-\u003etop += carry;\n\n    r-\u003eneg = 0;\n    bn_check_top(r);\n    return 1;\n}","filepath":"crypto/bn/bn_add.c","line_number":76,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre6"},"269852896":{"score":0.9462863,"function_name":"BN_usub","code":"int BN_usub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)\n{\n    int max, min, dif;\n    BN_ULONG t1, t2, borrow, *rp;\n    const BN_ULONG *ap, *bp;\n\n    bn_check_top(a);\n    bn_check_top(b);\n\n    max = a-\u003etop;\n    min = b-\u003etop;\n    dif = max - min;\n\n    if (dif \u003c 0) {              /* hmm... should not be happening */\n        BNerr(BN_F_BN_USUB, BN_R_ARG2_LT_ARG3);\n        return 0;\n    }\n\n    if (bn_wexpand(r, max) == NULL)\n        return 0;\n\n    ap = a-\u003ed;\n    bp = b-\u003ed;\n    rp = r-\u003ed;\n\n    borrow = bn_sub_words(rp, ap, bp, min);\n    ap += min;\n    rp += min;\n\n    while (dif) {\n        dif--;\n        t1 = *(ap++);\n        t2 = (t1 - borrow) \u0026 BN_MASK2;\n        *(rp++) = t2;\n        borrow \u0026= (t1 == 0);\n    }\n\n    while (max \u0026\u0026 *--rp == 0)\n        max--;\n\n    r-\u003etop = max;\n    r-\u003eneg = 0;\n    bn_pollute(r);\n\n    return 1;\n}","filepath":"crypto/bn/bn_add.c","line_number":125,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre6"},"269853152":{"score":0.9322593,"function_name":"bn_mul_fixed_top","code":"int bn_mul_fixed_top(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)\n{\n    int ret = 0;\n    int top, al, bl;\n    BIGNUM *rr;\n#if defined(BN_MUL_COMBA) || defined(BN_RECURSION)\n    int i;\n#endif\n#ifdef BN_RECURSION\n    BIGNUM *t = NULL;\n    int j = 0, k;\n#endif\n\n    bn_check_top(a);\n    bn_check_top(b);\n    bn_check_top(r);\n\n    al = a-\u003etop;\n    bl = b-\u003etop;\n\n    if ((al == 0) || (bl == 0)) {\n        BN_zero(r);\n        return 1;\n    }\n    top = al + bl;\n\n    BN_CTX_start(ctx);\n    if ((r == a) || (r == b)) {\n        if ((rr = BN_CTX_get(ctx)) == NULL)\n            goto err;\n    } else\n        rr = r;\n\n#if defined(BN_MUL_COMBA) || defined(BN_RECURSION)\n    i = al - bl;\n#endif\n#ifdef BN_MUL_COMBA\n    if (i == 0) {\n# if 0\n        if (al == 4) {\n            if (bn_wexpand(rr, 8) == NULL)\n                goto err;\n            rr-\u003etop = 8;\n            bn_mul_comba4(rr-\u003ed, a-\u003ed, b-\u003ed);\n            goto end;\n        }\n# endif\n        if (al == 8) {\n            if (bn_wexpand(rr, 16) == NULL)\n                goto err;\n            rr-\u003etop = 16;\n            bn_mul_comba8(rr-\u003ed, a-\u003ed, b-\u003ed);\n            goto end;\n        }\n    }\n#endif                          /* BN_MUL_COMBA */\n#ifdef BN_RECURSION\n    if ((al \u003e= BN_MULL_SIZE_NORMAL) \u0026\u0026 (bl \u003e= BN_MULL_SIZE_NORMAL)) {\n        if (i \u003e= -1 \u0026\u0026 i \u003c= 1) {\n            /*\n             * Find out the power of two lower or equal to the longest of the\n             * two numbers\n             */\n            if (i \u003e= 0) {\n                j = BN_num_bits_word((BN_ULONG)al);\n            }\n            if (i == -1) {\n                j = BN_num_bits_word((BN_ULONG)bl);\n            }\n            j = 1 \u003c\u003c (j - 1);\n            assert(j \u003c= al || j \u003c= bl);\n            k = j + j;\n            t = BN_CTX_get(ctx);\n            if (t == NULL)\n                goto err;\n            if (al \u003e j || bl \u003e j) {\n                if (bn_wexpand(t, k * 4) == NULL)\n                    goto err;\n                if (bn_wexpand(rr, k * 4) == NULL)\n                    goto err;\n                bn_mul_part_recursive(rr-\u003ed, a-\u003ed, b-\u003ed,\n                                      j, al - j, bl - j, t-\u003ed);\n            } else {            /* al \u003c= j || bl \u003c= j */\n\n                if (bn_wexpand(t, k * 2) == NULL)\n                    goto err;\n                if (bn_wexpand(rr, k * 2) == NULL)\n                    goto err;\n                bn_mul_recursive(rr-\u003ed, a-\u003ed, b-\u003ed, j, al - j, bl - j, t-\u003ed);\n            }\n            rr-\u003etop = top;\n            goto end;\n        }\n    }\n#endif                          /* BN_RECURSION */\n    if (bn_wexpand(rr, top) == NULL)\n        goto err;\n    rr-\u003etop = top;\n    bn_mul_normal(rr-\u003ed, a-\u003ed, al, b-\u003ed, bl);\n\n#if defined(BN_MUL_COMBA) || defined(BN_RECURSION)\n end:\n#endif\n    rr-\u003eneg = a-\u003eneg ^ b-\u003eneg;\n    rr-\u003eflags |= BN_FLG_FIXED_TOP;\n    if (r != rr \u0026\u0026 BN_copy(r, rr) == NULL)\n        goto err;\n\n    ret = 1;\n err:\n    bn_check_top(r);\n    BN_CTX_end(ctx);\n    return ret;\n}","filepath":"crypto/bn/bn_mul.c","line_number":507,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1"},"269853776":{"score":0.8322458,"function_name":"bn_mul_normal","code":"void bn_mul_normal(BN_ULONG *r, BN_ULONG *a, int na, BN_ULONG *b, int nb)\n\t{\n\tBN_ULONG *rr;\n\n#ifdef BN_COUNT\n\tfprintf(stderr,\" bn_mul_normal %d * %d\\n\",na,nb);\n#endif\n\n\tif (na \u003c nb)\n\t\t{\n\t\tint itmp;\n\t\tBN_ULONG *ltmp;\n\n\t\titmp=na; na=nb; nb=itmp;\n\t\tltmp=a;   a=b;   b=ltmp;\n\n\t\t}\n\trr= \u0026(r[na]);\n\tif (nb \u003c= 0)\n\t\t{\n\t\t(void)bn_mul_words(r,a,na,0);\n\t\treturn;\n\t\t}\n\telse\n\t\trr[0]=bn_mul_words(r,a,na,b[0]);\n\n\tfor (;;)\n\t\t{\n\t\tif (--nb \u003c= 0) return;\n\t\trr[1]=bn_mul_add_words(\u0026(r[1]),a,na,b[1]);\n\t\tif (--nb \u003c= 0) return;\n\t\trr[2]=bn_mul_add_words(\u0026(r[2]),a,na,b[2]);\n\t\tif (--nb \u003c= 0) return;\n\t\trr[3]=bn_mul_add_words(\u0026(r[3]),a,na,b[3]);\n\t\tif (--nb \u003c= 0) return;\n\t\trr[4]=bn_mul_add_words(\u0026(r[4]),a,na,b[4]);\n\t\trr+=4;\n\t\tr+=4;\n\t\tb+=4;\n\t\t}\n\t}","filepath":"lib/openssl-1.0.0d/crypto/bn/bn_mul.c","line_number":1104,"entry_url":"https://github.com/UWNetworksLab/arrakis.git","slot_name":"arrakis-release-2014-05-14"},"269854064":{"score":0.87151945,"function_name":"bn_mul_part_recursive","code":"void bn_mul_part_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n,\n\t     int tna, int tnb, BN_ULONG *t)\n\t{\n\tint i,j,n2=n*2;\n\tint c1,c2,neg;\n\tBN_ULONG ln,lo,*p;\n\n# ifdef BN_COUNT\n\tfprintf(stderr,\" bn_mul_part_recursive (%d%+d) * (%d%+d)\\n\",\n\t\tn, tna, n, tnb);\n# endif\n\tif (n \u003c 8)\n\t\t{\n\t\tbn_mul_normal(r,a,n+tna,b,n+tnb);\n\t\treturn;\n\t\t}\n\n\t/* r=(a[0]-a[1])*(b[1]-b[0]) */\n\tc1=bn_cmp_part_words(a,\u0026(a[n]),tna,n-tna);\n\tc2=bn_cmp_part_words(\u0026(b[n]),b,tnb,tnb-n);\n\tneg=0;\n\tswitch (c1*3+c2)\n\t\t{\n\tcase -4:\n\t\tbn_sub_part_words(t,      \u0026(a[n]),a,      tna,tna-n); /* - */\n\t\tbn_sub_part_words(\u0026(t[n]),b,      \u0026(b[n]),tnb,n-tnb); /* - */\n\t\tbreak;\n\tcase -3:\n\t\t/* break; */\n\tcase -2:\n\t\tbn_sub_part_words(t,      \u0026(a[n]),a,      tna,tna-n); /* - */\n\t\tbn_sub_part_words(\u0026(t[n]),\u0026(b[n]),b,      tnb,tnb-n); /* + */\n\t\tneg=1;\n\t\tbreak;\n\tcase -1:\n\tcase 0:\n\tcase 1:\n\t\t/* break; */\n\tcase 2:\n\t\tbn_sub_part_words(t,      a,      \u0026(a[n]),tna,n-tna); /* + */\n\t\tbn_sub_part_words(\u0026(t[n]),b,      \u0026(b[n]),tnb,n-tnb); /* - */\n\t\tneg=1;\n\t\tbreak;\n\tcase 3:\n\t\t/* break; */\n\tcase 4:\n\t\tbn_sub_part_words(t,      a,      \u0026(a[n]),tna,n-tna);\n\t\tbn_sub_part_words(\u0026(t[n]),\u0026(b[n]),b,      tnb,tnb-n);\n\t\tbreak;\n\t\t}\n\t\t/* The zero case isn't yet implemented here. The speedup\n\t\t   would probably be negligible. */\n# if 0\n\tif (n == 4)\n\t\t{\n\t\tbn_mul_comba4(\u0026(t[n2]),t,\u0026(t[n]));\n\t\tbn_mul_comba4(r,a,b);\n\t\tbn_mul_normal(\u0026(r[n2]),\u0026(a[n]),tn,\u0026(b[n]),tn);\n\t\tmemset(\u0026(r[n2+tn*2]),0,sizeof(BN_ULONG)*(n2-tn*2));\n\t\t}\n\telse\n# endif\n\tif (n == 8)\n\t\t{\n\t\tbn_mul_comba8(\u0026(t[n2]),t,\u0026(t[n]));\n\t\tbn_mul_comba8(r,a,b);\n\t\tbn_mul_normal(\u0026(r[n2]),\u0026(a[n]),tna,\u0026(b[n]),tnb);\n\t\tmemset(\u0026(r[n2+tna+tnb]),0,sizeof(BN_ULONG)*(n2-tna-tnb));\n\t\t}\n\telse\n\t\t{\n\t\tp= \u0026(t[n2*2]);\n\t\tbn_mul_recursive(\u0026(t[n2]),t,\u0026(t[n]),n,0,0,p);\n\t\tbn_mul_recursive(r,a,b,n,0,0,p);\n\t\ti=n/2;\n\t\t/* If there is only a bottom half to the number,\n\t\t * just do it */\n\t\tif (tna \u003e tnb)\n\t\t\tj = tna - i;\n\t\telse\n\t\t\tj = tnb - i;\n\t\tif (j == 0)\n\t\t\t{\n\t\t\tbn_mul_recursive(\u0026(r[n2]),\u0026(a[n]),\u0026(b[n]),\n\t\t\t\ti,tna-i,tnb-i,p);\n\t\t\tmemset(\u0026(r[n2+i*2]),0,sizeof(BN_ULONG)*(n2-i*2));\n\t\t\t}\n\t\telse if (j \u003e 0) /* eg, n == 16, i == 8 and tn == 11 */\n\t\t\t\t{\n\t\t\t\tbn_mul_part_recursive(\u0026(r[n2]),\u0026(a[n]),\u0026(b[n]),\n\t\t\t\t\ti,tna-i,tnb-i,p);\n\t\t\t\tmemset(\u0026(r[n2+tna+tnb]),0,\n\t\t\t\t\tsizeof(BN_ULONG)*(n2-tna-tnb));\n\t\t\t\t}\n\t\telse /* (j \u003c 0) eg, n == 16, i == 8 and tn == 5 */\n\t\t\t{\n\t\t\tmemset(\u0026(r[n2]),0,sizeof(BN_ULONG)*n2);\n\t\t\tif (tna \u003c BN_MUL_RECURSIVE_SIZE_NORMAL\n\t\t\t\t\u0026\u0026 tnb \u003c BN_MUL_RECURSIVE_SIZE_NORMAL)\n\t\t\t\t{\n\t\t\t\tbn_mul_normal(\u0026(r[n2]),\u0026(a[n]),tna,\u0026(b[n]),tnb);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tfor (;;)\n\t\t\t\t\t{\n\t\t\t\t\ti/=2;\n\t\t\t\t\t/* these simplified conditions work\n\t\t\t\t\t * exclusively because difference\n\t\t\t\t\t * between tna and tnb is 1 or 0 */\n\t\t\t\t\tif (i \u003c tna || i \u003c tnb)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tbn_mul_part_recursive(\u0026(r[n2]),\n\t\t\t\t\t\t\t\u0026(a[n]),\u0026(b[n]),\n\t\t\t\t\t\t\ti,tna-i,tnb-i,p);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (i == tna || i == tnb)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tbn_mul_recursive(\u0026(r[n2]),\n\t\t\t\t\t\t\t\u0026(a[n]),\u0026(b[n]),\n\t\t\t\t\t\t\ti,tna-i,tnb-i,p);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t/* t[32] holds (a[0]-a[1])*(b[1]-b[0]), c1 is the sign\n\t * r[10] holds (a[0]*b[0])\n\t * r[32] holds (b[1]*b[1])\n\t */\n\n\tc1=(int)(bn_add_words(t,r,\u0026(r[n2]),n2));\n\n\tif (neg) /* if t[32] is negative */\n\t\t{\n\t\tc1-=(int)(bn_sub_words(\u0026(t[n2]),t,\u0026(t[n2]),n2));\n\t\t}\n\telse\n\t\t{\n\t\t/* Might have a carry */\n\t\tc1+=(int)(bn_add_words(\u0026(t[n2]),\u0026(t[n2]),t,n2));\n\t\t}\n\n\t/* t[32] holds (a[0]-a[1])*(b[1]-b[0])+(a[0]*b[0])+(a[1]*b[1])\n\t * r[10] holds (a[0]*b[0])\n\t * r[32] holds (b[1]*b[1])\n\t * c1 holds the carry bits\n\t */\n\tc1+=(int)(bn_add_words(\u0026(r[n]),\u0026(r[n]),\u0026(t[n2]),n2));\n\tif (c1)\n\t\t{\n\t\tp= \u0026(r[n+n2]);\n\t\tlo= *p;\n\t\tln=(lo+c1)\u0026BN_MASK2;\n\t\t*p=ln;\n\n\t\t/* The overflow will stop before we over write\n\t\t * words we should not overwrite */\n\t\tif (ln \u003c (BN_ULONG)c1)\n\t\t\t{\n\t\t\tdo\t{\n\t\t\t\tp++;\n\t\t\t\tlo= *p;\n\t\t\t\tln=(lo+1)\u0026BN_MASK2;\n\t\t\t\t*p=ln;\n\t\t\t\t} while (ln == 0);\n\t\t\t}\n\t\t}\n\t}","filepath":"lib/openssl-1.0.0d/crypto/bn/bn_mul.c","line_number":550,"entry_url":"https://github.com/UWNetworksLab/arrakis.git","slot_name":"arrakis-release-2014-05-14"},"269855264":{"score":0.86998105,"function_name":"bn_mul_recursive","code":"void bn_mul_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n2,\n\tint dna, int dnb, BN_ULONG *t)\n\t{\n\tint n=n2/2,c1,c2;\n\tint tna=n+dna, tnb=n+dnb;\n\tunsigned int neg,zero;\n\tBN_ULONG ln,lo,*p;\n\n# ifdef BN_COUNT\n\tfprintf(stderr,\" bn_mul_recursive %d%+d * %d%+d\\n\",n2,dna,n2,dnb);\n# endif\n# ifdef BN_MUL_COMBA\n#  if 0\n\tif (n2 == 4)\n\t\t{\n\t\tbn_mul_comba4(r,a,b);\n\t\treturn;\n\t\t}\n#  endif\n\t/* Only call bn_mul_comba 8 if n2 == 8 and the\n\t * two arrays are complete [steve]\n\t */\n\tif (n2 == 8 \u0026\u0026 dna == 0 \u0026\u0026 dnb == 0)\n\t\t{\n\t\tbn_mul_comba8(r,a,b);\n\t\treturn; \n\t\t}\n# endif /* BN_MUL_COMBA */\n\t/* Else do normal multiply */\n\tif (n2 \u003c BN_MUL_RECURSIVE_SIZE_NORMAL)\n\t\t{\n\t\tbn_mul_normal(r,a,n2+dna,b,n2+dnb);\n\t\tif ((dna + dnb) \u003c 0)\n\t\t\tmemset(\u0026r[2*n2 + dna + dnb], 0,\n\t\t\t\tsizeof(BN_ULONG) * -(dna + dnb));\n\t\treturn;\n\t\t}\n\t/* r=(a[0]-a[1])*(b[1]-b[0]) */\n\tc1=bn_cmp_part_words(a,\u0026(a[n]),tna,n-tna);\n\tc2=bn_cmp_part_words(\u0026(b[n]),b,tnb,tnb-n);\n\tzero=neg=0;\n\tswitch (c1*3+c2)\n\t\t{\n\tcase -4:\n\t\tbn_sub_part_words(t,      \u0026(a[n]),a,      tna,tna-n); /* - */\n\t\tbn_sub_part_words(\u0026(t[n]),b,      \u0026(b[n]),tnb,n-tnb); /* - */\n\t\tbreak;\n\tcase -3:\n\t\tzero=1;\n\t\tbreak;\n\tcase -2:\n\t\tbn_sub_part_words(t,      \u0026(a[n]),a,      tna,tna-n); /* - */\n\t\tbn_sub_part_words(\u0026(t[n]),\u0026(b[n]),b,      tnb,tnb-n); /* + */\n\t\tneg=1;\n\t\tbreak;\n\tcase -1:\n\tcase 0:\n\tcase 1:\n\t\tzero=1;\n\t\tbreak;\n\tcase 2:\n\t\tbn_sub_part_words(t,      a,      \u0026(a[n]),tna,n-tna); /* + */\n\t\tbn_sub_part_words(\u0026(t[n]),b,      \u0026(b[n]),tnb,n-tnb); /* - */\n\t\tneg=1;\n\t\tbreak;\n\tcase 3:\n\t\tzero=1;\n\t\tbreak;\n\tcase 4:\n\t\tbn_sub_part_words(t,      a,      \u0026(a[n]),tna,n-tna);\n\t\tbn_sub_part_words(\u0026(t[n]),\u0026(b[n]),b,      tnb,tnb-n);\n\t\tbreak;\n\t\t}\n\n# ifdef BN_MUL_COMBA\n\tif (n == 4 \u0026\u0026 dna == 0 \u0026\u0026 dnb == 0) /* XXX: bn_mul_comba4 could take\n\t\t\t\t\t       extra args to do this well */\n\t\t{\n\t\tif (!zero)\n\t\t\tbn_mul_comba4(\u0026(t[n2]),t,\u0026(t[n]));\n\t\telse\n\t\t\tmemset(\u0026(t[n2]),0,8*sizeof(BN_ULONG));\n\t\t\n\t\tbn_mul_comba4(r,a,b);\n\t\tbn_mul_comba4(\u0026(r[n2]),\u0026(a[n]),\u0026(b[n]));\n\t\t}\n\telse if (n == 8 \u0026\u0026 dna == 0 \u0026\u0026 dnb == 0) /* XXX: bn_mul_comba8 could\n\t\t\t\t\t\t    take extra args to do this\n\t\t\t\t\t\t    well */\n\t\t{\n\t\tif (!zero)\n\t\t\tbn_mul_comba8(\u0026(t[n2]),t,\u0026(t[n]));\n\t\telse\n\t\t\tmemset(\u0026(t[n2]),0,16*sizeof(BN_ULONG));\n\t\t\n\t\tbn_mul_comba8(r,a,b);\n\t\tbn_mul_comba8(\u0026(r[n2]),\u0026(a[n]),\u0026(b[n]));\n\t\t}\n\telse\n# endif /* BN_MUL_COMBA */\n\t\t{\n\t\tp= \u0026(t[n2*2]);\n\t\tif (!zero)\n\t\t\tbn_mul_recursive(\u0026(t[n2]),t,\u0026(t[n]),n,0,0,p);\n\t\telse\n\t\t\tmemset(\u0026(t[n2]),0,n2*sizeof(BN_ULONG));\n\t\tbn_mul_recursive(r,a,b,n,0,0,p);\n\t\tbn_mul_recursive(\u0026(r[n2]),\u0026(a[n]),\u0026(b[n]),n,dna,dnb,p);\n\t\t}\n\n\t/* t[32] holds (a[0]-a[1])*(b[1]-b[0]), c1 is the sign\n\t * r[10] holds (a[0]*b[0])\n\t * r[32] holds (b[1]*b[1])\n\t */\n\n\tc1=(int)(bn_add_words(t,r,\u0026(r[n2]),n2));\n\n\tif (neg) /* if t[32] is negative */\n\t\t{\n\t\tc1-=(int)(bn_sub_words(\u0026(t[n2]),t,\u0026(t[n2]),n2));\n\t\t}\n\telse\n\t\t{\n\t\t/* Might have a carry */\n\t\tc1+=(int)(bn_add_words(\u0026(t[n2]),\u0026(t[n2]),t,n2));\n\t\t}\n\n\t/* t[32] holds (a[0]-a[1])*(b[1]-b[0])+(a[0]*b[0])+(a[1]*b[1])\n\t * r[10] holds (a[0]*b[0])\n\t * r[32] holds (b[1]*b[1])\n\t * c1 holds the carry bits\n\t */\n\tc1+=(int)(bn_add_words(\u0026(r[n]),\u0026(r[n]),\u0026(t[n2]),n2));\n\tif (c1)\n\t\t{\n\t\tp= \u0026(r[n+n2]);\n\t\tlo= *p;\n\t\tln=(lo+c1)\u0026BN_MASK2;\n\t\t*p=ln;\n\n\t\t/* The overflow will stop before we over write\n\t\t * words we should not overwrite */\n\t\tif (ln \u003c (BN_ULONG)c1)\n\t\t\t{\n\t\t\tdo\t{\n\t\t\t\tp++;\n\t\t\t\tlo= *p;\n\t\t\t\tln=(lo+1)\u0026BN_MASK2;\n\t\t\t\t*p=ln;\n\t\t\t\t} while (ln == 0);\n\t\t\t}\n\t\t}\n\t}","filepath":"lib/openssl-1.0.0d/crypto/bn/bn_mul.c","line_number":393,"entry_url":"https://github.com/UWNetworksLab/arrakis.git","slot_name":"arrakis-release-2014-05-14"},"269856288":{"score":0.8337414,"function_name":"BN_gcd","code":"int BN_gcd(BIGNUM *r, const BIGNUM *in_a, const BIGNUM *in_b, BN_CTX *ctx)\n{\n    BIGNUM *a, *b, *t;\n    int ret = 0;\n\n    bn_check_top(in_a);\n    bn_check_top(in_b);\n\n    BN_CTX_start(ctx);\n    a = BN_CTX_get(ctx);\n    b = BN_CTX_get(ctx);\n    if (b == NULL)\n        goto err;\n\n    if (BN_copy(a, in_a) == NULL)\n        goto err;\n    if (BN_copy(b, in_b) == NULL)\n        goto err;\n    a-\u003eneg = 0;\n    b-\u003eneg = 0;\n\n    if (BN_cmp(a, b) \u003c 0) {\n        t = a;\n        a = b;\n        b = t;\n    }\n    t = euclid(a, b);\n    if (t == NULL)\n        goto err;\n\n    if (BN_copy(r, t) == NULL)\n        goto err;\n    ret = 1;\n err:\n    BN_CTX_end(ctx);\n    bn_check_top(r);\n    return ret;\n}","filepath":"crypto/bn/bn_gcd.c","line_number":15,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre7"},"269856688":{"score":0.8198006,"function_name":"BN_mod_inverse","code":"BIGNUM *BN_mod_inverse(BIGNUM *in,\n                       const BIGNUM *a, const BIGNUM *n, BN_CTX *ctx)\n{\n    BIGNUM *rv;\n    int noinv;\n    rv = int_bn_mod_inverse(in, a, n, ctx, \u0026noinv);\n    if (noinv)\n        BNerr(BN_F_BN_MOD_INVERSE, BN_R_NO_INVERSE);\n    return rv;\n}","filepath":"crypto/bn/bn_gcd.c","line_number":124,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre7"},"269856768":{"score":0.88211995,"function_name":"BN_mod_inverse_no_branch","code":"static BIGNUM *BN_mod_inverse_no_branch(BIGNUM *in,\n                                        const BIGNUM *a, const BIGNUM *n,\n                                        BN_CTX *ctx)\n{\n    BIGNUM *A, *B, *X, *Y, *M, *D, *T, *R = NULL;\n    BIGNUM *ret = NULL;\n    int sign;\n\n    bn_check_top(a);\n    bn_check_top(n);\n\n    BN_CTX_start(ctx);\n    A = BN_CTX_get(ctx);\n    B = BN_CTX_get(ctx);\n    X = BN_CTX_get(ctx);\n    D = BN_CTX_get(ctx);\n    M = BN_CTX_get(ctx);\n    Y = BN_CTX_get(ctx);\n    T = BN_CTX_get(ctx);\n    if (T == NULL)\n        goto err;\n\n    if (in == NULL)\n        R = BN_new();\n    else\n        R = in;\n    if (R == NULL)\n        goto err;\n\n    BN_one(X);\n    BN_zero(Y);\n    if (BN_copy(B, a) == NULL)\n        goto err;\n    if (BN_copy(A, n) == NULL)\n        goto err;\n    A-\u003eneg = 0;\n\n    if (B-\u003eneg || (BN_ucmp(B, A) \u003e= 0)) {\n        /*\n         * Turn BN_FLG_CONSTTIME flag on, so that when BN_div is invoked,\n         * BN_div_no_branch will be called eventually.\n         */\n         {\n            BIGNUM local_B;\n            bn_init(\u0026local_B);\n            BN_with_flags(\u0026local_B, B, BN_FLG_CONSTTIME);\n            if (!BN_nnmod(B, \u0026local_B, A, ctx))\n                goto err;\n            /* Ensure local_B goes out of scope before any further use of B */\n        }\n    }\n    sign = -1;\n    /*-\n     * From  B = a mod |n|,  A = |n|  it follows that\n     *\n     *      0 \u003c= B \u003c A,\n     *     -sign*X*a  ==  B   (mod |n|),\n     *      sign*Y*a  ==  A   (mod |n|).\n     */\n\n    while (!BN_is_zero(B)) {\n        BIGNUM *tmp;\n\n        /*-\n         *      0 \u003c B \u003c A,\n         * (*) -sign*X*a  ==  B   (mod |n|),\n         *      sign*Y*a  ==  A   (mod |n|)\n         */\n\n        /*\n         * Turn BN_FLG_CONSTTIME flag on, so that when BN_div is invoked,\n         * BN_div_no_branch will be called eventually.\n         */\n        {\n            BIGNUM local_A;\n            bn_init(\u0026local_A);\n            BN_with_flags(\u0026local_A, A, BN_FLG_CONSTTIME);\n\n            /* (D, M) := (A/B, A%B) ... */\n            if (!BN_div(D, M, \u0026local_A, B, ctx))\n                goto err;\n            /* Ensure local_A goes out of scope before any further use of A */\n        }\n\n        /*-\n         * Now\n         *      A = D*B + M;\n         * thus we have\n         * (**)  sign*Y*a  ==  D*B + M   (mod |n|).\n         */\n\n        tmp = A;                /* keep the BIGNUM object, the value does not\n                                 * matter */\n\n        /* (A, B) := (B, A mod B) ... */\n        A = B;\n        B = M;\n        /* ... so we have  0 \u003c= B \u003c A  again */\n\n        /*-\n         * Since the former  M  is now  B  and the former  B  is now  A,\n         * (**) translates into\n         *       sign*Y*a  ==  D*A + B    (mod |n|),\n         * i.e.\n         *       sign*Y*a - D*A  ==  B    (mod |n|).\n         * Similarly, (*) translates into\n         *      -sign*X*a  ==  A          (mod |n|).\n         *\n         * Thus,\n         *   sign*Y*a + D*sign*X*a  ==  B  (mod |n|),\n         * i.e.\n         *        sign*(Y + D*X)*a  ==  B  (mod |n|).\n         *\n         * So if we set  (X, Y, sign) := (Y + D*X, X, -sign), we arrive back at\n         *      -sign*X*a  ==  B   (mod |n|),\n         *       sign*Y*a  ==  A   (mod |n|).\n         * Note that  X  and  Y  stay non-negative all the time.\n         */\n\n        if (!BN_mul(tmp, D, X, ctx))\n            goto err;\n        if (!BN_add(tmp, tmp, Y))\n            goto err;\n\n        M = Y;                  /* keep the BIGNUM object, the value does not\n                                 * matter */\n        Y = X;\n        X = tmp;\n        sign = -sign;\n    }\n\n    /*-\n     * The while loop (Euclid's algorithm) ends when\n     *      A == gcd(a,n);\n     * we have\n     *       sign*Y*a  ==  A  (mod |n|),\n     * where  Y  is non-negative.\n     */\n\n    if (sign \u003c 0) {\n        if (!BN_sub(Y, n, Y))\n            goto err;\n    }\n    /* Now  Y*a  ==  A  (mod |n|).  */\n\n    if (BN_is_one(A)) {\n        /* Y*a == 1  (mod |n|) */\n        if (!Y-\u003eneg \u0026\u0026 BN_ucmp(Y, n) \u003c 0) {\n            if (!BN_copy(R, Y))\n                goto err;\n        } else {\n            if (!BN_nnmod(R, Y, n, ctx))\n                goto err;\n        }\n    } else {\n        BNerr(BN_F_BN_MOD_INVERSE_NO_BRANCH, BN_R_NO_INVERSE);\n        goto err;\n    }\n    ret = R;\n err:\n    if ((ret == NULL) \u0026\u0026 (in == NULL))\n        BN_free(R);\n    BN_CTX_end(ctx);\n    bn_check_top(ret);\n    return ret;\n}","filepath":"crypto/bn/bn_gcd.c","line_number":458,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre7"},"269857440":{"score":0.888904,"function_name":"int_bn_mod_inverse","code":"BIGNUM *int_bn_mod_inverse(BIGNUM *in,\n                           const BIGNUM *a, const BIGNUM *n, BN_CTX *ctx,\n                           int *pnoinv)\n{\n    BIGNUM *A, *B, *X, *Y, *M, *D, *T, *R = NULL;\n    BIGNUM *ret = NULL;\n    int sign;\n\n    /* This is invalid input so we don't worry about constant time here */\n    if (BN_abs_is_word(n, 1) || BN_is_zero(n)) {\n        if (pnoinv != NULL)\n            *pnoinv = 1;\n        return NULL;\n    }\n\n    if (pnoinv != NULL)\n        *pnoinv = 0;\n\n    if ((BN_get_flags(a, BN_FLG_CONSTTIME) != 0)\n        || (BN_get_flags(n, BN_FLG_CONSTTIME) != 0)) {\n        return BN_mod_inverse_no_branch(in, a, n, ctx);\n    }\n\n    bn_check_top(a);\n    bn_check_top(n);\n\n    BN_CTX_start(ctx);\n    A = BN_CTX_get(ctx);\n    B = BN_CTX_get(ctx);\n    X = BN_CTX_get(ctx);\n    D = BN_CTX_get(ctx);\n    M = BN_CTX_get(ctx);\n    Y = BN_CTX_get(ctx);\n    T = BN_CTX_get(ctx);\n    if (T == NULL)\n        goto err;\n\n    if (in == NULL)\n        R = BN_new();\n    else\n        R = in;\n    if (R == NULL)\n        goto err;\n\n    BN_one(X);\n    BN_zero(Y);\n    if (BN_copy(B, a) == NULL)\n        goto err;\n    if (BN_copy(A, n) == NULL)\n        goto err;\n    A-\u003eneg = 0;\n    if (B-\u003eneg || (BN_ucmp(B, A) \u003e= 0)) {\n        if (!BN_nnmod(B, B, A, ctx))\n            goto err;\n    }\n    sign = -1;\n    /*-\n     * From  B = a mod |n|,  A = |n|  it follows that\n     *\n     *      0 \u003c= B \u003c A,\n     *     -sign*X*a  ==  B   (mod |n|),\n     *      sign*Y*a  ==  A   (mod |n|).\n     */\n\n    if (BN_is_odd(n) \u0026\u0026 (BN_num_bits(n) \u003c= 2048)) {\n        /*\n         * Binary inversion algorithm; requires odd modulus. This is faster\n         * than the general algorithm if the modulus is sufficiently small\n         * (about 400 .. 500 bits on 32-bit systems, but much more on 64-bit\n         * systems)\n         */\n        int shift;\n\n        while (!BN_is_zero(B)) {\n            /*-\n             *      0 \u003c B \u003c |n|,\n             *      0 \u003c A \u003c= |n|,\n             * (1) -sign*X*a  ==  B   (mod |n|),\n             * (2)  sign*Y*a  ==  A   (mod |n|)\n             */\n\n            /*\n             * Now divide B by the maximum possible power of two in the\n             * integers, and divide X by the same value mod |n|. When we're\n             * done, (1) still holds.\n             */\n            shift = 0;\n            while (!BN_is_bit_set(B, shift)) { /* note that 0 \u003c B */\n                shift++;\n\n                if (BN_is_odd(X)) {\n                    if (!BN_uadd(X, X, n))\n                        goto err;\n                }\n                /*\n                 * now X is even, so we can easily divide it by two\n                 */\n                if (!BN_rshift1(X, X))\n                    goto err;\n            }\n            if (shift \u003e 0) {\n                if (!BN_rshift(B, B, shift))\n                    goto err;\n            }\n\n            /*\n             * Same for A and Y.  Afterwards, (2) still holds.\n             */\n            shift = 0;\n            while (!BN_is_bit_set(A, shift)) { /* note that 0 \u003c A */\n                shift++;\n\n                if (BN_is_odd(Y)) {\n                    if (!BN_uadd(Y, Y, n))\n                        goto err;\n                }\n                /* now Y is even */\n                if (!BN_rshift1(Y, Y))\n                    goto err;\n            }\n            if (shift \u003e 0) {\n                if (!BN_rshift(A, A, shift))\n                    goto err;\n            }\n\n            /*-\n             * We still have (1) and (2).\n             * Both  A  and  B  are odd.\n             * The following computations ensure that\n             *\n             *     0 \u003c= B \u003c |n|,\n             *      0 \u003c A \u003c |n|,\n             * (1) -sign*X*a  ==  B   (mod |n|),\n             * (2)  sign*Y*a  ==  A   (mod |n|),\n             *\n             * and that either  A  or  B  is even in the next iteration.\n             */\n            if (BN_ucmp(B, A) \u003e= 0) {\n                /* -sign*(X + Y)*a == B - A  (mod |n|) */\n                if (!BN_uadd(X, X, Y))\n                    goto err;\n                /*\n                 * NB: we could use BN_mod_add_quick(X, X, Y, n), but that\n                 * actually makes the algorithm slower\n                 */\n                if (!BN_usub(B, B, A))\n                    goto err;\n            } else {\n                /*  sign*(X + Y)*a == A - B  (mod |n|) */\n                if (!BN_uadd(Y, Y, X))\n                    goto err;\n                /*\n                 * as above, BN_mod_add_quick(Y, Y, X, n) would slow things down\n                 */\n                if (!BN_usub(A, A, B))\n                    goto err;\n            }\n        }\n    } else {\n        /* general inversion algorithm */\n\n        while (!BN_is_zero(B)) {\n            BIGNUM *tmp;\n\n            /*-\n             *      0 \u003c B \u003c A,\n             * (*) -sign*X*a  ==  B   (mod |n|),\n             *      sign*Y*a  ==  A   (mod |n|)\n             */\n\n            /* (D, M) := (A/B, A%B) ... */\n            if (BN_num_bits(A) == BN_num_bits(B)) {\n                if (!BN_one(D))\n                    goto err;\n                if (!BN_sub(M, A, B))\n                    goto err;\n            } else if (BN_num_bits(A) == BN_num_bits(B) + 1) {\n                /* A/B is 1, 2, or 3 */\n                if (!BN_lshift1(T, B))\n                    goto err;\n                if (BN_ucmp(A, T) \u003c 0) {\n                    /* A \u003c 2*B, so D=1 */\n                    if (!BN_one(D))\n                        goto err;\n                    if (!BN_sub(M, A, B))\n                        goto err;\n                } else {\n                    /* A \u003e= 2*B, so D=2 or D=3 */\n                    if (!BN_sub(M, A, T))\n                        goto err;\n                    if (!BN_add(D, T, B))\n                        goto err; /* use D (:= 3*B) as temp */\n                    if (BN_ucmp(A, D) \u003c 0) {\n                        /* A \u003c 3*B, so D=2 */\n                        if (!BN_set_word(D, 2))\n                            goto err;\n                        /*\n                         * M (= A - 2*B) already has the correct value\n                         */\n                    } else {\n                        /* only D=3 remains */\n                        if (!BN_set_word(D, 3))\n                            goto err;\n                        /*\n                         * currently M = A - 2*B, but we need M = A - 3*B\n                         */\n                        if (!BN_sub(M, M, B))\n                            goto err;\n                    }\n                }\n            } else {\n                if (!BN_div(D, M, A, B, ctx))\n                    goto err;\n            }\n\n            /*-\n             * Now\n             *      A = D*B + M;\n             * thus we have\n             * (**)  sign*Y*a  ==  D*B + M   (mod |n|).\n             */\n\n            tmp = A;    /* keep the BIGNUM object, the value does not matter */\n\n            /* (A, B) := (B, A mod B) ... */\n            A = B;\n            B = M;\n            /* ... so we have  0 \u003c= B \u003c A  again */\n\n            /*-\n             * Since the former  M  is now  B  and the former  B  is now  A,\n             * (**) translates into\n             *       sign*Y*a  ==  D*A + B    (mod |n|),\n             * i.e.\n             *       sign*Y*a - D*A  ==  B    (mod |n|).\n             * Similarly, (*) translates into\n             *      -sign*X*a  ==  A          (mod |n|).\n             *\n             * Thus,\n             *   sign*Y*a + D*sign*X*a  ==  B  (mod |n|),\n             * i.e.\n             *        sign*(Y + D*X)*a  ==  B  (mod |n|).\n             *\n             * So if we set  (X, Y, sign) := (Y + D*X, X, -sign), we arrive back at\n             *      -sign*X*a  ==  B   (mod |n|),\n             *       sign*Y*a  ==  A   (mod |n|).\n             * Note that  X  and  Y  stay non-negative all the time.\n             */\n\n            /*\n             * most of the time D is very small, so we can optimize tmp := D*X+Y\n             */\n            if (BN_is_one(D)) {\n                if (!BN_add(tmp, X, Y))\n                    goto err;\n            } else {\n                if (BN_is_word(D, 2)) {\n                    if (!BN_lshift1(tmp, X))\n                        goto err;\n                } else if (BN_is_word(D, 4)) {\n                    if (!BN_lshift(tmp, X, 2))\n                        goto err;\n                } else if (D-\u003etop == 1) {\n                    if (!BN_copy(tmp, X))\n                        goto err;\n                    if (!BN_mul_word(tmp, D-\u003ed[0]))\n                        goto err;\n                } else {\n                    if (!BN_mul(tmp, D, X, ctx))\n                        goto err;\n                }\n                if (!BN_add(tmp, tmp, Y))\n                    goto err;\n            }\n\n            M = Y;      /* keep the BIGNUM object, the value does not matter */\n            Y = X;\n            X = tmp;\n            sign = -sign;\n        }\n    }\n\n    /*-\n     * The while loop (Euclid's algorithm) ends when\n     *      A == gcd(a,n);\n     * we have\n     *       sign*Y*a  ==  A  (mod |n|),\n     * where  Y  is non-negative.\n     */\n\n    if (sign \u003c 0) {\n        if (!BN_sub(Y, n, Y))\n            goto err;\n    }\n    /* Now  Y*a  ==  A  (mod |n|).  */\n\n    if (BN_is_one(A)) {\n        /* Y*a == 1  (mod |n|) */\n        if (!Y-\u003eneg \u0026\u0026 BN_ucmp(Y, n) \u003c 0) {\n            if (!BN_copy(R, Y))\n                goto err;\n        } else {\n            if (!BN_nnmod(R, Y, n, ctx))\n                goto err;\n        }\n    } else {\n        if (pnoinv)\n            *pnoinv = 1;\n        goto err;\n    }\n    ret = R;\n err:\n    if ((ret == NULL) \u0026\u0026 (in == NULL))\n        BN_free(R);\n    BN_CTX_end(ctx);\n    bn_check_top(ret);\n    return ret;\n}","filepath":"crypto/bn/bn_gcd.c","line_number":135,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre7"},"269859024":{"score":0.7734401,"function_name":"BN_BLINDING_convert_ex","code":"int BN_BLINDING_convert_ex(BIGNUM *n, BIGNUM *r, BN_BLINDING *b, BN_CTX *ctx)\n{\n    int ret = 1;\n\n    bn_check_top(n);\n\n    if ((b-\u003eA == NULL) || (b-\u003eAi == NULL)) {\n        BNerr(BN_F_BN_BLINDING_CONVERT_EX, BN_R_NOT_INITIALIZED);\n        return (0);\n    }\n\n    if (b-\u003ecounter == -1)\n        /* Fresh blinding, doesn't need updating. */\n        b-\u003ecounter = 0;\n    else if (!BN_BLINDING_update(b, ctx))\n        return (0);\n\n    if (r != NULL \u0026\u0026 (BN_copy(r, b-\u003eAi) == NULL))\n        return 0;\n\n    if (b-\u003em_ctx != NULL)\n        ret = BN_mod_mul_montgomery(n, n, b-\u003eA, b-\u003em_ctx, ctx);\n    else\n        ret = BN_mod_mul(n, n, b-\u003eA, b-\u003emod, ctx);\n\n    return ret;\n}","filepath":"crypto/bn/bn_blind.c","line_number":135,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0j"},"269859344":{"score":0.81262064,"function_name":"BN_BLINDING_create_param","code":"BN_BLINDING *BN_BLINDING_create_param(BN_BLINDING *b,\n                                      const BIGNUM *e, BIGNUM *m, BN_CTX *ctx,\n                                      int (*bn_mod_exp) (BIGNUM *r,\n                                                         const BIGNUM *a,\n                                                         const BIGNUM *p,\n                                                         const BIGNUM *m,\n                                                         BN_CTX *ctx,\n                                                         BN_MONT_CTX *m_ctx),\n                                      BN_MONT_CTX *m_ctx)\n{\n    int retry_counter = 32;\n    BN_BLINDING *ret = NULL;\n\n    if (b == NULL)\n        ret = BN_BLINDING_new(NULL, NULL, m);\n    else\n        ret = b;\n\n    if (ret == NULL)\n        goto err;\n\n    if (ret-\u003eA == NULL \u0026\u0026 (ret-\u003eA = BN_new()) == NULL)\n        goto err;\n    if (ret-\u003eAi == NULL \u0026\u0026 (ret-\u003eAi = BN_new()) == NULL)\n        goto err;\n\n    if (e != NULL) {\n        BN_free(ret-\u003ee);\n        ret-\u003ee = BN_dup(e);\n    }\n    if (ret-\u003ee == NULL)\n        goto err;\n\n    if (bn_mod_exp != NULL)\n        ret-\u003ebn_mod_exp = bn_mod_exp;\n    if (m_ctx != NULL)\n        ret-\u003em_ctx = m_ctx;\n\n    do {\n        int rv;\n        if (!BN_rand_range(ret-\u003eA, ret-\u003emod))\n            goto err;\n        if (int_bn_mod_inverse(ret-\u003eAi, ret-\u003eA, ret-\u003emod, ctx, \u0026rv))\n            break;\n\n        /*\n         * this should almost never happen for good RSA keys\n         */\n        if (!rv)\n            goto err;\n\n        if (retry_counter-- == 0) {\n            BNerr(BN_F_BN_BLINDING_CREATE_PARAM, BN_R_TOO_MANY_ITERATIONS);\n            goto err;\n        }\n    } while (1);\n\n    if (ret-\u003ebn_mod_exp != NULL \u0026\u0026 ret-\u003em_ctx != NULL) {\n        if (!ret-\u003ebn_mod_exp(ret-\u003eA, ret-\u003eA, ret-\u003ee, ret-\u003emod, ctx, ret-\u003em_ctx))\n            goto err;\n    } else {\n        if (!BN_mod_exp(ret-\u003eA, ret-\u003eA, ret-\u003ee, ret-\u003emod, ctx))\n            goto err;\n    }\n\n    if (ret-\u003em_ctx != NULL) {\n        if (!bn_to_mont_fixed_top(ret-\u003eAi, ret-\u003eAi, ret-\u003em_ctx, ctx)\n            || !bn_to_mont_fixed_top(ret-\u003eA, ret-\u003eA, ret-\u003em_ctx, ctx))\n            goto err;\n    }\n\n    return ret;\n err:\n    if (b == NULL) {\n        BN_BLINDING_free(ret);\n        ret = NULL;\n    }\n\n    return ret;\n}","filepath":"crypto/bn/bn_blind.c","line_number":234,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0j"},"269859952":{"score":0.90708315,"function_name":"BN_BLINDING_free","code":"void BN_BLINDING_free(BN_BLINDING *r)\n{\n    if (r == NULL)\n        return;\n\n    BN_free(r-\u003eA);\n    BN_free(r-\u003eAi);\n    BN_free(r-\u003ee);\n    BN_free(r-\u003emod);\n    CRYPTO_THREAD_lock_free(r-\u003elock);\n    OPENSSL_free(r);\n}","filepath":"crypto/bn/bn_blind.c","line_number":81,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0j"},"269860032":{"score":0.8831621,"function_name":"BN_BLINDING_invert_ex","code":"int BN_BLINDING_invert_ex(BIGNUM *n, const BIGNUM *r, BN_BLINDING *b,\n                          BN_CTX *ctx)\n{\n    int ret;\n\n    bn_check_top(n);\n\n    if (r == NULL \u0026\u0026 (r = b-\u003eAi) == NULL) {\n        BNerr(BN_F_BN_BLINDING_INVERT_EX, BN_R_NOT_INITIALIZED);\n        return 0;\n    }\n\n    if (b-\u003em_ctx != NULL) {\n        /* ensure that BN_mod_mul_montgomery takes pre-defined path */\n        if (n-\u003edmax \u003e= r-\u003etop) {\n            size_t i, rtop = r-\u003etop, ntop = n-\u003etop;\n            BN_ULONG mask;\n\n            for (i = 0; i \u003c rtop; i++) {\n                mask = (BN_ULONG)0 - ((i - ntop) \u003e\u003e (8 * sizeof(i) - 1));\n                n-\u003ed[i] \u0026= mask;\n            }\n            mask = (BN_ULONG)0 - ((rtop - ntop) \u003e\u003e (8 * sizeof(ntop) - 1));\n            /* always true, if (rtop \u003e= ntop) n-\u003etop = r-\u003etop; */\n            n-\u003etop = (int)(rtop \u0026 ~mask) | (ntop \u0026 mask);\n            n-\u003eflags |= (BN_FLG_FIXED_TOP \u0026 ~mask);\n        }\n        ret = BN_mod_mul_montgomery(n, n, r, b-\u003em_ctx, ctx);\n    } else {\n        ret = BN_mod_mul(n, n, r, b-\u003emod, ctx);\n    }\n\n    bn_check_top(n);\n    return (ret);\n}","filepath":"crypto/bn/bn_blind.c","line_number":168,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0j"},"269860864":{"score":0.9211741,"function_name":"OPENSSL_sk_insert","code":"int OPENSSL_sk_insert(OPENSSL_STACK *st, const void *data, int loc)\n{\n    if (st == NULL || st-\u003enum == max_nodes)\n        return 0;\n\n    if (!sk_reserve(st, 1, 0))\n        return 0;\n\n    if ((loc \u003e= st-\u003enum) || (loc \u003c 0)) {\n        st-\u003edata[st-\u003enum] = data;\n    } else {\n        memmove(\u0026st-\u003edata[loc + 1], \u0026st-\u003edata[loc],\n                sizeof(st-\u003edata[0]) * (st-\u003enum - loc));\n        st-\u003edata[loc] = data;\n    }\n    st-\u003enum++;\n    st-\u003esorted = 0;\n    return st-\u003enum;\n}","filepath":"crypto/stack/stack.c","line_number":236,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269861120":{"score":0.9266129,"function_name":"OPENSSL_sk_new_reserve","code":"OPENSSL_STACK *OPENSSL_sk_new_reserve(OPENSSL_sk_compfunc c, int n)\n{\n    OPENSSL_STACK *st = OPENSSL_zalloc(sizeof(OPENSSL_STACK));\n\n    if (st == NULL)\n        return NULL;\n\n    st-\u003ecomp = c;\n\n    if (n \u003c= 0)\n        return st;\n\n    if (!sk_reserve(st, n, 1)) {\n        OPENSSL_sk_free(st);\n        return NULL;\n    }\n\n    return st;\n}","filepath":"crypto/stack/stack.c","line_number":206,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269861248":{"score":0.84530795,"function_name":"OPENSSL_sk_pop_free","code":"void OPENSSL_sk_pop_free(OPENSSL_STACK *st, OPENSSL_sk_freefunc func)\n{\n    int i;\n\n    if (st == NULL)\n        return;\n    for (i = 0; i \u003c st-\u003enum; i++)\n        if (st-\u003edata[i] != NULL)\n            func((char *)st-\u003edata[i]);\n    OPENSSL_sk_free(st);\n}","filepath":"crypto/stack/stack.c","line_number":359,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269861376":{"score":0.91812444,"function_name":"OPENSSL_sk_reserve","code":"int OPENSSL_sk_reserve(OPENSSL_STACK *st, int n)\n{\n    if (st == NULL)\n        return 0;\n\n    if (n \u003c 0)\n        return 1;\n    return sk_reserve(st, n, 1);\n}","filepath":"crypto/stack/stack.c","line_number":226,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269861424":{"score":0.95836306,"function_name":"OPENSSL_sk_set","code":"void *OPENSSL_sk_set(OPENSSL_STACK *st, int i, const void *data)\n{\n    if (st == NULL || i \u003c 0 || i \u003e= st-\u003enum)\n        return NULL;\n    st-\u003edata[i] = data;\n    st-\u003esorted = 0;\n    return (void *)st-\u003edata[i];\n}","filepath":"crypto/stack/stack.c","line_number":391,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269861584":{"score":0.9691279,"function_name":"OPENSSL_sk_sort","code":"void OPENSSL_sk_sort(OPENSSL_STACK *st)\n{\n    if (st != NULL \u0026\u0026 !st-\u003esorted \u0026\u0026 st-\u003ecomp != NULL) {\n        if (st-\u003enum \u003e 1)\n            qsort(st-\u003edata, st-\u003enum, sizeof(void *), st-\u003ecomp);\n        st-\u003esorted = 1; /* empty or single-element stack is considered sorted */\n    }\n}","filepath":"crypto/stack/stack.c","line_number":400,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269861744":{"score":0.88866246,"function_name":"internal_find","code":"static int internal_find(OPENSSL_STACK *st, const void *data,\n                         int ret_val_options)\n{\n    const void *r;\n    int i;\n\n    if (st == NULL || st-\u003enum == 0)\n        return -1;\n\n    if (st-\u003ecomp == NULL) {\n        for (i = 0; i \u003c st-\u003enum; i++)\n            if (st-\u003edata[i] == data)\n                return i;\n        return -1;\n    }\n\n    if (!st-\u003esorted) {\n        if (st-\u003enum \u003e 1)\n            qsort(st-\u003edata, st-\u003enum, sizeof(void *), st-\u003ecomp);\n        st-\u003esorted = 1; /* empty or single-element stack is considered sorted */\n    }\n    if (data == NULL)\n        return -1;\n    r = ossl_bsearch(\u0026data, st-\u003edata, st-\u003enum, sizeof(void *), st-\u003ecomp,\n                     ret_val_options);\n\n    return r == NULL ? -1 : (int)((const void **)r - st-\u003edata);\n}","filepath":"crypto/stack/stack.c","line_number":286,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269861888":{"score":0.9141441,"function_name":"sk_reserve","code":"static int sk_reserve(OPENSSL_STACK *st, int n, int exact)\n{\n    const void **tmpdata;\n    int num_alloc;\n\n    /* Check to see the reservation isn't exceeding the hard limit */\n    if (n \u003e max_nodes - st-\u003enum)\n        return 0;\n\n    /* Figure out the new size */\n    num_alloc = st-\u003enum + n;\n    if (num_alloc \u003c min_nodes)\n        num_alloc = min_nodes;\n\n    /* If |st-\u003edata| allocation was postponed */\n    if (st-\u003edata == NULL) {\n        /*\n         * At this point, |st-\u003enum_alloc| and |st-\u003enum| are 0;\n         * so |num_alloc| value is |n| or |min_nodes| if greater than |n|.\n         */\n        if ((st-\u003edata = OPENSSL_zalloc(sizeof(void *) * num_alloc)) == NULL) {\n            ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);\n            return 0;\n        }\n        st-\u003enum_alloc = num_alloc;\n        return 1;\n    }\n\n    if (!exact) {\n        if (num_alloc \u003c= st-\u003enum_alloc)\n            return 1;\n        num_alloc = compute_growth(num_alloc, st-\u003enum_alloc);\n        if (num_alloc == 0)\n            return 0;\n    } else if (num_alloc == st-\u003enum_alloc) {\n        return 1;\n    }\n\n    tmpdata = OPENSSL_realloc((void *)st-\u003edata, sizeof(void *) * num_alloc);\n    if (tmpdata == NULL)\n        return 0;\n\n    st-\u003edata = tmpdata;\n    st-\u003enum_alloc = num_alloc;\n    return 1;\n}","filepath":"crypto/stack/stack.c","line_number":159,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269862128":{"score":0.9213244,"function_name":"rsa_ossl_public_encrypt","code":"static int rsa_ossl_public_encrypt(int flen, const unsigned char *from,\n                                  unsigned char *to, RSA *rsa, int padding)\n{\n    BIGNUM *f, *ret;\n    int i, num = 0, r = -1;\n    unsigned char *buf = NULL;\n    BN_CTX *ctx = NULL;\n\n    if (BN_num_bits(rsa-\u003en) \u003e OPENSSL_RSA_MAX_MODULUS_BITS) {\n        RSAerr(RSA_F_RSA_OSSL_PUBLIC_ENCRYPT, RSA_R_MODULUS_TOO_LARGE);\n        return -1;\n    }\n\n    if (BN_ucmp(rsa-\u003en, rsa-\u003ee) \u003c= 0) {\n        RSAerr(RSA_F_RSA_OSSL_PUBLIC_ENCRYPT, RSA_R_BAD_E_VALUE);\n        return -1;\n    }\n\n    /* for large moduli, enforce exponent limit */\n    if (BN_num_bits(rsa-\u003en) \u003e OPENSSL_RSA_SMALL_MODULUS_BITS) {\n        if (BN_num_bits(rsa-\u003ee) \u003e OPENSSL_RSA_MAX_PUBEXP_BITS) {\n            RSAerr(RSA_F_RSA_OSSL_PUBLIC_ENCRYPT, RSA_R_BAD_E_VALUE);\n            return -1;\n        }\n    }\n\n    if ((ctx = BN_CTX_new()) == NULL)\n        goto err;\n    BN_CTX_start(ctx);\n    f = BN_CTX_get(ctx);\n    ret = BN_CTX_get(ctx);\n    num = BN_num_bytes(rsa-\u003en);\n    buf = OPENSSL_malloc(num);\n    if (ret == NULL || buf == NULL) {\n        RSAerr(RSA_F_RSA_OSSL_PUBLIC_ENCRYPT, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    switch (padding) {\n    case RSA_PKCS1_PADDING:\n        i = RSA_padding_add_PKCS1_type_2(buf, num, from, flen);\n        break;\n    case RSA_PKCS1_OAEP_PADDING:\n        i = RSA_padding_add_PKCS1_OAEP(buf, num, from, flen, NULL, 0);\n        break;\n    case RSA_SSLV23_PADDING:\n        i = RSA_padding_add_SSLv23(buf, num, from, flen);\n        break;\n    case RSA_NO_PADDING:\n        i = RSA_padding_add_none(buf, num, from, flen);\n        break;\n    default:\n        RSAerr(RSA_F_RSA_OSSL_PUBLIC_ENCRYPT, RSA_R_UNKNOWN_PADDING_TYPE);\n        goto err;\n    }\n    if (i \u003c= 0)\n        goto err;\n\n    if (BN_bin2bn(buf, num, f) == NULL)\n        goto err;\n\n    if (BN_ucmp(f, rsa-\u003en) \u003e= 0) {\n        /* usually the padding functions would catch this */\n        RSAerr(RSA_F_RSA_OSSL_PUBLIC_ENCRYPT,\n               RSA_R_DATA_TOO_LARGE_FOR_MODULUS);\n        goto err;\n    }\n\n    if (rsa-\u003eflags \u0026 RSA_FLAG_CACHE_PUBLIC)\n        if (!BN_MONT_CTX_set_locked(\u0026rsa-\u003e_method_mod_n, rsa-\u003elock,\n                                    rsa-\u003en, ctx))\n            goto err;\n\n    if (!rsa-\u003emeth-\u003ebn_mod_exp(ret, f, rsa-\u003ee, rsa-\u003en, ctx,\n                               rsa-\u003e_method_mod_n))\n        goto err;\n\n    /*\n     * BN_bn2binpad puts in leading 0 bytes if the number is less than\n     * the length of the modulus.\n     */\n    r = BN_bn2binpad(ret, to, num);\n err:\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    OPENSSL_clear_free(buf, num);\n    return r;\n}","filepath":"crypto/rsa/rsa_ossl.c","line_number":68,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1c"},"269862736":{"score":0.91725785,"function_name":"rsa_ossl_private_encrypt","code":"static int rsa_ossl_private_encrypt(int flen, const unsigned char *from,\n                                   unsigned char *to, RSA *rsa, int padding)\n{\n    BIGNUM *f, *ret, *res;\n    int i, num = 0, r = -1;\n    unsigned char *buf = NULL;\n    BN_CTX *ctx = NULL;\n    int local_blinding = 0;\n    /*\n     * Used only if the blinding structure is shared. A non-NULL unblind\n     * instructs rsa_blinding_convert() and rsa_blinding_invert() to store\n     * the unblinding factor outside the blinding structure.\n     */\n    BIGNUM *unblind = NULL;\n    BN_BLINDING *blinding = NULL;\n\n    if ((ctx = BN_CTX_new()) == NULL)\n        goto err;\n    BN_CTX_start(ctx);\n    f = BN_CTX_get(ctx);\n    ret = BN_CTX_get(ctx);\n    num = BN_num_bytes(rsa-\u003en);\n    buf = OPENSSL_malloc(num);\n    if (ret == NULL || buf == NULL) {\n        RSAerr(RSA_F_RSA_OSSL_PRIVATE_ENCRYPT, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    switch (padding) {\n    case RSA_PKCS1_PADDING:\n        i = RSA_padding_add_PKCS1_type_1(buf, num, from, flen);\n        break;\n    case RSA_X931_PADDING:\n        i = RSA_padding_add_X931(buf, num, from, flen);\n        break;\n    case RSA_NO_PADDING:\n        i = RSA_padding_add_none(buf, num, from, flen);\n        break;\n    case RSA_SSLV23_PADDING:\n    default:\n        RSAerr(RSA_F_RSA_OSSL_PRIVATE_ENCRYPT, RSA_R_UNKNOWN_PADDING_TYPE);\n        goto err;\n    }\n    if (i \u003c= 0)\n        goto err;\n\n    if (BN_bin2bn(buf, num, f) == NULL)\n        goto err;\n\n    if (BN_ucmp(f, rsa-\u003en) \u003e= 0) {\n        /* usually the padding functions would catch this */\n        RSAerr(RSA_F_RSA_OSSL_PRIVATE_ENCRYPT,\n               RSA_R_DATA_TOO_LARGE_FOR_MODULUS);\n        goto err;\n    }\n\n    if (rsa-\u003eflags \u0026 RSA_FLAG_CACHE_PUBLIC)\n        if (!BN_MONT_CTX_set_locked(\u0026rsa-\u003e_method_mod_n, rsa-\u003elock,\n                                    rsa-\u003en, ctx))\n            goto err;\n\n    if (!(rsa-\u003eflags \u0026 RSA_FLAG_NO_BLINDING)) {\n        blinding = rsa_get_blinding(rsa, \u0026local_blinding, ctx);\n        if (blinding == NULL) {\n            RSAerr(RSA_F_RSA_OSSL_PRIVATE_ENCRYPT, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n    }\n\n    if (blinding != NULL) {\n        if (!local_blinding \u0026\u0026 ((unblind = BN_CTX_get(ctx)) == NULL)) {\n            RSAerr(RSA_F_RSA_OSSL_PRIVATE_ENCRYPT, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        if (!rsa_blinding_convert(blinding, f, unblind, ctx))\n            goto err;\n    }\n\n    if ((rsa-\u003eflags \u0026 RSA_FLAG_EXT_PKEY) ||\n        (rsa-\u003eversion == RSA_ASN1_VERSION_MULTI) ||\n        ((rsa-\u003ep != NULL) \u0026\u0026\n         (rsa-\u003eq != NULL) \u0026\u0026\n         (rsa-\u003edmp1 != NULL) \u0026\u0026 (rsa-\u003edmq1 != NULL) \u0026\u0026 (rsa-\u003eiqmp != NULL))) {\n        if (!rsa-\u003emeth-\u003ersa_mod_exp(ret, f, rsa, ctx))\n            goto err;\n    } else {\n        BIGNUM *d = BN_new();\n        if (d == NULL) {\n            RSAerr(RSA_F_RSA_OSSL_PRIVATE_ENCRYPT, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        BN_with_flags(d, rsa-\u003ed, BN_FLG_CONSTTIME);\n\n        if (!rsa-\u003emeth-\u003ebn_mod_exp(ret, f, d, rsa-\u003en, ctx,\n                                   rsa-\u003e_method_mod_n)) {\n            BN_free(d);\n            goto err;\n        }\n        /* We MUST free d before any further use of rsa-\u003ed */\n        BN_free(d);\n    }\n\n    if (blinding)\n        if (!rsa_blinding_invert(blinding, ret, unblind, ctx))\n            goto err;\n\n    if (padding == RSA_X931_PADDING) {\n        if (!BN_sub(f, rsa-\u003en, ret))\n            goto err;\n        if (BN_cmp(ret, f) \u003e 0)\n            res = f;\n        else\n            res = ret;\n    } else {\n        res = ret;\n    }\n\n    /*\n     * BN_bn2binpad puts in leading 0 bytes if the number is less than\n     * the length of the modulus.\n     */\n    r = BN_bn2binpad(res, to, num);\n err:\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    OPENSSL_clear_free(buf, num);\n    return r;\n}","filepath":"crypto/rsa/rsa_ossl.c","line_number":233,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1c"},"269863584":{"score":0.9216256,"function_name":"rsa_ossl_public_decrypt","code":"static int rsa_ossl_public_decrypt(int flen, const unsigned char *from,\n                                  unsigned char *to, RSA *rsa, int padding)\n{\n    BIGNUM *f, *ret;\n    int i, num = 0, r = -1;\n    unsigned char *buf = NULL;\n    BN_CTX *ctx = NULL;\n\n    if (BN_num_bits(rsa-\u003en) \u003e OPENSSL_RSA_MAX_MODULUS_BITS) {\n        RSAerr(RSA_F_RSA_OSSL_PUBLIC_DECRYPT, RSA_R_MODULUS_TOO_LARGE);\n        return -1;\n    }\n\n    if (BN_ucmp(rsa-\u003en, rsa-\u003ee) \u003c= 0) {\n        RSAerr(RSA_F_RSA_OSSL_PUBLIC_DECRYPT, RSA_R_BAD_E_VALUE);\n        return -1;\n    }\n\n    /* for large moduli, enforce exponent limit */\n    if (BN_num_bits(rsa-\u003en) \u003e OPENSSL_RSA_SMALL_MODULUS_BITS) {\n        if (BN_num_bits(rsa-\u003ee) \u003e OPENSSL_RSA_MAX_PUBEXP_BITS) {\n            RSAerr(RSA_F_RSA_OSSL_PUBLIC_DECRYPT, RSA_R_BAD_E_VALUE);\n            return -1;\n        }\n    }\n\n    if ((ctx = BN_CTX_new()) == NULL)\n        goto err;\n    BN_CTX_start(ctx);\n    f = BN_CTX_get(ctx);\n    ret = BN_CTX_get(ctx);\n    num = BN_num_bytes(rsa-\u003en);\n    buf = OPENSSL_malloc(num);\n    if (ret == NULL || buf == NULL) {\n        RSAerr(RSA_F_RSA_OSSL_PUBLIC_DECRYPT, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    /*\n     * This check was for equality but PGP does evil things and chops off the\n     * top '0' bytes\n     */\n    if (flen \u003e num) {\n        RSAerr(RSA_F_RSA_OSSL_PUBLIC_DECRYPT, RSA_R_DATA_GREATER_THAN_MOD_LEN);\n        goto err;\n    }\n\n    if (BN_bin2bn(from, flen, f) == NULL)\n        goto err;\n\n    if (BN_ucmp(f, rsa-\u003en) \u003e= 0) {\n        RSAerr(RSA_F_RSA_OSSL_PUBLIC_DECRYPT,\n               RSA_R_DATA_TOO_LARGE_FOR_MODULUS);\n        goto err;\n    }\n\n    if (rsa-\u003eflags \u0026 RSA_FLAG_CACHE_PUBLIC)\n        if (!BN_MONT_CTX_set_locked(\u0026rsa-\u003e_method_mod_n, rsa-\u003elock,\n                                    rsa-\u003en, ctx))\n            goto err;\n\n    if (!rsa-\u003emeth-\u003ebn_mod_exp(ret, f, rsa-\u003ee, rsa-\u003en, ctx,\n                               rsa-\u003e_method_mod_n))\n        goto err;\n\n    if ((padding == RSA_X931_PADDING) \u0026\u0026 ((bn_get_words(ret)[0] \u0026 0xf) != 12))\n        if (!BN_sub(ret, rsa-\u003en, ret))\n            goto err;\n\n    i = BN_bn2binpad(ret, buf, num);\n\n    switch (padding) {\n    case RSA_PKCS1_PADDING:\n        r = RSA_padding_check_PKCS1_type_1(to, num, buf, i, num);\n        break;\n    case RSA_X931_PADDING:\n        r = RSA_padding_check_X931(to, num, buf, i, num);\n        break;\n    case RSA_NO_PADDING:\n        memcpy(to, buf, (r = i));\n        break;\n    default:\n        RSAerr(RSA_F_RSA_OSSL_PUBLIC_DECRYPT, RSA_R_UNKNOWN_PADDING_TYPE);\n        goto err;\n    }\n    if (r \u003c 0)\n        RSAerr(RSA_F_RSA_OSSL_PUBLIC_DECRYPT, RSA_R_PADDING_CHECK_FAILED);\n\n err:\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    OPENSSL_clear_free(buf, num);\n    return r;\n}","filepath":"crypto/rsa/rsa_ossl.c","line_number":492,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1c"},"269864320":{"score":0.90695107,"function_name":"rsa_ossl_private_decrypt","code":"static int rsa_ossl_private_decrypt(int flen, const unsigned char *from,\n                                   unsigned char *to, RSA *rsa, int padding)\n{\n    BIGNUM *f, *ret;\n    int j, num = 0, r = -1;\n    unsigned char *buf = NULL;\n    BN_CTX *ctx = NULL;\n    int local_blinding = 0;\n    /*\n     * Used only if the blinding structure is shared. A non-NULL unblind\n     * instructs rsa_blinding_convert() and rsa_blinding_invert() to store\n     * the unblinding factor outside the blinding structure.\n     */\n    BIGNUM *unblind = NULL;\n    BN_BLINDING *blinding = NULL;\n\n    if ((ctx = BN_CTX_new()) == NULL)\n        goto err;\n    BN_CTX_start(ctx);\n    f = BN_CTX_get(ctx);\n    ret = BN_CTX_get(ctx);\n    num = BN_num_bytes(rsa-\u003en);\n    buf = OPENSSL_malloc(num);\n    if (ret == NULL || buf == NULL) {\n        RSAerr(RSA_F_RSA_OSSL_PRIVATE_DECRYPT, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    /*\n     * This check was for equality but PGP does evil things and chops off the\n     * top '0' bytes\n     */\n    if (flen \u003e num) {\n        RSAerr(RSA_F_RSA_OSSL_PRIVATE_DECRYPT,\n               RSA_R_DATA_GREATER_THAN_MOD_LEN);\n        goto err;\n    }\n\n    /* make data into a big number */\n    if (BN_bin2bn(from, (int)flen, f) == NULL)\n        goto err;\n\n    if (BN_ucmp(f, rsa-\u003en) \u003e= 0) {\n        RSAerr(RSA_F_RSA_OSSL_PRIVATE_DECRYPT,\n               RSA_R_DATA_TOO_LARGE_FOR_MODULUS);\n        goto err;\n    }\n\n    if (!(rsa-\u003eflags \u0026 RSA_FLAG_NO_BLINDING)) {\n        blinding = rsa_get_blinding(rsa, \u0026local_blinding, ctx);\n        if (blinding == NULL) {\n            RSAerr(RSA_F_RSA_OSSL_PRIVATE_DECRYPT, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n    }\n\n    if (blinding != NULL) {\n        if (!local_blinding \u0026\u0026 ((unblind = BN_CTX_get(ctx)) == NULL)) {\n            RSAerr(RSA_F_RSA_OSSL_PRIVATE_DECRYPT, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        if (!rsa_blinding_convert(blinding, f, unblind, ctx))\n            goto err;\n    }\n\n    /* do the decrypt */\n    if ((rsa-\u003eflags \u0026 RSA_FLAG_EXT_PKEY) ||\n        (rsa-\u003eversion == RSA_ASN1_VERSION_MULTI) ||\n        ((rsa-\u003ep != NULL) \u0026\u0026\n         (rsa-\u003eq != NULL) \u0026\u0026\n         (rsa-\u003edmp1 != NULL) \u0026\u0026 (rsa-\u003edmq1 != NULL) \u0026\u0026 (rsa-\u003eiqmp != NULL))) {\n        if (!rsa-\u003emeth-\u003ersa_mod_exp(ret, f, rsa, ctx))\n            goto err;\n    } else {\n        BIGNUM *d = BN_new();\n        if (d == NULL) {\n            RSAerr(RSA_F_RSA_OSSL_PRIVATE_DECRYPT, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        BN_with_flags(d, rsa-\u003ed, BN_FLG_CONSTTIME);\n\n        if (rsa-\u003eflags \u0026 RSA_FLAG_CACHE_PUBLIC)\n            if (!BN_MONT_CTX_set_locked(\u0026rsa-\u003e_method_mod_n, rsa-\u003elock,\n                                        rsa-\u003en, ctx)) {\n                BN_free(d);\n                goto err;\n            }\n        if (!rsa-\u003emeth-\u003ebn_mod_exp(ret, f, d, rsa-\u003en, ctx,\n                                   rsa-\u003e_method_mod_n)) {\n            BN_free(d);\n            goto err;\n        }\n        /* We MUST free d before any further use of rsa-\u003ed */\n        BN_free(d);\n    }\n\n    if (blinding)\n        if (!rsa_blinding_invert(blinding, ret, unblind, ctx))\n            goto err;\n\n    j = BN_bn2binpad(ret, buf, num);\n\n    switch (padding) {\n    case RSA_PKCS1_PADDING:\n        r = RSA_padding_check_PKCS1_type_2(to, num, buf, j, num);\n        break;\n    case RSA_PKCS1_OAEP_PADDING:\n        r = RSA_padding_check_PKCS1_OAEP(to, num, buf, j, num, NULL, 0);\n        break;\n    case RSA_SSLV23_PADDING:\n        r = RSA_padding_check_SSLv23(to, num, buf, j, num);\n        break;\n    case RSA_NO_PADDING:\n        memcpy(to, buf, (r = j));\n        break;\n    default:\n        RSAerr(RSA_F_RSA_OSSL_PRIVATE_DECRYPT, RSA_R_UNKNOWN_PADDING_TYPE);\n        goto err;\n    }\n    RSAerr(RSA_F_RSA_OSSL_PRIVATE_DECRYPT, RSA_R_PADDING_CHECK_FAILED);\n    err_clear_last_constant_time(1 \u0026 ~constant_time_msb(r));\n\n err:\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    OPENSSL_clear_free(buf, num);\n    return r;\n}","filepath":"crypto/rsa/rsa_ossl.c","line_number":362,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1c"},"269865232":{"score":0.7843968,"function_name":"rsa_ossl_mod_exp","code":"static int rsa_ossl_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx)\n{\n    BIGNUM *r1, *m1, *vrfy, *r2, *m[RSA_MAX_PRIME_NUM - 2];\n    int ret = 0, i, ex_primes = 0, smooth = 0;\n    RSA_PRIME_INFO *pinfo;\n\n    BN_CTX_start(ctx);\n\n    r1 = BN_CTX_get(ctx);\n    r2 = BN_CTX_get(ctx);\n    m1 = BN_CTX_get(ctx);\n    vrfy = BN_CTX_get(ctx);\n    if (vrfy == NULL)\n        goto err;\n\n    if (rsa-\u003eversion == RSA_ASN1_VERSION_MULTI\n        \u0026\u0026 ((ex_primes = sk_RSA_PRIME_INFO_num(rsa-\u003eprime_infos)) \u003c= 0\n             || ex_primes \u003e RSA_MAX_PRIME_NUM - 2))\n        goto err;\n\n    if (rsa-\u003eflags \u0026 RSA_FLAG_CACHE_PRIVATE) {\n        BIGNUM *factor = BN_new();\n\n        if (factor == NULL)\n            goto err;\n\n        /*\n         * Make sure BN_mod_inverse in Montgomery initialization uses the\n         * BN_FLG_CONSTTIME flag\n         */\n        if (!(BN_with_flags(factor, rsa-\u003ep, BN_FLG_CONSTTIME),\n              BN_MONT_CTX_set_locked(\u0026rsa-\u003e_method_mod_p, rsa-\u003elock,\n                                     factor, ctx))\n            || !(BN_with_flags(factor, rsa-\u003eq, BN_FLG_CONSTTIME),\n                 BN_MONT_CTX_set_locked(\u0026rsa-\u003e_method_mod_q, rsa-\u003elock,\n                                        factor, ctx))) {\n            BN_free(factor);\n            goto err;\n        }\n        for (i = 0; i \u003c ex_primes; i++) {\n            pinfo = sk_RSA_PRIME_INFO_value(rsa-\u003eprime_infos, i);\n            BN_with_flags(factor, pinfo-\u003er, BN_FLG_CONSTTIME);\n            if (!BN_MONT_CTX_set_locked(\u0026pinfo-\u003em, rsa-\u003elock, factor, ctx)) {\n                BN_free(factor);\n                goto err;\n            }\n        }\n        /*\n         * We MUST free |factor| before any further use of the prime factors\n         */\n        BN_free(factor);\n\n        smooth = (ex_primes == 0)\n                 \u0026\u0026 (rsa-\u003emeth-\u003ebn_mod_exp == BN_mod_exp_mont)\n                 \u0026\u0026 (BN_num_bits(rsa-\u003eq) == BN_num_bits(rsa-\u003ep));\n    }\n\n    if (rsa-\u003eflags \u0026 RSA_FLAG_CACHE_PUBLIC)\n        if (!BN_MONT_CTX_set_locked(\u0026rsa-\u003e_method_mod_n, rsa-\u003elock,\n                                    rsa-\u003en, ctx))\n            goto err;\n\n    if (smooth) {\n        /*\n         * Conversion from Montgomery domain, a.k.a. Montgomery reduction,\n         * accepts values in [0-m*2^w) range. w is m's bit width rounded up\n         * to limb width. So that at the very least if |I| is fully reduced,\n         * i.e. less than p*q, we can count on from-to round to perform\n         * below modulo operations on |I|. Unlike BN_mod it's constant time.\n         */\n        if (/* m1 = I moq q */\n            !bn_from_mont_fixed_top(m1, I, rsa-\u003e_method_mod_q, ctx)\n            || !bn_to_mont_fixed_top(m1, m1, rsa-\u003e_method_mod_q, ctx)\n            /* m1 = m1^dmq1 mod q */\n            || !BN_mod_exp_mont_consttime(m1, m1, rsa-\u003edmq1, rsa-\u003eq, ctx,\n                                          rsa-\u003e_method_mod_q)\n            /* r1 = I mod p */\n            || !bn_from_mont_fixed_top(r1, I, rsa-\u003e_method_mod_p, ctx)\n            || !bn_to_mont_fixed_top(r1, r1, rsa-\u003e_method_mod_p, ctx)\n            /* r1 = r1^dmp1 mod p */\n            || !BN_mod_exp_mont_consttime(r1, r1, rsa-\u003edmp1, rsa-\u003ep, ctx,\n                                          rsa-\u003e_method_mod_p)\n            /* r1 = (r1 - m1) mod p */\n            /*\n             * bn_mod_sub_fixed_top is not regular modular subtraction,\n             * it can tolerate subtrahend to be larger than modulus, but\n             * not bit-wise wider. This makes up for uncommon q\u003ep case,\n             * when |m1| can be larger than |rsa-\u003ep|.\n             */\n            || !bn_mod_sub_fixed_top(r1, r1, m1, rsa-\u003ep)\n\n            /* r1 = r1 * iqmp mod p */\n            || !bn_to_mont_fixed_top(r1, r1, rsa-\u003e_method_mod_p, ctx)\n            || !bn_mul_mont_fixed_top(r1, r1, rsa-\u003eiqmp, rsa-\u003e_method_mod_p,\n                                      ctx)\n            /* r0 = r1 * q + m1 */\n            || !bn_mul_fixed_top(r0, r1, rsa-\u003eq, ctx)\n            || !bn_mod_add_fixed_top(r0, r0, m1, rsa-\u003en))\n            goto err;\n\n        goto tail;\n    }\n\n    /* compute I mod q */\n    {\n        BIGNUM *c = BN_new();\n        if (c == NULL)\n            goto err;\n        BN_with_flags(c, I, BN_FLG_CONSTTIME);\n\n        if (!BN_mod(r1, c, rsa-\u003eq, ctx)) {\n            BN_free(c);\n            goto err;\n        }\n\n        {\n            BIGNUM *dmq1 = BN_new();\n            if (dmq1 == NULL) {\n                BN_free(c);\n                goto err;\n            }\n            BN_with_flags(dmq1, rsa-\u003edmq1, BN_FLG_CONSTTIME);\n\n            /* compute r1^dmq1 mod q */\n            if (!rsa-\u003emeth-\u003ebn_mod_exp(m1, r1, dmq1, rsa-\u003eq, ctx,\n                                       rsa-\u003e_method_mod_q)) {\n                BN_free(c);\n                BN_free(dmq1);\n                goto err;\n            }\n            /* We MUST free dmq1 before any further use of rsa-\u003edmq1 */\n            BN_free(dmq1);\n        }\n\n        /* compute I mod p */\n        if (!BN_mod(r1, c, rsa-\u003ep, ctx)) {\n            BN_free(c);\n            goto err;\n        }\n        /* We MUST free c before any further use of I */\n        BN_free(c);\n    }\n\n    {\n        BIGNUM *dmp1 = BN_new();\n        if (dmp1 == NULL)\n            goto err;\n        BN_with_flags(dmp1, rsa-\u003edmp1, BN_FLG_CONSTTIME);\n\n        /* compute r1^dmp1 mod p */\n        if (!rsa-\u003emeth-\u003ebn_mod_exp(r0, r1, dmp1, rsa-\u003ep, ctx,\n                                   rsa-\u003e_method_mod_p)) {\n            BN_free(dmp1);\n            goto err;\n        }\n        /* We MUST free dmp1 before any further use of rsa-\u003edmp1 */\n        BN_free(dmp1);\n    }\n\n    /*\n     * calculate m_i in multi-prime case\n     *\n     * TODO:\n     * 1. squash the following two loops and calculate |m_i| there.\n     * 2. remove cc and reuse |c|.\n     * 3. remove |dmq1| and |dmp1| in previous block and use |di|.\n     *\n     * If these things are done, the code will be more readable.\n     */\n    if (ex_primes \u003e 0) {\n        BIGNUM *di = BN_new(), *cc = BN_new();\n\n        if (cc == NULL || di == NULL) {\n            BN_free(cc);\n            BN_free(di);\n            goto err;\n        }\n\n        for (i = 0; i \u003c ex_primes; i++) {\n            /* prepare m_i */\n            if ((m[i] = BN_CTX_get(ctx)) == NULL) {\n                BN_free(cc);\n                BN_free(di);\n                goto err;\n            }\n\n            pinfo = sk_RSA_PRIME_INFO_value(rsa-\u003eprime_infos, i);\n\n            /* prepare c and d_i */\n            BN_with_flags(cc, I, BN_FLG_CONSTTIME);\n            BN_with_flags(di, pinfo-\u003ed, BN_FLG_CONSTTIME);\n\n            if (!BN_mod(r1, cc, pinfo-\u003er, ctx)) {\n                BN_free(cc);\n                BN_free(di);\n                goto err;\n            }\n            /* compute r1 ^ d_i mod r_i */\n            if (!rsa-\u003emeth-\u003ebn_mod_exp(m[i], r1, di, pinfo-\u003er, ctx, pinfo-\u003em)) {\n                BN_free(cc);\n                BN_free(di);\n                goto err;\n            }\n        }\n\n        BN_free(cc);\n        BN_free(di);\n    }\n\n    if (!BN_sub(r0, r0, m1))\n        goto err;\n    /*\n     * This will help stop the size of r0 increasing, which does affect the\n     * multiply if it optimised for a power of 2 size\n     */\n    if (BN_is_negative(r0))\n        if (!BN_add(r0, r0, rsa-\u003ep))\n            goto err;\n\n    if (!BN_mul(r1, r0, rsa-\u003eiqmp, ctx))\n        goto err;\n\n    {\n        BIGNUM *pr1 = BN_new();\n        if (pr1 == NULL)\n            goto err;\n        BN_with_flags(pr1, r1, BN_FLG_CONSTTIME);\n\n        if (!BN_mod(r0, pr1, rsa-\u003ep, ctx)) {\n            BN_free(pr1);\n            goto err;\n        }\n        /* We MUST free pr1 before any further use of r1 */\n        BN_free(pr1);\n    }\n\n    /*\n     * If p \u003c q it is occasionally possible for the correction of adding 'p'\n     * if r0 is negative above to leave the result still negative. This can\n     * break the private key operations: the following second correction\n     * should *always* correct this rare occurrence. This will *never* happen\n     * with OpenSSL generated keys because they ensure p \u003e q [steve]\n     */\n    if (BN_is_negative(r0))\n        if (!BN_add(r0, r0, rsa-\u003ep))\n            goto err;\n    if (!BN_mul(r1, r0, rsa-\u003eq, ctx))\n        goto err;\n    if (!BN_add(r0, r1, m1))\n        goto err;\n\n    /* add m_i to m in multi-prime case */\n    if (ex_primes \u003e 0) {\n        BIGNUM *pr2 = BN_new();\n\n        if (pr2 == NULL)\n            goto err;\n\n        for (i = 0; i \u003c ex_primes; i++) {\n            pinfo = sk_RSA_PRIME_INFO_value(rsa-\u003eprime_infos, i);\n            if (!BN_sub(r1, m[i], r0)) {\n                BN_free(pr2);\n                goto err;\n            }\n\n            if (!BN_mul(r2, r1, pinfo-\u003et, ctx)) {\n                BN_free(pr2);\n                goto err;\n            }\n\n            BN_with_flags(pr2, r2, BN_FLG_CONSTTIME);\n\n            if (!BN_mod(r1, pr2, pinfo-\u003er, ctx)) {\n                BN_free(pr2);\n                goto err;\n            }\n\n            if (BN_is_negative(r1))\n                if (!BN_add(r1, r1, pinfo-\u003er)) {\n                    BN_free(pr2);\n                    goto err;\n                }\n            if (!BN_mul(r1, r1, pinfo-\u003epp, ctx)) {\n                BN_free(pr2);\n                goto err;\n            }\n            if (!BN_add(r0, r0, r1)) {\n                BN_free(pr2);\n                goto err;\n            }\n        }\n        BN_free(pr2);\n    }\n\n tail:\n    if (rsa-\u003ee \u0026\u0026 rsa-\u003en) {\n        if (rsa-\u003emeth-\u003ebn_mod_exp == BN_mod_exp_mont) {\n            if (!BN_mod_exp_mont(vrfy, r0, rsa-\u003ee, rsa-\u003en, ctx,\n                                 rsa-\u003e_method_mod_n))\n                goto err;\n        } else {\n            bn_correct_top(r0);\n            if (!rsa-\u003emeth-\u003ebn_mod_exp(vrfy, r0, rsa-\u003ee, rsa-\u003en, ctx,\n                                       rsa-\u003e_method_mod_n))\n                goto err;\n        }\n        /*\n         * If 'I' was greater than (or equal to) rsa-\u003en, the operation will\n         * be equivalent to using 'I mod n'. However, the result of the\n         * verify will *always* be less than 'n' so we don't check for\n         * absolute equality, just congruency.\n         */\n        if (!BN_sub(vrfy, vrfy, I))\n            goto err;\n        if (BN_is_zero(vrfy)) {\n            bn_correct_top(r0);\n            ret = 1;\n            goto err;   /* not actually error */\n        }\n        if (!BN_mod(vrfy, vrfy, rsa-\u003en, ctx))\n            goto err;\n        if (BN_is_negative(vrfy))\n            if (!BN_add(vrfy, vrfy, rsa-\u003en))\n                goto err;\n        if (!BN_is_zero(vrfy)) {\n            /*\n             * 'I' and 'vrfy' aren't congruent mod n. Don't leak\n             * miscalculated CRT output, just do a raw (slower) mod_exp and\n             * return that instead.\n             */\n\n            BIGNUM *d = BN_new();\n            if (d == NULL)\n                goto err;\n            BN_with_flags(d, rsa-\u003ed, BN_FLG_CONSTTIME);\n\n            if (!rsa-\u003emeth-\u003ebn_mod_exp(r0, I, d, rsa-\u003en, ctx,\n                                       rsa-\u003e_method_mod_n)) {\n                BN_free(d);\n                goto err;\n            }\n            /* We MUST free d before any further use of rsa-\u003ed */\n            BN_free(d);\n        }\n    }\n    /*\n     * It's unfortunate that we have to bn_correct_top(r0). What hopefully\n     * saves the day is that correction is highly unlike, and private key\n     * operations are customarily performed on blinded message. Which means\n     * that attacker won't observe correlation with chosen plaintext.\n     * Secondly, remaining code would still handle it in same computational\n     * time and even conceal memory access pattern around corrected top.\n     */\n    bn_correct_top(r0);\n    ret = 1;\n err:\n    BN_CTX_end(ctx);\n    return ret;\n}","filepath":"crypto/rsa/rsa_ossl.c","line_number":587,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1c"},"269867472":{"score":0.78467643,"function_name":"rsa_blinding_convert","code":"static int rsa_blinding_convert(BN_BLINDING *b, BIGNUM *f, BIGNUM *unblind,\n                                BN_CTX *ctx)\n{\n    if (unblind == NULL) {\n        /*\n         * Local blinding: store the unblinding factor in BN_BLINDING.\n         */\n        return BN_BLINDING_convert_ex(f, NULL, b, ctx);\n    } else {\n        /*\n         * Shared blinding: store the unblinding factor outside BN_BLINDING.\n         */\n        int ret;\n\n        BN_BLINDING_lock(b);\n        ret = BN_BLINDING_convert_ex(f, unblind, b, ctx);\n        BN_BLINDING_unlock(b);\n\n        return ret;\n    }\n}","filepath":"crypto/rsa/rsa_ossl.c","line_number":196,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1c"},"269867552":{"score":0.8619104,"function_name":"rsa_get_blinding","code":"static BN_BLINDING *rsa_get_blinding(RSA *rsa, int *local, BN_CTX *ctx)\n{\n    BN_BLINDING *ret;\n\n    CRYPTO_THREAD_write_lock(rsa-\u003elock);\n\n    if (rsa-\u003eblinding == NULL) {\n        rsa-\u003eblinding = RSA_setup_blinding(rsa, ctx);\n    }\n\n    ret = rsa-\u003eblinding;\n    if (ret == NULL)\n        goto err;\n\n    if (BN_BLINDING_is_current_thread(ret)) {\n        /* rsa-\u003eblinding is ours! */\n\n        *local = 1;\n    } else {\n        /* resort to rsa-\u003emt_blinding instead */\n\n        /*\n         * instructs rsa_blinding_convert(), rsa_blinding_invert() that the\n         * BN_BLINDING is shared, meaning that accesses require locks, and\n         * that the blinding factor must be stored outside the BN_BLINDING\n         */\n        *local = 0;\n\n        if (rsa-\u003emt_blinding == NULL) {\n            rsa-\u003emt_blinding = RSA_setup_blinding(rsa, ctx);\n        }\n        ret = rsa-\u003emt_blinding;\n    }\n\n err:\n    CRYPTO_THREAD_unlock(rsa-\u003elock);\n    return ret;\n}","filepath":"crypto/rsa/rsa_ossl.c","line_number":157,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1c"},"269869760":{"score":0.80493486,"function_name":"ENGINE_finish","code":"int ENGINE_finish(ENGINE *e)\n\t{\n\tint to_return = 1;\n\n\tif(e == NULL)\n\t\t{\n\t\tENGINEerr(ENGINE_F_ENGINE_FINISH,ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn 0;\n\t\t}\n\tCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\n\tto_return = engine_unlocked_finish(e, 1);\n\tCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\n\tif(!to_return)\n\t\t{\n\t\tENGINEerr(ENGINE_F_ENGINE_FINISH,ENGINE_R_FINISH_FAILED);\n\t\treturn 0;\n\t\t}\n\treturn to_return;\n\t}","filepath":"crypto/engine/eng_init.c","line_number":139,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_0_9_7-beta4"},"269870112":{"score":0.9186918,"function_name":"engine_unlocked_finish","code":"int engine_unlocked_finish(ENGINE *e, int unlock_for_handlers)\n\t{\n\tint to_return = 1;\n\n\t/* Reduce the functional reference count here so if it's the terminating\n\t * case, we can release the lock safely and call the finish() handler\n\t * without risk of a race. We get a race if we leave the count until\n\t * after and something else is calling \"finish\" at the same time -\n\t * there's a chance that both threads will together take the count from\n\t * 2 to 0 without either calling finish(). */\n\te-\u003efunct_ref--;\n\tengine_ref_debug(e, 1, -1);\n\tif((e-\u003efunct_ref == 0) \u0026\u0026 e-\u003efinish)\n\t\t{\n\t\tif(unlock_for_handlers)\n\t\t\tCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\n\t\tto_return = e-\u003efinish(e);\n\t\tif(unlock_for_handlers)\n\t\t\tCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\n\t\tif(!to_return)\n\t\t\treturn 0;\n\t\t}\n#ifdef REF_CHECK\n\tif(e-\u003efunct_ref \u003c 0)\n\t\t{\n\t\tfprintf(stderr,\"ENGINE_finish, bad functional reference count\\n\");\n\t\tabort();\n\t\t}\n#endif\n\t/* Release the structural reference too */\n\tif(!engine_free_util(e, 0))\n\t\t{\n\t\tENGINEerr(ENGINE_F_ENGINE_FINISH,ENGINE_R_FINISH_FAILED);\n\t\treturn 0;\n\t\t}\n\treturn to_return;\n\t}","filepath":"crypto/engine/eng_init.c","line_number":85,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_0_9_7-beta4"},"269870256":{"score":0.9057402,"function_name":"engine_unlocked_init","code":"int engine_unlocked_init(ENGINE *e)\n\t{\n\tint to_return = 1;\n\n\tif((e-\u003efunct_ref == 0) \u0026\u0026 e-\u003einit)\n\t\t/* This is the first functional reference and the engine\n\t\t * requires initialisation so we do it now. */\n\t\tto_return = e-\u003einit(e);\n\tif(to_return)\n\t\t{\n\t\t/* OK, we return a functional reference which is also a\n\t\t * structural reference. */\n\t\te-\u003estruct_ref++;\n\t\te-\u003efunct_ref++;\n\t\tengine_ref_debug(e, 0, 1)\n\t\tengine_ref_debug(e, 1, 1)\n\t\t}\n\treturn to_return;\n\t}","filepath":"crypto/engine/eng_init.c","line_number":63,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_0_9_7-beta4"},"269870320":{"score":0.91069084,"function_name":"ossl_rsa_multip_calc_product","code":"int ossl_rsa_multip_calc_product(RSA *rsa)\n{\n    RSA_PRIME_INFO *pinfo;\n    BIGNUM *p1 = NULL, *p2 = NULL;\n    BN_CTX *ctx = NULL;\n    int i, rv = 0, ex_primes;\n\n    if ((ex_primes = sk_RSA_PRIME_INFO_num(rsa-\u003eprime_infos)) \u003c= 0) {\n        /* invalid */\n        goto err;\n    }\n\n    if ((ctx = BN_CTX_new()) == NULL)\n        goto err;\n\n    /* calculate pinfo-\u003epp = p * q for first 'extra' prime */\n    p1 = rsa-\u003ep;\n    p2 = rsa-\u003eq;\n\n    for (i = 0; i \u003c ex_primes; i++) {\n        pinfo = sk_RSA_PRIME_INFO_value(rsa-\u003eprime_infos, i);\n        if (pinfo-\u003epp == NULL) {\n            pinfo-\u003epp = BN_secure_new();\n            if (pinfo-\u003epp == NULL)\n                goto err;\n        }\n        if (!BN_mul(pinfo-\u003epp, p1, p2, ctx))\n            goto err;\n        /* save previous one */\n        p1 = pinfo-\u003epp;\n        p2 = pinfo-\u003er;\n    }\n\n    rv = 1;\n err:\n    BN_CTX_free(ctx);\n    return rv;\n}","filepath":"crypto/rsa/rsa_mp.c","line_number":61,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.1.0-beta1"},"269870512":{"score":0.92969257,"function_name":"ossl_rsa_multip_cap","code":"int ossl_rsa_multip_cap(int bits)\n{\n    int cap = 5;\n\n    if (bits \u003c 1024)\n        cap = 2;\n    else if (bits \u003c 4096)\n        cap = 3;\n    else if (bits \u003c 8192)\n        cap = 4;\n\n    if (cap \u003e RSA_MAX_PRIME_NUM)\n        cap = RSA_MAX_PRIME_NUM;\n\n    return cap;\n}","filepath":"crypto/rsa/rsa_mp.c","line_number":100,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.1.0-beta1"},"269870640":{"score":0.948123,"function_name":"ossl_rsa_multip_info_new","code":"RSA_PRIME_INFO *ossl_rsa_multip_info_new(void)\n{\n    RSA_PRIME_INFO *pinfo;\n\n    /* create a RSA_PRIME_INFO structure */\n    if ((pinfo = OPENSSL_zalloc(sizeof(RSA_PRIME_INFO))) == NULL) {\n        ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    if ((pinfo-\u003er = BN_secure_new()) == NULL)\n        goto err;\n    if ((pinfo-\u003ed = BN_secure_new()) == NULL)\n        goto err;\n    if ((pinfo-\u003et = BN_secure_new()) == NULL)\n        goto err;\n    if ((pinfo-\u003epp = BN_secure_new()) == NULL)\n        goto err;\n\n    return pinfo;\n\n err:\n    BN_free(pinfo-\u003er);\n    BN_free(pinfo-\u003ed);\n    BN_free(pinfo-\u003et);\n    BN_free(pinfo-\u003epp);\n    OPENSSL_free(pinfo);\n    return NULL;\n}"},"269870896":{"score":0.9515508,"function_name":"EVP_PKEY_cmp","code":"int EVP_PKEY_cmp(const EVP_PKEY *a, const EVP_PKEY *b)\n{\n    if (a-\u003etype != b-\u003etype)\n        return -1;\n\n    if (a-\u003eameth) {\n        int ret;\n        /* Compare parameters if the algorithm has them */\n        if (a-\u003eameth-\u003eparam_cmp) {\n            ret = a-\u003eameth-\u003eparam_cmp(a, b);\n            if (ret \u003c= 0)\n                return ret;\n        }\n\n        if (a-\u003eameth-\u003epub_cmp)\n            return a-\u003eameth-\u003epub_cmp(a, b);\n    }\n\n    return -2;\n}","filepath":"crypto/evp/p_lib.c","line_number":119,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1b"},"269870976":{"score":0.95928955,"function_name":"EVP_PKEY_cmp_parameters","code":"int EVP_PKEY_cmp_parameters(const EVP_PKEY *a, const EVP_PKEY *b)\n{\n    if (a-\u003etype != b-\u003etype)\n        return -1;\n    if (a-\u003eameth \u0026\u0026 a-\u003eameth-\u003eparam_cmp)\n        return a-\u003eameth-\u003eparam_cmp(a, b);\n    return -2;\n}","filepath":"crypto/evp/p_lib.c","line_number":110,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1b"},"269871024":{"score":0.9087977,"function_name":"EVP_PKEY_copy_parameters","code":"int EVP_PKEY_copy_parameters(EVP_PKEY *to, const EVP_PKEY *from)\n{\n    if (to-\u003etype == EVP_PKEY_NONE) {\n        if (EVP_PKEY_set_type(to, from-\u003etype) == 0)\n            return 0;\n    } else if (to-\u003etype != from-\u003etype) {\n        EVPerr(EVP_F_EVP_PKEY_COPY_PARAMETERS, EVP_R_DIFFERENT_KEY_TYPES);\n        goto err;\n    }\n\n    if (EVP_PKEY_missing_parameters(from)) {\n        EVPerr(EVP_F_EVP_PKEY_COPY_PARAMETERS, EVP_R_MISSING_PARAMETERS);\n        goto err;\n    }\n\n    if (!EVP_PKEY_missing_parameters(to)) {\n        if (EVP_PKEY_cmp_parameters(to, from) == 1)\n            return 1;\n        EVPerr(EVP_F_EVP_PKEY_COPY_PARAMETERS, EVP_R_DIFFERENT_PARAMETERS);\n        return 0;\n    }\n\n    if (from-\u003eameth \u0026\u0026 from-\u003eameth-\u003eparam_copy)\n        return from-\u003eameth-\u003eparam_copy(to, from);\n err:\n    return 0;\n}","filepath":"crypto/evp/p_lib.c","line_number":75,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1b"},"269871264":{"score":0.77759236,"function_name":"EVP_PKEY_free","code":"void EVP_PKEY_free(EVP_PKEY *x)\n{\n    int i;\n\n    if (x == NULL)\n        return;\n\n    CRYPTO_DOWN_REF(\u0026x-\u003ereferences, \u0026i, x-\u003elock);\n    REF_PRINT_COUNT(\"EVP_PKEY\", x);\n    if (i \u003e 0)\n        return;\n    REF_ASSERT_ISNT(i \u003c 0);\n    EVP_PKEY_free_it(x);\n    CRYPTO_THREAD_lock_free(x-\u003elock);\n    sk_X509_ATTRIBUTE_pop_free(x-\u003eattributes, X509_ATTRIBUTE_free);\n    OPENSSL_free(x);\n}","filepath":"crypto/evp/p_lib.c","line_number":588,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1b"},"269871344":{"score":0.9432198,"function_name":"EVP_PKEY_free_it","code":"static void EVP_PKEY_free_it(EVP_PKEY *x)\n{\n    /* internal function; x is never NULL */\n    if (x-\u003eameth \u0026\u0026 x-\u003eameth-\u003epkey_free) {\n        x-\u003eameth-\u003epkey_free(x);\n        x-\u003epkey.ptr = NULL;\n    }\n#ifndef OPENSSL_NO_ENGINE\n    ENGINE_finish(x-\u003eengine);\n    x-\u003eengine = NULL;\n    ENGINE_finish(x-\u003epmeth_engine);\n    x-\u003epmeth_engine = NULL;\n#endif\n}","filepath":"crypto/evp/p_lib.c","line_number":606,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1b"},"269871424":{"score":0.9048118,"function_name":"EVP_PKEY_get0_EC_KEY","code":"EC_KEY *EVP_PKEY_get0_EC_KEY(EVP_PKEY *pkey)\n{\n    if (pkey-\u003etype != EVP_PKEY_EC) {\n        EVPerr(EVP_F_EVP_PKEY_GET0_EC_KEY, EVP_R_EXPECTING_A_EC_KEY);\n        return NULL;\n    }\n    return pkey-\u003epkey.ec;\n}","filepath":"crypto/evp/p_lib.c","line_number":516,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1b"},"269871488":{"score":0.89615047,"function_name":"EVP_PKEY_get0_siphash","code":"const unsigned char *EVP_PKEY_get0_siphash(const EVP_PKEY *pkey, size_t *len)\n{\n    ASN1_OCTET_STRING *os = NULL;\n\n    if (pkey-\u003etype != EVP_PKEY_SIPHASH) {\n        EVPerr(EVP_F_EVP_PKEY_GET0_SIPHASH, EVP_R_EXPECTING_A_SIPHASH_KEY);\n        return NULL;\n    }\n    os = EVP_PKEY_get0(pkey);\n    *len = os-\u003elength;\n    return os-\u003edata;\n}","filepath":"crypto/evp/p_lib.c","line_number":438,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1b"},"269871552":{"score":0.8931223,"function_name":"EVP_PKEY_get0_poly1305","code":"const unsigned char *EVP_PKEY_get0_poly1305(const EVP_PKEY *pkey, size_t *len)\n{\n    ASN1_OCTET_STRING *os = NULL;\n    if (pkey-\u003etype != EVP_PKEY_POLY1305) {\n        EVPerr(EVP_F_EVP_PKEY_GET0_POLY1305, EVP_R_EXPECTING_A_POLY1305_KEY);\n        return NULL;\n    }\n    os = EVP_PKEY_get0(pkey);\n    *len = os-\u003elength;\n    return os-\u003edata;\n}","filepath":"crypto/evp/p_lib.c","line_number":424,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1b"},"269871616":{"score":0.8202392,"function_name":"EVP_PKEY_get0_RSA","code":"RSA *EVP_PKEY_get0_RSA(EVP_PKEY *pkey)\n{\n    if (pkey-\u003etype != EVP_PKEY_RSA) {\n        EVPerr(EVP_F_EVP_PKEY_GET0_RSA, EVP_R_EXPECTING_AN_RSA_KEY);\n        return NULL;\n    }\n    return pkey-\u003epkey.rsa;\n}","filepath":"crypto/evp/p_lib.c","line_number":461,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1b"},"269871760":{"score":0.9434074,"function_name":"EVP_PKEY_new","code":"EVP_PKEY *EVP_PKEY_new(void)\n{\n    EVP_PKEY *ret = OPENSSL_zalloc(sizeof(*ret));\n\n    if (ret == NULL) {\n        EVPerr(EVP_F_EVP_PKEY_NEW, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    ret-\u003etype = EVP_PKEY_NONE;\n    ret-\u003esave_type = EVP_PKEY_NONE;\n    ret-\u003ereferences = 1;\n    ret-\u003esave_parameters = 1;\n    ret-\u003elock = CRYPTO_THREAD_lock_new();\n    if (ret-\u003elock == NULL) {\n        EVPerr(EVP_F_EVP_PKEY_NEW, ERR_R_MALLOC_FAILURE);\n        OPENSSL_free(ret);\n        return NULL;\n    }\n    return ret;\n}","filepath":"crypto/evp/p_lib.c","line_number":140,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1b"},"269871904":{"score":0.88359874,"function_name":"EVP_PKEY_new_raw_private_key","code":"EVP_PKEY *EVP_PKEY_new_raw_private_key(int type, ENGINE *e,\n                                       const unsigned char *priv,\n                                       size_t len)\n{\n    EVP_PKEY *ret = EVP_PKEY_new();\n\n    if (ret == NULL\n            || !pkey_set_type(ret, e, type, NULL, -1)) {\n        /* EVPerr already called */\n        goto err;\n    }\n\n    if (ret-\u003eameth-\u003eset_priv_key == NULL) {\n        EVPerr(EVP_F_EVP_PKEY_NEW_RAW_PRIVATE_KEY,\n               EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\n        goto err;\n    }\n\n    if (!ret-\u003eameth-\u003eset_priv_key(ret, priv, len)) {\n        EVPerr(EVP_F_EVP_PKEY_NEW_RAW_PRIVATE_KEY, EVP_R_KEY_SETUP_FAILED);\n        goto err;\n    }\n\n    return ret;\n\n err:\n    EVP_PKEY_free(ret);\n    return NULL;\n}","filepath":"crypto/evp/p_lib.c","line_number":223,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1b"},"269872272":{"score":0.7962397,"function_name":"EVP_PKEY_type","code":"int EVP_PKEY_type(int type)\n{\n    int ret;\n    const EVP_PKEY_ASN1_METHOD *ameth;\n    ENGINE *e;\n    ameth = EVP_PKEY_asn1_find(\u0026e, type);\n    if (ameth)\n        ret = ameth-\u003epkey_id;\n    else\n        ret = NID_undef;\n#ifndef OPENSSL_NO_ENGINE\n    ENGINE_finish(e);\n#endif\n    return ret;\n}","filepath":"crypto/evp/p_lib.c","line_number":562,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1b"},"269872384":{"score":0.8671155,"function_name":"pkey_set_type","code":"static int pkey_set_type(EVP_PKEY *pkey, ENGINE *e, int type, const char *str,\n                         int len)\n{\n    const EVP_PKEY_ASN1_METHOD *ameth;\n    ENGINE **eptr = (e == NULL) ? \u0026e :  NULL;\n\n    if (pkey) {\n        if (pkey-\u003epkey.ptr)\n            EVP_PKEY_free_it(pkey);\n        /*\n         * If key type matches and a method exists then this lookup has\n         * succeeded once so just indicate success.\n         */\n        if ((type == pkey-\u003esave_type) \u0026\u0026 pkey-\u003eameth)\n            return 1;\n#ifndef OPENSSL_NO_ENGINE\n        /* If we have ENGINEs release them */\n        ENGINE_finish(pkey-\u003eengine);\n        pkey-\u003eengine = NULL;\n        ENGINE_finish(pkey-\u003epmeth_engine);\n        pkey-\u003epmeth_engine = NULL;\n#endif\n    }\n    if (str)\n        ameth = EVP_PKEY_asn1_find_str(eptr, str, len);\n    else\n        ameth = EVP_PKEY_asn1_find(eptr, type);\n#ifndef OPENSSL_NO_ENGINE\n    if (pkey == NULL \u0026\u0026 eptr != NULL)\n        ENGINE_finish(e);\n#endif\n    if (ameth == NULL) {\n        EVPerr(EVP_F_PKEY_SET_TYPE, EVP_R_UNSUPPORTED_ALGORITHM);\n        return 0;\n    }\n    if (pkey) {\n        pkey-\u003eameth = ameth;\n        pkey-\u003eengine = e;\n\n        pkey-\u003etype = pkey-\u003eameth-\u003epkey_id;\n        pkey-\u003esave_type = type;\n    }\n    return 1;\n}","filepath":"crypto/evp/p_lib.c","line_number":178,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1b"},"269879152":{"score":0.93568945,"function_name":"EC_KEY_check_key","code":"int EC_KEY_check_key(const EC_KEY *eckey)\n{\n    if (eckey == NULL || eckey-\u003egroup == NULL || eckey-\u003epub_key == NULL) {\n        ECerr(EC_F_EC_KEY_CHECK_KEY, ERR_R_PASSED_NULL_PARAMETER);\n        return 0;\n    }\n\n    if (eckey-\u003egroup-\u003emeth-\u003ekeycheck == NULL) {\n        ECerr(EC_F_EC_KEY_CHECK_KEY, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return 0;\n    }\n\n    return eckey-\u003egroup-\u003emeth-\u003ekeycheck(eckey);\n}","filepath":"crypto/ec/ec_key.c","line_number":256,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1r"},"269879280":{"score":0.91529304,"function_name":"EC_KEY_copy","code":"EC_KEY *EC_KEY_copy(EC_KEY *dest, const EC_KEY *src)\n{\n    if (dest == NULL || src == NULL) {\n        ECerr(EC_F_EC_KEY_COPY, ERR_R_PASSED_NULL_PARAMETER);\n        return NULL;\n    }\n    if (src-\u003emeth != dest-\u003emeth) {\n        if (dest-\u003emeth-\u003efinish != NULL)\n            dest-\u003emeth-\u003efinish(dest);\n        if (dest-\u003egroup \u0026\u0026 dest-\u003egroup-\u003emeth-\u003ekeyfinish)\n            dest-\u003egroup-\u003emeth-\u003ekeyfinish(dest);\n#ifndef OPENSSL_NO_ENGINE\n        if (ENGINE_finish(dest-\u003eengine) == 0)\n            return 0;\n        dest-\u003eengine = NULL;\n#endif\n    }\n    /* copy the parameters */\n    if (src-\u003egroup != NULL) {\n        const EC_METHOD *meth = EC_GROUP_method_of(src-\u003egroup);\n        /* clear the old group */\n        EC_GROUP_free(dest-\u003egroup);\n        dest-\u003egroup = EC_GROUP_new(meth);\n        if (dest-\u003egroup == NULL)\n            return NULL;\n        if (!EC_GROUP_copy(dest-\u003egroup, src-\u003egroup))\n            return NULL;\n\n        /*  copy the public key */\n        if (src-\u003epub_key != NULL) {\n            EC_POINT_free(dest-\u003epub_key);\n            dest-\u003epub_key = EC_POINT_new(src-\u003egroup);\n            if (dest-\u003epub_key == NULL)\n                return NULL;\n            if (!EC_POINT_copy(dest-\u003epub_key, src-\u003epub_key))\n                return NULL;\n        }\n        /* copy the private key */\n        if (src-\u003epriv_key != NULL) {\n            if (dest-\u003epriv_key == NULL) {\n                dest-\u003epriv_key = BN_new();\n                if (dest-\u003epriv_key == NULL)\n                    return NULL;\n            }\n            if (!BN_copy(dest-\u003epriv_key, src-\u003epriv_key))\n                return NULL;\n            if (src-\u003egroup-\u003emeth-\u003ekeycopy\n                \u0026\u0026 src-\u003egroup-\u003emeth-\u003ekeycopy(dest, src) == 0)\n                return NULL;\n        }\n    }\n\n\n    /* copy the rest */\n    dest-\u003eenc_flag = src-\u003eenc_flag;\n    dest-\u003econv_form = src-\u003econv_form;\n    dest-\u003eversion = src-\u003eversion;\n    dest-\u003eflags = src-\u003eflags;\n    if (!CRYPTO_dup_ex_data(CRYPTO_EX_INDEX_EC_KEY,\n                            \u0026dest-\u003eex_data, \u0026src-\u003eex_data))\n        return NULL;\n\n    if (src-\u003emeth != dest-\u003emeth) {\n#ifndef OPENSSL_NO_ENGINE\n        if (src-\u003eengine != NULL \u0026\u0026 ENGINE_init(src-\u003eengine) == 0)\n            return NULL;\n        dest-\u003eengine = src-\u003eengine;\n#endif\n        dest-\u003emeth = src-\u003emeth;\n    }\n\n    if (src-\u003emeth-\u003ecopy != NULL \u0026\u0026 src-\u003emeth-\u003ecopy(dest, src) == 0)\n        return NULL;\n\n    return dest;\n}\n\nEC_KEY *EC_KEY_dup(const EC_KEY *ec_key)\n{\n    EC_KEY *ret = EC_KEY_new_method(ec_key-\u003eengine);\n\n    if (ret == NULL)\n        return NULL;\n\n    if (EC_KEY_copy(ret, ec_key) == NULL) {\n        EC_KEY_free(ret);\n        return NULL;\n    }\n    return ret;\n}\n\nint EC_KEY_up_ref(EC_KEY *r)\n{\n    int i;\n\n    if (CRYPTO_UP_REF(\u0026r-\u003ereferences, \u0026i, r-\u003elock) \u003c= 0)\n        return 0;\n\n    REF_PRINT_COUNT(\"EC_KEY\", r);\n    REF_ASSERT_ISNT(i \u003c 2);\n    return ((i \u003e 1) ? 1 : 0);\n}\n\nENGINE *EC_KEY_get0_engine(const EC_KEY *eckey)\n{\n    return eckey-\u003eengine;\n}\n\nint EC_KEY_generate_key(EC_KEY *eckey)\n{\n    if (eckey == NULL || eckey-\u003egroup == NULL) {\n        ECerr(EC_F_EC_KEY_GENERATE_KEY, ERR_R_PASSED_NULL_PARAMETER);\n        return 0;\n    }\n    if (eckey-\u003emeth-\u003ekeygen != NULL)\n        return eckey-\u003emeth-\u003ekeygen(eckey);\n    ECerr(EC_F_EC_KEY_GENERATE_KEY, EC_R_OPERATION_NOT_SUPPORTED);\n    return 0;\n}\n\nint ossl_ec_key_gen(EC_KEY *eckey)\n{\n    return eckey-\u003egroup-\u003emeth-\u003ekeygen(eckey);\n}\n\nint ec_key_simple_generate_key(EC_KEY *eckey)\n{\n    int ok = 0;\n    BN_CTX *ctx = NULL;\n    BIGNUM *priv_key = NULL;\n    const BIGNUM *order = NULL;\n    EC_POINT *pub_key = NULL;\n\n    if ((ctx = BN_CTX_new()) == NULL)\n        goto err;\n\n    if (eckey-\u003epriv_key == NULL) {\n        priv_key = BN_new();\n        if (priv_key == NULL)\n            goto err;\n    } else\n        priv_key = eckey-\u003epriv_key;\n\n    order = EC_GROUP_get0_order(eckey-\u003egroup);\n    if (order == NULL)\n        goto err;\n\n    do\n        if (!BN_priv_rand_range(priv_key, order))\n            goto err;\n    while (BN_is_zero(priv_key)) ;\n\n    if (eckey-\u003epub_key == NULL) {\n        pub_key = EC_POINT_new(eckey-\u003egroup);\n        if (pub_key == NULL)\n            goto err;\n    } else\n        pub_key = eckey-\u003epub_key;\n\n    if (!EC_POINT_mul(eckey-\u003egroup, pub_key, priv_key, NULL, NULL, ctx))\n        goto err;\n\n    eckey-\u003epriv_key = priv_key;\n    eckey-\u003epub_key = pub_key;\n\n    ok = 1;\n\n err:\n    if (eckey-\u003epub_key == NULL)\n        EC_POINT_free(pub_key);\n    if (eckey-\u003epriv_key != priv_key)\n        BN_free(priv_key);\n    BN_CTX_free(ctx);\n    return ok;\n}\n\nint ec_key_simple_generate_public_key(EC_KEY *eckey)\n{\n    return EC_POINT_mul(eckey-\u003egroup, eckey-\u003epub_key, eckey-\u003epriv_key, NULL,\n                        NULL, NULL);\n}\n\nint EC_KEY_check_key(const EC_KEY *eckey)\n{\n    if (eckey == NULL || eckey-\u003egroup == NULL || eckey-\u003epub_key == NULL) {\n        ECerr(EC_F_EC_KEY_CHECK_KEY, ERR_R_PASSED_NULL_PARAMETER);\n        return 0;\n    }\n\n    if (eckey-\u003egroup-\u003emeth-\u003ekeycheck == NULL) {\n        ECerr(EC_F_EC_KEY_CHECK_KEY, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return 0;\n    }\n\n    return eckey-\u003egroup-\u003emeth-\u003ekeycheck(eckey);\n}\n\nint ec_key_simple_check_key(const EC_KEY *eckey)\n{\n    int ok = 0;\n    BN_CTX *ctx = NULL;\n    const BIGNUM *order = NULL;\n    EC_POINT *point = NULL;\n\n    if (eckey == NULL || eckey-\u003egroup == NULL || eckey-\u003epub_key == NULL) {\n        ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, ERR_R_PASSED_NULL_PARAMETER);\n        return 0;\n    }\n\n    if (EC_POINT_is_at_infinity(eckey-\u003egroup, eckey-\u003epub_key)) {\n        ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, EC_R_POINT_AT_INFINITY);\n        goto err;\n    }\n\n    if ((ctx = BN_CTX_new()) == NULL)\n        goto err;\n    if ((point = EC_POINT_new(eckey-\u003egroup)) == NULL)\n        goto err;\n\n    /* testing whether the pub_key is on the elliptic curve */\n    if (EC_POINT_is_on_curve(eckey-\u003egroup, eckey-\u003epub_key, ctx) \u003c= 0) {\n        ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, EC_R_POINT_IS_NOT_ON_CURVE);\n        goto err;\n    }\n    /* testing whether pub_key * order is the point at infinity */\n    order = eckey-\u003egroup-\u003eorder;\n    if (BN_is_zero(order)) {\n        ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, EC_R_INVALID_GROUP_ORDER);\n        goto err;\n    }\n    if (!EC_POINT_mul(eckey-\u003egroup, point, NULL, eckey-\u003epub_key, order, ctx)) {\n        ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, ERR_R_EC_LIB);\n        goto err;\n    }\n    if (!EC_POINT_is_at_infinity(eckey-\u003egroup, point)) {\n        ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, EC_R_WRONG_ORDER);\n        goto err;\n    }\n    /*\n     * in case the priv_key is present : check if generator * priv_key ==\n     * pub_key\n     */\n    if (eckey-\u003epriv_key != NULL) {\n        if (BN_cmp(eckey-\u003epriv_key, order) \u003e= 0) {\n            ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, EC_R_WRONG_ORDER);\n            goto err;\n        }\n        if (!EC_POINT_mul(eckey-\u003egroup, point, eckey-\u003epriv_key,\n                          NULL, NULL, ctx)) {\n            ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, ERR_R_EC_LIB);\n            goto err;\n        }\n        if (EC_POINT_cmp(eckey-\u003egroup, point, eckey-\u003epub_key, ctx) != 0) {\n            ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, EC_R_INVALID_PRIVATE_KEY);\n            goto err;\n        }\n    }\n    ok = 1;\n err:\n    BN_CTX_free(ctx);\n    EC_POINT_free(point);\n    return ok;\n}\n\nint EC_KEY_set_public_key_affine_coordinates(EC_KEY *key, BIGNUM *x,\n                                             BIGNUM *y)\n{\n    BN_CTX *ctx = NULL;\n    BIGNUM *tx, *ty;\n    EC_POINT *point = NULL;\n    int ok = 0;\n\n    if (key == NULL || key-\u003egroup == NULL || x == NULL || y == NULL) {\n        ECerr(EC_F_EC_KEY_SET_PUBLIC_KEY_AFFINE_COORDINATES,\n              ERR_R_PASSED_NULL_PARAMETER);\n        return 0;\n    }\n    ctx = BN_CTX_new();\n    if (ctx == NULL)\n        return 0;\n\n    BN_CTX_start(ctx);\n    point = EC_POINT_new(key-\u003egroup);\n\n    if (point == NULL)\n        goto err;\n\n    tx = BN_CTX_get(ctx);\n    ty = BN_CTX_get(ctx);\n    if (ty == NULL)\n        goto err;\n\n    if (!EC_POINT_set_affine_coordinates(key-\u003egroup, point, x, y, ctx))\n        goto err;\n    if (!EC_POINT_get_affine_coordinates(key-\u003egroup, point, tx, ty, ctx))\n        goto err;\n\n    /*\n     * Check if retrieved coordinates match originals and are less than field\n     * order: if not values are out of range.\n     */\n    if (BN_cmp(x, tx) || BN_cmp(y, ty)\n        || (BN_cmp(x, key-\u003egroup-\u003efield) \u003e= 0)\n        || (BN_cmp(y, key-\u003egroup-\u003efield) \u003e= 0)) {\n        ECerr(EC_F_EC_KEY_SET_PUBLIC_KEY_AFFINE_COORDINATES,\n              EC_R_COORDINATES_OUT_OF_RANGE);\n        goto err;\n    }\n\n    if (!EC_KEY_set_public_key(key, point))\n        goto err;\n\n    if (EC_KEY_check_key(key) == 0)\n        goto err;\n\n    ok = 1;\n\n err:\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    EC_POINT_free(point);\n    return ok;\n\n}\n\nconst EC_GROUP *EC_KEY_get0_group(const EC_KEY *key)\n{\n    return key-\u003egroup;\n}\n\nint EC_KEY_set_group(EC_KEY *key, const EC_GROUP *group)\n{\n    if (key-\u003emeth-\u003eset_group != NULL \u0026\u0026 key-\u003emeth-\u003eset_group(key, group) == 0)\n        return 0;\n    EC_GROUP_free(key-\u003egroup);\n    key-\u003egroup = EC_GROUP_dup(group);\n    return (key-\u003egroup == NULL) ? 0 : 1;\n}\n\nconst BIGNUM *EC_KEY_get0_private_key(const EC_KEY *key)\n{\n    return key-\u003epriv_key;\n}\n\nint EC_KEY_set_private_key(EC_KEY *key, const BIGNUM *priv_key)\n{\n    int fixed_top;\n    const BIGNUM *order = NULL;\n    BIGNUM *tmp_key = NULL;\n\n    if (key-\u003egroup == NULL || key-\u003egroup-\u003emeth == NULL)\n        return 0;\n\n    /*\n     * Not only should key-\u003egroup be set, but it should also be in a valid\n     * fully initialized state.\n     *\n     * Specifically, to operate in constant time, we need that the group order\n     * is set, as we use its length as the fixed public size of any scalar used\n     * as an EC private key.\n     */\n    order = EC_GROUP_get0_order(key-\u003egroup);\n    if (order == NULL || BN_is_zero(order))\n        return 0; /* This should never happen */\n\n    if (key-\u003egroup-\u003emeth-\u003eset_private != NULL\n        \u0026\u0026 key-\u003egroup-\u003emeth-\u003eset_private(key, priv_key) == 0)\n        return 0;\n    if (key-\u003emeth-\u003eset_private != NULL\n        \u0026\u0026 key-\u003emeth-\u003eset_private(key, priv_key) == 0)\n        return 0;\n\n    /*\n     * Return `0` to comply with legacy behavior for this function, see\n     * https://github.com/openssl/openssl/issues/18744#issuecomment-1195175696\n     */\n    if (priv_key == NULL) {\n        BN_clear_free(key-\u003epriv_key);\n        key-\u003epriv_key = NULL;\n        return 0; /* intentional for legacy compatibility */\n    }\n\n    /*\n     * We should never leak the bit length of the secret scalar in the key,\n     * so we always set the `BN_FLG_CONSTTIME` flag on the internal `BIGNUM`\n     * holding the secret scalar.\n     *\n     * This is important also because `BN_dup()` (and `BN_copy()`) do not\n     * propagate the `BN_FLG_CONSTTIME` flag from the source `BIGNUM`, and\n     * this brings an extra risk of inadvertently losing the flag, even when\n     * the caller specifically set it.\n     *\n     * The propagation has been turned on and off a few times in the past\n     * years because in some conditions has shown unintended consequences in\n     * some code paths, so at the moment we can't fix this in the BN layer.\n     *\n     * In `EC_KEY_set_private_key()` we can work around the propagation by\n     * manually setting the flag after `BN_dup()` as we know for sure that\n     * inside the EC module the `BN_FLG_CONSTTIME` is always treated\n     * correctly and should not generate unintended consequences.\n     *\n     * Setting the BN_FLG_CONSTTIME flag alone is never enough, we also have\n     * to preallocate the BIGNUM internal buffer to a fixed public size big\n     * enough that operations performed during the processing never trigger\n     * a realloc which would leak the size of the scalar through memory\n     * accesses.\n     *\n     * Fixed Length\n     * ------------\n     *\n     * The order of the large prime subgroup of the curve is our choice for\n     * a fixed public size, as that is generally the upper bound for\n     * generating a private key in EC cryptosystems and should fit all valid\n     * secret scalars.\n     *\n     * For preallocating the BIGNUM storage we look at the number of \"words\"\n     * required for the internal representation of the order, and we\n     * preallocate 2 extra \"words\" in case any of the subsequent processing\n     * might temporarily overflow the order length.\n     */\n    tmp_key = BN_dup(priv_key);\n    if (tmp_key == NULL)\n        return 0;\n\n    BN_set_flags(tmp_key, BN_FLG_CONSTTIME);\n\n    fixed_top = bn_get_top(order) + 2;\n    if (bn_wexpand(tmp_key, fixed_top) == NULL) {\n        BN_clear_free(tmp_key);\n        return 0;\n    }\n\n    BN_clear_free(key-\u003epriv_key);\n    key-\u003epriv_key = tmp_key;\n\n    return 1;\n}\n\nconst EC_POINT *EC_KEY_get0_public_key(const EC_KEY *key)\n{\n    return key-\u003epub_key;\n}\n\nint EC_KEY_set_public_key(EC_KEY *key, const EC_POINT *pub_key)\n{\n    if (key-\u003emeth-\u003eset_public != NULL\n        \u0026\u0026 key-\u003emeth-\u003eset_public(key, pub_key) == 0)\n        return 0;\n    EC_POINT_free(key-\u003epub_key);\n    key-\u003epub_key = EC_POINT_dup(pub_key, key-\u003egroup);\n    return (key-\u003epub_key == NULL) ? 0 : 1;\n}\n\nunsigned int EC_KEY_get_enc_flags(const EC_KEY *key)\n{\n    return key-\u003eenc_flag;\n}\n\nvoid EC_KEY_set_enc_flags(EC_KEY *key, unsigned int flags)\n{\n    key-\u003eenc_flag = flags;\n}\n\npoint_conversion_form_t EC_KEY_get_conv_form(const EC_KEY *key)\n{\n    return key-\u003econv_form;\n}\n\nvoid EC_KEY_set_conv_form(EC_KEY *key, point_conversion_form_t cform)\n{\n    key-\u003econv_form = cform;\n    if (key-\u003egroup != NULL)\n        EC_GROUP_set_point_conversion_form(key-\u003egroup, cform);\n}\n\nvoid EC_KEY_set_asn1_flag(EC_KEY *key, int flag)\n{\n    if (key-\u003egroup != NULL)\n        EC_GROUP_set_asn1_flag(key-\u003egroup, flag);\n}\n\nint EC_KEY_precompute_mult(EC_KEY *key, BN_CTX *ctx)\n{\n    if (key-\u003egroup == NULL)\n        return 0;\n    return EC_GROUP_precompute_mult(key-\u003egroup, ctx);\n}\n\nint EC_KEY_get_flags(const EC_KEY *key)\n{\n    return key-\u003eflags;\n}\n\nvoid EC_KEY_set_flags(EC_KEY *key, int flags)\n{\n    key-\u003eflags |= flags;\n}\n\nvoid EC_KEY_clear_flags(EC_KEY *key, int flags)\n{\n    key-\u003eflags \u0026= ~flags;\n}\n\nint EC_KEY_decoded_from_explicit_params(const EC_KEY *key)\n{\n    if (key == NULL || key-\u003egroup == NULL)\n        return -1;\n    return key-\u003egroup-\u003edecoded_from_explicit_params;\n}\n\nsize_t EC_KEY_key2buf(const EC_KEY *key, point_conversion_form_t form,\n                        unsigned char **pbuf, BN_CTX *ctx)\n{\n    if (key == NULL || key-\u003epub_key == NULL || key-\u003egroup == NULL)\n        return 0;\n    return EC_POINT_point2buf(key-\u003egroup, key-\u003epub_key, form, pbuf, ctx);\n}\n\nint EC_KEY_oct2key(EC_KEY *key, const unsigned char *buf, size_t len,\n                   BN_CTX *ctx)\n{\n    if (key == NULL || key-\u003egroup == NULL)\n        return 0;\n    if (key-\u003epub_key == NULL)\n        key-\u003epub_key = EC_POINT_new(key-\u003egroup);\n    if (key-\u003epub_key == NULL)\n        return 0;\n    if (EC_POINT_oct2point(key-\u003egroup, key-\u003epub_key, buf, len, ctx) == 0)\n        return 0;\n    /*\n     * Save the point conversion form.\n     * For non-custom curves the first octet of the buffer (excluding\n     * the last significant bit) contains the point conversion form.\n     * EC_POINT_oct2point() has already performed sanity checking of\n     * the buffer so we know it is valid.\n     */\n    if ((key-\u003egroup-\u003emeth-\u003eflags \u0026 EC_FLAGS_CUSTOM_CURVE) == 0)\n        key-\u003econv_form = (point_conversion_form_t)(buf[0] \u0026 ~0x01);\n    return 1;\n}\n\nsize_t EC_KEY_priv2oct(const EC_KEY *eckey,\n                       unsigned char *buf, size_t len)\n{\n    if (eckey-\u003egroup == NULL || eckey-\u003egroup-\u003emeth == NULL)\n        return 0;\n    if (eckey-\u003egroup-\u003emeth-\u003epriv2oct == NULL) {\n        ECerr(EC_F_EC_KEY_PRIV2OCT, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return 0;\n    }\n\n    return eckey-\u003egroup-\u003emeth-\u003epriv2oct(eckey, buf, len);\n}\n\nsize_t ec_key_simple_priv2oct(const EC_KEY *eckey,\n                              unsigned char *buf, size_t len)\n{\n    size_t buf_len;\n\n    buf_len = (EC_GROUP_order_bits(eckey-\u003egroup) + 7) / 8;\n    if (eckey-\u003epriv_key == NULL)\n        return 0;\n    if (buf == NULL)\n        return buf_len;\n    else if (len \u003c buf_len)\n        return 0;\n\n    /* Octetstring may need leading zeros if BN is to short */\n\n    if (BN_bn2binpad(eckey-\u003epriv_key, buf, buf_len) == -1) {\n        ECerr(EC_F_EC_KEY_SIMPLE_PRIV2OCT, EC_R_BUFFER_TOO_SMALL);\n        return 0;\n    }\n\n    return buf_len;\n}\n\nint EC_KEY_oct2priv(EC_KEY *eckey, const unsigned char *buf, size_t len)\n{\n    if (eckey-\u003egroup == NULL || eckey-\u003egroup-\u003emeth == NULL)\n        return 0;\n    if (eckey-\u003egroup-\u003emeth-\u003eoct2priv == NULL) {\n        ECerr(EC_F_EC_KEY_OCT2PRIV, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return 0;\n    }\n    return eckey-\u003egroup-\u003emeth-\u003eoct2priv(eckey, buf, len);\n}\n\nint ec_key_simple_oct2priv(EC_KEY *eckey, const unsigned char *buf, size_t len)\n{\n    if (eckey-\u003epriv_key == NULL)\n        eckey-\u003epriv_key = BN_secure_new();\n    if (eckey-\u003epriv_key == NULL) {\n        ECerr(EC_F_EC_KEY_SIMPLE_OCT2PRIV, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n    if (BN_bin2bn(buf, len, eckey-\u003epriv_key) == NULL) {\n        ECerr(EC_F_EC_KEY_SIMPLE_OCT2PRIV, ERR_R_BN_LIB);\n        return 0;\n    }\n    return 1;\n}\n\nsize_t EC_KEY_priv2buf(const EC_KEY *eckey, unsigned char **pbuf)\n{\n    size_t len;\n    unsigned char *buf;\n\n    len = EC_KEY_priv2oct(eckey, NULL, 0);\n    if (len == 0)\n        return 0;\n    if ((buf = OPENSSL_malloc(len)) == NULL) {\n        ECerr(EC_F_EC_KEY_PRIV2BUF, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n    len = EC_KEY_priv2oct(eckey, buf, len);\n    if (len == 0) {\n        OPENSSL_free(buf);\n        return 0;\n    }\n    *pbuf = buf;\n    return len;\n}\n\nint EC_KEY_can_sign(const EC_KEY *eckey)\n{\n    if (eckey-\u003egroup == NULL || eckey-\u003egroup-\u003emeth == NULL\n        || (eckey-\u003egroup-\u003emeth-\u003eflags \u0026 EC_FLAGS_NO_SIGN))\n        return 0;\n    return 1;\n}","filepath":"crypto/ec/ec_key.c","line_number":74,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1r"},"269879728":{"score":0.85664976,"function_name":"EC_KEY_dup","code":"EC_KEY *EC_KEY_dup(const EC_KEY *ec_key)\n{\n    EC_KEY *ret = EC_KEY_new_method(ec_key-\u003eengine);\n\n    if (ret == NULL)\n        return NULL;\n\n    if (EC_KEY_copy(ret, ec_key) == NULL) {\n        EC_KEY_free(ret);\n        return NULL;\n    }\n    return ret;\n}","filepath":"crypto/ec/ec_key.c","line_number":151,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1r"},"269879792":{"score":0.8603818,"function_name":"EC_KEY_free","code":"void EC_KEY_free(EC_KEY *r)\n{\n    int i;\n\n    if (r == NULL)\n        return;\n\n    CRYPTO_DOWN_REF(\u0026r-\u003ereferences, \u0026i, r-\u003elock);\n    REF_PRINT_COUNT(\"EC_KEY\", r);\n    if (i \u003e 0)\n        return;\n    REF_ASSERT_ISNT(i \u003c 0);\n\n    if (r-\u003emeth != NULL \u0026\u0026 r-\u003emeth-\u003efinish != NULL)\n        r-\u003emeth-\u003efinish(r);\n\n#ifndef OPENSSL_NO_ENGINE\n    ENGINE_finish(r-\u003eengine);\n#endif\n\n    if (r-\u003egroup \u0026\u0026 r-\u003egroup-\u003emeth-\u003ekeyfinish)\n        r-\u003egroup-\u003emeth-\u003ekeyfinish(r);\n\n    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_EC_KEY, r, \u0026r-\u003eex_data);\n    CRYPTO_THREAD_lock_free(r-\u003elock);\n    EC_GROUP_free(r-\u003egroup);\n    EC_POINT_free(r-\u003epub_key);\n    BN_clear_free(r-\u003epriv_key);\n\n    OPENSSL_clear_free((void *)r, sizeof(EC_KEY));\n}","filepath":"crypto/ec/ec_key.c","line_number":42,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1r"},"269880160":{"score":0.9193919,"function_name":"EC_KEY_oct2key","code":"int EC_KEY_oct2key(EC_KEY *key, const unsigned char *buf, size_t len,\n                   BN_CTX *ctx)\n{\n    if (key == NULL || key-\u003egroup == NULL)\n        return 0;\n    if (key-\u003epub_key == NULL)\n        key-\u003epub_key = EC_POINT_new(key-\u003egroup);\n    if (key-\u003epub_key == NULL)\n        return 0;\n    if (EC_POINT_oct2point(key-\u003egroup, key-\u003epub_key, buf, len, ctx) == 0)\n        return 0;\n    /*\n     * Save the point conversion form.\n     * For non-custom curves the first octet of the buffer (excluding\n     * the last significant bit) contains the point conversion form.\n     * EC_POINT_oct2point() has already performed sanity checking of\n     * the buffer so we know it is valid.\n     */\n    if ((key-\u003egroup-\u003emeth-\u003eflags \u0026 EC_FLAGS_CUSTOM_CURVE) == 0)\n        key-\u003econv_form = (point_conversion_form_t)(buf[0] \u0026 ~0x01);\n    return 1;\n}","filepath":"crypto/ec/ec_key.c","line_number":592,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1r"},"269880272":{"score":0.9033652,"function_name":"EC_KEY_oct2priv","code":"int EC_KEY_oct2priv(EC_KEY *eckey, const unsigned char *buf, size_t len)\n{\n    if (eckey-\u003egroup == NULL || eckey-\u003egroup-\u003emeth == NULL)\n        return 0;\n    if (eckey-\u003egroup-\u003emeth-\u003eoct2priv == NULL) {\n        ECerr(EC_F_EC_KEY_OCT2PRIV, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return 0;\n    }\n    return eckey-\u003egroup-\u003emeth-\u003eoct2priv(eckey, buf, len);\n}","filepath":"crypto/ec/ec_key.c","line_number":651,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1r"},"269880336":{"score":0.81189394,"function_name":"EC_KEY_priv2buf","code":"size_t EC_KEY_priv2buf(const EC_KEY *eckey, unsigned char **pbuf)\n{\n    size_t len;\n    unsigned char *buf;\n\n    len = EC_KEY_priv2oct(eckey, NULL, 0);\n    if (len == 0)\n        return 0;\n    if ((buf = OPENSSL_malloc(len)) == NULL) {\n        ECerr(EC_F_EC_KEY_PRIV2BUF, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n    len = EC_KEY_priv2oct(eckey, buf, len);\n    if (len == 0) {\n        OPENSSL_free(buf);\n        return 0;\n    }\n    *pbuf = buf;\n    return len;\n}","filepath":"crypto/ec/ec_key.c","line_number":677,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1r"},"269880592":{"score":0.81183183,"function_name":"EC_KEY_set_group","code":"int EC_KEY_set_group(EC_KEY *key, const EC_GROUP *group)\n{\n    if (key-\u003emeth-\u003eset_group != NULL \u0026\u0026 key-\u003emeth-\u003eset_group(key, group) == 0)\n        return 0;\n    EC_GROUP_free(key-\u003egroup);\n    key-\u003egroup = EC_GROUP_dup(group);\n    return (key-\u003egroup == NULL) ? 0 : 1;\n}","filepath":"crypto/ec/ec_key.c","line_number":404,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1r"},"269880688":{"score":0.936688,"function_name":"ec_key_simple_check_key","code":"int ec_key_simple_check_key(const EC_KEY *eckey)\n{\n    int ok = 0;\n    BN_CTX *ctx = NULL;\n    const BIGNUM *order = NULL;\n    EC_POINT *point = NULL;\n\n    if (eckey == NULL || eckey-\u003egroup == NULL || eckey-\u003epub_key == NULL) {\n        ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, ERR_R_PASSED_NULL_PARAMETER);\n        return 0;\n    }\n\n    if (EC_POINT_is_at_infinity(eckey-\u003egroup, eckey-\u003epub_key)) {\n        ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, EC_R_POINT_AT_INFINITY);\n        goto err;\n    }\n\n    if ((ctx = BN_CTX_new()) == NULL)\n        goto err;\n    if ((point = EC_POINT_new(eckey-\u003egroup)) == NULL)\n        goto err;\n\n    /* testing whether the pub_key is on the elliptic curve */\n    if (EC_POINT_is_on_curve(eckey-\u003egroup, eckey-\u003epub_key, ctx) \u003c= 0) {\n        ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, EC_R_POINT_IS_NOT_ON_CURVE);\n        goto err;\n    }\n    /* testing whether pub_key * order is the point at infinity */\n    order = eckey-\u003egroup-\u003eorder;\n    if (BN_is_zero(order)) {\n        ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, EC_R_INVALID_GROUP_ORDER);\n        goto err;\n    }\n    if (!EC_POINT_mul(eckey-\u003egroup, point, NULL, eckey-\u003epub_key, order, ctx)) {\n        ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, ERR_R_EC_LIB);\n        goto err;\n    }\n    if (!EC_POINT_is_at_infinity(eckey-\u003egroup, point)) {\n        ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, EC_R_WRONG_ORDER);\n        goto err;\n    }\n    /*\n     * in case the priv_key is present : check if generator * priv_key ==\n     * pub_key\n     */\n    if (eckey-\u003epriv_key != NULL) {\n        if (BN_cmp(eckey-\u003epriv_key, order) \u003e= 0) {\n            ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, EC_R_WRONG_ORDER);\n            goto err;\n        }\n        if (!EC_POINT_mul(eckey-\u003egroup, point, eckey-\u003epriv_key,\n                          NULL, NULL, ctx)) {\n            ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, ERR_R_EC_LIB);\n            goto err;\n        }\n        if (EC_POINT_cmp(eckey-\u003egroup, point, eckey-\u003epub_key, ctx) != 0) {\n            ECerr(EC_F_EC_KEY_SIMPLE_CHECK_KEY, EC_R_INVALID_PRIVATE_KEY);\n            goto err;\n        }\n    }\n    ok = 1;\n err:\n    BN_CTX_free(ctx);\n    EC_POINT_free(point);\n    return ok;\n}","filepath":"crypto/ec/ec_key.c","line_number":271,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1r"},"269881216":{"score":0.89289653,"function_name":"ec_key_simple_generate_key","code":"int ec_key_simple_generate_key(EC_KEY *eckey)\n{\n    int ok = 0;\n    BN_CTX *ctx = NULL;\n    BIGNUM *priv_key = NULL;\n    const BIGNUM *order = NULL;\n    EC_POINT *pub_key = NULL;\n\n    if ((ctx = BN_CTX_new()) == NULL)\n        goto err;\n\n    if (eckey-\u003epriv_key == NULL) {\n        priv_key = BN_new();\n        if (priv_key == NULL)\n            goto err;\n    } else\n        priv_key = eckey-\u003epriv_key;\n\n    order = EC_GROUP_get0_order(eckey-\u003egroup);\n    if (order == NULL)\n        goto err;\n\n    do\n        if (!BN_priv_rand_range(priv_key, order))\n            goto err;\n    while (BN_is_zero(priv_key)) ;\n\n    if (eckey-\u003epub_key == NULL) {\n        pub_key = EC_POINT_new(eckey-\u003egroup);\n        if (pub_key == NULL)\n            goto err;\n    } else\n        pub_key = eckey-\u003epub_key;\n\n    if (!EC_POINT_mul(eckey-\u003egroup, pub_key, priv_key, NULL, NULL, ctx))\n        goto err;\n\n    eckey-\u003epriv_key = priv_key;\n    eckey-\u003epub_key = pub_key;\n\n    ok = 1;\n\n err:\n    if (eckey-\u003epub_key == NULL)\n        EC_POINT_free(pub_key);\n    if (eckey-\u003epriv_key != priv_key)\n        BN_free(priv_key);\n    BN_CTX_free(ctx);\n    return ok;\n}","filepath":"crypto/ec/ec_key.c","line_number":199,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1r"},"269882640":{"score":0.87686545,"function_name":"DSA_free","code":"void DSA_free(DSA *r)\n{\n    int i;\n\n    if (r == NULL)\n        return;\n\n    i = CRYPTO_add(\u0026r-\u003ereferences, -1, CRYPTO_LOCK_DSA);\n#ifdef REF_PRINT\n    REF_PRINT(\"DSA\", r);\n#endif\n    if (i \u003e 0)\n        return;\n#ifdef REF_CHECK\n    if (i \u003c 0) {\n        fprintf(stderr, \"DSA_free, bad reference count\\n\");\n        abort();\n    }\n#endif\n\n    if (r-\u003emeth-\u003efinish)\n        r-\u003emeth-\u003efinish(r);\n#ifndef OPENSSL_NO_ENGINE\n    if (r-\u003eengine)\n        ENGINE_finish(r-\u003eengine);\n#endif\n\n    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_DSA, r, \u0026r-\u003eex_data);\n\n    BN_clear_free(r-\u003ep);\n    BN_clear_free(r-\u003eq);\n    BN_clear_free(r-\u003eg);\n    BN_clear_free(r-\u003epub_key);\n    BN_clear_free(r-\u003epriv_key);\n    BN_clear_free(r-\u003ekinv);\n    BN_clear_free(r-\u003er);\n    OPENSSL_free(r);\n}","filepath":"crypto/dsa/dsa_lib.c","line_number":161,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre2"},"269882800":{"score":0.83844143,"function_name":"DSA_new_method","code":"DSA *DSA_new_method(ENGINE *engine)\n{\n    DSA *ret;\n\n    ret = OPENSSL_zalloc(sizeof(*ret));\n    if (ret == NULL) {\n        DSAerr(DSA_F_DSA_NEW_METHOD, ERR_R_MALLOC_FAILURE);\n        return (NULL);\n    }\n    ret-\u003emeth = DSA_get_default_method();\n#ifndef OPENSSL_NO_ENGINE\n    if (engine) {\n        if (!ENGINE_init(engine)) {\n            DSAerr(DSA_F_DSA_NEW_METHOD, ERR_R_ENGINE_LIB);\n            OPENSSL_free(ret);\n            return NULL;\n        }\n        ret-\u003eengine = engine;\n    } else\n        ret-\u003eengine = ENGINE_get_default_DSA();\n    if (ret-\u003eengine) {\n        ret-\u003emeth = ENGINE_get_DSA(ret-\u003eengine);\n        if (!ret-\u003emeth) {\n            DSAerr(DSA_F_DSA_NEW_METHOD, ERR_R_ENGINE_LIB);\n            ENGINE_finish(ret-\u003eengine);\n            OPENSSL_free(ret);\n            return NULL;\n        }\n    }\n#endif\n\n    ret-\u003ereferences = 1;\n    ret-\u003eflags = ret-\u003emeth-\u003eflags \u0026 ~DSA_FLAG_NON_FIPS_ALLOW;\n    CRYPTO_new_ex_data(CRYPTO_EX_INDEX_DSA, ret, \u0026ret-\u003eex_data);\n    if ((ret-\u003emeth-\u003einit != NULL) \u0026\u0026 !ret-\u003emeth-\u003einit(ret)) {\n#ifndef OPENSSL_NO_ENGINE\n        if (ret-\u003eengine)\n            ENGINE_finish(ret-\u003eengine);\n#endif\n        CRYPTO_free_ex_data(CRYPTO_EX_INDEX_DSA, ret, \u0026ret-\u003eex_data);\n        OPENSSL_free(ret);\n        ret = NULL;\n    }\n\n    return (ret);\n}","filepath":"crypto/dsa/dsa_lib.c","line_number":114,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre2"},"269883296":{"score":0.85495347,"function_name":"DSA_size","code":"int DSA_size(const DSA *r)\n{\n    int ret, i;\n    ASN1_INTEGER bs;\n    unsigned char buf[4];       /* 4 bytes looks really small. However,\n                                 * i2d_ASN1_INTEGER() will not look beyond\n                                 * the first byte, as long as the second\n                                 * parameter is NULL. */\n\n    i = BN_num_bits(r-\u003eq);\n    bs.length = (i + 7) / 8;\n    bs.data = buf;\n    bs.type = V_ASN1_INTEGER;\n    /* If the top bit is set the asn1 encoding is 1 larger. */\n    buf[0] = 0xff;\n\n    i = i2d_ASN1_INTEGER(\u0026bs, NULL);\n    i += i;                     /* r and s */\n    ret = ASN1_object_size(1, i, V_ASN1_SEQUENCE);\n    return (ret);\n}","filepath":"crypto/dsa/dsa_lib.c","line_number":215,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre2"},"269884768":{"score":0.92013395,"function_name":"X509_PUBKEY_get0","code":"EVP_PKEY *X509_PUBKEY_get0(X509_PUBKEY *key)\n{\n    EVP_PKEY *ret = NULL;\n\n    if (key == NULL || key-\u003epublic_key == NULL)\n        return NULL;\n\n    if (key-\u003epkey != NULL)\n        return key-\u003epkey;\n\n    /*\n     * When the key ASN.1 is initially parsed an attempt is made to\n     * decode the public key and cache the EVP_PKEY structure. If this\n     * operation fails the cached value will be NULL. Parsing continues\n     * to allow parsing of unknown key types or unsupported forms.\n     * We repeat the decode operation so the appropriate errors are left\n     * in the queue.\n     */\n    x509_pubkey_decode(\u0026ret, key);\n    /* If decode doesn't fail something bad happened */\n    if (ret != NULL) {\n        X509err(X509_F_X509_PUBKEY_GET0, ERR_R_INTERNAL_ERROR);\n        EVP_PKEY_free(ret);\n    }\n\n    return NULL;\n}","filepath":"libs-ext/openssl/crypto/x509/x_pubkey.c","line_number":142,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269884864":{"score":0.9327428,"function_name":"X509_PUBKEY_get0_param","code":"int X509_PUBKEY_get0_param(ASN1_OBJECT **ppkalg,\n                           const unsigned char **pk, int *ppklen,\n                           X509_ALGOR **pa, X509_PUBKEY *pub)\n{\n    if (ppkalg)\n        *ppkalg = pub-\u003ealgor-\u003ealgorithm;\n    if (pk) {\n        *pk = pub-\u003epublic_key-\u003edata;\n        *ppklen = pub-\u003epublic_key-\u003elength;\n    }\n    if (pa)\n        *pa = pub-\u003ealgor;\n    return 1;\n}","filepath":"libs-ext/openssl/crypto/x509/x_pubkey.c","line_number":366,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269884944":{"score":0.928913,"function_name":"X509_PUBKEY_set0_param","code":"int X509_PUBKEY_set0_param(X509_PUBKEY *pub, ASN1_OBJECT *aobj,\n                           int ptype, void *pval,\n                           unsigned char *penc, int penclen)\n{\n    if (!X509_ALGOR_set0(pub-\u003ealgor, aobj, ptype, pval))\n        return 0;\n    if (penc) {\n        OPENSSL_free(pub-\u003epublic_key-\u003edata);\n        pub-\u003epublic_key-\u003edata = penc;\n        pub-\u003epublic_key-\u003elength = penclen;\n        /* Set number of unused bits to zero */\n        pub-\u003epublic_key-\u003eflags \u0026= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);\n        pub-\u003epublic_key-\u003eflags |= ASN1_STRING_FLAG_BITS_LEFT;\n    }\n    return 1;\n}","filepath":"libs-ext/openssl/crypto/x509/x_pubkey.c","line_number":349,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269885056":{"score":0.8511778,"function_name":"d2i_PUBKEY","code":"EVP_PKEY *d2i_PUBKEY(EVP_PKEY **a, const unsigned char **pp, long length)\n{\n    X509_PUBKEY *xpk;\n    EVP_PKEY *pktmp;\n    const unsigned char *q;\n    q = *pp;\n    xpk = d2i_X509_PUBKEY(NULL, \u0026q, length);\n    if (!xpk)\n        return NULL;\n    pktmp = X509_PUBKEY_get(xpk);\n    X509_PUBKEY_free(xpk);\n    if (!pktmp)\n        return NULL;\n    *pp = q;\n    if (a) {\n        EVP_PKEY_free(*a);\n        *a = pktmp;\n    }\n    return pktmp;\n}","filepath":"libs-ext/openssl/crypto/x509/x_pubkey.c","line_number":183,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269885376":{"score":0.9243992,"function_name":"x509_pubkey_decode","code":"static int x509_pubkey_decode(EVP_PKEY **ppkey, X509_PUBKEY *key)\n{\n    EVP_PKEY *pkey = EVP_PKEY_new();\n\n    if (pkey == NULL) {\n        X509err(X509_F_X509_PUBKEY_DECODE, ERR_R_MALLOC_FAILURE);\n        return -1;\n    }\n\n    if (!EVP_PKEY_set_type(pkey, OBJ_obj2nid(key-\u003ealgor-\u003ealgorithm))) {\n        X509err(X509_F_X509_PUBKEY_DECODE, X509_R_UNSUPPORTED_ALGORITHM);\n        goto error;\n    }\n\n    if (pkey-\u003eameth-\u003epub_decode) {\n        /*\n         * Treat any failure of pub_decode as a decode error. In\n         * future we could have different return codes for decode\n         * errors and fatal errors such as malloc failure.\n         */\n        if (!pkey-\u003eameth-\u003epub_decode(pkey, key)) {\n            X509err(X509_F_X509_PUBKEY_DECODE, X509_R_PUBLIC_KEY_DECODE_ERROR);\n            goto error;\n        }\n    } else {\n        X509err(X509_F_X509_PUBKEY_DECODE, X509_R_METHOD_NOT_SUPPORTED);\n        goto error;\n    }\n\n    *ppkey = pkey;\n    return 1;\n\n error:\n    EVP_PKEY_free(pkey);\n    return 0;\n}","filepath":"libs-ext/openssl/crypto/x509/x_pubkey.c","line_number":105,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269887616":{"score":0.87769103,"function_name":"PEM_def_callback","code":"int PEM_def_callback(char *buf, int num, int rwflag, void *userdata)\n{\n    int i, min_len;\n    const char *prompt;\n\n    /* We assume that the user passes a default password as userdata */\n    if (userdata) {\n        i = strlen(userdata);\n        i = (i \u003e num) ? num : i;\n        memcpy(buf, userdata, i);\n        return i;\n    }\n\n    prompt = EVP_get_pw_prompt();\n    if (prompt == NULL)\n        prompt = \"Enter PEM pass phrase:\";\n\n    /*\n     * rwflag == 0 means decryption\n     * rwflag == 1 means encryption\n     *\n     * We assume that for encryption, we want a minimum length, while for\n     * decryption, we cannot know any minimum length, so we assume zero.\n     */\n    min_len = rwflag ? MIN_LENGTH : 0;\n\n    i = EVP_read_pw_string_min(buf, min_len, num, prompt, rwflag);\n    if (i != 0) {\n        ERR_raise(ERR_LIB_PEM, PEM_R_PROBLEMS_GETTING_PASSWORD);\n        memset(buf, 0, (unsigned int)num);\n        return -1;\n    }\n    return strlen(buf);\n}","filepath":"crypto/pem/pem_lib.c","line_number":34,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269887776":{"score":0.76157326,"function_name":"PEM_do_header","code":"int PEM_do_header(EVP_CIPHER_INFO *cipher, unsigned char *data, long *plen,\n                  pem_password_cb *callback, void *u)\n{\n    int ok;\n    int keylen;\n    long len = *plen;\n    int ilen = (int) len;       /* EVP_DecryptUpdate etc. take int lengths */\n    EVP_CIPHER_CTX *ctx;\n    unsigned char key[EVP_MAX_KEY_LENGTH];\n    char buf[PEM_BUFSIZE];\n\n#if LONG_MAX \u003e INT_MAX\n    /* Check that we did not truncate the length */\n    if (len \u003e INT_MAX) {\n        ERR_raise(ERR_LIB_PEM, PEM_R_HEADER_TOO_LONG);\n        return 0;\n    }\n#endif\n\n    if (cipher-\u003ecipher == NULL)\n        return 1;\n    if (callback == NULL)\n        keylen = PEM_def_callback(buf, PEM_BUFSIZE, 0, u);\n    else\n        keylen = callback(buf, PEM_BUFSIZE, 0, u);\n    if (keylen \u003c 0) {\n        ERR_raise(ERR_LIB_PEM, PEM_R_BAD_PASSWORD_READ);\n        return 0;\n    }\n#ifdef CHARSET_EBCDIC\n    /* Convert the pass phrase from EBCDIC */\n    ebcdic2ascii(buf, buf, keylen);\n#endif\n\n    if (!EVP_BytesToKey(cipher-\u003ecipher, EVP_md5(), \u0026(cipher-\u003eiv[0]),\n                        (unsigned char *)buf, keylen, 1, key, NULL))\n        return 0;\n\n    ctx = EVP_CIPHER_CTX_new();\n    if (ctx == NULL)\n        return 0;\n\n    ok = EVP_DecryptInit_ex(ctx, cipher-\u003ecipher, NULL, key, \u0026(cipher-\u003eiv[0]));\n    if (ok)\n        ok = EVP_DecryptUpdate(ctx, data, \u0026ilen, data, ilen);\n    if (ok) {\n        /* Squirrel away the length of data decrypted so far. */\n        *plen = ilen;\n        ok = EVP_DecryptFinal_ex(ctx, \u0026(data[ilen]), \u0026ilen);\n    }\n    if (ok)\n        *plen += ilen;\n    else\n        ERR_raise(ERR_LIB_PEM, PEM_R_BAD_DECRYPT);\n\n    EVP_CIPHER_CTX_free(ctx);\n    OPENSSL_cleanse((char *)buf, sizeof(buf));\n    OPENSSL_cleanse((char *)key, sizeof(key));\n    return ok;\n}","filepath":"crypto/pem/pem_lib.c","line_number":413,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269888368":{"score":0.90311,"function_name":"PEM_get_EVP_CIPHER_INFO","code":"int PEM_get_EVP_CIPHER_INFO(char *header, EVP_CIPHER_INFO *cipher)\n{\n    static const char ProcType[] = \"Proc-Type:\";\n    static const char ENCRYPTED[] = \"ENCRYPTED\";\n    static const char DEKInfo[] = \"DEK-Info:\";\n    const EVP_CIPHER *enc = NULL;\n    int ivlen;\n    char *dekinfostart, c;\n\n    cipher-\u003ecipher = NULL;\n    memset(cipher-\u003eiv, 0, sizeof(cipher-\u003eiv));\n    if ((header == NULL) || (*header == '\\0') || (*header == '\\n'))\n        return 1;\n\n    if (strncmp(header, ProcType, sizeof(ProcType)-1) != 0) {\n        ERR_raise(ERR_LIB_PEM, PEM_R_NOT_PROC_TYPE);\n        return 0;\n    }\n    header += sizeof(ProcType)-1;\n    header += strspn(header, \" \\t\");\n\n    if (*header++ != '4' || *header++ != ',')\n        return 0;\n    header += strspn(header, \" \\t\");\n\n    /* We expect \"ENCRYPTED\" followed by optional white-space + line break */\n    if (strncmp(header, ENCRYPTED, sizeof(ENCRYPTED)-1) != 0 ||\n        strspn(header+sizeof(ENCRYPTED)-1, \" \\t\\r\\n\") == 0) {\n        ERR_raise(ERR_LIB_PEM, PEM_R_NOT_ENCRYPTED);\n        return 0;\n    }\n    header += sizeof(ENCRYPTED)-1;\n    header += strspn(header, \" \\t\\r\");\n    if (*header++ != '\\n') {\n        ERR_raise(ERR_LIB_PEM, PEM_R_SHORT_HEADER);\n        return 0;\n    }\n\n    /*-\n     * https://tools.ietf.org/html/rfc1421#section-4.6.1.3\n     * We expect \"DEK-Info: algo[,hex-parameters]\"\n     */\n    if (strncmp(header, DEKInfo, sizeof(DEKInfo)-1) != 0) {\n        ERR_raise(ERR_LIB_PEM, PEM_R_NOT_DEK_INFO);\n        return 0;\n    }\n    header += sizeof(DEKInfo)-1;\n    header += strspn(header, \" \\t\");\n\n    /*\n     * DEK-INFO is a comma-separated combination of algorithm name and optional\n     * parameters.\n     */\n    dekinfostart = header;\n    header += strcspn(header, \" \\t,\");\n    c = *header;\n    *header = '\\0';\n    cipher-\u003ecipher = enc = EVP_get_cipherbyname(dekinfostart);\n    *header = c;\n    header += strspn(header, \" \\t\");\n\n    if (enc == NULL) {\n        ERR_raise(ERR_LIB_PEM, PEM_R_UNSUPPORTED_ENCRYPTION);\n        return 0;\n    }\n    ivlen = EVP_CIPHER_iv_length(enc);\n    if (ivlen \u003e 0 \u0026\u0026 *header++ != ',') {\n        ERR_raise(ERR_LIB_PEM, PEM_R_MISSING_DEK_IV);\n        return 0;\n    } else if (ivlen == 0 \u0026\u0026 *header == ',') {\n        ERR_raise(ERR_LIB_PEM, PEM_R_UNEXPECTED_DEK_IV);\n        return 0;\n    }\n\n    if (!load_iv(\u0026header, cipher-\u003eiv, EVP_CIPHER_iv_length(enc)))\n        return 0;\n\n    return 1;\n}","filepath":"crypto/pem/pem_lib.c","line_number":486,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269889104":{"score":0.94488734,"function_name":"PEM_read_bio_ex","code":"int PEM_read_bio_ex(BIO *bp, char **name_out, char **header,\n                    unsigned char **data, long *len_out, unsigned int flags)\n{\n    EVP_ENCODE_CTX *ctx = EVP_ENCODE_CTX_new();\n    const BIO_METHOD *bmeth;\n    BIO *headerB = NULL, *dataB = NULL;\n    char *name = NULL;\n    int len, taillen, headerlen, ret = 0;\n    BUF_MEM * buf_mem;\n\n    if (ctx == NULL) {\n        ERR_raise(ERR_LIB_PEM, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n\n    *len_out = 0;\n    *name_out = *header = NULL;\n    *data = NULL;\n    if ((flags \u0026 PEM_FLAG_EAY_COMPATIBLE) \u0026\u0026 (flags \u0026 PEM_FLAG_ONLY_B64)) {\n        /* These two are mutually incompatible; bail out. */\n        ERR_raise(ERR_LIB_PEM, ERR_R_PASSED_INVALID_ARGUMENT);\n        goto end;\n    }\n    bmeth = (flags \u0026 PEM_FLAG_SECURE) ? BIO_s_secmem() : BIO_s_mem();\n\n    headerB = BIO_new(bmeth);\n    dataB = BIO_new(bmeth);\n    if (headerB == NULL || dataB == NULL) {\n        ERR_raise(ERR_LIB_PEM, ERR_R_MALLOC_FAILURE);\n        goto end;\n    }\n\n    if (!get_name(bp, \u0026name, flags))\n        goto end;\n    if (!get_header_and_data(bp, \u0026headerB, \u0026dataB, name, flags))\n        goto end;\n\n    EVP_DecodeInit(ctx);\n    BIO_get_mem_ptr(dataB, \u0026buf_mem);\n    len = buf_mem-\u003elength;\n    if (EVP_DecodeUpdate(ctx, (unsigned char*)buf_mem-\u003edata, \u0026len,\n                         (unsigned char*)buf_mem-\u003edata, len) \u003c 0\n            || EVP_DecodeFinal(ctx, (unsigned char*)\u0026(buf_mem-\u003edata[len]),\n                               \u0026taillen) \u003c 0) {\n        ERR_raise(ERR_LIB_PEM, PEM_R_BAD_BASE64_DECODE);\n        goto end;\n    }\n    len += taillen;\n    buf_mem-\u003elength = len;\n\n    /* There was no data in the PEM file; avoid malloc(0). */\n    if (len == 0)\n        goto end;\n    headerlen = BIO_get_mem_data(headerB, NULL);\n    *header = pem_malloc(headerlen + 1, flags);\n    *data = pem_malloc(len, flags);\n    if (*header == NULL || *data == NULL) {\n        pem_free(*header, flags, 0);\n        pem_free(*data, flags, 0);\n        goto end;\n    }\n    BIO_read(headerB, *header, headerlen);\n    (*header)[headerlen] = '\\0';\n    BIO_read(dataB, *data, len);\n    *len_out = len;\n    *name_out = name;\n    name = NULL;\n    ret = 1;\n\nend:\n    EVP_ENCODE_CTX_free(ctx);\n    pem_free(name, flags, 0);\n    BIO_free(headerB);\n    BIO_free(dataB);\n    return ret;\n}","filepath":"crypto/pem/pem_lib.c","line_number":917,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269889824":{"score":0.83169866,"function_name":"check_pem","code":"static int check_pem(const char *nm, const char *name)\n{\n    /* Normal matching nm and name */\n    if (strcmp(nm, name) == 0)\n        return 1;\n\n    /* Make PEM_STRING_EVP_PKEY match any private key */\n\n    if (strcmp(name, PEM_STRING_EVP_PKEY) == 0) {\n        int slen;\n        const EVP_PKEY_ASN1_METHOD *ameth;\n        if (strcmp(nm, PEM_STRING_PKCS8) == 0)\n            return 1;\n        if (strcmp(nm, PEM_STRING_PKCS8INF) == 0)\n            return 1;\n        slen = pem_check_suffix(nm, \"PRIVATE KEY\");\n        if (slen \u003e 0) {\n            /*\n             * NB: ENGINE implementations won't contain a deprecated old\n             * private key decode function so don't look for them.\n             */\n            ameth = EVP_PKEY_asn1_find_str(NULL, nm, slen);\n            if (ameth \u0026\u0026 ameth-\u003eold_priv_decode)\n                return 1;\n        }\n        return 0;\n    }\n\n    if (strcmp(name, PEM_STRING_PARAMETERS) == 0) {\n        int slen;\n        const EVP_PKEY_ASN1_METHOD *ameth;\n        slen = pem_check_suffix(nm, \"PARAMETERS\");\n        if (slen \u003e 0) {\n            ENGINE *e;\n            ameth = EVP_PKEY_asn1_find_str(\u0026e, nm, slen);\n            if (ameth) {\n                int r;\n                if (ameth-\u003eparam_decode)\n                    r = 1;\n                else\n                    r = 0;\n#ifndef OPENSSL_NO_ENGINE\n                ENGINE_finish(e);\n#endif\n                return r;\n            }\n        }\n        return 0;\n    }\n    /* If reading DH parameters handle X9.42 DH format too */\n    if (strcmp(nm, PEM_STRING_DHXPARAMS) == 0\n        \u0026\u0026 strcmp(name, PEM_STRING_DHPARAMS) == 0)\n        return 1;\n\n    /* Permit older strings */\n\n    if (strcmp(nm, PEM_STRING_X509_OLD) == 0\n        \u0026\u0026 strcmp(name, PEM_STRING_X509) == 0)\n        return 1;\n\n    if (strcmp(nm, PEM_STRING_X509_REQ_OLD) == 0\n        \u0026\u0026 strcmp(name, PEM_STRING_X509_REQ) == 0)\n        return 1;\n\n    /* Allow normal certs to be read as trusted certs */\n    if (strcmp(nm, PEM_STRING_X509) == 0\n        \u0026\u0026 strcmp(name, PEM_STRING_X509_TRUSTED) == 0)\n        return 1;\n\n    if (strcmp(nm, PEM_STRING_X509_OLD) == 0\n        \u0026\u0026 strcmp(name, PEM_STRING_X509_TRUSTED) == 0)\n        return 1;\n\n    /* Some CAs use PKCS#7 with CERTIFICATE headers */\n    if (strcmp(nm, PEM_STRING_X509) == 0\n        \u0026\u0026 strcmp(name, PEM_STRING_PKCS7) == 0)\n        return 1;\n\n    if (strcmp(nm, PEM_STRING_PKCS7_SIGNED) == 0\n        \u0026\u0026 strcmp(name, PEM_STRING_PKCS7) == 0)\n        return 1;\n\n#ifndef OPENSSL_NO_CMS\n    if (strcmp(nm, PEM_STRING_X509) == 0\n        \u0026\u0026 strcmp(name, PEM_STRING_CMS) == 0)\n        return 1;\n    /* Allow CMS to be read from PKCS#7 headers */\n    if (strcmp(nm, PEM_STRING_PKCS7) == 0\n        \u0026\u0026 strcmp(name, PEM_STRING_CMS) == 0)\n        return 1;\n#endif\n\n    return 0;\n}","filepath":"crypto/pem/pem_lib.c","line_number":126,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269891152":{"score":0.86332977,"function_name":"get_header_and_data","code":"static int get_header_and_data(BIO *bp, BIO **header, BIO **data, char *name,\n                               unsigned int flags)\n{\n    BIO *tmp = *header;\n    char *linebuf, *p;\n    int len, line, ret = 0, end = 0, prev_partial_line_read = 0, partial_line_read = 0;\n    /* 0 if not seen (yet), 1 if reading header, 2 if finished header */\n    enum header_status got_header = MAYBE_HEADER;\n    unsigned int flags_mask;\n    size_t namelen;\n\n    /* Need to hold trailing NUL (accounted for by BIO_gets() and the newline\n     * that will be added by sanitize_line() (the extra '1'). */\n    linebuf = pem_malloc(LINESIZE + 1, flags);\n    if (linebuf == NULL) {\n        ERR_raise(ERR_LIB_PEM, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n\n    for (line = 0; ; line++) {\n        flags_mask = ~0u;\n        len = BIO_gets(bp, linebuf, LINESIZE);\n        if (len \u003c= 0) {\n            ERR_raise(ERR_LIB_PEM, PEM_R_BAD_END_LINE);\n            goto err;\n        }\n\n        /*\n         * Check if line has been read completely or if only part of the line\n         * has been read. Keep the previous value to ignore newlines that\n         * appear due to reading a line up until the char before the newline.\n         */\n        prev_partial_line_read = partial_line_read;\n        partial_line_read = len == LINESIZE-1 \u0026\u0026 linebuf[LINESIZE-2] != '\\n';\n\n        if (got_header == MAYBE_HEADER) {\n            if (memchr(linebuf, ':', len) != NULL)\n                got_header = IN_HEADER;\n        }\n        if (!strncmp(linebuf, endstr, ENDLEN) || got_header == IN_HEADER)\n            flags_mask \u0026= ~PEM_FLAG_ONLY_B64;\n        len = sanitize_line(linebuf, len, flags \u0026 flags_mask, 0);\n\n        /* Check for end of header. */\n        if (linebuf[0] == '\\n') {\n            /*\n             * If previous line has been read only partially this newline is a\n             * regular newline at the end of a line and not an empty line.\n             */\n            if (!prev_partial_line_read) {\n                if (got_header == POST_HEADER) {\n                    /* Another blank line is an error. */\n                    ERR_raise(ERR_LIB_PEM, PEM_R_BAD_END_LINE);\n                    goto err;\n                }\n                got_header = POST_HEADER;\n                tmp = *data;\n            }\n            continue;\n        }\n\n        /* Check for end of stream (which means there is no header). */\n        if (strncmp(linebuf, endstr, ENDLEN) == 0) {\n            p = linebuf + ENDLEN;\n            namelen = strlen(name);\n            if (strncmp(p, name, namelen) != 0 ||\n                strncmp(p + namelen, tailstr, TAILLEN) != 0) {\n                ERR_raise(ERR_LIB_PEM, PEM_R_BAD_END_LINE);\n                goto err;\n            }\n            if (got_header == MAYBE_HEADER) {\n                *header = *data;\n                *data = tmp;\n            }\n            break;\n        } else if (end) {\n            /* Malformed input; short line not at end of data. */\n            ERR_raise(ERR_LIB_PEM, PEM_R_BAD_END_LINE);\n            goto err;\n        }\n        /*\n         * Else, a line of text -- could be header or data; we don't\n         * know yet.  Just pass it through.\n         */\n        if (BIO_puts(tmp, linebuf) \u003c 0)\n            goto err;\n        /*\n         * Only encrypted files need the line length check applied.\n         */\n        if (got_header == POST_HEADER) {\n            /* 65 includes the trailing newline */\n            if (len \u003e 65)\n                goto err;\n            if (len \u003c 65)\n                end = 1;\n        }\n    }\n\n    ret = 1;\nerr:\n    pem_free(linebuf, flags, LINESIZE + 1);\n    return ret;\n}","filepath":"crypto/pem/pem_lib.c","line_number":807,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269891760":{"score":0.84775305,"function_name":"get_name","code":"static int get_name(BIO *bp, char **name, unsigned int flags)\n{\n    char *linebuf;\n    int ret = 0;\n    int len;\n    int first_call = 1;\n\n    /*\n     * Need to hold trailing NUL (accounted for by BIO_gets() and the newline\n     * that will be added by sanitize_line() (the extra '1').\n     */\n    linebuf = pem_malloc(LINESIZE + 1, flags);\n    if (linebuf == NULL) {\n        ERR_raise(ERR_LIB_PEM, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n\n    do {\n        len = BIO_gets(bp, linebuf, LINESIZE);\n\n        if (len \u003c= 0) {\n            ERR_raise(ERR_LIB_PEM, PEM_R_NO_START_LINE);\n            goto err;\n        }\n\n        /* Strip trailing garbage and standardize ending. */\n        len = sanitize_line(linebuf, len, flags \u0026 ~PEM_FLAG_ONLY_B64, first_call);\n        first_call = 0;\n\n        /* Allow leading empty or non-matching lines. */\n    } while (strncmp(linebuf, beginstr, BEGINLEN) != 0\n             || len \u003c TAILLEN\n             || strncmp(linebuf + len - TAILLEN, tailstr, TAILLEN) != 0);\n    linebuf[len - TAILLEN] = '\\0';\n    len = len - BEGINLEN - TAILLEN + 1;\n    *name = pem_malloc(len, flags);\n    if (*name == NULL) {\n        ERR_raise(ERR_LIB_PEM, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    memcpy(*name, linebuf + BEGINLEN, len);\n    ret = 1;\n\nerr:\n    pem_free(linebuf, flags, LINESIZE + 1);\n    return ret;\n}","filepath":"crypto/pem/pem_lib.c","line_number":741,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269892144":{"score":0.8541605,"function_name":"pem_bytes_read_bio_flags","code":"static int pem_bytes_read_bio_flags(unsigned char **pdata, long *plen,\n                                    char **pnm, const char *name, BIO *bp,\n                                    pem_password_cb *cb, void *u,\n                                    unsigned int flags)\n{\n    EVP_CIPHER_INFO cipher;\n    char *nm = NULL, *header = NULL;\n    unsigned char *data = NULL;\n    long len = 0;\n    int ret = 0;\n\n    do {\n        pem_free(nm, flags, 0);\n        pem_free(header, flags, 0);\n        pem_free(data, flags, len);\n        if (!PEM_read_bio_ex(bp, \u0026nm, \u0026header, \u0026data, \u0026len, flags)) {\n            if (ERR_GET_REASON(ERR_peek_error()) == PEM_R_NO_START_LINE)\n                ERR_add_error_data(2, \"Expecting: \", name);\n            return 0;\n        }\n    } while (!check_pem(nm, name));\n    if (!PEM_get_EVP_CIPHER_INFO(header, \u0026cipher))\n        goto err;\n    if (!PEM_do_header(\u0026cipher, data, \u0026len, cb, u))\n        goto err;\n\n    *pdata = data;\n    *plen = len;\n\n    if (pnm != NULL)\n        *pnm = nm;\n\n    ret = 1;\n\n err:\n    if (!ret || pnm == NULL)\n        pem_free(nm, flags, 0);\n    pem_free(header, flags, 0);\n    if (!ret)\n        pem_free(data, flags, len);\n    return ret;\n}","filepath":"crypto/pem/pem_lib.c","line_number":235,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269892816":{"score":0.80652857,"function_name":"pem_check_suffix","code":"int pem_check_suffix(const char *pem_str, const char *suffix)\n{\n    int pem_len = strlen(pem_str);\n    int suffix_len = strlen(suffix);\n    const char *p;\n    if (suffix_len + 1 \u003e= pem_len)\n        return 0;\n    p = pem_str + pem_len - suffix_len;\n    if (strcmp(p, suffix))\n        return 0;\n    p--;\n    if (*p != ' ')\n        return 0;\n    return p - pem_str;\n}","filepath":"crypto/pem/pem_lib.c","line_number":1006,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269893072":{"score":0.7839421,"function_name":"sanitize_line","code":"static int sanitize_line(char *linebuf, int len, unsigned int flags, int first_call)\n{\n    int i;\n    if (first_call) {\n        /* Other BOMs imply unsupported multibyte encoding,\n         * so don't strip them and let the error raise */\n        const unsigned char utf8_bom[3] = {0xEF, 0xBB, 0xBF};\n\n        if (len \u003e 3 \u0026\u0026 memcmp(linebuf, utf8_bom, 3) == 0) {\n            memmove(linebuf, linebuf + 3, len - 3);\n            linebuf[len - 3] = 0;\n            len -= 3;\n        }\n    }\n\n    if (flags \u0026 PEM_FLAG_EAY_COMPATIBLE) {\n        /* Strip trailing whitespace */\n        while ((len \u003e= 0) \u0026\u0026 (linebuf[len] \u003c= ' '))\n            len--;\n        /* Go back to whitespace before applying uniform line ending. */\n        len++;\n    } else if (flags \u0026 PEM_FLAG_ONLY_B64) {\n        for (i = 0; i \u003c len; ++i) {\n            if (!ossl_isbase64(linebuf[i]) || linebuf[i] == '\\n'\n                || linebuf[i] == '\\r')\n                break;\n        }\n        len = i;\n    } else {\n        /* EVP_DecodeBlock strips leading and trailing whitespace, so just strip\n         * control characters in-place and let everything through. */\n        for (i = 0; i \u003c len; ++i) {\n            if (linebuf[i] == '\\n' || linebuf[i] == '\\r')\n                break;\n            if (ossl_iscntrl(linebuf[i]))\n                linebuf[i] = ' ';\n        }\n        len = i;\n    }\n    /* The caller allocated LINESIZE+1, so this is safe. */\n    linebuf[len++] = '\\n';\n    linebuf[len] = '\\0';\n    return len;\n}","filepath":"crypto/pem/pem_lib.c","line_number":688,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269893920":{"score":0.8393232,"function_name":"OPENSSL_init_crypto","code":"int OPENSSL_init_crypto(uint64_t opts, const OPENSSL_INIT_SETTINGS *settings)\n{\n    if (stopped) {\n        if (!(opts \u0026 OPENSSL_INIT_BASE_ONLY))\n            CRYPTOerr(CRYPTO_F_OPENSSL_INIT_CRYPTO, ERR_R_INIT_FAIL);\n        return 0;\n    }\n\n    /*\n     * When the caller specifies OPENSSL_INIT_BASE_ONLY, that should be the\n     * *only* option specified.  With that option we return immediately after\n     * doing the requested limited initialization.  Note that\n     * err_shelve_state() called by us via ossl_init_load_crypto_nodelete()\n     * re-enters OPENSSL_init_crypto() with OPENSSL_INIT_BASE_ONLY, but with\n     * base already initialized this is a harmless NOOP.\n     *\n     * If we remain the only caller of err_shelve_state() the recursion should\n     * perhaps be removed, but if in doubt, it can be left in place.\n     */\n    if (!RUN_ONCE(\u0026base, ossl_init_base))\n        return 0;\n    if (opts \u0026 OPENSSL_INIT_BASE_ONLY)\n        return 1;\n\n    /*\n     * Now we don't always set up exit handlers, the INIT_BASE_ONLY calls\n     * should not have the side-effect of setting up exit handlers, and\n     * therefore, this code block is below the INIT_BASE_ONLY-conditioned early\n     * return above.\n     */\n    if ((opts \u0026 OPENSSL_INIT_NO_ATEXIT) != 0) {\n        if (!RUN_ONCE_ALT(\u0026register_atexit, ossl_init_no_register_atexit,\n                          ossl_init_register_atexit))\n            return 0;\n    } else if (!RUN_ONCE(\u0026register_atexit, ossl_init_register_atexit)) {\n        return 0;\n    }\n\n    if (!RUN_ONCE(\u0026load_crypto_nodelete, ossl_init_load_crypto_nodelete))\n        return 0;\n\n    if ((opts \u0026 OPENSSL_INIT_NO_LOAD_CRYPTO_STRINGS)\n            \u0026\u0026 !RUN_ONCE_ALT(\u0026load_crypto_strings,\n                             ossl_init_no_load_crypto_strings,\n                             ossl_init_load_crypto_strings))\n        return 0;\n\n    if ((opts \u0026 OPENSSL_INIT_LOAD_CRYPTO_STRINGS)\n            \u0026\u0026 !RUN_ONCE(\u0026load_crypto_strings, ossl_init_load_crypto_strings))\n        return 0;\n\n    if ((opts \u0026 OPENSSL_INIT_NO_ADD_ALL_CIPHERS)\n            \u0026\u0026 !RUN_ONCE_ALT(\u0026add_all_ciphers, ossl_init_no_add_all_ciphers,\n                             ossl_init_add_all_ciphers))\n        return 0;\n\n    if ((opts \u0026 OPENSSL_INIT_ADD_ALL_CIPHERS)\n            \u0026\u0026 !RUN_ONCE(\u0026add_all_ciphers, ossl_init_add_all_ciphers))\n        return 0;\n\n    if ((opts \u0026 OPENSSL_INIT_NO_ADD_ALL_DIGESTS)\n            \u0026\u0026 !RUN_ONCE_ALT(\u0026add_all_digests, ossl_init_no_add_all_digests,\n                             ossl_init_add_all_digests))\n        return 0;\n\n    if ((opts \u0026 OPENSSL_INIT_ADD_ALL_DIGESTS)\n            \u0026\u0026 !RUN_ONCE(\u0026add_all_digests, ossl_init_add_all_digests))\n        return 0;\n\n    if ((opts \u0026 OPENSSL_INIT_ATFORK)\n            \u0026\u0026 !openssl_init_fork_handlers())\n        return 0;\n\n    if ((opts \u0026 OPENSSL_INIT_NO_LOAD_CONFIG)\n            \u0026\u0026 !RUN_ONCE_ALT(\u0026config, ossl_init_no_config, ossl_init_config))\n        return 0;\n\n    if (opts \u0026 OPENSSL_INIT_LOAD_CONFIG) {\n        int ret;\n        CRYPTO_THREAD_write_lock(init_lock);\n        conf_settings = settings;\n        ret = RUN_ONCE(\u0026config, ossl_init_config);\n        conf_settings = NULL;\n        CRYPTO_THREAD_unlock(init_lock);\n        if (ret \u003c= 0)\n            return 0;\n    }\n\n    if ((opts \u0026 OPENSSL_INIT_ASYNC)\n            \u0026\u0026 !RUN_ONCE(\u0026async, ossl_init_async))\n        return 0;\n\n#ifndef OPENSSL_NO_ENGINE\n    if ((opts \u0026 OPENSSL_INIT_ENGINE_OPENSSL)\n            \u0026\u0026 !RUN_ONCE(\u0026engine_openssl, ossl_init_engine_openssl))\n        return 0;\n# if !defined(OPENSSL_NO_HW) \u0026\u0026 !defined(OPENSSL_NO_DEVCRYPTOENG)\n    if ((opts \u0026 OPENSSL_INIT_ENGINE_CRYPTODEV)\n            \u0026\u0026 !RUN_ONCE(\u0026engine_devcrypto, ossl_init_engine_devcrypto))\n        return 0;\n# endif\n# ifndef OPENSSL_NO_RDRAND\n    if ((opts \u0026 OPENSSL_INIT_ENGINE_RDRAND)\n            \u0026\u0026 !RUN_ONCE(\u0026engine_rdrand, ossl_init_engine_rdrand))\n        return 0;\n# endif\n    if ((opts \u0026 OPENSSL_INIT_ENGINE_DYNAMIC)\n            \u0026\u0026 !RUN_ONCE(\u0026engine_dynamic, ossl_init_engine_dynamic))\n        return 0;\n# ifndef OPENSSL_NO_STATIC_ENGINE\n#  if !defined(OPENSSL_NO_HW) \u0026\u0026 !defined(OPENSSL_NO_HW_PADLOCK)\n    if ((opts \u0026 OPENSSL_INIT_ENGINE_PADLOCK)\n            \u0026\u0026 !RUN_ONCE(\u0026engine_padlock, ossl_init_engine_padlock))\n        return 0;\n#  endif\n#  if defined(OPENSSL_SYS_WIN32) \u0026\u0026 !defined(OPENSSL_NO_CAPIENG)\n    if ((opts \u0026 OPENSSL_INIT_ENGINE_CAPI)\n            \u0026\u0026 !RUN_ONCE(\u0026engine_capi, ossl_init_engine_capi))\n        return 0;\n#  endif\n#  if !defined(OPENSSL_NO_AFALGENG)\n    if ((opts \u0026 OPENSSL_INIT_ENGINE_AFALG)\n            \u0026\u0026 !RUN_ONCE(\u0026engine_afalg, ossl_init_engine_afalg))\n        return 0;\n#  endif\n# endif\n    if (opts \u0026 (OPENSSL_INIT_ENGINE_ALL_BUILTIN\n                | OPENSSL_INIT_ENGINE_OPENSSL\n                | OPENSSL_INIT_ENGINE_AFALG)) {\n        ENGINE_register_all_complete();\n    }\n#endif\n\n#ifndef OPENSSL_NO_COMP\n    if ((opts \u0026 OPENSSL_INIT_ZLIB)\n            \u0026\u0026 !RUN_ONCE(\u0026zlib, ossl_init_zlib))\n        return 0;\n#endif\n\n    return 1;\n}","filepath":"crypto/init.c","line_number":620,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1c"},"269895312":{"score":0.855154,"function_name":"ossl_init_thread_stop","code":"static void ossl_init_thread_stop(struct thread_local_inits_st *locals)\n{\n    /* Can't do much about this */\n    if (locals == NULL)\n        return;\n\n    if (locals-\u003easync) {\n#ifdef OPENSSL_INIT_DEBUG\n        fprintf(stderr, \"OPENSSL_INIT: ossl_init_thread_stop: \"\n                        \"async_delete_thread_state()\\n\");\n#endif\n        async_delete_thread_state();\n    }\n\n    if (locals-\u003eerr_state) {\n#ifdef OPENSSL_INIT_DEBUG\n        fprintf(stderr, \"OPENSSL_INIT: ossl_init_thread_stop: \"\n                        \"err_delete_thread_state()\\n\");\n#endif\n        err_delete_thread_state();\n    }\n\n    if (locals-\u003erand) {\n#ifdef OPENSSL_INIT_DEBUG\n        fprintf(stderr, \"OPENSSL_INIT: ossl_init_thread_stop: \"\n                        \"drbg_delete_thread_state()\\n\");\n#endif\n        drbg_delete_thread_state();\n    }\n\n    OPENSSL_free(locals);\n}","filepath":"crypto/init.c","line_number":419,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1c"},"269895376":{"score":0.8815873,"function_name":"ossl_init_thread_start","code":"int ossl_init_thread_start(uint64_t opts)\n{\n    struct thread_local_inits_st *locals;\n\n    if (!OPENSSL_init_crypto(0, NULL))\n        return 0;\n\n    locals = ossl_init_get_thread_local(1);\n\n    if (locals == NULL)\n        return 0;\n\n    if (opts \u0026 OPENSSL_INIT_THREAD_ASYNC) {\n#ifdef OPENSSL_INIT_DEBUG\n        fprintf(stderr, \"OPENSSL_INIT: ossl_init_thread_start: \"\n                        \"marking thread for async\\n\");\n#endif\n        locals-\u003easync = 1;\n    }\n\n    if (opts \u0026 OPENSSL_INIT_THREAD_ERR_STATE) {\n#ifdef OPENSSL_INIT_DEBUG\n        fprintf(stderr, \"OPENSSL_INIT: ossl_init_thread_start: \"\n                        \"marking thread for err_state\\n\");\n#endif\n        locals-\u003eerr_state = 1;\n    }\n\n    if (opts \u0026 OPENSSL_INIT_THREAD_RAND) {\n#ifdef OPENSSL_INIT_DEBUG\n        fprintf(stderr, \"OPENSSL_INIT: ossl_init_thread_start: \"\n                        \"marking thread for rand\\n\");\n#endif\n        locals-\u003erand = 1;\n    }\n\n    return 1;\n}","filepath":"crypto/init.c","line_number":458,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1c"},"269895568":{"score":0.616561,"function_name":"OPENSSL_cleanup","code":"void OPENSSL_cleanup(void)\n{\n    OPENSSL_INIT_STOP *currhandler, *lasthandler;\n    CRYPTO_THREAD_LOCAL key;\n\n    /* If we've not been inited then no need to deinit */\n    if (!base_inited)\n        return;\n\n    /* Might be explicitly called and also by atexit */\n    if (stopped)\n        return;\n    stopped = 1;\n\n    /*\n     * Thread stop may not get automatically called by the thread library for\n     * the very last thread in some situations, so call it directly.\n     */\n    ossl_init_thread_stop(ossl_init_get_thread_local(0));\n\n    currhandler = stop_handlers;\n    while (currhandler != NULL) {\n        currhandler-\u003ehandler();\n        lasthandler = currhandler;\n        currhandler = currhandler-\u003enext;\n        OPENSSL_free(lasthandler);\n    }\n    stop_handlers = NULL;\n\n    CRYPTO_THREAD_lock_free(init_lock);\n    init_lock = NULL;\n\n    /*\n     * We assume we are single-threaded for this function, i.e. no race\n     * conditions for the various \"*_inited\" vars below.\n     */\n\n#ifndef OPENSSL_NO_COMP\n    if (zlib_inited) {\n#ifdef OPENSSL_INIT_DEBUG\n        fprintf(stderr, \"OPENSSL_INIT: OPENSSL_cleanup: \"\n                        \"comp_zlib_cleanup_int()\\n\");\n#endif\n        comp_zlib_cleanup_int();\n    }\n#endif\n\n    if (async_inited) {\n# ifdef OPENSSL_INIT_DEBUG\n        fprintf(stderr, \"OPENSSL_INIT: OPENSSL_cleanup: \"\n                        \"async_deinit()\\n\");\n# endif\n        async_deinit();\n    }","filepath":"crypto/init.c","line_number":497,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1c"},"269895872":{"score":0.8589623,"function_name":"CRYPTO_memdup","code":"void *CRYPTO_memdup(const void *data, size_t siz, const char* file, int line)\n{\n    void *ret;\n\n    if (data == NULL || siz \u003e= INT_MAX)\n        return NULL;\n\n    ret = CRYPTO_malloc(siz, file, line);\n    if (ret == NULL) {\n        CRYPTOerr(CRYPTO_F_CRYPTO_MEMDUP, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    return memcpy(ret, data, siz);\n}","filepath":"crypto/o_str.c","line_number":60,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0f"},"269895968":{"score":0.6549795,"function_name":"CRYPTO_strdup","code":"char *CRYPTO_strdup(const char *str, const char* file, int line)\n{\n    char *ret;\n    size_t size;\n\n    if (str == NULL)\n        return NULL;\n    size = strlen(str) + 1;\n    ret = CRYPTO_malloc(size, file, line);\n    if (ret != NULL)\n        memcpy(ret, str, size);\n    return ret;\n}","filepath":"crypto/o_str.c","line_number":28,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0f"},"269896064":{"score":0.8025749,"function_name":"CRYPTO_strndup","code":"char *CRYPTO_strndup(const char *str, size_t s, const char* file, int line)\n{\n    size_t maxlen;\n    char *ret;\n\n    if (str == NULL)\n        return NULL;\n\n    maxlen = OPENSSL_strnlen(str, s);\n\n    ret = CRYPTO_malloc(maxlen + 1, file, line);\n    if (ret) {\n        memcpy(ret, str, maxlen);\n        ret[maxlen] = '\\0';\n    }\n    return ret;\n}","filepath":"crypto/o_str.c","line_number":42,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0f"},"269896320":{"score":0.9365851,"function_name":"OPENSSL_hexchar2int","code":"int OPENSSL_hexchar2int(unsigned char c)\n{\n#ifdef CHARSET_EBCDIC\n    c = os_toebcdic[c];\n#endif\n\n    switch (c) {\n    case '0':\n        return 0;\n    case '1':\n        return 1;\n    case '2':\n        return 2;\n    case '3':\n        return 3;\n    case '4':\n          return 4;\n    case '5':\n          return 5;\n    case '6':\n          return 6;\n    case '7':\n          return 7;\n    case '8':\n          return 8;\n    case '9':\n          return 9;\n    case 'a': case 'A':\n          return 0x0A;\n    case 'b': case 'B':\n          return 0x0B;\n    case 'c': case 'C':\n          return 0x0C;\n    case 'd': case 'D':\n          return 0x0D;\n    case 'e': case 'E':\n          return 0x0E;\n    case 'f': case 'F':\n          return 0x0F;\n    }\n    return -1;\n}","filepath":"crypto/o_str.c","line_number":104,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0f"},"269896576":{"score":0.8864857,"function_name":"OPENSSL_hexstr2buf","code":"unsigned char *OPENSSL_hexstr2buf(const char *str, long *len)\n{\n    unsigned char *hexbuf, *q;\n    unsigned char ch, cl;\n    int chi, cli;\n    const unsigned char *p;\n    size_t s;\n\n    s = strlen(str);\n    if ((hexbuf = OPENSSL_malloc(s \u003e\u003e 1)) == NULL) {\n        CRYPTOerr(CRYPTO_F_OPENSSL_HEXSTR2BUF, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    for (p = (const unsigned char *)str, q = hexbuf; *p; ) {\n        ch = *p++;\n        if (ch == ':')\n            continue;\n        cl = *p++;\n        if (!cl) {\n            CRYPTOerr(CRYPTO_F_OPENSSL_HEXSTR2BUF,\n                      CRYPTO_R_ODD_NUMBER_OF_DIGITS);\n            OPENSSL_free(hexbuf);\n            return NULL;\n        }\n        cli = OPENSSL_hexchar2int(cl);\n        chi = OPENSSL_hexchar2int(ch);\n        if (cli \u003c 0 || chi \u003c 0) {\n            OPENSSL_free(hexbuf);\n            CRYPTOerr(CRYPTO_F_OPENSSL_HEXSTR2BUF, CRYPTO_R_ILLEGAL_HEX_DIGIT);\n            return NULL;\n        }\n        *q++ = (unsigned char)((chi \u003c\u003c 4) | cli);\n    }\n\n    if (len)\n        *len = q - hexbuf;\n    return hexbuf;\n}","filepath":"crypto/o_str.c","line_number":150,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0f"},"269896976":{"score":0.77492666,"function_name":"OPENSSL_strlcpy","code":"size_t OPENSSL_strlcpy(char *dst, const char *src, size_t size)\n{\n    size_t l = 0;\n    for (; size \u003e 1 \u0026\u0026 *src; size--) {\n        *dst++ = *src++;\n        l++;\n    }\n    if (size)\n        *dst = '\\0';\n    return l + strlen(src);\n}","filepath":"crypto/o_str.c","line_number":84,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0f"},"269897344":{"score":0.8950483,"function_name":"BIO_vsnprintf","code":"int BIO_vsnprintf(char *buf, size_t n, const char *format, va_list args)\n{\n    size_t retlen;\n    int truncated;\n\n    if(!_dopr(\u0026buf, NULL, \u0026n, \u0026retlen, \u0026truncated, format, args))\n        return -1;\n\n    if (truncated)\n        /*\n         * In case of truncation, return -1 like traditional snprintf.\n         * (Current drafts for ISO/IEC 9899 say snprintf should return the\n         * number of characters that would have been written, had the buffer\n         * been large enough.)\n         */\n        return -1;\n    else\n        return (retlen \u003c= INT_MAX) ? (int)retlen : -1;\n}","filepath":"crypto/bio/b_print.c","line_number":926,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0d"},"269897456":{"score":0.862177,"function_name":"_dopr","code":"static int\n_dopr(char **sbuffer,\n      char **buffer,\n      size_t *maxlen,\n      size_t *retlen, int *truncated, const char *format, va_list args)\n{\n    char ch;\n    LLONG value;\n    LDOUBLE fvalue;\n    char *strvalue;\n    int min;\n    int max;\n    int state;\n    int flags;\n    int cflags;\n    size_t currlen;\n\n    state = DP_S_DEFAULT;\n    flags = currlen = cflags = min = 0;\n    max = -1;\n    ch = *format++;\n\n    while (state != DP_S_DONE) {\n        if (ch == '\\0' || (buffer == NULL \u0026\u0026 currlen \u003e= *maxlen))\n            state = DP_S_DONE;\n\n        switch (state) {\n        case DP_S_DEFAULT:\n            if (ch == '%')\n                state = DP_S_FLAGS;\n            else\n                if(!doapr_outch(sbuffer, buffer, \u0026currlen, maxlen, ch))\n                    return 0;\n            ch = *format++;\n            break;\n        case DP_S_FLAGS:\n            switch (ch) {\n            case '-':\n                flags |= DP_F_MINUS;\n                ch = *format++;\n                break;\n            case '+':\n                flags |= DP_F_PLUS;\n                ch = *format++;\n                break;\n            case ' ':\n                flags |= DP_F_SPACE;\n                ch = *format++;\n                break;\n            case '#':\n                flags |= DP_F_NUM;\n                ch = *format++;\n                break;\n            case '0':\n                flags |= DP_F_ZERO;\n                ch = *format++;\n                break;\n            default:\n                state = DP_S_MIN;\n                break;\n            }\n            break;\n        case DP_S_MIN:\n            if (isdigit((unsigned char)ch)) {\n                min = 10 * min + char_to_int(ch);\n                ch = *format++;\n            } else if (ch == '*') {\n                min = va_arg(args, int);\n                ch = *format++;\n                state = DP_S_DOT;\n            } else\n                state = DP_S_DOT;\n            break;\n        case DP_S_DOT:\n            if (ch == '.') {\n                state = DP_S_MAX;\n                ch = *format++;\n            } else\n                state = DP_S_MOD;\n            break;\n        case DP_S_MAX:\n            if (isdigit((unsigned char)ch)) {\n                if (max \u003c 0)\n                    max = 0;\n                max = 10 * max + char_to_int(ch);\n                ch = *format++;\n            } else if (ch == '*') {\n                max = va_arg(args, int);\n                ch = *format++;\n                state = DP_S_MOD;\n            } else\n                state = DP_S_MOD;\n            break;\n        case DP_S_MOD:\n            switch (ch) {\n            case 'h':\n                cflags = DP_C_SHORT;\n                ch = *format++;\n                break;\n            case 'l':\n                if (*format == 'l') {\n                    cflags = DP_C_LLONG;\n                    format++;\n                } else\n                    cflags = DP_C_LONG;\n                ch = *format++;\n                break;\n            case 'q':\n                cflags = DP_C_LLONG;\n                ch = *format++;\n                break;\n            case 'L':\n                cflags = DP_C_LDOUBLE;\n                ch = *format++;\n                break;\n            default:\n                break;\n            }\n            state = DP_S_CONV;\n            break;\n        case DP_S_CONV:\n            switch (ch) {\n            case 'd':\n            case 'i':\n                switch (cflags) {\n                case DP_C_SHORT:\n                    value = (short int)va_arg(args, int);\n                    break;\n                case DP_C_LONG:\n                    value = va_arg(args, long int);\n                    break;\n                case DP_C_LLONG:\n                    value = va_arg(args, LLONG);\n                    break;\n                default:\n                    value = va_arg(args, int);\n                    break;\n                }\n                if (!fmtint(sbuffer, buffer, \u0026currlen, maxlen, value, 10, min,\n                            max, flags))\n                    return 0;\n                break;\n            case 'X':\n                flags |= DP_F_UP;\n                /* FALLTHROUGH */\n            case 'x':\n            case 'o':\n            case 'u':\n                flags |= DP_F_UNSIGNED;\n                switch (cflags) {\n                case DP_C_SHORT:\n                    value = (unsigned short int)va_arg(args, unsigned int);\n                    break;\n                case DP_C_LONG:\n                    value = (LLONG) va_arg(args, unsigned long int);\n                    break;\n                case DP_C_LLONG:\n                    value = va_arg(args, unsigned LLONG);\n                    break;\n                default:\n                    value = (LLONG) va_arg(args, unsigned int);\n                    break;\n                }\n                if (!fmtint(sbuffer, buffer, \u0026currlen, maxlen, value,\n                            ch == 'o' ? 8 : (ch == 'u' ? 10 : 16),\n                            min, max, flags))\n                    return 0;\n                break;\n            case 'f':\n                if (cflags == DP_C_LDOUBLE)\n                    fvalue = va_arg(args, LDOUBLE);\n                else\n                    fvalue = va_arg(args, double);\n                if (!fmtfp(sbuffer, buffer, \u0026currlen, maxlen, fvalue, min, max,\n                           flags, F_FORMAT))\n                    return 0;\n                break;\n            case 'E':\n                flags |= DP_F_UP;\n            case 'e':\n                if (cflags == DP_C_LDOUBLE)\n                    fvalue = va_arg(args, LDOUBLE);\n                else\n                    fvalue = va_arg(args, double);\n                if (!fmtfp(sbuffer, buffer, \u0026currlen, maxlen, fvalue, min, max,\n                           flags, E_FORMAT))\n                    return 0;\n                break;\n            case 'G':\n                flags |= DP_F_UP;\n            case 'g':\n                if (cflags == DP_C_LDOUBLE)\n                    fvalue = va_arg(args, LDOUBLE);\n                else\n                    fvalue = va_arg(args, double);\n                if (!fmtfp(sbuffer, buffer, \u0026currlen, maxlen, fvalue, min, max,\n                           flags, G_FORMAT))\n                    return 0;\n                break;\n            case 'c':\n                if(!doapr_outch(sbuffer, buffer, \u0026currlen, maxlen,\n                            va_arg(args, int)))\n                    return 0;\n                break;\n            case 's':\n                strvalue = va_arg(args, char *);\n                if (max \u003c 0) {\n                    if (buffer)\n                        max = INT_MAX;\n                    else\n                        max = *maxlen;\n                }\n                if (!fmtstr(sbuffer, buffer, \u0026currlen, maxlen, strvalue,\n                            flags, min, max))\n                    return 0;\n                break;\n            case 'p':\n                value = (size_t)va_arg(args, void *);\n                if (!fmtint(sbuffer, buffer, \u0026currlen, maxlen,\n                            value, 16, min, max, flags | DP_F_NUM))\n                    return 0;\n                break;\n            case 'n':          /* XXX */\n                if (cflags == DP_C_SHORT) {\n                    short int *num;\n                    num = va_arg(args, short int *);\n                    *num = currlen;\n                } else if (cflags == DP_C_LONG) { /* XXX */\n                    long int *num;\n                    num = va_arg(args, long int *);\n                    *num = (long int)currlen;\n                } else if (cflags == DP_C_LLONG) { /* XXX */\n                    LLONG *num;\n                    num = va_arg(args, LLONG *);\n                    *num = (LLONG) currlen;\n                } else {\n                    int *num;\n                    num = va_arg(args, int *);\n                    *num = currlen;\n                }\n                break;\n            case '%':\n                if(!doapr_outch(sbuffer, buffer, \u0026currlen, maxlen, ch))\n                    return 0;\n                break;\n            case 'w':\n                /* not supported yet, treat as next char */\n                ch = *format++;\n                break;\n            default:\n                /* unknown, skip */\n                break;\n            }\n            ch = *format++;\n            state = DP_S_DEFAULT;\n            flags = cflags = min = 0;\n            max = -1;\n            break;\n        case DP_S_DONE:\n            break;\n        default:\n            break;\n        }\n    }\n    /*\n     * We have to truncate if there is no dynamic buffer and we have filled the\n     * static buffer.\n     */\n    if (buffer == NULL) {\n        *truncated = (currlen \u003e *maxlen - 1);\n        if (*truncated)\n            currlen = *maxlen - 1;\n    }\n    if(!doapr_outch(sbuffer, buffer, \u0026currlen, maxlen, '\\0'))\n        return 0;\n    *retlen = currlen - 1;\n    return 1;\n}","filepath":"crypto/bio/b_print.c","line_number":102,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0d"},"269899568":{"score":0.8004444,"function_name":"doapr_outch","code":"static int\ndoapr_outch(char **sbuffer,\n            char **buffer, size_t *currlen, size_t *maxlen, int c)\n{\n    /* If we haven't at least one buffer, someone has doe a big booboo */\n    OPENSSL_assert(*sbuffer != NULL || buffer != NULL);\n\n    /* |currlen| must always be \u003c= |*maxlen| */\n    OPENSSL_assert(*currlen \u003c= *maxlen);\n\n    if (buffer \u0026\u0026 *currlen == *maxlen) {\n        if (*maxlen \u003e INT_MAX - BUFFER_INC)\n            return 0;\n\n        *maxlen += BUFFER_INC;\n        if (*buffer == NULL) {\n            *buffer = OPENSSL_malloc(*maxlen);\n            if (*buffer == NULL)\n                return 0;\n            if (*currlen \u003e 0) {\n                OPENSSL_assert(*sbuffer != NULL);\n                memcpy(*buffer, *sbuffer, *currlen);\n            }\n            *sbuffer = NULL;\n        } else {\n            char *tmpbuf;\n            tmpbuf = OPENSSL_realloc(*buffer, *maxlen);\n            if (tmpbuf == NULL)\n                return 0;\n            *buffer = tmpbuf;\n        }\n    }\n\n    if (*currlen \u003c *maxlen) {\n        if (*sbuffer)\n            (*sbuffer)[(*currlen)++] = (char)c;\n        else\n            (*buffer)[(*currlen)++] = (char)c;\n    }\n\n    return 1;\n}","filepath":"crypto/bio/b_print.c","line_number":822,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0d"},"269899808":{"score":0.84724003,"function_name":"fmtfp","code":"static int\nfmtfp(char **sbuffer,\n      char **buffer,\n      size_t *currlen,\n      size_t *maxlen, LDOUBLE fvalue, int min, int max, int flags, int style)\n{\n    int signvalue = 0;\n    LDOUBLE ufvalue;\n    LDOUBLE tmpvalue;\n    char iconvert[20];\n    char fconvert[20];\n    char econvert[20];\n    int iplace = 0;\n    int fplace = 0;\n    int eplace = 0;\n    int padlen = 0;\n    int zpadlen = 0;\n    long exp = 0;\n    unsigned long intpart;\n    unsigned long fracpart;\n    unsigned long max10;\n    int realstyle;\n\n    if (max \u003c 0)\n        max = 6;\n\n    if (fvalue \u003c 0)\n        signvalue = '-';\n    else if (flags \u0026 DP_F_PLUS)\n        signvalue = '+';\n    else if (flags \u0026 DP_F_SPACE)\n        signvalue = ' ';\n\n    /*\n     * G_FORMAT sometimes prints like E_FORMAT and sometimes like F_FORMAT\n     * depending on the number to be printed. Work out which one it is and use\n     * that from here on.\n     */\n    if (style == G_FORMAT) {\n        if (fvalue == 0.0) {\n            realstyle = F_FORMAT;\n        } else if (fvalue \u003c 0.0001) {\n            realstyle = E_FORMAT;\n        } else if ((max == 0 \u0026\u0026 fvalue \u003e= 10)\n                    || (max \u003e 0 \u0026\u0026 fvalue \u003e= pow_10(max))) {\n            realstyle = E_FORMAT;\n        } else {\n            realstyle = F_FORMAT;\n        }\n    } else {\n        realstyle = style;\n    }\n\n    if (style != F_FORMAT) {\n        tmpvalue = fvalue;\n        /* Calculate the exponent */\n        if (fvalue != 0.0) {\n            while (tmpvalue \u003c 1) {\n                tmpvalue *= 10;\n                exp--;\n            }\n            while (tmpvalue \u003e 10) {\n                tmpvalue /= 10;\n                exp++;\n            }\n        }\n        if (style == G_FORMAT) {\n            /*\n             * In G_FORMAT the \"precision\" represents significant digits. We\n             * always have at least 1 significant digit.\n             */\n            if (max == 0)\n                max = 1;\n            /* Now convert significant digits to decimal places */\n            if (realstyle == F_FORMAT) {\n                max -= (exp + 1);\n                if (max \u003c 0) {\n                    /*\n                     * Should not happen. If we're in F_FORMAT then exp \u003c max?\n                     */\n                    return 0;\n                }\n            } else {\n                /*\n                 * In E_FORMAT there is always one significant digit in front\n                 * of the decimal point, so:\n                 * significant digits == 1 + decimal places\n                 */\n                max--;\n            }\n        }\n        if (realstyle == E_FORMAT)\n            fvalue = tmpvalue;\n    }\n    ufvalue = abs_val(fvalue);\n    if (ufvalue \u003e ULONG_MAX) {\n        /* Number too big */\n        return 0;\n    }\n    intpart = (unsigned long)ufvalue;\n\n    /*\n     * sorry, we only support 9 digits past the decimal because of our\n     * conversion method\n     */\n    if (max \u003e 9)\n        max = 9;\n\n    /*\n     * we \"cheat\" by converting the fractional part to integer by multiplying\n     * by a factor of 10\n     */\n    max10 = roundv(pow_10(max));\n    fracpart = roundv(pow_10(max) * (ufvalue - intpart));\n\n    if (fracpart \u003e= max10) {\n        intpart++;\n        fracpart -= max10;\n    }\n\n    /* convert integer part */\n    do {\n        iconvert[iplace++] = \"0123456789\"[intpart % 10];\n        intpart = (intpart / 10);\n    } while (intpart \u0026\u0026 (iplace \u003c (int)sizeof(iconvert)));\n    if (iplace == sizeof iconvert)\n        iplace--;\n    iconvert[iplace] = 0;\n\n    /* convert fractional part */\n    while (fplace \u003c max) {\n        if (style == G_FORMAT \u0026\u0026 fplace == 0 \u0026\u0026 (fracpart % 10) == 0) {\n            /* We strip trailing zeros in G_FORMAT */\n            max--;\n            fracpart = fracpart / 10;\n            if (fplace \u003c max)\n                continue;\n            break;\n        }\n        fconvert[fplace++] = \"0123456789\"[fracpart % 10];\n        fracpart = (fracpart / 10);\n    }\n\n    if (fplace == sizeof fconvert)\n        fplace--;\n    fconvert[fplace] = 0;\n\n    /* convert exponent part */\n    if (realstyle == E_FORMAT) {\n        int tmpexp;\n        if (exp \u003c 0)\n            tmpexp = -exp;\n        else\n            tmpexp = exp;\n\n        do {\n            econvert[eplace++] = \"0123456789\"[tmpexp % 10];\n            tmpexp = (tmpexp / 10);\n        } while (tmpexp \u003e 0 \u0026\u0026 eplace \u003c (int)sizeof(econvert));\n        /* Exponent is huge!! Too big to print */\n        if (tmpexp \u003e 0)\n            return 0;\n        /* Add a leading 0 for single digit exponents */\n        if (eplace == 1)\n            econvert[eplace++] = '0';\n    }\n\n    /*\n     * -1 for decimal point (if we have one, i.e. max \u003e 0),\n     * another -1 if we are printing a sign\n     */\n    padlen = min - iplace - max - (max \u003e 0 ? 1 : 0) - ((signvalue) ? 1 : 0);\n    /* Take some off for exponent prefix \"+e\" and exponent */\n    if (realstyle == E_FORMAT)\n        padlen -= 2 + eplace;\n    zpadlen = max - fplace;\n    if (zpadlen \u003c 0)\n        zpadlen = 0;\n    if (padlen \u003c 0)\n        padlen = 0;\n    if (flags \u0026 DP_F_MINUS)\n        padlen = -padlen;\n\n    if ((flags \u0026 DP_F_ZERO) \u0026\u0026 (padlen \u003e 0)) {\n        if (signvalue) {\n            if (!doapr_outch(sbuffer, buffer, currlen, maxlen, signvalue))\n                return 0;\n            --padlen;\n            signvalue = 0;\n        }\n        while (padlen \u003e 0) {\n            if (!doapr_outch(sbuffer, buffer, currlen, maxlen, '0'))\n                return 0;\n            --padlen;\n        }\n    }\n    while (padlen \u003e 0) {\n        if (!doapr_outch(sbuffer, buffer, currlen, maxlen, ' '))\n            return 0;\n        --padlen;\n    }\n    if (signvalue \u0026\u0026 !doapr_outch(sbuffer, buffer, currlen, maxlen, signvalue))\n        return 0;\n\n    while (iplace \u003e 0) {\n        if (!doapr_outch(sbuffer, buffer, currlen, maxlen, iconvert[--iplace]))\n            return 0;\n    }\n\n    /*\n     * Decimal point. This should probably use locale to find the correct\n     * char to print out.\n     */\n    if (max \u003e 0 || (flags \u0026 DP_F_NUM)) {\n        if (!doapr_outch(sbuffer, buffer, currlen, maxlen, '.'))\n            return 0;\n\n        while (fplace \u003e 0) {\n            if(!doapr_outch(sbuffer, buffer, currlen, maxlen,\n                            fconvert[--fplace]))\n                return 0;\n        }\n    }\n    while (zpadlen \u003e 0) {\n        if (!doapr_outch(sbuffer, buffer, currlen, maxlen, '0'))\n            return 0;\n        --zpadlen;\n    }\n    if (realstyle == E_FORMAT) {\n        char ech;\n\n        if ((flags \u0026 DP_F_UP) == 0)\n            ech = 'e';\n        else\n            ech = 'E';\n        if (!doapr_outch(sbuffer, buffer, currlen, maxlen, ech))\n                return 0;\n        if (exp \u003c 0) {\n            if (!doapr_outch(sbuffer, buffer, currlen, maxlen, '-'))\n                    return 0;\n        } else {\n            if (!doapr_outch(sbuffer, buffer, currlen, maxlen, '+'))\n                    return 0;\n        }\n        while (eplace \u003e 0) {\n            if (!doapr_outch(sbuffer, buffer, currlen, maxlen,\n                             econvert[--eplace]))\n                return 0;\n        }\n    }\n\n    while (padlen \u003c 0) {\n        if (!doapr_outch(sbuffer, buffer, currlen, maxlen, ' '))\n            return 0;\n        ++padlen;\n    }\n    return 1;\n}","filepath":"crypto/bio/b_print.c","line_number":561,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0d"},"269902384":{"score":0.88858557,"function_name":"pow_10","code":"static LDOUBLE pow_10(int in_exp)\n{\n    LDOUBLE result = 1;\n    while (in_exp) {\n        result *= 10;\n        in_exp--;\n    }\n    return result;\n}","filepath":"crypto/bio/b_print.c","line_number":541,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0d"},"269902448":{"score":0.84130603,"function_name":"lh_delete","code":"void *lh_delete(_LHASH *lh, const void *data)\n{\n    unsigned long hash;\n    LHASH_NODE *nn, **rn;\n    void *ret;\n\n    lh-\u003eerror = 0;\n    rn = getrn(lh, data, \u0026hash);\n\n    if (*rn == NULL) {\n        lh-\u003enum_no_delete++;\n        return (NULL);\n    } else {\n        nn = *rn;\n        *rn = nn-\u003enext;\n        ret = nn-\u003edata;\n        OPENSSL_free(nn);\n        lh-\u003enum_delete++;\n    }\n\n    lh-\u003enum_items--;\n    if ((lh-\u003enum_nodes \u003e MIN_NODES) \u0026\u0026\n        (lh-\u003edown_load \u003e= (lh-\u003enum_items * LH_LOAD_MULT / lh-\u003enum_nodes)))\n        contract(lh);\n\n    return (ret);\n}","filepath":"crypto/lhash/lhash.c","line_number":188,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre3"},"269902784":{"score":0.88335717,"function_name":"lh_free","code":"void lh_free(_LHASH *lh)\n{\n    unsigned int i;\n    LHASH_NODE *n, *nn;\n\n    if (lh == NULL)\n        return;\n\n    for (i = 0; i \u003c lh-\u003enum_nodes; i++) {\n        n = lh-\u003eb[i];\n        while (n != NULL) {\n            nn = n-\u003enext;\n            OPENSSL_free(n);\n            n = nn;\n        }\n    }\n    OPENSSL_free(lh-\u003eb);\n    OPENSSL_free(lh);\n}","filepath":"crypto/lhash/lhash.c","line_number":135,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre3"},"269902896":{"score":0.7978231,"function_name":"lh_insert","code":"void *lh_insert(_LHASH *lh, void *data)\n{\n    unsigned long hash;\n    LHASH_NODE *nn, **rn;\n    void *ret;\n\n    lh-\u003eerror = 0;\n    if (lh-\u003eup_load \u003c= (lh-\u003enum_items * LH_LOAD_MULT / lh-\u003enum_nodes))\n        expand(lh);\n\n    rn = getrn(lh, data, \u0026hash);\n\n    if (*rn == NULL) {\n        if ((nn = OPENSSL_malloc(sizeof(*nn))) == NULL) {\n            lh-\u003eerror++;\n            return (NULL);\n        }\n        nn-\u003edata = data;\n        nn-\u003enext = NULL;\n        nn-\u003ehash = hash;\n        *rn = nn;\n        ret = NULL;\n        lh-\u003enum_insert++;\n        lh-\u003enum_items++;\n    } else {                    /* replace same key */\n\n        ret = (*rn)-\u003edata;\n        (*rn)-\u003edata = data;\n        lh-\u003enum_replace++;\n    }\n    return (ret);\n}","filepath":"crypto/lhash/lhash.c","line_number":155,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre3"},"269903264":{"score":0.89370793,"function_name":"lh_new","code":"_LHASH *lh_new(LHASH_HASH_FN_TYPE h, LHASH_COMP_FN_TYPE c)\n{\n    _LHASH *ret;\n\n    if ((ret = OPENSSL_zalloc(sizeof(*ret))) == NULL)\n        goto err0;\n    if ((ret-\u003eb = OPENSSL_zalloc(sizeof(*ret-\u003eb) * MIN_NODES)) == NULL)\n        goto err1;\n    ret-\u003ecomp = ((c == NULL) ? (LHASH_COMP_FN_TYPE)strcmp : c);\n    ret-\u003ehash = ((h == NULL) ? (LHASH_HASH_FN_TYPE)lh_strhash : h);\n    ret-\u003enum_nodes = MIN_NODES / 2;\n    ret-\u003enum_alloc_nodes = MIN_NODES;\n    ret-\u003epmax = MIN_NODES / 2;\n    ret-\u003eup_load = UP_LOAD;\n    ret-\u003edown_load = DOWN_LOAD;\n    return (ret);\n\n err1:\n    OPENSSL_free(ret);\n err0:\n    return (NULL);\n}","filepath":"crypto/lhash/lhash.c","line_number":112,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre3"},"269903424":{"score":0.8261402,"function_name":"lh_retrieve","code":"void *lh_retrieve(_LHASH *lh, const void *data)\n{\n    unsigned long hash;\n    LHASH_NODE **rn;\n    void *ret;\n\n    lh-\u003eerror = 0;\n    rn = getrn(lh, data, \u0026hash);\n\n    if (*rn == NULL) {\n        lh-\u003enum_retrieve_miss++;\n        return (NULL);\n    } else {\n        ret = (*rn)-\u003edata;\n        lh-\u003enum_retrieve++;\n    }\n    return (ret);\n}","filepath":"crypto/lhash/lhash.c","line_number":216,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre3"},"269903520":{"score":0.9343368,"function_name":"lh_strhash","code":"unsigned long lh_strhash(const char *c)\n{\n    unsigned long ret = 0;\n    long n;\n    unsigned long v;\n    int r;\n\n    if ((c == NULL) || (*c == '\\0'))\n        return (ret);\n/*-\n    unsigned char b[16];\n    MD5(c,strlen(c),b);\n    return(b[0]|(b[1]\u003c\u003c8)|(b[2]\u003c\u003c16)|(b[3]\u003c\u003c24));\n*/\n\n    n = 0x100;\n    while (*c) {\n        v = n | (*c);\n        n += 0x100;\n        r = (int)((v \u003e\u003e 2) ^ v) \u0026 0x0f;\n        ret = (ret \u003c\u003c r) | (ret \u003e\u003e (32 - r));\n        ret \u0026= 0xFFFFFFFFL;\n        ret ^= v * v;\n        c++;\n    }\n    return ((ret \u003e\u003e 16) ^ ret);\n}","filepath":"crypto/lhash/lhash.c","line_number":392,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre3"},"269903600":{"score":0.97491854,"function_name":"doall_util_fn","code":"static void doall_util_fn(_LHASH *lh, int use_arg, LHASH_DOALL_FN_TYPE func,\n                          LHASH_DOALL_ARG_FN_TYPE func_arg, void *arg)\n{\n    int i;\n    LHASH_NODE *a, *n;\n\n    if (lh == NULL)\n        return;\n\n    /*\n     * reverse the order so we search from 'top to bottom' We were having\n     * memory leaks otherwise\n     */\n    for (i = lh-\u003enum_nodes - 1; i \u003e= 0; i--) {\n        a = lh-\u003eb[i];\n        while (a != NULL) {\n            /*\n             * 28/05/91 - eay - n added so items can be deleted via lh_doall\n             */\n            /*\n             * 22/05/08 - ben - eh? since a is not passed, this should not be\n             * needed\n             */\n            n = a-\u003enext;\n            if (use_arg)\n                func_arg(a-\u003edata, arg);\n            else\n                func(a-\u003edata);\n            a = n;\n        }\n    }\n}","filepath":"crypto/lhash/lhash.c","line_number":235,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre3"},"269903712":{"score":0.91218835,"function_name":"getrn","code":"static LHASH_NODE **getrn(_LHASH *lh, const void *data, unsigned long *rhash)\n{\n    LHASH_NODE **ret, *n1;\n    unsigned long hash, nn;\n    LHASH_COMP_FN_TYPE cf;\n\n    hash = (*(lh-\u003ehash)) (data);\n    lh-\u003enum_hash_calls++;\n    *rhash = hash;\n\n    nn = hash % lh-\u003epmax;\n    if (nn \u003c lh-\u003ep)\n        nn = hash % lh-\u003enum_alloc_nodes;\n\n    cf = lh-\u003ecomp;\n    ret = \u0026(lh-\u003eb[(int)nn]);\n    for (n1 = *ret; n1 != NULL; n1 = n1-\u003enext) {\n        lh-\u003enum_hash_comps++;\n        if (n1-\u003ehash != hash) {\n            ret = \u0026(n1-\u003enext);\n            continue;\n        }\n        lh-\u003enum_comp_calls++;\n        if (cf(n1-\u003edata, data) == 0)\n            break;\n        ret = \u0026(n1-\u003enext);\n    }\n    return (ret);\n}","filepath":"crypto/lhash/lhash.c","line_number":357,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre3"},"269905072":{"score":0.8789503,"function_name":"BN_MONT_CTX_copy","code":"BN_MONT_CTX *BN_MONT_CTX_copy(BN_MONT_CTX *to, BN_MONT_CTX *from)\n{\n    if (to == from)\n        return to;\n\n    if (!BN_copy(\u0026(to-\u003eRR), \u0026(from-\u003eRR)))\n        return NULL;\n    if (!BN_copy(\u0026(to-\u003eN), \u0026(from-\u003eN)))\n        return NULL;\n    if (!BN_copy(\u0026(to-\u003eNi), \u0026(from-\u003eNi)))\n        return NULL;\n    to-\u003eri = from-\u003eri;\n    to-\u003en0[0] = from-\u003en0[0];\n    to-\u003en0[1] = from-\u003en0[1];\n    return to;\n}","filepath":"crypto/bn/bn_mont.c","line_number":411,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269905184":{"score":0.85405856,"function_name":"BN_MONT_CTX_free","code":"void BN_MONT_CTX_free(BN_MONT_CTX *mont)\n{\n    if (mont == NULL)\n        return;\n    BN_clear_free(\u0026mont-\u003eRR);\n    BN_clear_free(\u0026mont-\u003eN);\n    BN_clear_free(\u0026mont-\u003eNi);\n    if (mont-\u003eflags \u0026 BN_FLG_MALLOCED)\n        OPENSSL_free(mont);\n}","filepath":"crypto/bn/bn_mont.c","line_number":252,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269905392":{"score":0.84773636,"function_name":"BN_MONT_CTX_set","code":"int BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *mod, BN_CTX *ctx)\n{\n    int i, ret = 0;\n    BIGNUM *Ri, *R;\n\n    if (BN_is_zero(mod))\n        return 0;\n\n    BN_CTX_start(ctx);\n    if ((Ri = BN_CTX_get(ctx)) == NULL)\n        goto err;\n    R = \u0026(mont-\u003eRR);            /* grab RR as a temp */\n    if (!BN_copy(\u0026(mont-\u003eN), mod))\n        goto err;               /* Set N */\n    if (BN_get_flags(mod, BN_FLG_CONSTTIME) != 0)\n        BN_set_flags(\u0026(mont-\u003eN), BN_FLG_CONSTTIME);\n    mont-\u003eN.neg = 0;\n\n#ifdef MONT_WORD\n    {\n        BIGNUM tmod;\n        BN_ULONG buf[2];\n\n        bn_init(\u0026tmod);\n        tmod.d = buf;\n        tmod.dmax = 2;\n        tmod.neg = 0;\n\n        if (BN_get_flags(mod, BN_FLG_CONSTTIME) != 0)\n            BN_set_flags(\u0026tmod, BN_FLG_CONSTTIME);\n\n        mont-\u003eri = (BN_num_bits(mod) + (BN_BITS2 - 1)) / BN_BITS2 * BN_BITS2;\n\n# if defined(OPENSSL_BN_ASM_MONT) \u0026\u0026 (BN_BITS2\u003c=32)\n        /*\n         * Only certain BN_BITS2\u003c=32 platforms actually make use of n0[1],\n         * and we could use the #else case (with a shorter R value) for the\n         * others.  However, currently only the assembler files do know which\n         * is which.\n         */\n\n        BN_zero(R);\n        if (!(BN_set_bit(R, 2 * BN_BITS2)))\n            goto err;\n\n        tmod.top = 0;\n        if ((buf[0] = mod-\u003ed[0]))\n            tmod.top = 1;\n        if ((buf[1] = mod-\u003etop \u003e 1 ? mod-\u003ed[1] : 0))\n            tmod.top = 2;\n\n        if (BN_is_one(\u0026tmod))\n            BN_zero(Ri);\n        else if ((BN_mod_inverse(Ri, R, \u0026tmod, ctx)) == NULL)\n            goto err;\n        if (!BN_lshift(Ri, Ri, 2 * BN_BITS2))\n            goto err;           /* R*Ri */\n        if (!BN_is_zero(Ri)) {\n            if (!BN_sub_word(Ri, 1))\n                goto err;\n        } else {                /* if N mod word size == 1 */\n\n            if (bn_expand(Ri, (int)sizeof(BN_ULONG) * 2) == NULL)\n                goto err;\n            /* Ri-- (mod double word size) */\n            Ri-\u003eneg = 0;\n            Ri-\u003ed[0] = BN_MASK2;\n            Ri-\u003ed[1] = BN_MASK2;\n            Ri-\u003etop = 2;\n        }\n        if (!BN_div(Ri, NULL, Ri, \u0026tmod, ctx))\n            goto err;\n        /*\n         * Ni = (R*Ri-1)/N, keep only couple of least significant words:\n         */\n        mont-\u003en0[0] = (Ri-\u003etop \u003e 0) ? Ri-\u003ed[0] : 0;\n        mont-\u003en0[1] = (Ri-\u003etop \u003e 1) ? Ri-\u003ed[1] : 0;\n# else\n        BN_zero(R);\n        if (!(BN_set_bit(R, BN_BITS2)))\n            goto err;           /* R */\n\n        buf[0] = mod-\u003ed[0];     /* tmod = N mod word size */\n        buf[1] = 0;\n        tmod.top = buf[0] != 0 ? 1 : 0;\n        /* Ri = R^-1 mod N */\n        if (BN_is_one(\u0026tmod))\n            BN_zero(Ri);\n        else if ((BN_mod_inverse(Ri, R, \u0026tmod, ctx)) == NULL)\n            goto err;\n        if (!BN_lshift(Ri, Ri, BN_BITS2))\n            goto err;           /* R*Ri */\n        if (!BN_is_zero(Ri)) {\n            if (!BN_sub_word(Ri, 1))\n                goto err;\n        } else {                /* if N mod word size == 1 */\n\n            if (!BN_set_word(Ri, BN_MASK2))\n                goto err;       /* Ri-- (mod word size) */\n        }\n        if (!BN_div(Ri, NULL, Ri, \u0026tmod, ctx))\n            goto err;\n        /*\n         * Ni = (R*Ri-1)/N, keep only least significant word:\n         */\n        mont-\u003en0[0] = (Ri-\u003etop \u003e 0) ? Ri-\u003ed[0] : 0;\n        mont-\u003en0[1] = 0;\n# endif\n    }\n#else                           /* !MONT_WORD */\n    {                           /* bignum version */\n        mont-\u003eri = BN_num_bits(\u0026mont-\u003eN);\n        BN_zero(R);\n        if (!BN_set_bit(R, mont-\u003eri))\n            goto err;           /* R = 2^ri */\n        /* Ri = R^-1 mod N */\n        if ((BN_mod_inverse(Ri, R, \u0026mont-\u003eN, ctx)) == NULL)\n            goto err;\n        if (!BN_lshift(Ri, Ri, mont-\u003eri))\n            goto err;           /* R*Ri */\n        if (!BN_sub_word(Ri, 1))\n            goto err;\n        /*\n         * Ni = (R*Ri-1) / N\n         */\n        if (!BN_div(\u0026(mont-\u003eNi), NULL, Ri, \u0026mont-\u003eN, ctx))\n            goto err;\n    }\n#endif\n\n    /* setup RR for conversions */\n    BN_zero(\u0026(mont-\u003eRR));\n    if (!BN_set_bit(\u0026(mont-\u003eRR), mont-\u003eri * 2))\n        goto err;\n    if (!BN_mod(\u0026(mont-\u003eRR), \u0026(mont-\u003eRR), \u0026(mont-\u003eN), ctx))\n        goto err;\n\n    for (i = mont-\u003eRR.top, ret = mont-\u003eN.top; i \u003c ret; i++)\n        mont-\u003eRR.d[i] = 0;\n    mont-\u003eRR.top = ret;\n    mont-\u003eRR.flags |= BN_FLG_FIXED_TOP;\n\n    ret = 1;\n err:\n    BN_CTX_end(ctx);\n    return ret;\n}","filepath":"crypto/bn/bn_mont.c","line_number":263,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269906080":{"score":0.81515694,"function_name":"BN_MONT_CTX_set_locked","code":"BN_MONT_CTX *BN_MONT_CTX_set_locked(BN_MONT_CTX **pmont, CRYPTO_RWLOCK *lock,\n                                    const BIGNUM *mod, BN_CTX *ctx)\n{\n    BN_MONT_CTX *ret;\n\n    CRYPTO_THREAD_read_lock(lock);\n    ret = *pmont;\n    CRYPTO_THREAD_unlock(lock);\n    if (ret)\n        return ret;\n\n    /*\n     * We don't want to serialise globally while doing our lazy-init math in\n     * BN_MONT_CTX_set. That punishes threads that are doing independent\n     * things. Instead, punish the case where more than one thread tries to\n     * lazy-init the same 'pmont', by having each do the lazy-init math work\n     * independently and only use the one from the thread that wins the race\n     * (the losers throw away the work they've done).\n     */\n    ret = BN_MONT_CTX_new();\n    if (ret == NULL)\n        return NULL;\n    if (!BN_MONT_CTX_set(ret, mod, ctx)) {\n        BN_MONT_CTX_free(ret);\n        return NULL;\n    }\n\n    /* The locked compare-and-set, after the local work is done. */\n    CRYPTO_THREAD_write_lock(lock);\n    if (*pmont) {\n        BN_MONT_CTX_free(ret);\n        ret = *pmont;\n    } else\n        *pmont = ret;\n    CRYPTO_THREAD_unlock(lock);\n    return ret;\n}","filepath":"crypto/bn/bn_mont.c","line_number":428,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269906432":{"score":0.69366646,"function_name":"BN_mod_mul_montgomery","code":"int BN_mod_mul_montgomery(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,\n                          BN_MONT_CTX *mont, BN_CTX *ctx)\n{\n    int ret = bn_mul_mont_fixed_top(r, a, b, mont, ctx);\n\n    bn_correct_top(r);\n    bn_check_top(r);\n\n    return ret;\n}","filepath":"crypto/bn/bn_mont.c","line_number":26,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269907472":{"score":0.8867924,"function_name":"bn_mul_mont_fixed_top","code":"int bn_mul_mont_fixed_top(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,\n                          BN_MONT_CTX *mont, BN_CTX *ctx)\n{\n    BIGNUM *tmp;\n    int ret = 0;\n    int num = mont-\u003eN.top;\n\n#if defined(OPENSSL_BN_ASM_MONT) \u0026\u0026 defined(MONT_WORD)\n    if (num \u003e 1 \u0026\u0026 a-\u003etop == num \u0026\u0026 b-\u003etop == num) {\n        if (bn_wexpand(r, num) == NULL)\n            return 0;\n        if (bn_mul_mont(r-\u003ed, a-\u003ed, b-\u003ed, mont-\u003eN.d, mont-\u003en0, num)) {\n            r-\u003eneg = a-\u003eneg ^ b-\u003eneg;\n            r-\u003etop = num;\n            r-\u003eflags |= BN_FLG_FIXED_TOP;\n            return 1;\n        }\n    }\n#endif\n\n    if ((a-\u003etop + b-\u003etop) \u003e 2 * num)\n        return 0;\n\n    BN_CTX_start(ctx);\n    tmp = BN_CTX_get(ctx);\n    if (tmp == NULL)\n        goto err;\n\n    bn_check_top(tmp);\n    if (a == b) {\n        if (!bn_sqr_fixed_top(tmp, a, ctx))\n            goto err;\n    } else {\n        if (!bn_mul_fixed_top(tmp, a, b, ctx))\n            goto err;\n    }\n    /* reduce from aRR to aR */\n#ifdef MONT_WORD\n    if (!bn_from_montgomery_word(r, tmp, mont))\n        goto err;\n#else\n    if (!BN_from_montgomery(r, tmp, mont, ctx))\n        goto err;\n#endif\n    ret = 1;\n err:\n    BN_CTX_end(ctx);\n    return ret;\n}","filepath":"crypto/bn/bn_mont.c","line_number":37,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269909104":{"score":0.7548524,"function_name":"BN_mod_add_quick","code":"int BN_mod_add_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,\n                     const BIGNUM *m)\n{\n    int ret = bn_mod_add_fixed_top(r, a, b, m);\n\n    if (ret)\n        bn_correct_top(r);\n\n    return ret;\n}","filepath":"crypto/bn/bn_mod.c","line_number":95,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0j"},"269909152":{"score":0.8937839,"function_name":"BN_mod_lshift1_quick","code":"int BN_mod_lshift1_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *m)\n{\n    if (!BN_lshift1(r, a))\n        return 0;\n    bn_check_top(r);\n    if (BN_cmp(r, m) \u003e= 0)\n        return BN_sub(r, r, m);\n    return 1;\n}","filepath":"crypto/bn/bn_mod.c","line_number":242,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0j"},"269909216":{"score":0.915787,"function_name":"BN_mod_lshift_quick","code":"int BN_mod_lshift_quick(BIGNUM *r, const BIGNUM *a, int n, const BIGNUM *m)\n{\n    if (r != a) {\n        if (BN_copy(r, a) == NULL)\n            return 0;\n    }\n\n    while (n \u003e 0) {\n        int max_shift;\n\n        /* 0 \u003c r \u003c m */\n        max_shift = BN_num_bits(m) - BN_num_bits(r);\n        /* max_shift \u003e= 0 */\n\n        if (max_shift \u003c 0) {\n            BNerr(BN_F_BN_MOD_LSHIFT_QUICK, BN_R_INPUT_NOT_REDUCED);\n            return 0;\n        }\n\n        if (max_shift \u003e n)\n            max_shift = n;\n\n        if (max_shift) {\n            if (!BN_lshift(r, r, max_shift))\n                return 0;\n            n -= max_shift;\n        } else {\n            if (!BN_lshift1(r, r))\n                return 0;\n            --n;\n        }\n\n        /* BN_num_bits(r) \u003c= BN_num_bits(m) */\n\n        if (BN_cmp(r, m) \u003e= 0) {\n            if (!BN_sub(r, r, m))\n                return 0;\n        }\n    }\n    bn_check_top(r);\n\n    return 1;\n}","filepath":"crypto/bn/bn_mod.c","line_number":279,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0j"},"269909408":{"score":0.8727473,"function_name":"BN_mod_mul","code":"int BN_mod_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m,\n               BN_CTX *ctx)\n{\n    BIGNUM *t;\n    int ret = 0;\n\n    bn_check_top(a);\n    bn_check_top(b);\n    bn_check_top(m);\n\n    BN_CTX_start(ctx);\n    if ((t = BN_CTX_get(ctx)) == NULL)\n        goto err;\n    if (a == b) {\n        if (!BN_sqr(t, a, ctx))\n            goto err;\n    } else {\n        if (!BN_mul(t, a, b, ctx))\n            goto err;\n    }\n    if (!BN_nnmod(r, t, m, ctx))\n        goto err;\n    bn_check_top(r);\n    ret = 1;\n err:\n    BN_CTX_end(ctx);\n    return (ret);\n}","filepath":"crypto/bn/bn_mod.c","line_number":193,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0j"},"269909600":{"score":0.8670379,"function_name":"BN_mod_sub_quick","code":"int BN_mod_sub_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,\n                     const BIGNUM *m)\n{\n    if (!BN_sub(r, a, b))\n        return 0;\n    if (r-\u003eneg)\n        return BN_add(r, r, m);\n    return 1;\n}","filepath":"crypto/bn/bn_mod.c","line_number":182,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0j"},"269909664":{"score":0.817226,"function_name":"BN_nnmod","code":"int BN_nnmod(BIGNUM *r, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx)\n{\n    /*\n     * like BN_mod, but returns non-negative remainder (i.e., 0 \u003c= r \u003c |d|\n     * always holds)\n     */\n\n    if (!(BN_mod(r, m, d, ctx)))\n        return 0;\n    if (!r-\u003eneg)\n        return 1;\n    /* now   -|d| \u003c r \u003c 0,  so we have to set  r := r + |d| */\n    return (d-\u003eneg ? BN_sub : BN_add) (r, r, d);\n}","filepath":"crypto/bn/bn_mod.c","line_number":13,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0j"},"269909744":{"score":0.7496327,"function_name":"bn_mod_add_fixed_top","code":"int bn_mod_add_fixed_top(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,\n                         const BIGNUM *m)\n{\n    size_t i, ai, bi, mtop = m-\u003etop;\n    BN_ULONG storage[1024 / BN_BITS2];\n    BN_ULONG carry, temp, mask, *rp, *tp = storage;\n    const BN_ULONG *ap, *bp;\n\n    if (bn_wexpand(r, mtop) == NULL)\n        return 0;\n\n    if (mtop \u003e sizeof(storage) / sizeof(storage[0])\n        \u0026\u0026 (tp = OPENSSL_malloc(mtop * sizeof(BN_ULONG))) == NULL)\n        return 0;\n\n    ap = a-\u003ed != NULL ? a-\u003ed : tp;\n    bp = b-\u003ed != NULL ? b-\u003ed : tp;\n\n    for (i = 0, ai = 0, bi = 0, carry = 0; i \u003c mtop;) {\n        mask = (BN_ULONG)0 - ((i - a-\u003etop) \u003e\u003e (8 * sizeof(i) - 1));\n        temp = ((ap[ai] \u0026 mask) + carry) \u0026 BN_MASK2;\n        carry = (temp \u003c carry);\n\n        mask = (BN_ULONG)0 - ((i - b-\u003etop) \u003e\u003e (8 * sizeof(i) - 1));\n        tp[i] = ((bp[bi] \u0026 mask) + temp) \u0026 BN_MASK2;\n        carry += (tp[i] \u003c temp);\n\n        i++;\n        ai += (i - a-\u003edmax) \u003e\u003e (8 * sizeof(i) - 1);\n        bi += (i - b-\u003edmax) \u003e\u003e (8 * sizeof(i) - 1);\n    }\n    rp = r-\u003ed;\n    carry -= bn_sub_words(rp, tp, m-\u003ed, mtop);\n    for (i = 0; i \u003c mtop; i++) {\n        rp[i] = (carry \u0026 tp[i]) | (~carry \u0026 rp[i]);\n        ((volatile BN_ULONG *)tp)[i] = 0;\n    }\n    r-\u003etop = mtop;\n    r-\u003eflags |= BN_FLG_FIXED_TOP;\n    r-\u003eneg = 0;\n\n    if (tp != storage)\n        OPENSSL_free(tp);\n\n    return 1;\n}","filepath":"crypto/bn/bn_mod.c","line_number":48,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0j"},"269910240":{"score":0.8923035,"function_name":"bn_mod_sub_fixed_top","code":"int bn_mod_sub_fixed_top(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,\n                         const BIGNUM *m)\n{\n    size_t i, ai, bi, mtop = m-\u003etop;\n    BN_ULONG borrow, carry, ta, tb, mask, *rp;\n    const BN_ULONG *ap, *bp;\n\n    if (bn_wexpand(r, mtop) == NULL)\n        return 0;\n\n    rp = r-\u003ed;\n    ap = a-\u003ed != NULL ? a-\u003ed : rp;\n    bp = b-\u003ed != NULL ? b-\u003ed : rp;\n\n    for (i = 0, ai = 0, bi = 0, borrow = 0; i \u003c mtop;) {\n        mask = (BN_ULONG)0 - ((i - a-\u003etop) \u003e\u003e (8 * sizeof(i) - 1));\n        ta = ap[ai] \u0026 mask;\n\n        mask = (BN_ULONG)0 - ((i - b-\u003etop) \u003e\u003e (8 * sizeof(i) - 1));\n        tb = bp[bi] \u0026 mask;\n        rp[i] = ta - tb - borrow;\n        if (ta != tb)\n            borrow = (ta \u003c tb);\n\n        i++;\n        ai += (i - a-\u003edmax) \u003e\u003e (8 * sizeof(i) - 1);\n        bi += (i - b-\u003edmax) \u003e\u003e (8 * sizeof(i) - 1);\n    }\n    ap = m-\u003ed;\n    for (i = 0, mask = 0 - borrow, carry = 0; i \u003c mtop; i++) {\n        ta = ((ap[i] \u0026 mask) + carry) \u0026 BN_MASK2;\n        carry = (ta \u003c carry);\n        rp[i] = (rp[i] + ta) \u0026 BN_MASK2;\n        carry += (rp[i] \u003c ta);\n    }\n    borrow -= carry;\n    for (i = 0, mask = 0 - borrow, carry = 0; i \u003c mtop; i++) {\n        ta = ((ap[i] \u0026 mask) + carry) \u0026 BN_MASK2;\n        carry = (ta \u003c carry);\n        rp[i] = (rp[i] + ta) \u0026 BN_MASK2;\n        carry += (rp[i] \u003c ta);\n    }\n\n    r-\u003etop = mtop;\n    r-\u003eflags |= BN_FLG_FIXED_TOP;\n    r-\u003eneg = 0;\n\n    return 1;\n}","filepath":"crypto/bn/bn_mod.c","line_number":128,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0j"},"269911008":{"score":0.9079906,"function_name":"BN_div_word","code":"BN_ULONG BN_div_word(BIGNUM *a, BN_ULONG w)\n{\n    BN_ULONG ret = 0;\n    int i, j;\n\n    bn_check_top(a);\n    w \u0026= BN_MASK2;\n\n    if (!w)\n        /* actually this an error (division by zero) */\n        return (BN_ULONG)-1;\n    if (a-\u003etop == 0)\n        return 0;\n\n    /* normalize input (so bn_div_words doesn't complain) */\n    j = BN_BITS2 - BN_num_bits_word(w);\n    w \u003c\u003c= j;\n    if (!BN_lshift(a, a, j))\n        return (BN_ULONG)-1;\n\n    for (i = a-\u003etop - 1; i \u003e= 0; i--) {\n        BN_ULONG l, d;\n\n        l = a-\u003ed[i];\n        d = bn_div_words(ret, l, w);\n        ret = (l - ((d * w) \u0026 BN_MASK2)) \u0026 BN_MASK2;\n        a-\u003ed[i] = d;\n    }\n    if ((a-\u003etop \u003e 0) \u0026\u0026 (a-\u003ed[a-\u003etop - 1] == 0))\n        a-\u003etop--;\n    ret \u003e\u003e= j;\n    if (!a-\u003etop)\n        a-\u003eneg = 0; /* don't allow negative zero */\n    bn_check_top(a);\n    return ret;\n}","filepath":"crypto/bn/bn_word.c","line_number":61,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269911328":{"score":0.83688855,"function_name":"BN_mul_word","code":"int BN_mul_word(BIGNUM *a, BN_ULONG w)\n{\n    BN_ULONG ll;\n\n    bn_check_top(a);\n    w \u0026= BN_MASK2;\n    if (a-\u003etop) {\n        if (w == 0)\n            BN_zero(a);\n        else {\n            ll = bn_mul_words(a-\u003ed, a-\u003ed, a-\u003etop, w);\n            if (ll) {\n                if (bn_wexpand(a, a-\u003etop + 1) == NULL)\n                    return 0;\n                a-\u003ed[a-\u003etop++] = ll;\n            }\n        }\n    }\n    bn_check_top(a);\n    return 1;\n}","filepath":"crypto/bn/bn_word.c","line_number":181,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269911440":{"score":0.8637031,"function_name":"BN_sub_word","code":"int BN_sub_word(BIGNUM *a, BN_ULONG w)\n{\n    int i;\n\n    bn_check_top(a);\n    w \u0026= BN_MASK2;\n\n    /* degenerate case: w is zero */\n    if (!w)\n        return 1;\n    /* degenerate case: a is zero */\n    if (BN_is_zero(a)) {\n        i = BN_set_word(a, w);\n        if (i != 0)\n            BN_set_negative(a, 1);\n        return i;\n    }\n    /* handle 'a' when negative */\n    if (a-\u003eneg) {\n        a-\u003eneg = 0;\n        i = BN_add_word(a, w);\n        a-\u003eneg = 1;\n        return i;\n    }\n\n    if ((a-\u003etop == 1) \u0026\u0026 (a-\u003ed[0] \u003c w)) {\n        a-\u003ed[0] = w - a-\u003ed[0];\n        a-\u003eneg = 1;\n        return 1;\n    }\n    i = 0;\n    for (;;) {\n        if (a-\u003ed[i] \u003e= w) {\n            a-\u003ed[i] -= w;\n            break;\n        } else {\n            a-\u003ed[i] = (a-\u003ed[i] - w) \u0026 BN_MASK2;\n            i++;\n            w = 1;\n        }\n    }\n    if ((a-\u003ed[i] == 0) \u0026\u0026 (i == (a-\u003etop - 1)))\n        a-\u003etop--;\n    bn_check_top(a);\n    return 1;\n}","filepath":"crypto/bn/bn_word.c","line_number":134,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269912016":{"score":0.9084691,"function_name":"BN_lshift1","code":"int BN_lshift1(BIGNUM *r, const BIGNUM *a)\n{\n    register BN_ULONG *ap, *rp, t, c;\n    int i;\n\n    bn_check_top(r);\n    bn_check_top(a);\n\n    if (r != a) {\n        r-\u003eneg = a-\u003eneg;\n        if (bn_wexpand(r, a-\u003etop + 1) == NULL)\n            return 0;\n        r-\u003etop = a-\u003etop;\n    } else {\n        if (bn_wexpand(r, a-\u003etop + 1) == NULL)\n            return 0;\n    }\n    ap = a-\u003ed;\n    rp = r-\u003ed;\n    c = 0;\n    for (i = 0; i \u003c a-\u003etop; i++) {\n        t = *(ap++);\n        *(rp++) = ((t \u003c\u003c 1) | c) \u0026 BN_MASK2;\n        c = (t \u0026 BN_TBIT) ? 1 : 0;\n    }\n    if (c) {\n        *rp = 1;\n        r-\u003etop++;\n    }\n    bn_check_top(r);\n    return 1;\n}","filepath":"crypto/bn/bn_shift.c","line_number":14,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1b"},"269912160":{"score":0.95649904,"function_name":"BN_rshift","code":"int BN_rshift(BIGNUM *r, const BIGNUM *a, int n)\n{\n    int i, j, nw, lb, rb;\n    BN_ULONG *t, *f;\n    BN_ULONG l, tmp;\n\n    bn_check_top(r);\n    bn_check_top(a);\n\n    if (n \u003c 0) {\n        BNerr(BN_F_BN_RSHIFT, BN_R_INVALID_SHIFT);\n        return 0;\n    }\n\n    nw = n / BN_BITS2;\n    rb = n % BN_BITS2;\n    lb = BN_BITS2 - rb;\n    if (nw \u003e= a-\u003etop || a-\u003etop == 0) {\n        BN_zero(r);\n        return 1;\n    }\n    i = (BN_num_bits(a) - n + (BN_BITS2 - 1)) / BN_BITS2;\n    if (r != a) {\n        if (bn_wexpand(r, i) == NULL)\n            return 0;\n        r-\u003eneg = a-\u003eneg;\n    } else {\n        if (n == 0)\n            return 1;           /* or the copying loop will go berserk */\n    }\n\n    f = \u0026(a-\u003ed[nw]);\n    t = r-\u003ed;\n    j = a-\u003etop - nw;\n    r-\u003etop = i;\n\n    if (rb == 0) {\n        for (i = j; i != 0; i--)\n            *(t++) = *(f++);\n    } else {\n        l = *(f++);\n        for (i = j - 1; i != 0; i--) {\n            tmp = (l \u003e\u003e rb) \u0026 BN_MASK2;\n            l = *(f++);\n            *(t++) = (tmp | (l \u003c\u003c lb)) \u0026 BN_MASK2;\n        }\n        if ((l = (l \u003e\u003e rb) \u0026 BN_MASK2))\n            *(t) = l;\n    }\n    if (!r-\u003etop)\n        r-\u003eneg = 0; /* don't allow negative zero */\n    bn_check_top(r);\n    return 1;\n}","filepath":"crypto/bn/bn_shift.c","line_number":153,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1b"},"269912544":{"score":0.93978786,"function_name":"BN_rshift1","code":"int BN_rshift1(BIGNUM *r, const BIGNUM *a)\n{\n    BN_ULONG *ap, *rp, t, c;\n    int i, j;\n\n    bn_check_top(r);\n    bn_check_top(a);\n\n    if (BN_is_zero(a)) {\n        BN_zero(r);\n        return 1;\n    }\n    i = a-\u003etop;\n    ap = a-\u003ed;\n    j = i - (ap[i - 1] == 1);\n    if (a != r) {\n        if (bn_wexpand(r, j) == NULL)\n            return 0;\n        r-\u003eneg = a-\u003eneg;\n    }\n    rp = r-\u003ed;\n    t = ap[--i];\n    c = (t \u0026 1) ? BN_TBIT : 0;\n    if (t \u003e\u003e= 1)\n        rp[i] = t;\n    while (i \u003e 0) {\n        t = ap[--i];\n        rp[i] = ((t \u003e\u003e 1) \u0026 BN_MASK2) | c;\n        c = (t \u0026 1) ? BN_TBIT : 0;\n    }\n    r-\u003etop = j;\n    if (!r-\u003etop)\n        r-\u003eneg = 0; /* don't allow negative zero */\n    bn_check_top(r);\n    return 1;\n}","filepath":"crypto/bn/bn_shift.c","line_number":47,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1b"},"269912752":{"score":0.9335653,"function_name":"bn_lshift_fixed_top","code":"int bn_lshift_fixed_top(BIGNUM *r, const BIGNUM *a, int n)\n{\n    int i, nw;\n    unsigned int lb, rb;\n    BN_ULONG *t, *f;\n    BN_ULONG l, m, rmask = 0;\n\n    assert(n \u003e= 0);\n\n    bn_check_top(r);\n    bn_check_top(a);\n\n    nw = n / BN_BITS2;\n    if (bn_wexpand(r, a-\u003etop + nw + 1) == NULL)\n        return 0;\n\n    if (a-\u003etop != 0) {\n        lb = (unsigned int)n % BN_BITS2;\n        rb = BN_BITS2 - lb;\n        rb %= BN_BITS2;            /* say no to undefined behaviour */\n        rmask = (BN_ULONG)0 - rb;  /* rmask = 0 - (rb != 0) */\n        rmask |= rmask \u003e\u003e 8;\n        f = \u0026(a-\u003ed[0]);\n        t = \u0026(r-\u003ed[nw]);\n        l = f[a-\u003etop - 1];\n        t[a-\u003etop] = (l \u003e\u003e rb) \u0026 rmask;\n        for (i = a-\u003etop - 1; i \u003e 0; i--) {\n            m = l \u003c\u003c lb;\n            l = f[i - 1];\n            t[i] = (m | ((l \u003e\u003e rb) \u0026 rmask)) \u0026 BN_MASK2;\n        }\n        t[0] = (l \u003c\u003c lb) \u0026 BN_MASK2;\n    } else {\n        /* shouldn't happen, but formally required */\n        r-\u003ed[nw] = 0;\n    }\n    if (nw != 0)\n        memset(r-\u003ed, 0, sizeof(*t) * nw);\n\n    r-\u003eneg = a-\u003eneg;\n    r-\u003etop = a-\u003etop + nw + 1;\n    r-\u003eflags |= BN_FLG_FIXED_TOP;\n\n    return 1;\n}","filepath":"crypto/bn/bn_shift.c","line_number":107,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1b"},"269913072":{"score":0.93234193,"function_name":"bn_rshift_fixed_top","code":"int bn_rshift_fixed_top(BIGNUM *r, const BIGNUM *a, int n)\n{\n    int i, top, nw;\n    unsigned int lb, rb;\n    BN_ULONG *t, *f;\n    BN_ULONG l, m, mask;\n\n    bn_check_top(r);\n    bn_check_top(a);\n\n    assert(n \u003e= 0);\n\n    nw = n / BN_BITS2;\n    if (nw \u003e= a-\u003etop) {\n        /* shouldn't happen, but formally required */\n        BN_zero(r);\n        return 1;\n    }\n\n    rb = (unsigned int)n % BN_BITS2;\n    lb = BN_BITS2 - rb;\n    lb %= BN_BITS2;            /* say no to undefined behaviour */\n    mask = (BN_ULONG)0 - lb;   /* mask = 0 - (lb != 0) */\n    mask |= mask \u003e\u003e 8;\n    top = a-\u003etop - nw;\n    if (r != a \u0026\u0026 bn_wexpand(r, top) == NULL)\n        return 0;\n\n    t = \u0026(r-\u003ed[0]);\n    f = \u0026(a-\u003ed[nw]);\n    l = f[0];\n    for (i = 0; i \u003c top - 1; i++) {\n        m = f[i + 1];\n        t[i] = (l \u003e\u003e rb) | ((m \u003c\u003c lb) \u0026 mask);\n        l = m;\n    }\n    t[i] = l \u003e\u003e rb;\n\n    r-\u003eneg = a-\u003eneg;\n    r-\u003etop = top;\n    r-\u003eflags |= BN_FLG_FIXED_TOP;\n\n    return 1;\n}","filepath":"crypto/bn/bn_shift.c","line_number":214,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1b"},"269913344":{"score":0.78264827,"function_name":"BN_generate_dsa_nonce","code":"int BN_generate_dsa_nonce(BIGNUM *out, const BIGNUM *range,\n                          const BIGNUM *priv, const unsigned char *message,\n                          size_t message_len, BN_CTX *ctx)\n{\n    SHA512_CTX sha;\n    /*\n     * We use 512 bits of random data per iteration to ensure that we have at\n     * least |range| bits of randomness.\n     */\n    unsigned char random_bytes[64];\n    unsigned char digest[SHA512_DIGEST_LENGTH];\n    unsigned done, todo;\n    /* We generate |range|+8 bytes of random output. */\n    const unsigned num_k_bytes = BN_num_bytes(range) + 8;\n    unsigned char private_bytes[96];\n    unsigned char *k_bytes;\n    int ret = 0;\n\n    k_bytes = OPENSSL_malloc(num_k_bytes);\n    if (k_bytes == NULL)\n        goto err;\n\n    /* We copy |priv| into a local buffer to avoid exposing its length. */\n    if (BN_bn2binpad(priv, private_bytes, sizeof(private_bytes)) \u003c 0) {\n        /*\n         * No reasonable DSA or ECDSA key should have a private key this\n         * large and we don't handle this case in order to avoid leaking the\n         * length of the private key.\n         */\n        BNerr(BN_F_BN_GENERATE_DSA_NONCE, BN_R_PRIVATE_KEY_TOO_LARGE);\n        goto err;\n    }\n\n    for (done = 0; done \u003c num_k_bytes;) {\n        if (RAND_priv_bytes(random_bytes, sizeof(random_bytes)) != 1)\n            goto err;\n        SHA512_Init(\u0026sha);\n        SHA512_Update(\u0026sha, \u0026done, sizeof(done));\n        SHA512_Update(\u0026sha, private_bytes, sizeof(private_bytes));\n        SHA512_Update(\u0026sha, message, message_len);\n        SHA512_Update(\u0026sha, random_bytes, sizeof(random_bytes));\n        SHA512_Final(digest, \u0026sha);\n\n        todo = num_k_bytes - done;\n        if (todo \u003e SHA512_DIGEST_LENGTH)\n            todo = SHA512_DIGEST_LENGTH;\n        memcpy(k_bytes + done, digest, todo);\n        done += todo;\n    }\n\n    if (!BN_bin2bn(k_bytes, num_k_bytes, out))\n        goto err;\n    if (BN_mod(out, out, range, ctx) != 1)\n        goto err;\n    ret = 1;\n\n err:\n    OPENSSL_free(k_bytes);\n    OPENSSL_cleanse(private_bytes, sizeof(private_bytes));\n    return ret;\n}","filepath":"crypto/bn/bn_rand.c","line_number":205,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269913968":{"score":0.9195948,"function_name":"bnrand","code":"static int bnrand(BNRAND_FLAG flag, BIGNUM *rnd, int bits, int top, int bottom)\n{\n    unsigned char *buf = NULL;\n    int b, ret = 0, bit, bytes, mask;\n\n    if (bits == 0) {\n        if (top != BN_RAND_TOP_ANY || bottom != BN_RAND_BOTTOM_ANY)\n            goto toosmall;\n        BN_zero(rnd);\n        return 1;\n    }\n    if (bits \u003c 0 || (bits == 1 \u0026\u0026 top \u003e 0))\n        goto toosmall;\n\n    bytes = (bits + 7) / 8;\n    bit = (bits - 1) % 8;\n    mask = 0xff \u003c\u003c (bit + 1);\n\n    buf = OPENSSL_malloc(bytes);\n    if (buf == NULL) {\n        BNerr(BN_F_BNRAND, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    /* make a random number and set the top and bottom bits */\n    b = flag == NORMAL ? RAND_bytes(buf, bytes) : RAND_priv_bytes(buf, bytes);\n    if (b \u003c= 0)\n        goto err;\n\n    if (flag == TESTING) {\n        /*\n         * generate patterns that are more likely to trigger BN library bugs\n         */\n        int i;\n        unsigned char c;\n\n        for (i = 0; i \u003c bytes; i++) {\n            if (RAND_bytes(\u0026c, 1) \u003c= 0)\n                goto err;\n            if (c \u003e= 128 \u0026\u0026 i \u003e 0)\n                buf[i] = buf[i - 1];\n            else if (c \u003c 42)\n                buf[i] = 0;\n            else if (c \u003c 84)\n                buf[i] = 255;\n        }\n    }\n\n    if (top \u003e= 0) {\n        if (top) {\n            if (bit == 0) {\n                buf[0] = 1;\n                buf[1] |= 0x80;\n            } else {\n                buf[0] |= (3 \u003c\u003c (bit - 1));\n            }\n        } else {\n            buf[0] |= (1 \u003c\u003c bit);\n        }\n    }\n    buf[0] \u0026= ~mask;\n    if (bottom)                 /* set bottom bit if requested */\n        buf[bytes - 1] |= 1;\n    if (!BN_bin2bn(buf, bytes, rnd))\n        goto err;\n    ret = 1;\n err:\n    OPENSSL_clear_free(buf, bytes);\n    bn_check_top(rnd);\n    return ret;\n\ntoosmall:\n    BNerr(BN_F_BNRAND, BN_R_BITS_TOO_SMALL);\n    return 0;\n}","filepath":"crypto/bn/bn_rand.c","line_number":21,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269914416":{"score":0.9484154,"function_name":"bnrand_range","code":"static int bnrand_range(BNRAND_FLAG flag, BIGNUM *r, const BIGNUM *range)\n{\n    int n;\n    int count = 100;\n\n    if (range-\u003eneg || BN_is_zero(range)) {\n        BNerr(BN_F_BNRAND_RANGE, BN_R_INVALID_RANGE);\n        return 0;\n    }\n\n    n = BN_num_bits(range);     /* n \u003e 0 */\n\n    /* BN_is_bit_set(range, n - 1) always holds */\n\n    if (n == 1)\n        BN_zero(r);\n    else if (!BN_is_bit_set(range, n - 2) \u0026\u0026 !BN_is_bit_set(range, n - 3)) {\n        /*\n         * range = 100..._2, so 3*range (= 11..._2) is exactly one bit longer\n         * than range\n         */\n        do {\n            if (!bnrand(flag, r, n + 1, BN_RAND_TOP_ANY, BN_RAND_BOTTOM_ANY))\n                return 0;\n\n            /*\n             * If r \u003c 3*range, use r := r MOD range (which is either r, r -\n             * range, or r - 2*range). Otherwise, iterate once more. Since\n             * 3*range = 11..._2, each iteration succeeds with probability \u003e=\n             * .75.\n             */\n            if (BN_cmp(r, range) \u003e= 0) {\n                if (!BN_sub(r, r, range))\n                    return 0;\n                if (BN_cmp(r, range) \u003e= 0)\n                    if (!BN_sub(r, r, range))\n                        return 0;\n            }\n\n            if (!--count) {\n                BNerr(BN_F_BNRAND_RANGE, BN_R_TOO_MANY_ITERATIONS);\n                return 0;\n            }\n\n        }\n        while (BN_cmp(r, range) \u003e= 0);\n    } else {\n        do {\n            /* range = 11..._2  or  range = 101..._2 */\n            if (!bnrand(flag, r, n, BN_RAND_TOP_ANY, BN_RAND_BOTTOM_ANY))\n                return 0;\n\n            if (!--count) {\n                BNerr(BN_F_BNRAND_RANGE, BN_R_TOO_MANY_ITERATIONS);\n                return 0;\n            }\n        }\n        while (BN_cmp(r, range) \u003e= 0);\n    }\n\n    bn_check_top(r);\n    return 1;\n}","filepath":"crypto/bn/bn_rand.c","line_number":113,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269914800":{"score":0.6738571,"function_name":"BN_mod_exp","code":"int BN_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m,\n               BN_CTX *ctx)\n{\n    int ret;\n\n    bn_check_top(a);\n    bn_check_top(p);\n    bn_check_top(m);\n\n    /*-\n     * For even modulus  m = 2^k*m_odd, it might make sense to compute\n     * a^p mod m_odd  and  a^p mod 2^k  separately (with Montgomery\n     * exponentiation for the odd part), using appropriate exponent\n     * reductions, and combine the results using the CRT.\n     *\n     * For now, we use Montgomery only if the modulus is odd; otherwise,\n     * exponentiation using the reciprocal-based quick remaindering\n     * algorithm is used.\n     *\n     * (Timing obtained with expspeed.c [computations  a^p mod m\n     * where  a, p, m  are of the same length: 256, 512, 1024, 2048,\n     * 4096, 8192 bits], compared to the running time of the\n     * standard algorithm:\n     *\n     *   BN_mod_exp_mont   33 .. 40 %  [AMD K6-2, Linux, debug configuration]\n     *                     55 .. 77 %  [UltraSparc processor, but\n     *                                  debug-solaris-sparcv8-gcc conf.]\n     *\n     *   BN_mod_exp_recp   50 .. 70 %  [AMD K6-2, Linux, debug configuration]\n     *                     62 .. 118 % [UltraSparc, debug-solaris-sparcv8-gcc]\n     *\n     * On the Sparc, BN_mod_exp_recp was faster than BN_mod_exp_mont\n     * at 2048 and more bits, but at 512 and 1024 bits, it was\n     * slower even than the standard algorithm!\n     *\n     * \"Real\" timings [linux-elf, solaris-sparcv9-gcc configurations]\n     * should be obtained when the new Montgomery reduction code\n     * has been integrated into OpenSSL.)\n     */\n\n#define MONT_MUL_MOD\n#define MONT_EXP_WORD\n#define RECP_MUL_MOD\n\n#ifdef MONT_MUL_MOD\n    if (BN_is_odd(m)) {\n# ifdef MONT_EXP_WORD\n        if (a-\u003etop == 1 \u0026\u0026 !a-\u003eneg\n            \u0026\u0026 (BN_get_flags(p, BN_FLG_CONSTTIME) == 0)\n            \u0026\u0026 (BN_get_flags(a, BN_FLG_CONSTTIME) == 0)\n            \u0026\u0026 (BN_get_flags(m, BN_FLG_CONSTTIME) == 0)) {\n            BN_ULONG A = a-\u003ed[0];\n            ret = BN_mod_exp_mont_word(r, A, p, m, ctx, NULL);\n        } else\n# endif\n            ret = BN_mod_exp_mont(r, a, p, m, ctx, NULL);\n    } else\n#endif\n#ifdef RECP_MUL_MOD\n    {\n        ret = BN_mod_exp_recp(r, a, p, m, ctx);\n    }\n#else\n    {\n        ret = BN_mod_exp_simple(r, a, p, m, ctx);\n    }\n#endif\n\n    bn_check_top(r);\n    return ret;\n}","filepath":"crypto/bn/bn_exp.c","line_number":89,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1b"},"269914976":{"score":0.7979864,"function_name":"BN_mod_exp_mont","code":"int BN_mod_exp_mont(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p,\n                    const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)\n{\n    int i, j, bits, ret = 0, wstart, wend, window, wvalue;\n    int start = 1;\n    BIGNUM *d, *r;\n    const BIGNUM *aa;\n    /* Table of variables obtained from 'ctx' */\n    BIGNUM *val[TABLE_SIZE];\n    BN_MONT_CTX *mont = NULL;\n\n    if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0\n            || BN_get_flags(a, BN_FLG_CONSTTIME) != 0\n            || BN_get_flags(m, BN_FLG_CONSTTIME) != 0) {\n        return BN_mod_exp_mont_consttime(rr, a, p, m, ctx, in_mont);\n    }\n\n    bn_check_top(a);\n    bn_check_top(p);\n    bn_check_top(m);\n\n    if (!BN_is_odd(m)) {\n        BNerr(BN_F_BN_MOD_EXP_MONT, BN_R_CALLED_WITH_EVEN_MODULUS);\n        return 0;\n    }\n    bits = BN_num_bits(p);\n    if (bits == 0) {\n        /* x**0 mod 1, or x**0 mod -1 is still zero. */\n        if (BN_abs_is_word(m, 1)) {\n            ret = 1;\n            BN_zero(rr);\n        } else {\n            ret = BN_one(rr);\n        }\n        return ret;\n    }\n\n    BN_CTX_start(ctx);\n    d = BN_CTX_get(ctx);\n    r = BN_CTX_get(ctx);\n    val[0] = BN_CTX_get(ctx);\n    if (val[0] == NULL)\n        goto err;\n\n    /*\n     * If this is not done, things will break in the montgomery part\n     */\n\n    if (in_mont != NULL)\n        mont = in_mont;\n    else {\n        if ((mont = BN_MONT_CTX_new()) == NULL)\n            goto err;\n        if (!BN_MONT_CTX_set(mont, m, ctx))\n            goto err;\n    }\n\n    if (a-\u003eneg || BN_ucmp(a, m) \u003e= 0) {\n        if (!BN_nnmod(val[0], a, m, ctx))\n            goto err;\n        aa = val[0];\n    } else\n        aa = a;\n    if (!bn_to_mont_fixed_top(val[0], aa, mont, ctx))\n        goto err;               /* 1 */\n\n    window = BN_window_bits_for_exponent_size(bits);\n    if (window \u003e 1) {\n        if (!bn_mul_mont_fixed_top(d, val[0], val[0], mont, ctx))\n            goto err;           /* 2 */\n        j = 1 \u003c\u003c (window - 1);\n        for (i = 1; i \u003c j; i++) {\n            if (((val[i] = BN_CTX_get(ctx)) == NULL) ||\n                !bn_mul_mont_fixed_top(val[i], val[i - 1], d, mont, ctx))\n                goto err;\n        }\n    }\n\n    start = 1;                  /* This is used to avoid multiplication etc\n                                 * when there is only the value '1' in the\n                                 * buffer. */\n    wvalue = 0;                 /* The 'value' of the window */\n    wstart = bits - 1;          /* The top bit of the window */\n    wend = 0;                   /* The bottom bit of the window */\n\n#if 1                           /* by Shay Gueron's suggestion */\n    j = m-\u003etop;                 /* borrow j */\n    if (m-\u003ed[j - 1] \u0026 (((BN_ULONG)1) \u003c\u003c (BN_BITS2 - 1))) {\n        if (bn_wexpand(r, j) == NULL)\n            goto err;\n        /* 2^(top*BN_BITS2) - m */\n        r-\u003ed[0] = (0 - m-\u003ed[0]) \u0026 BN_MASK2;\n        for (i = 1; i \u003c j; i++)\n            r-\u003ed[i] = (~m-\u003ed[i]) \u0026 BN_MASK2;\n        r-\u003etop = j;\n        r-\u003eflags |= BN_FLG_FIXED_TOP;\n    } else\n#endif\n    if (!bn_to_mont_fixed_top(r, BN_value_one(), mont, ctx))\n        goto err;\n    for (;;) {\n        if (BN_is_bit_set(p, wstart) == 0) {\n            if (!start) {\n                if (!bn_mul_mont_fixed_top(r, r, r, mont, ctx))\n                    goto err;\n            }\n            if (wstart == 0)\n                break;\n            wstart--;\n            continue;\n        }\n        /*\n         * We now have wstart on a 'set' bit, we now need to work out how bit\n         * a window to do.  To do this we need to scan forward until the last\n         * set bit before the end of the window\n         */\n        j = wstart;\n        wvalue = 1;\n        wend = 0;\n        for (i = 1; i \u003c window; i++) {\n            if (wstart - i \u003c 0)\n                break;\n            if (BN_is_bit_set(p, wstart - i)) {\n                wvalue \u003c\u003c= (i - wend);\n                wvalue |= 1;\n                wend = i;\n            }\n        }\n\n        /* wend is the size of the current window */\n        j = wend + 1;\n        /* add the 'bytes above' */\n        if (!start)\n            for (i = 0; i \u003c j; i++) {\n                if (!bn_mul_mont_fixed_top(r, r, r, mont, ctx))\n                    goto err;\n            }\n\n        /* wvalue will be an odd number \u003c 2^window */\n        if (!bn_mul_mont_fixed_top(r, r, val[wvalue \u003e\u003e 1], mont, ctx))\n            goto err;\n\n        /* move the 'window' down further */\n        wstart -= wend + 1;\n        wvalue = 0;\n        start = 0;\n        if (wstart \u003c 0)\n            break;\n    }\n    /*\n     * Done with zero-padded intermediate BIGNUMs. Final BN_from_montgomery\n     * removes padding [if any] and makes return value suitable for public\n     * API consumer.\n     */\n#if defined(SPARC_T4_MONT)\n    if (OPENSSL_sparcv9cap_P[0] \u0026 (SPARCV9_VIS3 | SPARCV9_PREFER_FPU)) {\n        j = mont-\u003eN.top;        /* borrow j */\n        val[0]-\u003ed[0] = 1;       /* borrow val[0] */\n        for (i = 1; i \u003c j; i++)\n            val[0]-\u003ed[i] = 0;\n        val[0]-\u003etop = j;\n        if (!BN_mod_mul_montgomery(rr, r, val[0], mont, ctx))\n            goto err;\n    } else\n#endif\n    if (!BN_from_montgomery(rr, r, mont, ctx))\n        goto err;\n    ret = 1;\n err:\n    if (in_mont == NULL)\n        BN_MONT_CTX_free(mont);\n    BN_CTX_end(ctx);\n    bn_check_top(rr);\n    return ret;\n}","filepath":"crypto/bn/bn_exp.c","line_number":296,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1b"},"269918000":{"score":0.8806094,"function_name":"BN_mod_exp_mont_word","code":"int BN_mod_exp_mont_word(BIGNUM *rr, BN_ULONG a, const BIGNUM *p,\n                         const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)\n{\n    BN_MONT_CTX *mont = NULL;\n    int b, bits, ret = 0;\n    int r_is_one;\n    BN_ULONG w, next_w;\n    BIGNUM *r, *t;\n    BIGNUM *swap_tmp;\n#define BN_MOD_MUL_WORD(r, w, m) \\\n                (BN_mul_word(r, (w)) \u0026\u0026 \\\n                (/* BN_ucmp(r, (m)) \u003c 0 ? 1 :*/  \\\n                        (BN_mod(t, r, m, ctx) \u0026\u0026 (swap_tmp = r, r = t, t = swap_tmp, 1))))\n    /*\n     * BN_MOD_MUL_WORD is only used with 'w' large, so the BN_ucmp test is\n     * probably more overhead than always using BN_mod (which uses BN_copy if\n     * a similar test returns true).\n     */\n    /*\n     * We can use BN_mod and do not need BN_nnmod because our accumulator is\n     * never negative (the result of BN_mod does not depend on the sign of\n     * the modulus).\n     */\n#define BN_TO_MONTGOMERY_WORD(r, w, mont) \\\n                (BN_set_word(r, (w)) \u0026\u0026 BN_to_montgomery(r, r, (mont), ctx))\n\n    if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0\n            || BN_get_flags(m, BN_FLG_CONSTTIME) != 0) {\n        /* BN_FLG_CONSTTIME only supported by BN_mod_exp_mont() */\n        BNerr(BN_F_BN_MOD_EXP_MONT_WORD, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return 0;\n    }\n\n    bn_check_top(p);\n    bn_check_top(m);\n\n    if (!BN_is_odd(m)) {\n        BNerr(BN_F_BN_MOD_EXP_MONT_WORD, BN_R_CALLED_WITH_EVEN_MODULUS);\n        return 0;\n    }\n    if (m-\u003etop == 1)\n        a %= m-\u003ed[0];           /* make sure that 'a' is reduced */\n\n    bits = BN_num_bits(p);\n    if (bits == 0) {\n        /* x**0 mod 1, or x**0 mod -1 is still zero. */\n        if (BN_abs_is_word(m, 1)) {\n            ret = 1;\n            BN_zero(rr);\n        } else {\n            ret = BN_one(rr);\n        }\n        return ret;\n    }\n    if (a == 0) {\n        BN_zero(rr);\n        ret = 1;\n        return ret;\n    }\n\n    BN_CTX_start(ctx);\n    r = BN_CTX_get(ctx);\n    t = BN_CTX_get(ctx);\n    if (t == NULL)\n        goto err;\n\n    if (in_mont != NULL)\n        mont = in_mont;\n    else {\n        if ((mont = BN_MONT_CTX_new()) == NULL)\n            goto err;\n        if (!BN_MONT_CTX_set(mont, m, ctx))\n            goto err;\n    }\n\n    r_is_one = 1;               /* except for Montgomery factor */\n\n    /* bits-1 \u003e= 0 */\n\n    /* The result is accumulated in the product r*w. */\n    w = a;                      /* bit 'bits-1' of 'p' is always set */\n    for (b = bits - 2; b \u003e= 0; b--) {\n        /* First, square r*w. */\n        next_w = w * w;\n        if ((next_w / w) != w) { /* overflow */\n            if (r_is_one) {\n                if (!BN_TO_MONTGOMERY_WORD(r, w, mont))\n                    goto err;\n                r_is_one = 0;\n            } else {\n                if (!BN_MOD_MUL_WORD(r, w, m))\n                    goto err;\n            }\n            next_w = 1;\n        }\n        w = next_w;\n        if (!r_is_one) {\n            if (!BN_mod_mul_montgomery(r, r, r, mont, ctx))\n                goto err;\n        }\n\n        /* Second, multiply r*w by 'a' if exponent bit is set. */\n        if (BN_is_bit_set(p, b)) {\n            next_w = w * a;\n            if ((next_w / a) != w) { /* overflow */\n                if (r_is_one) {\n                    if (!BN_TO_MONTGOMERY_WORD(r, w, mont))\n                        goto err;\n                    r_is_one = 0;\n                } else {\n                    if (!BN_MOD_MUL_WORD(r, w, m))\n                        goto err;\n                }\n                next_w = a;\n            }\n            w = next_w;\n        }\n    }\n\n    /* Finally, set r:=r*w. */\n    if (w != 1) {\n        if (r_is_one) {\n            if (!BN_TO_MONTGOMERY_WORD(r, w, mont))\n                goto err;\n            r_is_one = 0;\n        } else {\n            if (!BN_MOD_MUL_WORD(r, w, m))\n                goto err;\n        }\n    }\n\n    if (r_is_one) {             /* can happen only if a == 1 */\n        if (!BN_one(rr))\n            goto err;\n    } else {\n        if (!BN_from_montgomery(rr, r, mont, ctx))\n            goto err;\n    }\n    ret = 1;\n err:\n    if (in_mont == NULL)\n        BN_MONT_CTX_free(mont);\n    BN_CTX_end(ctx);\n    bn_check_top(rr);\n    return ret;\n}","filepath":"crypto/bn/bn_exp.c","line_number":1129,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1b"},"269918944":{"score":0.8290765,"function_name":"BN_mod_exp_simple","code":"int BN_mod_exp_simple(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\n                      const BIGNUM *m, BN_CTX *ctx)\n{\n    int i, j, bits, ret = 0, wstart, wend, window, wvalue;\n    int start = 1;\n    BIGNUM *d;\n    /* Table of variables obtained from 'ctx' */\n    BIGNUM *val[TABLE_SIZE];\n\n    if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0\n            || BN_get_flags(a, BN_FLG_CONSTTIME) != 0\n            || BN_get_flags(m, BN_FLG_CONSTTIME) != 0) {\n        /* BN_FLG_CONSTTIME only supported by BN_mod_exp_mont() */\n        BNerr(BN_F_BN_MOD_EXP_SIMPLE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return 0;\n    }\n\n    bits = BN_num_bits(p);\n    if (bits == 0) {\n        /* x**0 mod 1, or x**0 mod -1 is still zero. */\n        if (BN_abs_is_word(m, 1)) {\n            ret = 1;\n            BN_zero(r);\n        } else {\n            ret = BN_one(r);\n        }\n        return ret;\n    }\n\n    BN_CTX_start(ctx);\n    d = BN_CTX_get(ctx);\n    val[0] = BN_CTX_get(ctx);\n    if (val[0] == NULL)\n        goto err;\n\n    if (!BN_nnmod(val[0], a, m, ctx))\n        goto err;               /* 1 */\n    if (BN_is_zero(val[0])) {\n        BN_zero(r);\n        ret = 1;\n        goto err;\n    }\n\n    window = BN_window_bits_for_exponent_size(bits);\n    if (window \u003e 1) {\n        if (!BN_mod_mul(d, val[0], val[0], m, ctx))\n            goto err;           /* 2 */\n        j = 1 \u003c\u003c (window - 1);\n        for (i = 1; i \u003c j; i++) {\n            if (((val[i] = BN_CTX_get(ctx)) == NULL) ||\n                !BN_mod_mul(val[i], val[i - 1], d, m, ctx))\n                goto err;\n        }\n    }\n\n    start = 1;                  /* This is used to avoid multiplication etc\n                                 * when there is only the value '1' in the\n                                 * buffer. */\n    wvalue = 0;                 /* The 'value' of the window */\n    wstart = bits - 1;          /* The top bit of the window */\n    wend = 0;                   /* The bottom bit of the window */\n\n    if (!BN_one(r))\n        goto err;\n\n    for (;;) {\n        if (BN_is_bit_set(p, wstart) == 0) {\n            if (!start)\n                if (!BN_mod_mul(r, r, r, m, ctx))\n                    goto err;\n            if (wstart == 0)\n                break;\n            wstart--;\n            continue;\n        }\n        /*\n         * We now have wstart on a 'set' bit, we now need to work out how bit\n         * a window to do.  To do this we need to scan forward until the last\n         * set bit before the end of the window\n         */\n        j = wstart;\n        wvalue = 1;\n        wend = 0;\n        for (i = 1; i \u003c window; i++) {\n            if (wstart - i \u003c 0)\n                break;\n            if (BN_is_bit_set(p, wstart - i)) {\n                wvalue \u003c\u003c= (i - wend);\n                wvalue |= 1;\n                wend = i;\n            }\n        }\n\n        /* wend is the size of the current window */\n        j = wend + 1;\n        /* add the 'bytes above' */\n        if (!start)\n            for (i = 0; i \u003c j; i++) {\n                if (!BN_mod_mul(r, r, r, m, ctx))\n                    goto err;\n            }\n\n        /* wvalue will be an odd number \u003c 2^window */\n        if (!BN_mod_mul(r, r, val[wvalue \u003e\u003e 1], m, ctx))\n            goto err;\n\n        /* move the 'window' down further */\n        wstart -= wend + 1;\n        wvalue = 0;\n        start = 0;\n        if (wstart \u003c 0)\n            break;\n    }\n    ret = 1;\n err:\n    BN_CTX_end(ctx);\n    bn_check_top(r);\n    return ret;\n}","filepath":"crypto/bn/bn_exp.c","line_number":1277,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1b"},"269919920":{"score":0.90402377,"function_name":"MOD_EXP_CTIME_COPY_FROM_PREBUF","code":"static int MOD_EXP_CTIME_COPY_FROM_PREBUF(BIGNUM *b, int top,\n                                          unsigned char *buf, int idx,\n                                          int window)\n{\n    int i, j;\n    int width = 1 \u003c\u003c window;\n    /*\n     * We declare table 'volatile' in order to discourage compiler\n     * from reordering loads from the table. Concern is that if\n     * reordered in specific manner loads might give away the\n     * information we are trying to conceal. Some would argue that\n     * compiler can reorder them anyway, but it can as well be\n     * argued that doing so would be violation of standard...\n     */\n    volatile BN_ULONG *table = (volatile BN_ULONG *)buf;\n\n    if (bn_wexpand(b, top) == NULL)\n        return 0;\n\n    if (window \u003c= 3) {\n        for (i = 0; i \u003c top; i++, table += width) {\n            BN_ULONG acc = 0;\n\n            for (j = 0; j \u003c width; j++) {\n                acc |= table[j] \u0026\n                       ((BN_ULONG)0 - (constant_time_eq_int(j,idx)\u00261));\n            }\n\n            b-\u003ed[i] = acc;\n        }\n    } else {\n        int xstride = 1 \u003c\u003c (window - 2);\n        BN_ULONG y0, y1, y2, y3;\n\n        i = idx \u003e\u003e (window - 2);        /* equivalent of idx / xstride */\n        idx \u0026= xstride - 1;             /* equivalent of idx % xstride */\n\n        y0 = (BN_ULONG)0 - (constant_time_eq_int(i,0)\u00261);\n        y1 = (BN_ULONG)0 - (constant_time_eq_int(i,1)\u00261);\n        y2 = (BN_ULONG)0 - (constant_time_eq_int(i,2)\u00261);\n        y3 = (BN_ULONG)0 - (constant_time_eq_int(i,3)\u00261);\n\n        for (i = 0; i \u003c top; i++, table += width) {\n            BN_ULONG acc = 0;\n\n            for (j = 0; j \u003c xstride; j++) {\n                acc |= ( (table[j + 0 * xstride] \u0026 y0) |\n                         (table[j + 1 * xstride] \u0026 y1) |\n                         (table[j + 2 * xstride] \u0026 y2) |\n                         (table[j + 3 * xstride] \u0026 y3) )\n                       \u0026 ((BN_ULONG)0 - (constant_time_eq_int(j,idx)\u00261));\n            }\n\n            b-\u003ed[i] = acc;\n        }\n    }\n\n    b-\u003etop = top;\n    b-\u003eflags |= BN_FLG_FIXED_TOP;\n    return 1;\n}","filepath":"crypto/bn/bn_exp.c","line_number":516,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1b"},"269920448":{"score":0.9234013,"function_name":"MOD_EXP_CTIME_COPY_TO_PREBUF","code":"static int MOD_EXP_CTIME_COPY_TO_PREBUF(const BIGNUM *b, int top,\n                                        unsigned char *buf, int idx,\n                                        int window)\n{\n    int i, j;\n    int width = 1 \u003c\u003c window;\n    BN_ULONG *table = (BN_ULONG *)buf;\n\n    if (top \u003e b-\u003etop)\n        top = b-\u003etop;           /* this works because 'buf' is explicitly\n                                 * zeroed */\n    for (i = 0, j = idx; i \u003c top; i++, j += width) {\n        table[j] = b-\u003ed[i];\n    }\n\n    return 1;\n}","filepath":"crypto/bn/bn_exp.c","line_number":498,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1b"},"269920528":{"score":0.8635743,"function_name":"bn_get_bits","code":"static BN_ULONG bn_get_bits(const BIGNUM *a, int bitpos)\n{\n    BN_ULONG ret = 0;\n    int wordpos;\n\n    wordpos = bitpos / BN_BITS2;\n    bitpos %= BN_BITS2;\n    if (wordpos \u003e= 0 \u0026\u0026 wordpos \u003c a-\u003etop) {\n        ret = a-\u003ed[wordpos] \u0026 BN_MASK2;\n        if (bitpos) {\n            ret \u003e\u003e= bitpos;\n            if (++wordpos \u003c a-\u003etop)\n                ret |= a-\u003ed[wordpos] \u003c\u003c (BN_BITS2 - bitpos);\n        }\n    }\n\n    return ret \u0026 BN_MASK2;\n}","filepath":"crypto/bn/bn_exp.c","line_number":472,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1b"},"269920752":{"score":0.9238595,"function_name":"OBJ_bsearch_ex_","code":"const void *OBJ_bsearch_ex_(const void *key, const void *base_, int num,\n                            int size,\n                            int (*cmp) (const void *, const void *),\n                            int flags)\n{\n    const char *base = base_;\n    int l, h, i = 0, c = 0;\n    const char *p = NULL;\n\n    if (num == 0)\n        return (NULL);\n    l = 0;\n    h = num;\n    while (l \u003c h) {\n        i = (l + h) / 2;\n        p = \u0026(base[i * size]);\n        c = (*cmp) (key, p);\n        if (c \u003c 0)\n            h = i;\n        else if (c \u003e 0)\n            l = i + 1;\n        else\n            break;\n    }\n#ifdef CHARSET_EBCDIC\n    /*\n     * THIS IS A KLUDGE - Because the *_obj is sorted in ASCII order, and I\n     * don't have perl (yet), we revert to a *LINEAR* search when the object\n     * wasn't found in the binary search.\n     */\n    if (c != 0) {\n        for (i = 0; i \u003c num; ++i) {\n            p = \u0026(base[i * size]);\n            c = (*cmp) (key, p);\n            if (c == 0 || (c \u003c 0 \u0026\u0026 (flags \u0026 OBJ_BSEARCH_VALUE_ON_NOMATCH)))\n                return p;\n        }\n    }\n#endif\n    if (c != 0 \u0026\u0026 !(flags \u0026 OBJ_BSEARCH_VALUE_ON_NOMATCH))\n        p = NULL;\n    else if (c == 0 \u0026\u0026 (flags \u0026 OBJ_BSEARCH_FIRST_VALUE_ON_MATCH)) {\n        while (i \u003e 0 \u0026\u0026 (*cmp) (key, \u0026(base[(i - 1) * size])) == 0)\n            i--;\n        p = \u0026(base[i * size]);\n    }\n    return (p);\n}","filepath":"crypto/objects/obj_dat.c","line_number":586,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0g"},"269920928":{"score":0.6648551,"function_name":"OBJ_create","code":"int OBJ_create(const char *oid, const char *sn, const char *ln)\n{\n    ASN1_OBJECT *tmpoid = NULL;\n    int ok = 0;\n\n    /* Check to see if short or long name already present */\n    if ((sn != NULL \u0026\u0026 OBJ_sn2nid(sn) != NID_undef)\n            || (ln != NULL \u0026\u0026 OBJ_ln2nid(ln) != NID_undef)) {\n        OBJerr(OBJ_F_OBJ_CREATE, OBJ_R_OID_EXISTS);\n        return 0;\n    }\n\n    /* Convert numerical OID string to an ASN1_OBJECT structure */\n    tmpoid = OBJ_txt2obj(oid, 1);\n    if (tmpoid == NULL)\n        return 0;\n\n    /* If NID is not NID_undef then object already exists */\n    if (OBJ_obj2nid(tmpoid) != NID_undef) {\n        OBJerr(OBJ_F_OBJ_CREATE, OBJ_R_OID_EXISTS);\n        goto err;\n    }\n\n    tmpoid-\u003enid = OBJ_new_nid(1);\n    tmpoid-\u003esn = (char *)sn;\n    tmpoid-\u003eln = (char *)ln;\n\n    ok = OBJ_add_object(tmpoid);\n\n    tmpoid-\u003esn = NULL;\n    tmpoid-\u003eln = NULL;\n\n err:\n    ASN1_OBJECT_free(tmpoid);\n    return ok;\n}","filepath":"crypto/objects/obj_dat.c","line_number":682,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0g"},"269921552":{"score":0.791489,"function_name":"OBJ_ln2nid","code":"int OBJ_ln2nid(const char *s)\n{\n    ASN1_OBJECT o;\n    const ASN1_OBJECT *oo = \u0026o;\n    ADDED_OBJ ad, *adp;\n    const unsigned int *op;\n\n    o.ln = s;\n    if (added != NULL) {\n        ad.type = ADDED_LNAME;\n        ad.obj = \u0026o;\n        adp = lh_ADDED_OBJ_retrieve(added, \u0026ad);\n        if (adp != NULL)\n            return (adp-\u003eobj-\u003enid);\n    }\n    op = OBJ_bsearch_ln(\u0026oo, ln_objs, NUM_LN);\n    if (op == NULL)\n        return (NID_undef);\n    return (nid_objs[*op].nid);\n}","filepath":"crypto/objects/obj_dat.c","line_number":538,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0g"},"269922112":{"score":0.89483726,"function_name":"OBJ_nid2ln","code":"const char *OBJ_nid2ln(int n)\n{\n    ADDED_OBJ ad, *adp;\n    ASN1_OBJECT ob;\n\n    if ((n \u003e= 0) \u0026\u0026 (n \u003c NUM_NID)) {\n        if ((n != NID_undef) \u0026\u0026 (nid_objs[n].nid == NID_undef)) {\n            OBJerr(OBJ_F_OBJ_NID2LN, OBJ_R_UNKNOWN_NID);\n            return (NULL);\n        }\n        return (nid_objs[n].ln);\n    } else if (added == NULL)\n        return (NULL);\n    else {\n        ad.type = ADDED_NID;\n        ad.obj = \u0026ob;\n        ob.nid = n;\n        adp = lh_ADDED_OBJ_retrieve(added, \u0026ad);\n        if (adp != NULL)\n            return (adp-\u003eobj-\u003eln);\n        else {\n            OBJerr(OBJ_F_OBJ_NID2LN, OBJ_R_UNKNOWN_NID);\n            return (NULL);\n        }\n    }\n}","filepath":"crypto/objects/obj_dat.c","line_number":274,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0g"},"269922272":{"score":0.8275305,"function_name":"OBJ_obj2nid","code":"int OBJ_obj2nid(const ASN1_OBJECT *a)\n{\n    const unsigned int *op;\n    ADDED_OBJ ad, *adp;\n\n    if (a == NULL)\n        return (NID_undef);\n    if (a-\u003enid != 0)\n        return (a-\u003enid);\n\n    if (a-\u003elength == 0)\n        return NID_undef;\n\n    if (added != NULL) {\n        ad.type = ADDED_DATA;\n        ad.obj = (ASN1_OBJECT *)a; /* XXX: ugly but harmless */\n        adp = lh_ADDED_OBJ_retrieve(added, \u0026ad);\n        if (adp != NULL)\n            return (adp-\u003eobj-\u003enid);\n    }\n    op = OBJ_bsearch_obj(\u0026a, obj_objs, NUM_OBJ);\n    if (op == NULL)\n        return (NID_undef);\n    return (nid_objs[*op].nid);\n}","filepath":"crypto/objects/obj_dat.c","line_number":317,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0g"},"269922608":{"score":0.7412368,"function_name":"OBJ_obj2txt","code":"int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name)\n{\n    int i, n = 0, len, nid, first, use_bn;\n    BIGNUM *bl;\n    unsigned long l;\n    const unsigned char *p;\n    char tbuf[DECIMAL_SIZE(i) + DECIMAL_SIZE(l) + 2];\n\n    /* Ensure that, at every state, |buf| is NUL-terminated. */\n    if (buf \u0026\u0026 buf_len \u003e 0)\n        buf[0] = '\\0';\n\n    if ((a == NULL) || (a-\u003edata == NULL))\n        return (0);\n\n    if (!no_name \u0026\u0026 (nid = OBJ_obj2nid(a)) != NID_undef) {\n        const char *s;\n        s = OBJ_nid2ln(nid);\n        if (s == NULL)\n            s = OBJ_nid2sn(nid);\n        if (s) {\n            if (buf)\n                OPENSSL_strlcpy(buf, s, buf_len);\n            n = strlen(s);\n            return n;\n        }\n    }\n\n    len = a-\u003elength;\n    p = a-\u003edata;\n\n    first = 1;\n    bl = NULL;\n\n    while (len \u003e 0) {\n        l = 0;\n        use_bn = 0;\n        for (;;) {\n            unsigned char c = *p++;\n            len--;\n            if ((len == 0) \u0026\u0026 (c \u0026 0x80))\n                goto err;\n            if (use_bn) {\n                if (!BN_add_word(bl, c \u0026 0x7f))\n                    goto err;\n            } else\n                l |= c \u0026 0x7f;\n            if (!(c \u0026 0x80))\n                break;\n            if (!use_bn \u0026\u0026 (l \u003e (ULONG_MAX \u003e\u003e 7L))) {\n                if (bl == NULL \u0026\u0026 (bl = BN_new()) == NULL)\n                    goto err;\n                if (!BN_set_word(bl, l))\n                    goto err;\n                use_bn = 1;\n            }\n            if (use_bn) {\n                if (!BN_lshift(bl, bl, 7))\n                    goto err;\n            } else\n                l \u003c\u003c= 7L;\n        }\n\n        if (first) {\n            first = 0;\n            if (l \u003e= 80) {\n                i = 2;\n                if (use_bn) {\n                    if (!BN_sub_word(bl, 80))\n                        goto err;\n                } else\n                    l -= 80;\n            } else {\n                i = (int)(l / 40);\n                l -= (long)(i * 40);\n            }\n            if (buf \u0026\u0026 (buf_len \u003e 1)) {\n                *buf++ = i + '0';\n                *buf = '\\0';\n                buf_len--;\n            }\n            n++;\n        }\n\n        if (use_bn) {\n            char *bndec;\n            bndec = BN_bn2dec(bl);\n            if (!bndec)\n                goto err;\n            i = strlen(bndec);\n            if (buf) {\n                if (buf_len \u003e 1) {\n                    *buf++ = '.';\n                    *buf = '\\0';\n                    buf_len--;\n                }\n                OPENSSL_strlcpy(buf, bndec, buf_len);\n                if (i \u003e buf_len) {\n                    buf += buf_len;\n                    buf_len = 0;\n                } else {\n                    buf += i;\n                    buf_len -= i;\n                }\n            }\n            n++;\n            n += i;\n            OPENSSL_free(bndec);\n        } else {\n            BIO_snprintf(tbuf, sizeof tbuf, \".%lu\", l);\n            i = strlen(tbuf);\n            if (buf \u0026\u0026 (buf_len \u003e 0)) {\n                OPENSSL_strlcpy(buf, tbuf, buf_len);\n                if (i \u003e buf_len) {\n                    buf += buf_len;\n                    buf_len = 0;\n                } else {\n                    buf += i;\n                    buf_len -= i;\n                }\n            }\n            n += i;\n            l = 0;\n        }\n    }\n\n    BN_free(bl);\n    return n;\n\n err:\n    BN_free(bl);\n    return -1;\n}","filepath":"crypto/objects/obj_dat.c","line_number":394,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0g"},"269923632":{"score":0.76914245,"function_name":"OBJ_sn2nid","code":"int OBJ_sn2nid(const char *s)\n{\n    ASN1_OBJECT o;\n    const ASN1_OBJECT *oo = \u0026o;\n    ADDED_OBJ ad, *adp;\n    const unsigned int *op;\n\n    o.sn = s;\n    if (added != NULL) {\n        ad.type = ADDED_SNAME;\n        ad.obj = \u0026o;\n        adp = lh_ADDED_OBJ_retrieve(added, \u0026ad);\n        if (adp != NULL)\n            return (adp-\u003eobj-\u003enid);\n    }\n    op = OBJ_bsearch_sn(\u0026oo, sn_objs, NUM_SN);\n    if (op == NULL)\n        return (NID_undef);\n    return (nid_objs[*op].nid);\n}","filepath":"crypto/objects/obj_dat.c","line_number":559,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0g"},"269923888":{"score":0.83134955,"function_name":"OBJ_txt2obj","code":"ASN1_OBJECT *OBJ_txt2obj(const char *s, int no_name)\n{\n    int nid = NID_undef;\n    ASN1_OBJECT *op = NULL;\n    unsigned char *buf;\n    unsigned char *p;\n    const unsigned char *cp;\n    int i, j;\n\n    if (!no_name) {\n        if (((nid = OBJ_sn2nid(s)) != NID_undef) ||\n            ((nid = OBJ_ln2nid(s)) != NID_undef))\n            return OBJ_nid2obj(nid);\n    }\n\n    /* Work out size of content octets */\n    i = a2d_ASN1_OBJECT(NULL, 0, s, -1);\n    if (i \u003c= 0) {\n        /* Don't clear the error */\n        /*\n         * ERR_clear_error();\n         */\n        return NULL;\n    }\n    /* Work out total size */\n    j = ASN1_object_size(0, i, V_ASN1_OBJECT);\n    if (j \u003c 0)\n        return NULL;\n\n    if ((buf = OPENSSL_malloc(j)) == NULL)\n        return NULL;\n\n    p = buf;\n    /* Write out tag+length */\n    ASN1_put_object(\u0026p, 0, i, V_ASN1_OBJECT, V_ASN1_UNIVERSAL);\n    /* Write out contents */\n    a2d_ASN1_OBJECT(p, i, s, -1);\n\n    cp = buf;\n    op = d2i_ASN1_OBJECT(NULL, \u0026cp, j);\n    OPENSSL_free(buf);\n    return op;\n}","filepath":"crypto/objects/obj_dat.c","line_number":350,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0g"},"269924864":{"score":0.92779684,"function_name":"obj_cleanup_int","code":"void obj_cleanup_int(void)\n{\n    if (added == NULL)\n        return;\n    lh_ADDED_OBJ_set_down_load(added, 0);\n    lh_ADDED_OBJ_doall(added, cleanup1_doall); /* zero counters */\n    lh_ADDED_OBJ_doall(added, cleanup2_doall); /* set counters */\n    lh_ADDED_OBJ_doall(added, cleanup3_doall); /* free objects */\n    lh_ADDED_OBJ_free(added);\n    added = NULL;\n}","filepath":"crypto/objects/obj_dat.c","line_number":153,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0g"},"269924960":{"score":0.92277545,"function_name":"bn_compute_wNAF","code":"signed char *bn_compute_wNAF(const BIGNUM *scalar, int w, size_t *ret_len)\n{\n    int window_val;\n    signed char *r = NULL;\n    int sign = 1;\n    int bit, next_bit, mask;\n    size_t len = 0, j;\n\n    if (BN_is_zero(scalar)) {\n        r = OPENSSL_malloc(1);\n        if (r == NULL) {\n            BNerr(BN_F_BN_COMPUTE_WNAF, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        r[0] = 0;\n        *ret_len = 1;\n        return r;\n    }\n\n    if (w \u003c= 0 || w \u003e 7) {      /* 'signed char' can represent integers with\n                                 * absolute values less than 2^7 */\n        BNerr(BN_F_BN_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n    bit = 1 \u003c\u003c w;               /* at most 128 */\n    next_bit = bit \u003c\u003c 1;        /* at most 256 */\n    mask = next_bit - 1;        /* at most 255 */\n\n    if (BN_is_negative(scalar)) {\n        sign = -1;\n    }\n\n    if (scalar-\u003ed == NULL || scalar-\u003etop == 0) {\n        BNerr(BN_F_BN_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    len = BN_num_bits(scalar);\n    r = OPENSSL_malloc(len + 1); /*\n                                  * Modified wNAF may be one digit longer than binary representation\n                                  * (*ret_len will be set to the actual length, i.e. at most\n                                  * BN_num_bits(scalar) + 1)\n                                  */\n    if (r == NULL) {\n        BNerr(BN_F_BN_COMPUTE_WNAF, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    window_val = scalar-\u003ed[0] \u0026 mask;\n    j = 0;\n    while ((window_val != 0) || (j + w + 1 \u003c len)) { /* if j+w+1 \u003e= len,\n                                                      * window_val will not\n                                                      * increase */\n        int digit = 0;\n\n        /* 0 \u003c= window_val \u003c= 2^(w+1) */\n\n        if (window_val \u0026 1) {\n            /* 0 \u003c window_val \u003c 2^(w+1) */\n\n            if (window_val \u0026 bit) {\n                digit = window_val - next_bit; /* -2^w \u003c digit \u003c 0 */\n\n#if 1                           /* modified wNAF */\n                if (j + w + 1 \u003e= len) {\n                    /*\n                     * Special case for generating modified wNAFs:\n                     * no new bits will be added into window_val,\n                     * so using a positive digit here will decrease\n                     * the total length of the representation\n                     */\n\n                    digit = window_val \u0026 (mask \u003e\u003e 1); /* 0 \u003c digit \u003c 2^w */\n                }\n#endif\n            } else {\n                digit = window_val; /* 0 \u003c digit \u003c 2^w */\n            }\n\n            if (digit \u003c= -bit || digit \u003e= bit || !(digit \u0026 1)) {\n                BNerr(BN_F_BN_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n\n            window_val -= digit;\n\n            /*\n             * now window_val is 0 or 2^(w+1) in standard wNAF generation;\n             * for modified window NAFs, it may also be 2^w\n             */\n            if (window_val != 0 \u0026\u0026 window_val != next_bit\n                \u0026\u0026 window_val != bit) {\n                BNerr(BN_F_BN_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n        }\n\n        r[j++] = sign * digit;\n\n        window_val \u003e\u003e= 1;\n        window_val += bit * BN_is_bit_set(scalar, j + w);\n\n        if (window_val \u003e next_bit) {\n            BNerr(BN_F_BN_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n    }\n\n    if (j \u003e len + 1) {\n        BNerr(BN_F_BN_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n    *ret_len = j;\n    return r;\n\n err:\n    OPENSSL_free(r);\n    return NULL;\n}","filepath":"crypto/bn/bn_intern.c","line_number":22,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0i"},"269925440":{"score":0.9173623,"function_name":"bn_copy_words","code":"int bn_copy_words(BN_ULONG *out, const BIGNUM *in, int size)\n{\n    if (in-\u003etop \u003e size)\n        return 0;\n\n    memset(out, 0, sizeof(*out) * size);\n    if (in-\u003ed != NULL)\n        memcpy(out, in-\u003ed, sizeof(*out) * in-\u003etop);\n    return 1;\n}","filepath":"crypto/bn/bn_intern.c","line_number":164,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0i"},"269925552":{"score":0.8833586,"function_name":"bn_set_words","code":"int bn_set_words(BIGNUM *a, const BN_ULONG *words, int num_words)\n{\n    if (bn_wexpand(a, num_words) == NULL) {\n        BNerr(BN_F_BN_SET_WORDS, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n\n    memcpy(a-\u003ed, words, sizeof(BN_ULONG) * num_words);\n    a-\u003etop = num_words;\n    bn_correct_top(a);\n    return 1;\n}","filepath":"crypto/bn/bn_intern.c","line_number":193,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0i"},"269925760":{"score":0.93479145,"function_name":"RSA_padding_add_PKCS1_type_2","code":"int RSA_padding_add_PKCS1_type_2(unsigned char *to, int tlen,\n                                 const unsigned char *from, int flen)\n{\n    int i, j;\n    unsigned char *p;\n\n    if (flen \u003e (tlen - RSA_PKCS1_PADDING_SIZE)) {\n        RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_2,\n               RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);\n        return 0;\n    }\n\n    p = (unsigned char *)to;\n\n    *(p++) = 0;\n    *(p++) = 2;                 /* Public Key BT (Block Type) */\n\n    /* pad out with non-zero random data */\n    j = tlen - 3 - flen;\n\n    if (RAND_bytes(p, j) \u003c= 0)\n        return 0;\n    for (i = 0; i \u003c j; i++) {\n        if (*p == '\\0')\n            do {\n                if (RAND_bytes(p, 1) \u003c= 0)\n                    return 0;\n            } while (*p == '\\0');\n        p++;\n    }\n\n    *(p++) = '\\0';\n\n    memcpy(p, from, (unsigned int)flen);\n    return 1;\n}","filepath":"libs-ext/openssl/crypto/rsa/rsa_pk1.c","line_number":117,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269925920":{"score":0.9281047,"function_name":"RSA_padding_check_PKCS1_type_1","code":"int RSA_padding_check_PKCS1_type_1(unsigned char *to, int tlen,\n                                   const unsigned char *from, int flen,\n                                   int num)\n{\n    int i, j;\n    const unsigned char *p;\n\n    p = from;\n\n    /*\n     * The format is\n     * 00 || 01 || PS || 00 || D\n     * PS - padding string, at least 8 bytes of FF\n     * D  - data.\n     */\n\n    if (num \u003c RSA_PKCS1_PADDING_SIZE)\n        return -1;\n\n    /* Accept inputs with and without the leading 0-byte. */\n    if (num == flen) {\n        if ((*p++) != 0x00) {\n            RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,\n                   RSA_R_INVALID_PADDING);\n            return -1;\n        }\n        flen--;\n    }\n\n    if ((num != (flen + 1)) || (*(p++) != 0x01)) {\n        RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,\n               RSA_R_BLOCK_TYPE_IS_NOT_01);\n        return -1;\n    }\n\n    /* scan over padding data */\n    j = flen - 1;               /* one for type. */\n    for (i = 0; i \u003c j; i++) {\n        if (*p != 0xff) {       /* should decrypt to 0xff */\n            if (*p == 0) {\n                p++;\n                break;\n            } else {\n                RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,\n                       RSA_R_BAD_FIXED_HEADER_DECRYPT);\n                return -1;\n            }\n        }\n        p++;\n    }\n\n    if (i == j) {\n        RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,\n               RSA_R_NULL_BEFORE_BLOCK_MISSING);\n        return -1;\n    }\n\n    if (i \u003c 8) {\n        RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,\n               RSA_R_BAD_PAD_BYTE_COUNT);\n        return -1;\n    }\n    i++;                        /* Skip over the '\\0' */\n    j -= i;\n    if (j \u003e tlen) {\n        RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1, RSA_R_DATA_TOO_LARGE);\n        return -1;\n    }\n    memcpy(to, p, (unsigned int)j);\n\n    return j;\n}","filepath":"libs-ext/openssl/crypto/rsa/rsa_pk1.c","line_number":44,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269926208":{"score":0.91264886,"function_name":"RSA_padding_check_PKCS1_type_2","code":"int RSA_padding_check_PKCS1_type_2(unsigned char *to, int tlen,\n                                   const unsigned char *from, int flen,\n                                   int num)\n{\n    int i;\n    /* |em| is the encoded message, zero-padded to exactly |num| bytes */\n    unsigned char *em = NULL;\n    unsigned int good, found_zero_byte, mask;\n    int zero_index = 0, msg_index, mlen = -1;\n\n    if (tlen \u003c= 0 || flen \u003c= 0)\n        return -1;\n\n    /*\n     * PKCS#1 v1.5 decryption. See \"PKCS #1 v2.2: RSA Cryptography Standard\",\n     * section 7.2.2.\n     */\n\n    if (flen \u003e num || num \u003c RSA_PKCS1_PADDING_SIZE) {\n        RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2,\n               RSA_R_PKCS_DECODING_ERROR);\n        return -1;\n    }\n\n    em = OPENSSL_malloc(num);\n    if (em == NULL) {\n        RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2, ERR_R_MALLOC_FAILURE);\n        return -1;\n    }\n    /*\n     * Caller is encouraged to pass zero-padded message created with\n     * BN_bn2binpad. Trouble is that since we can't read out of |from|'s\n     * bounds, it's impossible to have an invariant memory access pattern\n     * in case |from| was not zero-padded in advance.\n     */\n    for (from += flen, em += num, i = 0; i \u003c num; i++) {\n        mask = ~constant_time_is_zero(flen);\n        flen -= 1 \u0026 mask;\n        from -= 1 \u0026 mask;\n        *--em = *from \u0026 mask;\n    }\n\n    good = constant_time_is_zero(em[0]);\n    good \u0026= constant_time_eq(em[1], 2);\n\n    /* scan over padding data */\n    found_zero_byte = 0;\n    for (i = 2; i \u003c num; i++) {\n        unsigned int equals0 = constant_time_is_zero(em[i]);\n\n        zero_index = constant_time_select_int(~found_zero_byte \u0026 equals0,\n                                              i, zero_index);\n        found_zero_byte |= equals0;\n    }\n\n    /*\n     * PS must be at least 8 bytes long, and it starts two bytes into |em|.\n     * If we never found a 0-byte, then |zero_index| is 0 and the check\n     * also fails.\n     */\n    good \u0026= constant_time_ge(zero_index, 2 + 8);\n\n    /*\n     * Skip the zero byte. This is incorrect if we never found a zero-byte\n     * but in this case we also do not copy the message out.\n     */\n    msg_index = zero_index + 1;\n    mlen = num - msg_index;\n\n    /*\n     * For good measure, do this check in constant time as well.\n     */\n    good \u0026= constant_time_ge(tlen, mlen);\n\n    /*\n     * Move the result in-place by |num|-RSA_PKCS1_PADDING_SIZE-|mlen| bytes to the left.\n     * Then if |good| move |mlen| bytes from |em|+RSA_PKCS1_PADDING_SIZE to |to|.\n     * Otherwise leave |to| unchanged.\n     * Copy the memory back in a way that does not reveal the size of\n     * the data being copied via a timing side channel. This requires copying\n     * parts of the buffer multiple times based on the bits set in the real\n     * length. Clear bits do a non-copy with identical access pattern.\n     * The loop below has overall complexity of O(N*log(N)).\n     */\n    tlen = constant_time_select_int(constant_time_lt(num - RSA_PKCS1_PADDING_SIZE, tlen),\n                                    num - RSA_PKCS1_PADDING_SIZE, tlen);\n    for (msg_index = 1; msg_index \u003c num - RSA_PKCS1_PADDING_SIZE; msg_index \u003c\u003c= 1) {\n        mask = ~constant_time_eq(msg_index \u0026 (num - RSA_PKCS1_PADDING_SIZE - mlen), 0);\n        for (i = RSA_PKCS1_PADDING_SIZE; i \u003c num - msg_index; i++)\n            em[i] = constant_time_select_8(mask, em[i + msg_index], em[i]);\n    }\n    for (i = 0; i \u003c tlen; i++) {\n        mask = good \u0026 constant_time_lt(i, mlen);\n        to[i] = constant_time_select_8(mask, em[i + RSA_PKCS1_PADDING_SIZE], to[i]);\n    }\n\n    OPENSSL_clear_free(em, num);\n    RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2, RSA_R_PKCS_DECODING_ERROR);\n    err_clear_last_constant_time(1 \u0026 good);\n\n    return constant_time_select_int(good, mlen, -1);\n}","filepath":"libs-ext/openssl/crypto/rsa/rsa_pk1.c","line_number":154,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"269927008":{"score":0.7449762,"function_name":"PKCS1_MGF1","code":"int PKCS1_MGF1(unsigned char *mask, long len,\n               const unsigned char *seed, long seedlen, const EVP_MD *dgst)\n{\n    long i, outlen = 0;\n    unsigned char cnt[4];\n    EVP_MD_CTX *c = EVP_MD_CTX_new();\n    unsigned char md[EVP_MAX_MD_SIZE];\n    int mdlen;\n    int rv = -1;\n\n    if (c == NULL)\n        goto err;\n    mdlen = EVP_MD_size(dgst);\n    if (mdlen \u003c 0)\n        goto err;\n    for (i = 0; outlen \u003c len; i++) {\n        cnt[0] = (unsigned char)((i \u003e\u003e 24) \u0026 255);\n        cnt[1] = (unsigned char)((i \u003e\u003e 16) \u0026 255);\n        cnt[2] = (unsigned char)((i \u003e\u003e 8)) \u0026 255;\n        cnt[3] = (unsigned char)(i \u0026 255);\n        if (!EVP_DigestInit_ex(c, dgst, NULL)\n            || !EVP_DigestUpdate(c, seed, seedlen)\n            || !EVP_DigestUpdate(c, cnt, 4))\n            goto err;\n        if (outlen + mdlen \u003c= len) {\n            if (!EVP_DigestFinal_ex(c, mask + outlen, NULL))\n                goto err;\n            outlen += mdlen;\n        } else {\n            if (!EVP_DigestFinal_ex(c, md, NULL))\n                goto err;\n            memcpy(mask + outlen, md, len - outlen);\n            outlen = len;\n        }\n    }\n    rv = 0;\n err:\n    OPENSSL_cleanse(md, sizeof(md));\n    EVP_MD_CTX_free(c);\n    return rv;\n}","filepath":"crypto/rsa/rsa_oaep.c","line_number":273,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269927424":{"score":0.7557144,"function_name":"RSA_padding_add_PKCS1_OAEP_mgf1","code":"int RSA_padding_add_PKCS1_OAEP_mgf1(unsigned char *to, int tlen,\n                                    const unsigned char *from, int flen,\n                                    const unsigned char *param, int plen,\n                                    const EVP_MD *md, const EVP_MD *mgf1md)\n{\n    int rv = 0;\n    int i, emlen = tlen - 1;\n    unsigned char *db, *seed;\n    unsigned char *dbmask = NULL;\n    unsigned char seedmask[EVP_MAX_MD_SIZE];\n    int mdlen, dbmask_len = 0;\n\n    if (md == NULL)\n        md = EVP_sha1();\n    if (mgf1md == NULL)\n        mgf1md = md;\n\n    mdlen = EVP_MD_size(md);\n\n    if (flen \u003e emlen - 2 * mdlen - 1) {\n        RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP_MGF1,\n               RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);\n        return 0;\n    }\n\n    if (emlen \u003c 2 * mdlen + 1) {\n        RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP_MGF1,\n               RSA_R_KEY_SIZE_TOO_SMALL);\n        return 0;\n    }\n\n    to[0] = 0;\n    seed = to + 1;\n    db = to + mdlen + 1;\n\n    if (!EVP_Digest((void *)param, plen, db, NULL, md, NULL))\n        goto err;\n    memset(db + mdlen, 0, emlen - flen - 2 * mdlen - 1);\n    db[emlen - flen - mdlen - 1] = 0x01;\n    memcpy(db + emlen - flen - mdlen, from, (unsigned int)flen);\n    if (RAND_bytes(seed, mdlen) \u003c= 0)\n        goto err;\n\n    dbmask_len = emlen - mdlen;\n    dbmask = OPENSSL_malloc(dbmask_len);\n    if (dbmask == NULL) {\n        RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP_MGF1, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (PKCS1_MGF1(dbmask, dbmask_len, seed, mdlen, mgf1md) \u003c 0)\n        goto err;\n    for (i = 0; i \u003c dbmask_len; i++)\n        db[i] ^= dbmask[i];\n\n    if (PKCS1_MGF1(seedmask, mdlen, db, dbmask_len, mgf1md) \u003c 0)\n        goto err;\n    for (i = 0; i \u003c mdlen; i++)\n        seed[i] ^= seedmask[i];\n    rv = 1;\n\n err:\n    OPENSSL_cleanse(seedmask, sizeof(seedmask));\n    OPENSSL_clear_free(dbmask, dbmask_len);\n    return rv;\n}","filepath":"crypto/rsa/rsa_oaep.c","line_number":41,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269928496":{"score":0.87510437,"function_name":"RSA_padding_check_PKCS1_OAEP_mgf1","code":"int RSA_padding_check_PKCS1_OAEP_mgf1(unsigned char *to, int tlen,\n                                      const unsigned char *from, int flen,\n                                      int num, const unsigned char *param,\n                                      int plen, const EVP_MD *md,\n                                      const EVP_MD *mgf1md)\n{\n    int i, dblen = 0, mlen = -1, one_index = 0, msg_index;\n    unsigned int good = 0, found_one_byte, mask;\n    const unsigned char *maskedseed, *maskeddb;\n    /*\n     * |em| is the encoded message, zero-padded to exactly |num| bytes: em =\n     * Y || maskedSeed || maskedDB\n     */\n    unsigned char *db = NULL, *em = NULL, seed[EVP_MAX_MD_SIZE],\n        phash[EVP_MAX_MD_SIZE];\n    int mdlen;\n\n    if (md == NULL)\n        md = EVP_sha1();\n    if (mgf1md == NULL)\n        mgf1md = md;\n\n    mdlen = EVP_MD_size(md);\n\n    if (tlen \u003c= 0 || flen \u003c= 0)\n        return -1;\n    /*\n     * |num| is the length of the modulus; |flen| is the length of the\n     * encoded message. Therefore, for any |from| that was obtained by\n     * decrypting a ciphertext, we must have |flen| \u003c= |num|. Similarly,\n     * |num| \u003e= 2 * |mdlen| + 2 must hold for the modulus irrespective of\n     * the ciphertext, see PKCS #1 v2.2, section 7.1.2.\n     * This does not leak any side-channel information.\n     */\n    if (num \u003c flen || num \u003c 2 * mdlen + 2) {\n        RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP_MGF1,\n               RSA_R_OAEP_DECODING_ERROR);\n        return -1;\n    }\n\n    dblen = num - mdlen - 1;\n    db = OPENSSL_malloc(dblen);\n    if (db == NULL) {\n        RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP_MGF1, ERR_R_MALLOC_FAILURE);\n        goto cleanup;\n    }\n\n    em = OPENSSL_malloc(num);\n    if (em == NULL) {\n        RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP_MGF1,\n               ERR_R_MALLOC_FAILURE);\n        goto cleanup;\n    }\n\n    /*\n     * Caller is encouraged to pass zero-padded message created with\n     * BN_bn2binpad. Trouble is that since we can't read out of |from|'s\n     * bounds, it's impossible to have an invariant memory access pattern\n     * in case |from| was not zero-padded in advance.\n     */\n    for (from += flen, em += num, i = 0; i \u003c num; i++) {\n        mask = ~constant_time_is_zero(flen);\n        flen -= 1 \u0026 mask;\n        from -= 1 \u0026 mask;\n        *--em = *from \u0026 mask;\n    }\n\n    /*\n     * The first byte must be zero, however we must not leak if this is\n     * true. See James H. Manger, \"A Chosen Ciphertext  Attack on RSA\n     * Optimal Asymmetric Encryption Padding (OAEP) [...]\", CRYPTO 2001).\n     */\n    good = constant_time_is_zero(em[0]);\n\n    maskedseed = em + 1;\n    maskeddb = em + 1 + mdlen;\n\n    if (PKCS1_MGF1(seed, mdlen, maskeddb, dblen, mgf1md))\n        goto cleanup;\n    for (i = 0; i \u003c mdlen; i++)\n        seed[i] ^= maskedseed[i];\n\n    if (PKCS1_MGF1(db, dblen, seed, mdlen, mgf1md))\n        goto cleanup;\n    for (i = 0; i \u003c dblen; i++)\n        db[i] ^= maskeddb[i];\n\n    if (!EVP_Digest((void *)param, plen, phash, NULL, md, NULL))\n        goto cleanup;\n\n    good \u0026= constant_time_is_zero(CRYPTO_memcmp(db, phash, mdlen));\n\n    found_one_byte = 0;\n    for (i = mdlen; i \u003c dblen; i++) {\n        /*\n         * Padding consists of a number of 0-bytes, followed by a 1.\n         */\n        unsigned int equals1 = constant_time_eq(db[i], 1);\n        unsigned int equals0 = constant_time_is_zero(db[i]);\n        one_index = constant_time_select_int(~found_one_byte \u0026 equals1,\n                                             i, one_index);\n        found_one_byte |= equals1;\n        good \u0026= (found_one_byte | equals0);\n    }\n\n    good \u0026= found_one_byte;\n\n    /*\n     * At this point |good| is zero unless the plaintext was valid,\n     * so plaintext-awareness ensures timing side-channels are no longer a\n     * concern.\n     */\n    msg_index = one_index + 1;\n    mlen = dblen - msg_index;\n\n    /*\n     * For good measure, do this check in constant time as well.\n     */\n    good \u0026= constant_time_ge(tlen, mlen);\n\n    /*\n     * Move the result in-place by |dblen|-|mdlen|-1-|mlen| bytes to the left.\n     * Then if |good| move |mlen| bytes from |db|+|mdlen|+1 to |to|.\n     * Otherwise leave |to| unchanged.\n     * Copy the memory back in a way that does not reveal the size of\n     * the data being copied via a timing side channel. This requires copying\n     * parts of the buffer multiple times based on the bits set in the real\n     * length. Clear bits do a non-copy with identical access pattern.\n     * The loop below has overall complexity of O(N*log(N)).\n     */\n    tlen = constant_time_select_int(constant_time_lt(dblen - mdlen - 1, tlen),\n                                    dblen - mdlen - 1, tlen);\n    for (msg_index = 1; msg_index \u003c dblen - mdlen - 1; msg_index \u003c\u003c= 1) {\n        mask = ~constant_time_eq(msg_index \u0026 (dblen - mdlen - 1 - mlen), 0);\n        for (i = mdlen + 1; i \u003c dblen - msg_index; i++)\n            db[i] = constant_time_select_8(mask, db[i + msg_index], db[i]);\n    }\n    for (i = 0; i \u003c tlen; i++) {\n        mask = good \u0026 constant_time_lt(i, mlen);\n        to[i] = constant_time_select_8(mask, db[i + mdlen + 1], to[i]);\n    }\n\n    /*\n     * To avoid chosen ciphertext attacks, the error message should not\n     * reveal which kind of decoding error happened.\n     */\n    RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP_MGF1,\n           RSA_R_OAEP_DECODING_ERROR);\n    err_clear_last_constant_time(1 \u0026 good);\n cleanup:\n    OPENSSL_cleanse(seed, sizeof(seed));\n    OPENSSL_clear_free(db, dblen);\n    OPENSSL_clear_free(em, num);\n\n    return constant_time_select_int(good, mlen, -1);\n}","filepath":"crypto/rsa/rsa_oaep.c","line_number":116,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269931360":{"score":0.91759306,"function_name":"RSA_X931_hash_id","code":"int RSA_X931_hash_id(int nid)\n{\n    switch (nid) {\n    case NID_sha1:\n        return 0x33;\n\n    case NID_sha256:\n        return 0x34;\n\n    case NID_sha384:\n        return 0x36;\n\n    case NID_sha512:\n        return 0x35;\n\n    }\n    return -1;\n}","filepath":"crypto/rsa/rsa_x931.c","line_number":106,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269931424":{"score":0.9512575,"function_name":"RSA_padding_add_X931","code":"int RSA_padding_add_X931(unsigned char *to, int tlen,\n                         const unsigned char *from, int flen)\n{\n    int j;\n    unsigned char *p;\n\n    /*\n     * Absolute minimum amount of padding is 1 header nibble, 1 padding\n     * nibble and 2 trailer bytes: but 1 hash if is already in 'from'.\n     */\n\n    j = tlen - flen - 2;\n\n    if (j \u003c 0) {\n        ERR_raise(ERR_LIB_RSA, RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);\n        return -1;\n    }\n\n    p = (unsigned char *)to;\n\n    /* If no padding start and end nibbles are in one byte */\n    if (j == 0) {\n        *p++ = 0x6A;\n    } else {\n        *p++ = 0x6B;\n        if (j \u003e 1) {\n            memset(p, 0xBB, j - 1);\n            p += j - 1;\n        }\n        *p++ = 0xBA;\n    }\n    memcpy(p, from, (unsigned int)flen);\n    p += flen;\n    *p = 0xCC;\n    return 1;\n}","filepath":"crypto/rsa/rsa_x931.c","line_number":22,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269931552":{"score":0.94435203,"function_name":"RSA_padding_check_X931","code":"int RSA_padding_check_X931(unsigned char *to, int tlen,\n                           const unsigned char *from, int flen, int num)\n{\n    int i = 0, j;\n    const unsigned char *p;\n\n    p = from;\n    if ((num != flen) || ((*p != 0x6A) \u0026\u0026 (*p != 0x6B))) {\n        ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_HEADER);\n        return -1;\n    }\n\n    if (*p++ == 0x6B) {\n        j = flen - 3;\n        for (i = 0; i \u003c j; i++) {\n            unsigned char c = *p++;\n            if (c == 0xBA)\n                break;\n            if (c != 0xBB) {\n                ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_PADDING);\n                return -1;\n            }\n        }\n\n        j -= i;\n\n        if (i == 0) {\n            ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_PADDING);\n            return -1;\n        }\n\n    } else {\n        j = flen - 2;\n    }\n\n    if (p[j] != 0xCC) {\n        ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_TRAILER);\n        return -1;\n    }\n\n    memcpy(to, p, (unsigned int)j);\n\n    return j;\n}","filepath":"crypto/rsa/rsa_x931.c","line_number":59,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269935008":{"score":0.94703114,"function_name":"asn1_item_embed_new","code":"int asn1_item_embed_new(ASN1_VALUE **pval, const ASN1_ITEM *it, int embed)\n{\n    const ASN1_TEMPLATE *tt = NULL;\n    const ASN1_EXTERN_FUNCS *ef;\n    const ASN1_AUX *aux = it-\u003efuncs;\n    ASN1_aux_cb *asn1_cb;\n    ASN1_VALUE **pseqval;\n    int i;\n    if (aux \u0026\u0026 aux-\u003easn1_cb)\n        asn1_cb = aux-\u003easn1_cb;\n    else\n        asn1_cb = 0;\n\n    switch (it-\u003eitype) {\n\n    case ASN1_ITYPE_EXTERN:\n        ef = it-\u003efuncs;\n        if (ef \u0026\u0026 ef-\u003easn1_ex_new) {\n            if (!ef-\u003easn1_ex_new(pval, it))\n                goto memerr;\n        }\n        break;\n\n    case ASN1_ITYPE_PRIMITIVE:\n        if (it-\u003etemplates) {\n            if (!asn1_template_new(pval, it-\u003etemplates))\n                goto memerr;\n        } else if (!asn1_primitive_new(pval, it, embed))\n            goto memerr;\n        break;\n\n    case ASN1_ITYPE_MSTRING:\n        if (!asn1_primitive_new(pval, it, embed))\n            goto memerr;\n        break;\n\n    case ASN1_ITYPE_CHOICE:\n        if (asn1_cb) {\n            i = asn1_cb(ASN1_OP_NEW_PRE, pval, it, NULL);\n            if (!i)\n                goto auxerr;\n            if (i == 2) {\n                return 1;\n            }\n        }\n        if (embed) {\n            memset(*pval, 0, it-\u003esize);\n        } else {\n            *pval = OPENSSL_zalloc(it-\u003esize);\n            if (*pval == NULL)\n                goto memerr;\n        }\n        asn1_set_choice_selector(pval, -1, it);\n        if (asn1_cb \u0026\u0026 !asn1_cb(ASN1_OP_NEW_POST, pval, it, NULL))\n            goto auxerr2;\n        break;\n\n    case ASN1_ITYPE_NDEF_SEQUENCE:\n    case ASN1_ITYPE_SEQUENCE:\n        if (asn1_cb) {\n            i = asn1_cb(ASN1_OP_NEW_PRE, pval, it, NULL);\n            if (!i)\n                goto auxerr;\n            if (i == 2) {\n                return 1;\n            }\n        }\n        if (embed) {\n            memset(*pval, 0, it-\u003esize);\n        } else {\n            *pval = OPENSSL_zalloc(it-\u003esize);\n            if (*pval == NULL)\n                goto memerr;\n        }\n        /* 0 : init. lock */\n        if (asn1_do_lock(pval, 0, it) \u003c 0) {\n            if (!embed) {\n                OPENSSL_free(*pval);\n                *pval = NULL;\n            }\n            goto memerr;\n        }\n        asn1_enc_init(pval, it);\n        for (i = 0, tt = it-\u003etemplates; i \u003c it-\u003etcount; tt++, i++) {\n            pseqval = asn1_get_field_ptr(pval, tt);\n            if (!asn1_template_new(pseqval, tt))\n                goto memerr2;\n        }\n        if (asn1_cb \u0026\u0026 !asn1_cb(ASN1_OP_NEW_POST, pval, it, NULL))\n            goto auxerr2;\n        break;\n    }\n    return 1;\n\n memerr2:\n    asn1_item_embed_free(pval, it, embed);\n memerr:\n    ASN1err(ASN1_F_ASN1_ITEM_EMBED_NEW, ERR_R_MALLOC_FAILURE);\n    return 0;\n\n auxerr2:\n    asn1_item_embed_free(pval, it, embed);\n auxerr:\n    ASN1err(ASN1_F_ASN1_ITEM_EMBED_NEW, ASN1_R_AUX_ERROR);\n    return 0;\n\n}","filepath":"crypto/asn1/tasn_new.c","line_number":42,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"269935664":{"score":0.9561886,"function_name":"asn1_primitive_new","code":"static int asn1_primitive_new(ASN1_VALUE **pval, const ASN1_ITEM *it,\n                              int embed)\n{\n    ASN1_TYPE *typ;\n    ASN1_STRING *str;\n    int utype;\n\n    if (!it)\n        return 0;\n\n    if (it-\u003efuncs) {\n        const ASN1_PRIMITIVE_FUNCS *pf = it-\u003efuncs;\n        if (embed) {\n            if (pf-\u003eprim_clear) {\n                pf-\u003eprim_clear(pval, it);\n                return 1;\n            }\n        } else if (pf-\u003eprim_new) {\n            return pf-\u003eprim_new(pval, it);\n        }\n    }\n\n    if (it-\u003eitype == ASN1_ITYPE_MSTRING)\n        utype = -1;\n    else\n        utype = it-\u003eutype;\n    switch (utype) {\n    case V_ASN1_OBJECT:\n        *pval = (ASN1_VALUE *)OBJ_nid2obj(NID_undef);\n        return 1;\n\n    case V_ASN1_BOOLEAN:\n        *(ASN1_BOOLEAN *)pval = it-\u003esize;\n        return 1;\n\n    case V_ASN1_NULL:\n        *pval = (ASN1_VALUE *)1;\n        return 1;\n\n    case V_ASN1_ANY:\n        if ((typ = OPENSSL_malloc(sizeof(*typ))) == NULL) {\n            ASN1err(ASN1_F_ASN1_PRIMITIVE_NEW, ERR_R_MALLOC_FAILURE);\n            return 0;\n        }\n        typ-\u003evalue.ptr = NULL;\n        typ-\u003etype = -1;\n        *pval = (ASN1_VALUE *)typ;\n        break;\n\n    default:\n        if (embed) {\n            str = *(ASN1_STRING **)pval;\n            memset(str, 0, sizeof(*str));\n            str-\u003etype = utype;\n            str-\u003eflags = ASN1_STRING_FLAG_EMBED;\n        } else {\n            str = ASN1_STRING_type_new(utype);\n            *pval = (ASN1_VALUE *)str;\n        }\n        if (it-\u003eitype == ASN1_ITYPE_MSTRING \u0026\u0026 str)\n            str-\u003eflags |= ASN1_STRING_FLAG_MSTRING;\n        break;\n    }\n    if (*pval)\n        return 1;\n    return 0;\n}","filepath":"crypto/asn1/tasn_new.c","line_number":236,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"269936016":{"score":0.7607784,"function_name":"asn1_item_clear","code":"static void asn1_item_clear(ASN1_VALUE **pval, const ASN1_ITEM *it)\n{\n    const ASN1_EXTERN_FUNCS *ef;\n\n    switch (it-\u003eitype) {\n\n    case ASN1_ITYPE_EXTERN:\n        ef = it-\u003efuncs;\n        if (ef \u0026\u0026 ef-\u003easn1_ex_clear)\n            ef-\u003easn1_ex_clear(pval, it);\n        else\n            *pval = NULL;\n        break;\n\n    case ASN1_ITYPE_PRIMITIVE:\n        if (it-\u003etemplates)\n            asn1_template_clear(pval, it-\u003etemplates);\n        else\n            asn1_primitive_clear(pval, it);\n        break;\n\n    case ASN1_ITYPE_MSTRING:\n        asn1_primitive_clear(pval, it);\n        break;\n\n    case ASN1_ITYPE_CHOICE:\n    case ASN1_ITYPE_SEQUENCE:\n    case ASN1_ITYPE_NDEF_SEQUENCE:\n        *pval = NULL;\n        break;\n    }\n}","filepath":"crypto/asn1/tasn_new.c","line_number":150,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"269936144":{"score":0.8149845,"function_name":"asn1_template_new","code":"static int asn1_template_new(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt)\n{\n    const ASN1_ITEM *it = ASN1_ITEM_ptr(tt-\u003eitem);\n    int embed = tt-\u003eflags \u0026 ASN1_TFLG_EMBED;\n    ASN1_VALUE *tval;\n    int ret;\n    if (embed) {\n        tval = (ASN1_VALUE *)pval;\n        pval = \u0026tval;\n    }\n    if (tt-\u003eflags \u0026 ASN1_TFLG_OPTIONAL) {\n        asn1_template_clear(pval, tt);\n        return 1;\n    }\n    /* If ANY DEFINED BY nothing to do */\n\n    if (tt-\u003eflags \u0026 ASN1_TFLG_ADB_MASK) {\n        *pval = NULL;\n        return 1;\n    }\n    /* If SET OF or SEQUENCE OF, its a STACK */\n    if (tt-\u003eflags \u0026 ASN1_TFLG_SK_MASK) {\n        STACK_OF(ASN1_VALUE) *skval;\n        skval = sk_ASN1_VALUE_new_null();\n        if (!skval) {\n            ASN1err(ASN1_F_ASN1_TEMPLATE_NEW, ERR_R_MALLOC_FAILURE);\n            ret = 0;\n            goto done;\n        }\n        *pval = (ASN1_VALUE *)skval;\n        ret = 1;\n        goto done;\n    }\n    /* Otherwise pass it back to the item routine */\n    ret = asn1_item_embed_new(pval, it, embed);\n done:\n    return ret;\n}","filepath":"crypto/asn1/tasn_new.c","line_number":183,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"269936384":{"score":0.9004855,"function_name":"asn1_item_embed_free","code":"void asn1_item_embed_free(ASN1_VALUE **pval, const ASN1_ITEM *it, int embed)\n{\n    const ASN1_TEMPLATE *tt = NULL, *seqtt;\n    const ASN1_EXTERN_FUNCS *ef;\n    const ASN1_AUX *aux = it-\u003efuncs;\n    ASN1_aux_cb *asn1_cb;\n    int i;\n\n    if (!pval)\n        return;\n    if ((it-\u003eitype != ASN1_ITYPE_PRIMITIVE) \u0026\u0026 !*pval)\n        return;\n    if (aux \u0026\u0026 aux-\u003easn1_cb)\n        asn1_cb = aux-\u003easn1_cb;\n    else\n        asn1_cb = 0;\n\n    switch (it-\u003eitype) {\n\n    case ASN1_ITYPE_PRIMITIVE:\n        if (it-\u003etemplates)\n            asn1_template_free(pval, it-\u003etemplates);\n        else\n            asn1_primitive_free(pval, it, embed);\n        break;\n\n    case ASN1_ITYPE_MSTRING:\n        asn1_primitive_free(pval, it, embed);\n        break;\n\n    case ASN1_ITYPE_CHOICE:\n        if (asn1_cb) {\n            i = asn1_cb(ASN1_OP_FREE_PRE, pval, it, NULL);\n            if (i == 2)\n                return;\n        }\n        i = asn1_get_choice_selector(pval, it);\n        if ((i \u003e= 0) \u0026\u0026 (i \u003c it-\u003etcount)) {\n            ASN1_VALUE **pchval;\n\n            tt = it-\u003etemplates + i;\n            pchval = asn1_get_field_ptr(pval, tt);\n            asn1_template_free(pchval, tt);\n        }\n        if (asn1_cb)\n            asn1_cb(ASN1_OP_FREE_POST, pval, it, NULL);\n        if (embed == 0) {\n            OPENSSL_free(*pval);\n            *pval = NULL;\n        }\n        break;\n\n    case ASN1_ITYPE_EXTERN:\n        ef = it-\u003efuncs;\n        if (ef \u0026\u0026 ef-\u003easn1_ex_free)\n            ef-\u003easn1_ex_free(pval, it);\n        break;\n\n    case ASN1_ITYPE_NDEF_SEQUENCE:\n    case ASN1_ITYPE_SEQUENCE:\n        if (asn1_do_lock(pval, -1, it) != 0) /* if error or ref-counter \u003e 0 */\n            return;\n        if (asn1_cb) {\n            i = asn1_cb(ASN1_OP_FREE_PRE, pval, it, NULL);\n            if (i == 2)\n                return;\n        }\n        asn1_enc_free(pval, it);\n        /*\n         * If we free up as normal we will invalidate any ANY DEFINED BY\n         * field and we won't be able to determine the type of the field it\n         * defines. So free up in reverse order.\n         */\n        tt = it-\u003etemplates + it-\u003etcount;\n        for (i = 0; i \u003c it-\u003etcount; i++) {\n            ASN1_VALUE **pseqval;\n\n            tt--;\n            seqtt = asn1_do_adb(pval, tt, 0);\n            if (!seqtt)\n                continue;\n            pseqval = asn1_get_field_ptr(pval, seqtt);\n            asn1_template_free(pseqval, seqtt);\n        }\n        if (asn1_cb)\n            asn1_cb(ASN1_OP_FREE_POST, pval, it, NULL);\n        if (embed == 0) {\n            OPENSSL_free(*pval);\n            *pval = NULL;\n        }\n        break;\n    }\n}","filepath":"crypto/asn1/tasn_fre.c","line_number":28,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269936848":{"score":0.9106515,"function_name":"asn1_primitive_free","code":"void asn1_primitive_free(ASN1_VALUE **pval, const ASN1_ITEM *it, int embed)\n{\n    int utype;\n\n    /* Special case: if 'it' is a primitive with a free_func, use that. */\n    if (it) {\n        const ASN1_PRIMITIVE_FUNCS *pf = it-\u003efuncs;\n\n        if (embed) {\n            if (pf \u0026\u0026 pf-\u003eprim_clear) {\n                pf-\u003eprim_clear(pval, it);\n                return;\n            }\n        } else if (pf \u0026\u0026 pf-\u003eprim_free) {\n            pf-\u003eprim_free(pval, it);\n            return;\n        }\n    }\n\n    /* Special case: if 'it' is NULL, free contents of ASN1_TYPE */\n    if (!it) {\n        ASN1_TYPE *typ = (ASN1_TYPE *)*pval;\n\n        utype = typ-\u003etype;\n        pval = \u0026typ-\u003evalue.asn1_value;\n        if (!*pval)\n            return;\n    } else if (it-\u003eitype == ASN1_ITYPE_MSTRING) {\n        utype = -1;\n        if (!*pval)\n            return;\n    } else {\n        utype = it-\u003eutype;\n        if ((utype != V_ASN1_BOOLEAN) \u0026\u0026 !*pval)\n            return;\n    }\n\n    switch (utype) {\n    case V_ASN1_OBJECT:\n        ASN1_OBJECT_free((ASN1_OBJECT *)*pval);\n        break;\n\n    case V_ASN1_BOOLEAN:\n        if (it)\n            *(ASN1_BOOLEAN *)pval = it-\u003esize;\n        else\n            *(ASN1_BOOLEAN *)pval = -1;\n        return;\n\n    case V_ASN1_NULL:\n        break;\n\n    case V_ASN1_ANY:\n        asn1_primitive_free(pval, NULL, 0);\n        OPENSSL_free(*pval);\n        break;\n\n    default:\n        asn1_string_embed_free((ASN1_STRING *)*pval, embed);\n        break;\n    }\n    *pval = NULL;\n}","filepath":"crypto/asn1/tasn_fre.c","line_number":146,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269937088":{"score":0.8687219,"function_name":"asn1_template_free","code":"void asn1_template_free(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt)\n{\n    int embed = tt-\u003eflags \u0026 ASN1_TFLG_EMBED;\n    ASN1_VALUE *tval;\n    if (embed) {\n        tval = (ASN1_VALUE *)pval;\n        pval = \u0026tval;\n    }\n    if (tt-\u003eflags \u0026 ASN1_TFLG_SK_MASK) {\n        STACK_OF(ASN1_VALUE) *sk = (STACK_OF(ASN1_VALUE) *)*pval;\n        int i;\n\n        for (i = 0; i \u003c sk_ASN1_VALUE_num(sk); i++) {\n            ASN1_VALUE *vtmp = sk_ASN1_VALUE_value(sk, i);\n\n            asn1_item_embed_free(\u0026vtmp, ASN1_ITEM_ptr(tt-\u003eitem), embed);\n        }\n        sk_ASN1_VALUE_free(sk);\n        *pval = NULL;\n    } else {\n        asn1_item_embed_free(pval, ASN1_ITEM_ptr(tt-\u003eitem), embed);\n    }\n}","filepath":"crypto/asn1/tasn_fre.c","line_number":122,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269937264":{"score":0.63528574,"function_name":"ASN1_item_d2i","code":"ASN1_VALUE *ASN1_item_d2i(ASN1_VALUE **pval,\n                          const unsigned char **in, long len,\n                          const ASN1_ITEM *it)\n{\n    ASN1_TLC c;\n    ASN1_VALUE *ptmpval = NULL;\n\n    if (pval == NULL)\n        pval = \u0026ptmpval;\n    asn1_tlc_clear_nc(\u0026c);\n    if (ASN1_item_ex_d2i(pval, in, len, it, -1, 0, 0, \u0026c) \u003e 0)\n        return *pval;\n    return NULL;\n}","filepath":"crypto/asn1/tasn_dec.c","line_number":104,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269937408":{"score":0.89232016,"function_name":"ASN1_item_ex_d2i","code":"int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,\n                     const ASN1_ITEM *it,\n                     int tag, int aclass, char opt, ASN1_TLC *ctx)\n{\n    int rv;\n    rv = asn1_item_embed_d2i(pval, in, len, it, tag, aclass, opt, ctx, 0);\n    if (rv \u003c= 0)\n        ASN1_item_ex_free(pval, it);\n    return rv;\n}","filepath":"crypto/asn1/tasn_dec.c","line_number":119,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269937520":{"score":0.88812435,"function_name":"asn1_check_eoc","code":"static int asn1_check_eoc(const unsigned char **in, long len)\n{\n    const unsigned char *p;\n\n    if (len \u003c 2)\n        return 0;\n    p = *in;\n    if (p[0] == '\\0' \u0026\u0026 p[1] == '\\0') {\n        *in += 2;\n        return 1;\n    }\n    return 0;\n}","filepath":"crypto/asn1/tasn_dec.c","line_number":1053,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269937568":{"score":0.92595917,"function_name":"asn1_check_tlen","code":"static int asn1_check_tlen(long *olen, int *otag, unsigned char *oclass,\n                           char *inf, char *cst,\n                           const unsigned char **in, long len,\n                           int exptag, int expclass, char opt, ASN1_TLC *ctx)\n{\n    int i;\n    int ptag, pclass;\n    long plen;\n    const unsigned char *p, *q;\n    p = *in;\n    q = p;\n\n    if (ctx \u0026\u0026 ctx-\u003evalid) {\n        i = ctx-\u003eret;\n        plen = ctx-\u003eplen;\n        pclass = ctx-\u003epclass;\n        ptag = ctx-\u003eptag;\n        p += ctx-\u003ehdrlen;\n    } else {\n        i = ASN1_get_object(\u0026p, \u0026plen, \u0026ptag, \u0026pclass, len);\n        if (ctx) {\n            ctx-\u003eret = i;\n            ctx-\u003eplen = plen;\n            ctx-\u003epclass = pclass;\n            ctx-\u003eptag = ptag;\n            ctx-\u003ehdrlen = p - q;\n            ctx-\u003evalid = 1;\n            /*\n             * If definite length, and no error, length + header can't exceed\n             * total amount of data available.\n             */\n            if (!(i \u0026 0x81) \u0026\u0026 ((plen + ctx-\u003ehdrlen) \u003e len)) {\n                ERR_raise(ERR_LIB_ASN1, ASN1_R_TOO_LONG);\n                asn1_tlc_clear(ctx);\n                return 0;\n            }\n        }\n    }\n\n    if (i \u0026 0x80) {\n        ERR_raise(ERR_LIB_ASN1, ASN1_R_BAD_OBJECT_HEADER);\n        asn1_tlc_clear(ctx);\n        return 0;\n    }\n    if (exptag \u003e= 0) {\n        if ((exptag != ptag) || (expclass != pclass)) {\n            /*\n             * If type is OPTIONAL, not an error: indicate missing type.\n             */\n            if (opt)\n                return -1;\n            asn1_tlc_clear(ctx);\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_WRONG_TAG);\n            return 0;\n        }\n        /*\n         * We have a tag and class match: assume we are going to do something\n         * with it\n         */\n        asn1_tlc_clear(ctx);\n    }\n\n    if (i \u0026 1)\n        plen = len - (p - q);\n\n    if (inf)\n        *inf = i \u0026 1;\n\n    if (cst)\n        *cst = i \u0026 V_ASN1_CONSTRUCTED;\n\n    if (olen)\n        *olen = plen;\n\n    if (oclass)\n        *oclass = pclass;\n\n    if (otag)\n        *otag = ptag;\n\n    *in = p;\n    return 1;\n}","filepath":"crypto/asn1/tasn_dec.c","line_number":1074,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269938016":{"score":0.8304801,"function_name":"asn1_collect","code":"static int asn1_collect(BUF_MEM *buf, const unsigned char **in, long len,\n                        char inf, int tag, int aclass, int depth)\n{\n    const unsigned char *p, *q;\n    long plen;\n    char cst, ininf;\n    p = *in;\n    inf \u0026= 1;\n    /*\n     * If no buffer and not indefinite length constructed just pass over the\n     * encoded data\n     */\n    if (!buf \u0026\u0026 !inf) {\n        *in += len;\n        return 1;\n    }\n    while (len \u003e 0) {\n        q = p;\n        /* Check for EOC */\n        if (asn1_check_eoc(\u0026p, len)) {\n            /*\n             * EOC is illegal outside indefinite length constructed form\n             */\n            if (!inf) {\n                ERR_raise(ERR_LIB_ASN1, ASN1_R_UNEXPECTED_EOC);\n                return 0;\n            }\n            inf = 0;\n            break;\n        }\n\n        if (!asn1_check_tlen(\u0026plen, NULL, NULL, \u0026ininf, \u0026cst, \u0026p,\n                             len, tag, aclass, 0, NULL)) {\n            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);\n            return 0;\n        }\n\n        /* If indefinite length constructed update max length */\n        if (cst) {\n            if (depth \u003e= ASN1_MAX_STRING_NEST) {\n                ERR_raise(ERR_LIB_ASN1, ASN1_R_NESTED_ASN1_STRING);\n                return 0;\n            }\n            if (!asn1_collect(buf, \u0026p, plen, ininf, tag, aclass, depth + 1))\n                return 0;\n        } else if (plen \u0026\u0026 !collect_data(buf, \u0026p, plen))\n            return 0;\n        len -= p - q;\n    }\n    if (inf) {\n        ERR_raise(ERR_LIB_ASN1, ASN1_R_MISSING_EOC);\n        return 0;\n    }\n    *in = p;\n    return 1;\n}","filepath":"crypto/asn1/tasn_dec.c","line_number":979,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269938656":{"score":0.8939057,"function_name":"asn1_d2i_ex_primitive","code":"static int asn1_d2i_ex_primitive(ASN1_VALUE **pval,\n                                 const unsigned char **in, long inlen,\n                                 const ASN1_ITEM *it,\n                                 int tag, int aclass, char opt, ASN1_TLC *ctx)\n{\n    int ret = 0, utype;\n    long plen;\n    char cst, inf, free_cont = 0;\n    const unsigned char *p;\n    BUF_MEM buf = { 0, NULL, 0, 0 };\n    const unsigned char *cont = NULL;\n    long len;\n\n    if (pval == NULL) {\n        ERR_raise(ERR_LIB_ASN1, ASN1_R_ILLEGAL_NULL);\n        return 0;               /* Should never happen */\n    }\n\n    if (it-\u003eitype == ASN1_ITYPE_MSTRING) {\n        utype = tag;\n        tag = -1;\n    } else\n        utype = it-\u003eutype;\n\n    if (utype == V_ASN1_ANY) {\n        /* If type is ANY need to figure out type from tag */\n        unsigned char oclass;\n        if (tag \u003e= 0) {\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_ILLEGAL_TAGGED_ANY);\n            return 0;\n        }\n        if (opt) {\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_ILLEGAL_OPTIONAL_ANY);\n            return 0;\n        }\n        p = *in;\n        ret = asn1_check_tlen(NULL, \u0026utype, \u0026oclass, NULL, NULL,\n                              \u0026p, inlen, -1, 0, 0, ctx);\n        if (!ret) {\n            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);\n            return 0;\n        }\n        if (oclass != V_ASN1_UNIVERSAL)\n            utype = V_ASN1_OTHER;\n    }\n    if (tag == -1) {\n        tag = utype;\n        aclass = V_ASN1_UNIVERSAL;\n    }\n    p = *in;\n    /* Check header */\n    ret = asn1_check_tlen(\u0026plen, NULL, NULL, \u0026inf, \u0026cst,\n                          \u0026p, inlen, tag, aclass, opt, ctx);\n    if (!ret) {\n        ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);\n        return 0;\n    } else if (ret == -1)\n        return -1;\n    ret = 0;\n    /* SEQUENCE, SET and \"OTHER\" are left in encoded form */\n    if ((utype == V_ASN1_SEQUENCE)\n        || (utype == V_ASN1_SET) || (utype == V_ASN1_OTHER)) {\n        /*\n         * Clear context cache for type OTHER because the auto clear when we\n         * have a exact match won't work\n         */\n        if (utype == V_ASN1_OTHER) {\n            asn1_tlc_clear(ctx);\n        }\n        /* SEQUENCE and SET must be constructed */\n        else if (!cst) {\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_TYPE_NOT_CONSTRUCTED);\n            return 0;\n        }\n\n        cont = *in;\n        /* If indefinite length constructed find the real end */\n        if (inf) {\n            if (!asn1_find_end(\u0026p, plen, inf))\n                goto err;\n            len = p - cont;\n        } else {\n            len = p - cont + plen;\n            p += plen;\n        }\n    } else if (cst) {\n        if (utype == V_ASN1_NULL || utype == V_ASN1_BOOLEAN\n            || utype == V_ASN1_OBJECT || utype == V_ASN1_INTEGER\n            || utype == V_ASN1_ENUMERATED) {\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_TYPE_NOT_PRIMITIVE);\n            return 0;\n        }\n\n        /* Free any returned 'buf' content */\n        free_cont = 1;\n        /*\n         * Should really check the internal tags are correct but some things\n         * may get this wrong. The relevant specs say that constructed string\n         * types should be OCTET STRINGs internally irrespective of the type.\n         * So instead just check for UNIVERSAL class and ignore the tag.\n         */\n        if (!asn1_collect(\u0026buf, \u0026p, plen, inf, -1, V_ASN1_UNIVERSAL, 0)) {\n            goto err;\n        }\n        len = buf.length;\n        /* Append a final null to string */\n        if (!BUF_MEM_grow_clean(\u0026buf, len + 1)) {\n            ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        buf.data[len] = 0;\n        cont = (const unsigned char *)buf.data;\n    } else {\n        cont = p;\n        len = plen;\n        p += plen;\n    }\n\n    /* We now have content length and type: translate into a structure */\n    /* asn1_ex_c2i may reuse allocated buffer, and so sets free_cont to 0 */\n    if (!asn1_ex_c2i(pval, cont, len, utype, \u0026free_cont, it))\n        goto err;\n\n    *in = p;\n    ret = 1;\n err:\n    if (free_cont)\n        OPENSSL_free(buf.data);\n    return ret;\n}","filepath":"crypto/asn1/tasn_dec.c","line_number":637,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269939792":{"score":0.942806,"function_name":"asn1_ex_c2i","code":"static int asn1_ex_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len,\n                       int utype, char *free_cont, const ASN1_ITEM *it)\n{\n    ASN1_VALUE **opval = NULL;\n    ASN1_STRING *stmp;\n    ASN1_TYPE *typ = NULL;\n    int ret = 0;\n    const ASN1_PRIMITIVE_FUNCS *pf;\n    ASN1_INTEGER **tint;\n    pf = it-\u003efuncs;\n\n    if (pf \u0026\u0026 pf-\u003eprim_c2i)\n        return pf-\u003eprim_c2i(pval, cont, len, utype, free_cont, it);\n    /* If ANY type clear type and set pointer to internal value */\n    if (it-\u003eutype == V_ASN1_ANY) {\n        if (*pval == NULL) {\n            typ = ASN1_TYPE_new();\n            if (typ == NULL)\n                goto err;\n            *pval = (ASN1_VALUE *)typ;\n        } else\n            typ = (ASN1_TYPE *)*pval;\n\n        if (utype != typ-\u003etype)\n            ASN1_TYPE_set(typ, utype, NULL);\n        opval = pval;\n        pval = \u0026typ-\u003evalue.asn1_value;\n    }\n    switch (utype) {\n    case V_ASN1_OBJECT:\n        if (!c2i_ASN1_OBJECT((ASN1_OBJECT **)pval, \u0026cont, len))\n            goto err;\n        break;\n\n    case V_ASN1_NULL:\n        if (len) {\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_NULL_IS_WRONG_LENGTH);\n            goto err;\n        }\n        *pval = (ASN1_VALUE *)1;\n        break;\n\n    case V_ASN1_BOOLEAN:\n        if (len != 1) {\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_BOOLEAN_IS_WRONG_LENGTH);\n            goto err;\n        } else {\n            ASN1_BOOLEAN *tbool;\n            tbool = (ASN1_BOOLEAN *)pval;\n            *tbool = *cont;\n        }\n        break;\n\n    case V_ASN1_BIT_STRING:\n        if (!c2i_ASN1_BIT_STRING((ASN1_BIT_STRING **)pval, \u0026cont, len))\n            goto err;\n        break;\n\n    case V_ASN1_INTEGER:\n    case V_ASN1_ENUMERATED:\n        tint = (ASN1_INTEGER **)pval;\n        if (!c2i_ASN1_INTEGER(tint, \u0026cont, len))\n            goto err;\n        /* Fixup type to match the expected form */\n        (*tint)-\u003etype = utype | ((*tint)-\u003etype \u0026 V_ASN1_NEG);\n        break;\n\n    case V_ASN1_OCTET_STRING:\n    case V_ASN1_NUMERICSTRING:\n    case V_ASN1_PRINTABLESTRING:\n    case V_ASN1_T61STRING:\n    case V_ASN1_VIDEOTEXSTRING:\n    case V_ASN1_IA5STRING:\n    case V_ASN1_UTCTIME:\n    case V_ASN1_GENERALIZEDTIME:\n    case V_ASN1_GRAPHICSTRING:\n    case V_ASN1_VISIBLESTRING:\n    case V_ASN1_GENERALSTRING:\n    case V_ASN1_UNIVERSALSTRING:\n    case V_ASN1_BMPSTRING:\n    case V_ASN1_UTF8STRING:\n    case V_ASN1_OTHER:\n    case V_ASN1_SET:\n    case V_ASN1_SEQUENCE:\n    default:\n        if (utype == V_ASN1_BMPSTRING \u0026\u0026 (len \u0026 1)) {\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_BMPSTRING_IS_WRONG_LENGTH);\n            goto err;\n        }\n        if (utype == V_ASN1_UNIVERSALSTRING \u0026\u0026 (len \u0026 3)) {\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_UNIVERSALSTRING_IS_WRONG_LENGTH);\n            goto err;\n        }\n        /* All based on ASN1_STRING and handled the same */\n        if (*pval == NULL) {\n            stmp = ASN1_STRING_type_new(utype);\n            if (stmp == NULL) {\n                ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n            *pval = (ASN1_VALUE *)stmp;\n        } else {\n            stmp = (ASN1_STRING *)*pval;\n            stmp-\u003etype = utype;\n        }\n        /* If we've already allocated a buffer use it */\n        if (*free_cont) {\n            OPENSSL_free(stmp-\u003edata);\n            stmp-\u003edata = (unsigned char *)cont; /* UGLY CAST! RL */\n            stmp-\u003elength = len;\n            *free_cont = 0;\n        } else {\n            if (!ASN1_STRING_set(stmp, cont, len)) {\n                ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);\n                ASN1_STRING_free(stmp);\n                *pval = NULL;\n                goto err;\n            }\n        }\n        break;\n    }\n    /* If ASN1_ANY and NULL type fix up value */\n    if (typ \u0026\u0026 (utype == V_ASN1_NULL))\n        typ-\u003evalue.ptr = NULL;\n\n    ret = 1;\n err:\n    if (!ret) {\n        ASN1_TYPE_free(typ);\n        if (opval)\n            *opval = NULL;\n    }\n    return ret;\n}","filepath":"crypto/asn1/tasn_dec.c","line_number":770,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269940512":{"score":0.90951025,"function_name":"asn1_item_embed_d2i","code":"static int asn1_item_embed_d2i(ASN1_VALUE **pval, const unsigned char **in,\n                               long len, const ASN1_ITEM *it,\n                               int tag, int aclass, char opt, ASN1_TLC *ctx,\n                               int depth)\n{\n    const ASN1_TEMPLATE *tt, *errtt = NULL;\n    const ASN1_EXTERN_FUNCS *ef;\n    const ASN1_AUX *aux = it-\u003efuncs;\n    ASN1_aux_cb *asn1_cb;\n    const unsigned char *p = NULL, *q;\n    unsigned char oclass;\n    char seq_eoc, seq_nolen, cst, isopt;\n    long tmplen;\n    int i;\n    int otag;\n    int ret = 0;\n    ASN1_VALUE **pchptr;\n\n    if (pval == NULL)\n        return 0;\n    if (aux \u0026\u0026 aux-\u003easn1_cb)\n        asn1_cb = aux-\u003easn1_cb;\n    else\n        asn1_cb = 0;\n\n    if (++depth \u003e ASN1_MAX_CONSTRUCTED_NEST) {\n        ERR_raise(ERR_LIB_ASN1, ASN1_R_NESTED_TOO_DEEP);\n        goto err;\n    }\n\n    switch (it-\u003eitype) {\n    case ASN1_ITYPE_PRIMITIVE:\n        if (it-\u003etemplates) {\n            /*\n             * tagging or OPTIONAL is currently illegal on an item template\n             * because the flags can't get passed down. In practice this\n             * isn't a problem: we include the relevant flags from the item\n             * template in the template itself.\n             */\n            if ((tag != -1) || opt) {\n                ERR_raise(ERR_LIB_ASN1,\n                          ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);\n                goto err;\n            }\n            return asn1_template_ex_d2i(pval, in, len,\n                                        it-\u003etemplates, opt, ctx, depth);\n        }\n        return asn1_d2i_ex_primitive(pval, in, len, it,\n                                     tag, aclass, opt, ctx);\n\n    case ASN1_ITYPE_MSTRING:\n        p = *in;\n        /* Just read in tag and class */\n        ret = asn1_check_tlen(NULL, \u0026otag, \u0026oclass, NULL, NULL,\n                              \u0026p, len, -1, 0, 1, ctx);\n        if (!ret) {\n            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        }\n\n        /* Must be UNIVERSAL class */\n        if (oclass != V_ASN1_UNIVERSAL) {\n            /* If OPTIONAL, assume this is OK */\n            if (opt)\n                return -1;\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_MSTRING_NOT_UNIVERSAL);\n            goto err;\n        }\n        /* Check tag matches bit map */\n        if (!(ASN1_tag2bit(otag) \u0026 it-\u003eutype)) {\n            /* If OPTIONAL, assume this is OK */\n            if (opt)\n                return -1;\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_MSTRING_WRONG_TAG);\n            goto err;\n        }\n        return asn1_d2i_ex_primitive(pval, in, len, it, otag, 0, 0, ctx);\n\n    case ASN1_ITYPE_EXTERN:\n        /* Use new style d2i */\n        ef = it-\u003efuncs;\n        return ef-\u003easn1_ex_d2i(pval, in, len, it, tag, aclass, opt, ctx);\n\n    case ASN1_ITYPE_CHOICE:\n        if (asn1_cb \u0026\u0026 !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))\n            goto auxerr;\n        if (*pval) {\n            /* Free up and zero CHOICE value if initialised */\n            i = asn1_get_choice_selector(pval, it);\n            if ((i \u003e= 0) \u0026\u0026 (i \u003c it-\u003etcount)) {\n                tt = it-\u003etemplates + i;\n                pchptr = asn1_get_field_ptr(pval, tt);\n                asn1_template_free(pchptr, tt);\n                asn1_set_choice_selector(pval, -1, it);\n            }\n        } else if (!ASN1_item_ex_new(pval, it)) {\n            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        }\n        /* CHOICE type, try each possibility in turn */\n        p = *in;\n        for (i = 0, tt = it-\u003etemplates; i \u003c it-\u003etcount; i++, tt++) {\n            pchptr = asn1_get_field_ptr(pval, tt);\n            /*\n             * We mark field as OPTIONAL so its absence can be recognised.\n             */\n            ret = asn1_template_ex_d2i(pchptr, \u0026p, len, tt, 1, ctx, depth);\n            /* If field not present, try the next one */\n            if (ret == -1)\n                continue;\n            /* If positive return, read OK, break loop */\n            if (ret \u003e 0)\n                break;\n            /*\n             * Must be an ASN1 parsing error.\n             * Free up any partial choice value\n             */\n            asn1_template_free(pchptr, tt);\n            errtt = tt;\n            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        }\n\n        /* Did we fall off the end without reading anything? */\n        if (i == it-\u003etcount) {\n            /* If OPTIONAL, this is OK */\n            if (opt) {\n                /* Free and zero it */\n                ASN1_item_ex_free(pval, it);\n                return -1;\n            }\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_NO_MATCHING_CHOICE_TYPE);\n            goto err;\n        }\n\n        asn1_set_choice_selector(pval, i, it);\n\n        if (asn1_cb \u0026\u0026 !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))\n            goto auxerr;\n        *in = p;\n        return 1;\n\n    case ASN1_ITYPE_NDEF_SEQUENCE:\n    case ASN1_ITYPE_SEQUENCE:\n        p = *in;\n        tmplen = len;\n\n        /* If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL */\n        if (tag == -1) {\n            tag = V_ASN1_SEQUENCE;\n            aclass = V_ASN1_UNIVERSAL;\n        }\n        /* Get SEQUENCE length and update len, p */\n        ret = asn1_check_tlen(\u0026len, NULL, NULL, \u0026seq_eoc, \u0026cst,\n                              \u0026p, len, tag, aclass, opt, ctx);\n        if (!ret) {\n            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        } else if (ret == -1)\n            return -1;\n        if (aux \u0026\u0026 (aux-\u003eflags \u0026 ASN1_AFLG_BROKEN)) {\n            len = tmplen - (p - *in);\n            seq_nolen = 1;\n        }\n        /* If indefinite we don't do a length check */\n        else\n            seq_nolen = seq_eoc;\n        if (!cst) {\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_SEQUENCE_NOT_CONSTRUCTED);\n            goto err;\n        }\n\n        if (*pval == NULL \u0026\u0026 !ASN1_item_ex_new(pval, it)) {\n            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        }\n\n        if (asn1_cb \u0026\u0026 !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))\n            goto auxerr;\n\n        /* Free up and zero any ADB found */\n        for (i = 0, tt = it-\u003etemplates; i \u003c it-\u003etcount; i++, tt++) {\n            if (tt-\u003eflags \u0026 ASN1_TFLG_ADB_MASK) {\n                const ASN1_TEMPLATE *seqtt;\n                ASN1_VALUE **pseqval;\n                seqtt = asn1_do_adb(*pval, tt, 0);\n                if (seqtt == NULL)\n                    continue;\n                pseqval = asn1_get_field_ptr(pval, seqtt);\n                asn1_template_free(pseqval, seqtt);\n            }\n        }\n\n        /* Get each field entry */\n        for (i = 0, tt = it-\u003etemplates; i \u003c it-\u003etcount; i++, tt++) {\n            const ASN1_TEMPLATE *seqtt;\n            ASN1_VALUE **pseqval;\n            seqtt = asn1_do_adb(*pval, tt, 1);\n            if (seqtt == NULL)\n                goto err;\n            pseqval = asn1_get_field_ptr(pval, seqtt);\n            /* Have we ran out of data? */\n            if (!len)\n                break;\n            q = p;\n            if (asn1_check_eoc(\u0026p, len)) {\n                if (!seq_eoc) {\n                    ERR_raise(ERR_LIB_ASN1, ASN1_R_UNEXPECTED_EOC);\n                    goto err;\n                }\n                len -= p - q;\n                seq_eoc = 0;\n                q = p;\n                break;\n            }\n            /*\n             * This determines the OPTIONAL flag value. The field cannot be\n             * omitted if it is the last of a SEQUENCE and there is still\n             * data to be read. This isn't strictly necessary but it\n             * increases efficiency in some cases.\n             */\n            if (i == (it-\u003etcount - 1))\n                isopt = 0;\n            else\n                isopt = (char)(seqtt-\u003eflags \u0026 ASN1_TFLG_OPTIONAL);\n            /*\n             * attempt to read in field, allowing each to be OPTIONAL\n             */\n\n            ret = asn1_template_ex_d2i(pseqval, \u0026p, len, seqtt, isopt, ctx,\n                                       depth);\n            if (!ret) {\n                errtt = seqtt;\n                goto err;\n            } else if (ret == -1) {\n                /*\n                 * OPTIONAL component absent. Free and zero the field.\n                 */\n                asn1_template_free(pseqval, seqtt);\n                continue;\n            }\n            /* Update length */\n            len -= p - q;\n        }\n\n        /* Check for EOC if expecting one */\n        if (seq_eoc \u0026\u0026 !asn1_check_eoc(\u0026p, len)) {\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_MISSING_EOC);\n            goto err;\n        }\n        /* Check all data read */\n        if (!seq_nolen \u0026\u0026 len) {\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_SEQUENCE_LENGTH_MISMATCH);\n            goto err;\n        }\n\n        /*\n         * If we get here we've got no more data in the SEQUENCE, however we\n         * may not have read all fields so check all remaining are OPTIONAL\n         * and clear any that are.\n         */\n        for (; i \u003c it-\u003etcount; tt++, i++) {\n            const ASN1_TEMPLATE *seqtt;\n            seqtt = asn1_do_adb(*pval, tt, 1);\n            if (seqtt == NULL)\n                goto err;\n            if (seqtt-\u003eflags \u0026 ASN1_TFLG_OPTIONAL) {\n                ASN1_VALUE **pseqval;\n                pseqval = asn1_get_field_ptr(pval, seqtt);\n                asn1_template_free(pseqval, seqtt);\n            } else {\n                errtt = seqtt;\n                ERR_raise(ERR_LIB_ASN1, ASN1_R_FIELD_MISSING);\n                goto err;\n            }\n        }\n        /* Save encoding */\n        if (!asn1_enc_save(pval, *in, p - *in, it))\n            goto auxerr;\n        if (asn1_cb \u0026\u0026 !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))\n            goto auxerr;\n        *in = p;\n        return 1;\n\n    default:\n        return 0;\n    }\n auxerr:\n    ERR_raise(ERR_LIB_ASN1, ASN1_R_AUX_ERROR);\n err:\n    if (errtt)\n        ERR_add_error_data(4, \"Field=\", errtt-\u003efield_name,\n                           \", Type=\", it-\u003esname);\n    else\n        ERR_add_error_data(2, \"Type=\", it-\u003esname);\n    return 0;\n}","filepath":"crypto/asn1/tasn_dec.c","line_number":135,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269942304":{"score":0.8886467,"function_name":"asn1_template_ex_d2i","code":"static int asn1_template_ex_d2i(ASN1_VALUE **val,\n                                const unsigned char **in, long inlen,\n                                const ASN1_TEMPLATE *tt, char opt,\n                                ASN1_TLC *ctx, int depth)\n{\n    int flags, aclass;\n    int ret;\n    long len;\n    const unsigned char *p, *q;\n    char exp_eoc;\n    if (!val)\n        return 0;\n    flags = tt-\u003eflags;\n    aclass = flags \u0026 ASN1_TFLG_TAG_CLASS;\n\n    p = *in;\n\n    /* Check if EXPLICIT tag expected */\n    if (flags \u0026 ASN1_TFLG_EXPTAG) {\n        char cst;\n        /*\n         * Need to work out amount of data available to the inner content and\n         * where it starts: so read in EXPLICIT header to get the info.\n         */\n        ret = asn1_check_tlen(\u0026len, NULL, NULL, \u0026exp_eoc, \u0026cst,\n                              \u0026p, inlen, tt-\u003etag, aclass, opt, ctx);\n        q = p;\n        if (!ret) {\n            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);\n            return 0;\n        } else if (ret == -1)\n            return -1;\n        if (!cst) {\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED);\n            return 0;\n        }\n        /* We've found the field so it can't be OPTIONAL now */\n        ret = asn1_template_noexp_d2i(val, \u0026p, len, tt, 0, ctx, depth);\n        if (!ret) {\n            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);\n            return 0;\n        }\n        /* We read the field in OK so update length */\n        len -= p - q;\n        if (exp_eoc) {\n            /* If NDEF we must have an EOC here */\n            if (!asn1_check_eoc(\u0026p, len)) {\n                ERR_raise(ERR_LIB_ASN1, ASN1_R_MISSING_EOC);\n                goto err;\n            }\n        } else {\n            /*\n             * Otherwise we must hit the EXPLICIT tag end or its an error\n             */\n            if (len) {\n                ERR_raise(ERR_LIB_ASN1, ASN1_R_EXPLICIT_LENGTH_MISMATCH);\n                goto err;\n            }\n        }\n    } else\n        return asn1_template_noexp_d2i(val, in, inlen, tt, opt, ctx, depth);\n\n    *in = p;\n    return 1;\n\n err:\n    return 0;\n}","filepath":"crypto/asn1/tasn_dec.c","line_number":438,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269942672":{"score":0.8600046,"function_name":"asn1_template_noexp_d2i","code":"static int asn1_template_noexp_d2i(ASN1_VALUE **val,\n                                   const unsigned char **in, long len,\n                                   const ASN1_TEMPLATE *tt, char opt,\n                                   ASN1_TLC *ctx, int depth)\n{\n    int flags, aclass;\n    int ret;\n    ASN1_VALUE *tval;\n    const unsigned char *p, *q;\n    if (!val)\n        return 0;\n    flags = tt-\u003eflags;\n    aclass = flags \u0026 ASN1_TFLG_TAG_CLASS;\n\n    p = *in;\n    q = p;\n\n    /*\n     * If field is embedded then val needs fixing so it is a pointer to\n     * a pointer to a field.\n     */\n    if (tt-\u003eflags \u0026 ASN1_TFLG_EMBED) {\n        tval = (ASN1_VALUE *)val;\n        val = \u0026tval;\n    }\n\n    if (flags \u0026 ASN1_TFLG_SK_MASK) {\n        /* SET OF, SEQUENCE OF */\n        int sktag, skaclass;\n        char sk_eoc;\n        /* First work out expected inner tag value */\n        if (flags \u0026 ASN1_TFLG_IMPTAG) {\n            sktag = tt-\u003etag;\n            skaclass = aclass;\n        } else {\n            skaclass = V_ASN1_UNIVERSAL;\n            if (flags \u0026 ASN1_TFLG_SET_OF)\n                sktag = V_ASN1_SET;\n            else\n                sktag = V_ASN1_SEQUENCE;\n        }\n        /* Get the tag */\n        ret = asn1_check_tlen(\u0026len, NULL, NULL, \u0026sk_eoc, NULL,\n                              \u0026p, len, sktag, skaclass, opt, ctx);\n        if (!ret) {\n            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);\n            return 0;\n        } else if (ret == -1)\n            return -1;\n        if (*val == NULL)\n            *val = (ASN1_VALUE *)sk_ASN1_VALUE_new_null();\n        else {\n            /*\n             * We've got a valid STACK: free up any items present\n             */\n            STACK_OF(ASN1_VALUE) *sktmp = (STACK_OF(ASN1_VALUE) *)*val;\n            ASN1_VALUE *vtmp;\n            while (sk_ASN1_VALUE_num(sktmp) \u003e 0) {\n                vtmp = sk_ASN1_VALUE_pop(sktmp);\n                ASN1_item_ex_free(\u0026vtmp, ASN1_ITEM_ptr(tt-\u003eitem));\n            }\n        }\n\n        if (*val == NULL) {\n            ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        /* Read as many items as we can */\n        while (len \u003e 0) {\n            ASN1_VALUE *skfield;\n            q = p;\n            /* See if EOC found */\n            if (asn1_check_eoc(\u0026p, len)) {\n                if (!sk_eoc) {\n                    ERR_raise(ERR_LIB_ASN1, ASN1_R_UNEXPECTED_EOC);\n                    goto err;\n                }\n                len -= p - q;\n                sk_eoc = 0;\n                break;\n            }\n            skfield = NULL;\n            if (!asn1_item_embed_d2i(\u0026skfield, \u0026p, len,\n                                     ASN1_ITEM_ptr(tt-\u003eitem), -1, 0, 0, ctx,\n                                     depth)) {\n                ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);\n                /* |skfield| may be partially allocated despite failure. */\n                ASN1_item_free(skfield, ASN1_ITEM_ptr(tt-\u003eitem));\n                goto err;\n            }\n            len -= p - q;\n            if (!sk_ASN1_VALUE_push((STACK_OF(ASN1_VALUE) *)*val, skfield)) {\n                ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);\n                ASN1_item_free(skfield, ASN1_ITEM_ptr(tt-\u003eitem));\n                goto err;\n            }\n        }\n        if (sk_eoc) {\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_MISSING_EOC);\n            goto err;\n        }\n    } else if (flags \u0026 ASN1_TFLG_IMPTAG) {\n        /* IMPLICIT tagging */\n        ret = asn1_item_embed_d2i(val, \u0026p, len,\n                                  ASN1_ITEM_ptr(tt-\u003eitem), tt-\u003etag, aclass, opt,\n                                  ctx, depth);\n        if (!ret) {\n            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        } else if (ret == -1)\n            return -1;\n    } else {\n        /* Nothing special */\n        ret = asn1_item_embed_d2i(val, \u0026p, len, ASN1_ITEM_ptr(tt-\u003eitem),\n                                  -1, 0, opt, ctx, depth);\n        if (!ret) {\n            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);\n            goto err;\n        } else if (ret == -1)\n            return -1;\n    }\n\n    *in = p;\n    return 1;\n\n err:\n    return 0;\n}","filepath":"crypto/asn1/tasn_dec.c","line_number":507,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269943360":{"score":0.9290384,"function_name":"ASN1_item_ex_i2d","code":"int ASN1_item_ex_i2d(const ASN1_VALUE **pval, unsigned char **out,\n                     const ASN1_ITEM *it, int tag, int aclass)\n{\n    const ASN1_TEMPLATE *tt = NULL;\n    int i, seqcontlen, seqlen, ndef = 1;\n    const ASN1_EXTERN_FUNCS *ef;\n    const ASN1_AUX *aux = it-\u003efuncs;\n    ASN1_aux_const_cb *asn1_cb = NULL;\n\n    if ((it-\u003eitype != ASN1_ITYPE_PRIMITIVE) \u0026\u0026 *pval == NULL)\n        return 0;\n\n    if (aux != NULL) {\n        asn1_cb = ((aux-\u003eflags \u0026 ASN1_AFLG_CONST_CB) != 0) ? aux-\u003easn1_const_cb\n            : (ASN1_aux_const_cb *)aux-\u003easn1_cb; /* backward compatibility */\n    }\n\n    switch (it-\u003eitype) {\n\n    case ASN1_ITYPE_PRIMITIVE:\n        if (it-\u003etemplates)\n            return asn1_template_ex_i2d(pval, out, it-\u003etemplates,\n                                        tag, aclass);\n        return asn1_i2d_ex_primitive(pval, out, it, tag, aclass);\n\n    case ASN1_ITYPE_MSTRING:\n        return asn1_i2d_ex_primitive(pval, out, it, -1, aclass);\n\n    case ASN1_ITYPE_CHOICE:\n        if (asn1_cb \u0026\u0026 !asn1_cb(ASN1_OP_I2D_PRE, pval, it, NULL))\n            return 0;\n        i = asn1_get_choice_selector_const(pval, it);\n        if ((i \u003e= 0) \u0026\u0026 (i \u003c it-\u003etcount)) {\n            const ASN1_VALUE **pchval;\n            const ASN1_TEMPLATE *chtt;\n            chtt = it-\u003etemplates + i;\n            pchval = asn1_get_const_field_ptr(pval, chtt);\n            return asn1_template_ex_i2d(pchval, out, chtt, -1, aclass);\n        }\n        /* Fixme: error condition if selector out of range */\n        if (asn1_cb \u0026\u0026 !asn1_cb(ASN1_OP_I2D_POST, pval, it, NULL))\n            return 0;\n        break;\n\n    case ASN1_ITYPE_EXTERN:\n        /* If new style i2d it does all the work */\n        ef = it-\u003efuncs;\n        return ef-\u003easn1_ex_i2d(pval, out, it, tag, aclass);\n\n    case ASN1_ITYPE_NDEF_SEQUENCE:\n        /* Use indefinite length constructed if requested */\n        if (aclass \u0026 ASN1_TFLG_NDEF)\n            ndef = 2;\n        /* fall through */\n\n    case ASN1_ITYPE_SEQUENCE:\n        i = asn1_enc_restore(\u0026seqcontlen, out, pval, it);\n        /* An error occurred */\n        if (i \u003c 0)\n            return 0;\n        /* We have a valid cached encoding... */\n        if (i \u003e 0)\n            return seqcontlen;\n        /* Otherwise carry on */\n        seqcontlen = 0;\n        /* If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL */\n        if (tag == -1) {\n            tag = V_ASN1_SEQUENCE;\n            /* Retain any other flags in aclass */\n            aclass = (aclass \u0026 ~ASN1_TFLG_TAG_CLASS)\n                | V_ASN1_UNIVERSAL;\n        }\n        if (asn1_cb \u0026\u0026 !asn1_cb(ASN1_OP_I2D_PRE, pval, it, NULL))\n            return 0;\n        /* First work out sequence content length */\n        for (i = 0, tt = it-\u003etemplates; i \u003c it-\u003etcount; tt++, i++) {\n            const ASN1_TEMPLATE *seqtt;\n            const ASN1_VALUE **pseqval;\n            int tmplen;\n            seqtt = asn1_do_adb(*pval, tt, 1);\n            if (!seqtt)\n                return 0;\n            pseqval = asn1_get_const_field_ptr(pval, seqtt);\n            tmplen = asn1_template_ex_i2d(pseqval, NULL, seqtt, -1, aclass);\n            if (tmplen == -1 || (tmplen \u003e INT_MAX - seqcontlen))\n                return -1;\n            seqcontlen += tmplen;\n        }\n\n        seqlen = ASN1_object_size(ndef, seqcontlen, tag);\n        if (!out || seqlen == -1)\n            return seqlen;\n        /* Output SEQUENCE header */\n        ASN1_put_object(out, ndef, seqcontlen, tag, aclass);\n        for (i = 0, tt = it-\u003etemplates; i \u003c it-\u003etcount; tt++, i++) {\n            const ASN1_TEMPLATE *seqtt;\n            const ASN1_VALUE **pseqval;\n            seqtt = asn1_do_adb(*pval, tt, 1);\n            if (!seqtt)\n                return 0;\n            pseqval = asn1_get_const_field_ptr(pval, seqtt);\n            /* FIXME: check for errors in enhanced version */\n            asn1_template_ex_i2d(pseqval, out, seqtt, -1, aclass);\n        }\n        if (ndef == 2)\n            ASN1_put_eoc(out);\n        if (asn1_cb \u0026\u0026 !asn1_cb(ASN1_OP_I2D_POST, pval, it, NULL))\n            return 0;\n        return seqlen;\n\n    default:\n        return 0;\n\n    }\n    return 0;\n}","filepath":"crypto/asn1/tasn_enc.c","line_number":83,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"269944192":{"score":0.9270278,"function_name":"asn1_ex_i2c","code":"static int asn1_ex_i2c(const ASN1_VALUE **pval, unsigned char *cout, int *putype,\n                       const ASN1_ITEM *it)\n{\n    ASN1_BOOLEAN *tbool = NULL;\n    ASN1_STRING *strtmp;\n    ASN1_OBJECT *otmp;\n    int utype;\n    const unsigned char *cont;\n    unsigned char c;\n    int len;\n    const ASN1_PRIMITIVE_FUNCS *pf;\n    pf = it-\u003efuncs;\n    if (pf \u0026\u0026 pf-\u003eprim_i2c)\n        return pf-\u003eprim_i2c(pval, cout, putype, it);\n\n    /* Should type be omitted? */\n    if ((it-\u003eitype != ASN1_ITYPE_PRIMITIVE)\n        || (it-\u003eutype != V_ASN1_BOOLEAN)) {\n        if (*pval == NULL)\n            return -1;\n    }\n\n    if (it-\u003eitype == ASN1_ITYPE_MSTRING) {\n        /* If MSTRING type set the underlying type */\n        strtmp = (ASN1_STRING *)*pval;\n        utype = strtmp-\u003etype;\n        *putype = utype;\n    } else if (it-\u003eutype == V_ASN1_ANY) {\n        /* If ANY set type and pointer to value */\n        ASN1_TYPE *typ;\n        typ = (ASN1_TYPE *)*pval;\n        utype = typ-\u003etype;\n        *putype = utype;\n        pval = (const ASN1_VALUE **)\u0026typ-\u003evalue.asn1_value; /* actually is const */\n    } else\n        utype = *putype;\n\n    switch (utype) {\n    case V_ASN1_OBJECT:\n        otmp = (ASN1_OBJECT *)*pval;\n        cont = otmp-\u003edata;\n        len = otmp-\u003elength;\n        if (cont == NULL || len == 0)\n            return -1;\n        break;\n\n    case V_ASN1_NULL:\n        cont = NULL;\n        len = 0;\n        break;\n\n    case V_ASN1_BOOLEAN:\n        tbool = (ASN1_BOOLEAN *)pval;\n        if (*tbool == -1)\n            return -1;\n        if (it-\u003eutype != V_ASN1_ANY) {\n            /*\n             * Default handling if value == size field then omit\n             */\n            if (*tbool \u0026\u0026 (it-\u003esize \u003e 0))\n                return -1;\n            if (!*tbool \u0026\u0026 !it-\u003esize)\n                return -1;\n        }\n        c = (unsigned char)*tbool;\n        cont = \u0026c;\n        len = 1;\n        break;\n\n    case V_ASN1_BIT_STRING:\n        return i2c_ASN1_BIT_STRING((ASN1_BIT_STRING *)*pval,\n                                   cout ? \u0026cout : NULL);\n\n    case V_ASN1_INTEGER:\n    case V_ASN1_ENUMERATED:\n        /*\n         * These are all have the same content format as ASN1_INTEGER\n         */\n        return i2c_ASN1_INTEGER((ASN1_INTEGER *)*pval, cout ? \u0026cout : NULL);\n\n    case V_ASN1_OCTET_STRING:\n    case V_ASN1_NUMERICSTRING:\n    case V_ASN1_PRINTABLESTRING:\n    case V_ASN1_T61STRING:\n    case V_ASN1_VIDEOTEXSTRING:\n    case V_ASN1_IA5STRING:\n    case V_ASN1_UTCTIME:\n    case V_ASN1_GENERALIZEDTIME:\n    case V_ASN1_GRAPHICSTRING:\n    case V_ASN1_VISIBLESTRING:\n    case V_ASN1_GENERALSTRING:\n    case V_ASN1_UNIVERSALSTRING:\n    case V_ASN1_BMPSTRING:\n    case V_ASN1_UTF8STRING:\n    case V_ASN1_SEQUENCE:\n    case V_ASN1_SET:\n    default:\n        /* All based on ASN1_STRING and handled the same */\n        strtmp = (ASN1_STRING *)*pval;\n        /* Special handling for NDEF */\n        if ((it-\u003esize == ASN1_TFLG_NDEF)\n            \u0026\u0026 (strtmp-\u003eflags \u0026 ASN1_STRING_FLAG_NDEF)) {\n            if (cout) {\n                strtmp-\u003edata = cout;\n                strtmp-\u003elength = 0;\n            }\n            /* Special return code */\n            return -2;\n        }\n        cont = strtmp-\u003edata;\n        len = strtmp-\u003elength;\n\n        break;\n\n    }\n    if (cout \u0026\u0026 len)\n        memcpy(cout, cont, len);\n    return len;\n}","filepath":"crypto/asn1/tasn_enc.c","line_number":495,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"269944560":{"score":0.9370209,"function_name":"asn1_i2d_ex_primitive","code":"static int asn1_i2d_ex_primitive(const ASN1_VALUE **pval, unsigned char **out,\n                                 const ASN1_ITEM *it, int tag, int aclass)\n{\n    int len;\n    int utype;\n    int usetag;\n    int ndef = 0;\n\n    utype = it-\u003eutype;\n\n    /*\n     * Get length of content octets and maybe find out the underlying type.\n     */\n\n    len = asn1_ex_i2c(pval, NULL, \u0026utype, it);\n\n    /*\n     * If SEQUENCE, SET or OTHER then header is included in pseudo content\n     * octets so don't include tag+length. We need to check here because the\n     * call to asn1_ex_i2c() could change utype.\n     */\n    if ((utype == V_ASN1_SEQUENCE) || (utype == V_ASN1_SET) ||\n        (utype == V_ASN1_OTHER))\n        usetag = 0;\n    else\n        usetag = 1;\n\n    /* -1 means omit type */\n\n    if (len == -1)\n        return 0;\n\n    /* -2 return is special meaning use ndef */\n    if (len == -2) {\n        ndef = 2;\n        len = 0;\n    }\n\n    /* If not implicitly tagged get tag from underlying type */\n    if (tag == -1)\n        tag = utype;\n\n    /* Output tag+length followed by content octets */\n    if (out) {\n        if (usetag)\n            ASN1_put_object(out, ndef, len, tag, aclass);\n        asn1_ex_i2c(pval, *out, \u0026utype, it);\n        if (ndef)\n            ASN1_put_eoc(out);\n        else\n            *out += len;\n    }\n\n    if (usetag)\n        return ASN1_object_size(ndef, len, tag);\n    return len;\n}","filepath":"crypto/asn1/tasn_enc.c","line_number":435,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"269944800":{"score":0.92742753,"function_name":"asn1_item_flags_i2d","code":"static int asn1_item_flags_i2d(const ASN1_VALUE *val, unsigned char **out,\n                               const ASN1_ITEM *it, int flags)\n{\n    if (out != NULL \u0026\u0026 *out == NULL) {\n        unsigned char *p, *buf;\n        int len;\n\n        len = ASN1_item_ex_i2d(\u0026val, NULL, it, -1, flags);\n        if (len \u003c= 0)\n            return len;\n        if ((buf = OPENSSL_malloc(len)) == NULL) {\n            ASN1err(ASN1_F_ASN1_ITEM_FLAGS_I2D, ERR_R_MALLOC_FAILURE);\n            return -1;\n        }\n        p = buf;\n        ASN1_item_ex_i2d(\u0026val, \u0026p, it, -1, flags);\n        *out = buf;\n        return len;\n    }\n\n    return ASN1_item_ex_i2d(\u0026val, out, it, -1, flags);\n}","filepath":"crypto/asn1/tasn_enc.c","line_number":55,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"269944976":{"score":0.8733588,"function_name":"asn1_set_seq_out","code":"static int asn1_set_seq_out(STACK_OF(const_ASN1_VALUE) *sk,\n                            unsigned char **out,\n                            int skcontlen, const ASN1_ITEM *item,\n                            int do_sort, int iclass)\n{\n    int i;\n    const ASN1_VALUE *skitem;\n    unsigned char *tmpdat = NULL, *p = NULL;\n    DER_ENC *derlst = NULL, *tder;\n    if (do_sort) {\n        /* Don't need to sort less than 2 items */\n        if (sk_const_ASN1_VALUE_num(sk) \u003c 2)\n            do_sort = 0;\n        else {\n            derlst = OPENSSL_malloc(sk_const_ASN1_VALUE_num(sk)\n                                    * sizeof(*derlst));\n            if (derlst == NULL)\n                return 0;\n            tmpdat = OPENSSL_malloc(skcontlen);\n            if (tmpdat == NULL) {\n                OPENSSL_free(derlst);\n                return 0;\n            }\n        }\n    }\n    /* If not sorting just output each item */\n    if (!do_sort) {\n        for (i = 0; i \u003c sk_const_ASN1_VALUE_num(sk); i++) {\n            skitem = sk_const_ASN1_VALUE_value(sk, i);\n            ASN1_item_ex_i2d(\u0026skitem, out, item, -1, iclass);\n        }\n        return 1;\n    }\n    p = tmpdat;\n\n    /* Doing sort: build up a list of each member's DER encoding */\n    for (i = 0, tder = derlst; i \u003c sk_const_ASN1_VALUE_num(sk); i++, tder++) {\n        skitem = sk_const_ASN1_VALUE_value(sk, i);\n        tder-\u003edata = p;\n        tder-\u003elength = ASN1_item_ex_i2d(\u0026skitem, \u0026p, item, -1, iclass);\n        tder-\u003efield = skitem;\n    }\n\n    /* Now sort them */\n    qsort(derlst, sk_const_ASN1_VALUE_num(sk), sizeof(*derlst), der_cmp);\n    /* Output sorted DER encoding */\n    p = *out;\n    for (i = 0, tder = derlst; i \u003c sk_const_ASN1_VALUE_num(sk); i++, tder++) {\n        memcpy(p, tder-\u003edata, tder-\u003elength);\n        p += tder-\u003elength;\n    }\n    *out = p;\n    /* If do_sort is 2 then reorder the STACK */\n    if (do_sort == 2) {\n        for (i = 0, tder = derlst; i \u003c sk_const_ASN1_VALUE_num(sk); i++, tder++)\n            (void)sk_const_ASN1_VALUE_set(sk, i, tder-\u003efield);\n    }\n    OPENSSL_free(derlst);\n    OPENSSL_free(tmpdat);\n    return 1;\n}","filepath":"crypto/asn1/tasn_enc.c","line_number":373,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"269945520":{"score":0.88244057,"function_name":"asn1_template_ex_i2d","code":"static int asn1_template_ex_i2d(const ASN1_VALUE **pval, unsigned char **out,\n                                const ASN1_TEMPLATE *tt, int tag, int iclass)\n{\n    int i, ret, flags, ttag, tclass, ndef;\n    const ASN1_VALUE *tval;\n    flags = tt-\u003eflags;\n\n    /*\n     * If field is embedded then val needs fixing so it is a pointer to\n     * a pointer to a field.\n     */\n    if (flags \u0026 ASN1_TFLG_EMBED) {\n        tval = (ASN1_VALUE *)pval;\n        pval = \u0026tval;\n    }\n    /*\n     * Work out tag and class to use: tagging may come either from the\n     * template or the arguments, not both because this would create\n     * ambiguity. Additionally the iclass argument may contain some\n     * additional flags which should be noted and passed down to other\n     * levels.\n     */\n    if (flags \u0026 ASN1_TFLG_TAG_MASK) {\n        /* Error if argument and template tagging */\n        if (tag != -1)\n            /* FIXME: error code here */\n            return -1;\n        /* Get tagging from template */\n        ttag = tt-\u003etag;\n        tclass = flags \u0026 ASN1_TFLG_TAG_CLASS;\n    } else if (tag != -1) {\n        /* No template tagging, get from arguments */\n        ttag = tag;\n        tclass = iclass \u0026 ASN1_TFLG_TAG_CLASS;\n    } else {\n        ttag = -1;\n        tclass = 0;\n    }\n    /*\n     * Remove any class mask from iflag.\n     */\n    iclass \u0026= ~ASN1_TFLG_TAG_CLASS;\n\n    /*\n     * At this point 'ttag' contains the outer tag to use, 'tclass' is the\n     * class and iclass is any flags passed to this function.\n     */\n\n    /* if template and arguments require ndef, use it */\n    if ((flags \u0026 ASN1_TFLG_NDEF) \u0026\u0026 (iclass \u0026 ASN1_TFLG_NDEF))\n        ndef = 2;\n    else\n        ndef = 1;\n\n    if (flags \u0026 ASN1_TFLG_SK_MASK) {\n        /* SET OF, SEQUENCE OF */\n        STACK_OF(const_ASN1_VALUE) *sk = (STACK_OF(const_ASN1_VALUE) *)*pval;\n        int isset, sktag, skaclass;\n        int skcontlen, sklen;\n        const ASN1_VALUE *skitem;\n\n        if (*pval == NULL)\n            return 0;\n\n        if (flags \u0026 ASN1_TFLG_SET_OF) {\n            isset = 1;\n            /* 2 means we reorder */\n            if (flags \u0026 ASN1_TFLG_SEQUENCE_OF)\n                isset = 2;\n        } else\n            isset = 0;\n\n        /*\n         * Work out inner tag value: if EXPLICIT or no tagging use underlying\n         * type.\n         */\n        if ((ttag != -1) \u0026\u0026 !(flags \u0026 ASN1_TFLG_EXPTAG)) {\n            sktag = ttag;\n            skaclass = tclass;\n        } else {\n            skaclass = V_ASN1_UNIVERSAL;\n            if (isset)\n                sktag = V_ASN1_SET;\n            else\n                sktag = V_ASN1_SEQUENCE;\n        }\n\n        /* Determine total length of items */\n        skcontlen = 0;\n        for (i = 0; i \u003c sk_const_ASN1_VALUE_num(sk); i++) {\n            int tmplen;\n            skitem = sk_const_ASN1_VALUE_value(sk, i);\n            tmplen = ASN1_item_ex_i2d(\u0026skitem, NULL, ASN1_ITEM_ptr(tt-\u003eitem),\n                                      -1, iclass);\n            if (tmplen == -1 || (skcontlen \u003e INT_MAX - tmplen))\n                return -1;\n            skcontlen += tmplen;\n        }\n        sklen = ASN1_object_size(ndef, skcontlen, sktag);\n        if (sklen == -1)\n            return -1;\n        /* If EXPLICIT need length of surrounding tag */\n        if (flags \u0026 ASN1_TFLG_EXPTAG)\n            ret = ASN1_object_size(ndef, sklen, ttag);\n        else\n            ret = sklen;\n\n        if (!out || ret == -1)\n            return ret;\n\n        /* Now encode this lot... */\n        /* EXPLICIT tag */\n        if (flags \u0026 ASN1_TFLG_EXPTAG)\n            ASN1_put_object(out, ndef, sklen, ttag, tclass);\n        /* SET or SEQUENCE and IMPLICIT tag */\n        ASN1_put_object(out, ndef, skcontlen, sktag, skaclass);\n        /* And the stuff itself */\n        asn1_set_seq_out(sk, out, skcontlen, ASN1_ITEM_ptr(tt-\u003eitem),\n                         isset, iclass);\n        if (ndef == 2) {\n            ASN1_put_eoc(out);\n            if (flags \u0026 ASN1_TFLG_EXPTAG)\n                ASN1_put_eoc(out);\n        }\n\n        return ret;\n    }\n\n    if (flags \u0026 ASN1_TFLG_EXPTAG) {\n        /* EXPLICIT tagging */\n        /* Find length of tagged item */\n        i = ASN1_item_ex_i2d(pval, NULL, ASN1_ITEM_ptr(tt-\u003eitem), -1, iclass);\n        if (!i)\n            return 0;\n        /* Find length of EXPLICIT tag */\n        ret = ASN1_object_size(ndef, i, ttag);\n        if (out \u0026\u0026 ret != -1) {\n            /* Output tag and item */\n            ASN1_put_object(out, ndef, i, ttag, tclass);\n            ASN1_item_ex_i2d(pval, out, ASN1_ITEM_ptr(tt-\u003eitem), -1, iclass);\n            if (ndef == 2)\n                ASN1_put_eoc(out);\n        }\n        return ret;\n    }\n\n    /* Either normal or IMPLICIT tagging: combine class and flags */\n    return ASN1_item_ex_i2d(pval, out, ASN1_ITEM_ptr(tt-\u003eitem),\n                            ttag, tclass | iclass);\n\n}","filepath":"crypto/asn1/tasn_enc.c","line_number":200,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"269956080":{"score":0.76022327,"function_name":"ecx_pub_decode","code":"static int ecx_pub_decode(EVP_PKEY *pkey, X509_PUBKEY *pubkey)\n{\n    const unsigned char *p;\n    int pklen;\n    X509_ALGOR *palg;\n\n    if (!X509_PUBKEY_get0_param(NULL, \u0026p, \u0026pklen, \u0026palg, pubkey))\n        return 0;\n    return ecx_key_op(pkey, pkey-\u003eameth-\u003epkey_id, palg, p, pklen,\n                      KEY_OP_PUBLIC);\n}","filepath":"crypto/ec/ecx_meth.c","line_number":149,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre5"},"269956272":{"score":0.86931616,"function_name":"ecx_priv_decode","code":"static int ecx_priv_decode(EVP_PKEY *pkey, const PKCS8_PRIV_KEY_INFO *p8)\n{\n    const unsigned char *p;\n    int plen;\n    ASN1_OCTET_STRING *oct = NULL;\n    const X509_ALGOR *palg;\n    int rv;\n\n    if (!PKCS8_pkey_get0(NULL, \u0026p, \u0026plen, \u0026palg, p8))\n        return 0;\n\n    oct = d2i_ASN1_OCTET_STRING(NULL, \u0026p, plen);\n    if (oct == NULL) {\n        p = NULL;\n        plen = 0;\n    } else {\n        p = ASN1_STRING_get0_data(oct);\n        plen = ASN1_STRING_length(oct);\n    }\n\n    rv = ecx_key_op(pkey, pkey-\u003eameth-\u003epkey_id, palg, p, plen, KEY_OP_PRIVATE);\n    ASN1_OCTET_STRING_free(oct);\n    return rv;\n}","filepath":"crypto/ec/ecx_meth.c","line_number":172,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre5"},"269956432":{"score":0.90012884,"function_name":"ecx_priv_encode","code":"static int ecx_priv_encode(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pkey)\n{\n    const ECX_KEY *ecxkey = pkey-\u003epkey.ecx;\n    ASN1_OCTET_STRING oct;\n    unsigned char *penc = NULL;\n    int penclen;\n\n    if (ecxkey == NULL || ecxkey-\u003eprivkey == NULL) {\n        ECerr(EC_F_ECX_PRIV_ENCODE, EC_R_INVALID_PRIVATE_KEY);\n        return 0;\n    }\n\n    oct.data = ecxkey-\u003eprivkey;\n    oct.length = KEYLEN(pkey);\n    oct.flags = 0;\n\n    penclen = i2d_ASN1_OCTET_STRING(\u0026oct, \u0026penc);\n    if (penclen \u003c 0) {\n        ECerr(EC_F_ECX_PRIV_ENCODE, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n\n    if (!PKCS8_pkey_set0(p8, OBJ_nid2obj(pkey-\u003eameth-\u003epkey_id), 0,\n                         V_ASN1_UNDEF, NULL, penc, penclen)) {\n        OPENSSL_clear_free(penc, penclen);\n        ECerr(EC_F_ECX_PRIV_ENCODE, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n\n    return 1;\n}","filepath":"crypto/ec/ecx_meth.c","line_number":197,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre5"},"269958096":{"score":0.8978796,"function_name":"ecd_item_verify","code":"static int ecd_item_verify(EVP_MD_CTX *ctx, const ASN1_ITEM *it, void *asn,\n                           X509_ALGOR *sigalg, ASN1_BIT_STRING *str,\n                           EVP_PKEY *pkey)\n{\n    const ASN1_OBJECT *obj;\n    int ptype;\n    int nid;\n\n    /* Sanity check: make sure it is ED25519/ED448 with absent parameters */\n    X509_ALGOR_get0(\u0026obj, \u0026ptype, NULL, sigalg);\n    nid = OBJ_obj2nid(obj);\n    if ((nid != NID_ED25519 \u0026\u0026 nid != NID_ED448) || ptype != V_ASN1_UNDEF) {\n        ECerr(EC_F_ECD_ITEM_VERIFY, EC_R_INVALID_ENCODING);\n        return 0;\n    }\n\n    if (!EVP_DigestVerifyInit(ctx, NULL, NULL, NULL, pkey))\n        return 0;\n\n    return 2;\n}","filepath":"crypto/ec/ecx_meth.c","line_number":449,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre5"},"269958608":{"score":0.85812527,"function_name":"pkey_ecx_derive448","code":"static int pkey_ecx_derive448(EVP_PKEY_CTX *ctx, unsigned char *key,\n                              size_t *keylen)\n{\n    const unsigned char *privkey, *pubkey;\n\n    if (!validate_ecx_derive(ctx, key, keylen, \u0026privkey, \u0026pubkey)\n            || (key != NULL\n                \u0026\u0026 X448(key, privkey, pubkey) == 0))\n        return 0;\n    *keylen = X448_KEYLEN;\n    return 1;\n}","filepath":"crypto/ec/ecx_meth.c","line_number":637,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre5"},"269959184":{"score":0.90799916,"function_name":"ecx_key_op","code":"static int ecx_key_op(EVP_PKEY *pkey, int id, const X509_ALGOR *palg,\n                      const unsigned char *p, int plen, ecx_key_op_t op)\n{\n    ECX_KEY *key = NULL;\n    unsigned char *privkey, *pubkey;\n\n    if (op != KEY_OP_KEYGEN) {\n        if (palg != NULL) {\n            int ptype;\n\n            /* Algorithm parameters must be absent */\n            X509_ALGOR_get0(NULL, \u0026ptype, NULL, palg);\n            if (ptype != V_ASN1_UNDEF) {\n                ECerr(EC_F_ECX_KEY_OP, EC_R_INVALID_ENCODING);\n                return 0;\n            }\n        }\n\n        if (p == NULL || plen != KEYLENID(id)) {\n            ECerr(EC_F_ECX_KEY_OP, EC_R_INVALID_ENCODING);\n            return 0;\n        }\n    }\n\n    key = OPENSSL_zalloc(sizeof(*key));\n    if (key == NULL) {\n        ECerr(EC_F_ECX_KEY_OP, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n    pubkey = key-\u003epubkey;\n\n    if (op == KEY_OP_PUBLIC) {\n        memcpy(pubkey, p, plen);\n    } else {\n        privkey = key-\u003eprivkey = OPENSSL_secure_malloc(KEYLENID(id));\n        if (privkey == NULL) {\n            ECerr(EC_F_ECX_KEY_OP, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        if (op == KEY_OP_KEYGEN) {\n            if (RAND_priv_bytes(privkey, KEYLENID(id)) \u003c= 0) {\n                OPENSSL_secure_free(privkey);\n                key-\u003eprivkey = NULL;\n                goto err;\n            }\n            if (id == EVP_PKEY_X25519) {\n                privkey[0] \u0026= 248;\n                privkey[X25519_KEYLEN - 1] \u0026= 127;\n                privkey[X25519_KEYLEN - 1] |= 64;\n            } else if (id == EVP_PKEY_X448) {\n                privkey[0] \u0026= 252;\n                privkey[X448_KEYLEN - 1] |= 128;\n            }\n        } else {\n            memcpy(privkey, p, KEYLENID(id));\n        }\n        switch (id) {\n        case EVP_PKEY_X25519:\n            X25519_public_from_private(pubkey, privkey);\n            break;\n        case EVP_PKEY_ED25519:\n            ED25519_public_from_private(pubkey, privkey);\n            break;\n        case EVP_PKEY_X448:\n            X448_public_from_private(pubkey, privkey);\n            break;\n        case EVP_PKEY_ED448:\n            ED448_public_from_private(pubkey, privkey);\n            break;\n        }\n    }\n\n    EVP_PKEY_assign(pkey, id, key);\n    return 1;\n err:\n    OPENSSL_free(key);\n    return 0;\n}","filepath":"crypto/ec/ecx_meth.c","line_number":45,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre5"},"269959856":{"score":0.9175773,"function_name":"ecx_key_print","code":"static int ecx_key_print(BIO *bp, const EVP_PKEY *pkey, int indent,\n                         ASN1_PCTX *ctx, ecx_key_op_t op)\n{\n    const ECX_KEY *ecxkey = pkey-\u003epkey.ecx;\n    const char *nm = OBJ_nid2ln(pkey-\u003eameth-\u003epkey_id);\n\n    if (op == KEY_OP_PRIVATE) {\n        if (ecxkey == NULL || ecxkey-\u003eprivkey == NULL) {\n            if (BIO_printf(bp, \"%*s\u003cINVALID PRIVATE KEY\u003e\\n\", indent, \"\") \u003c= 0)\n                return 0;\n            return 1;\n        }\n        if (BIO_printf(bp, \"%*s%s Private-Key:\\n\", indent, \"\", nm) \u003c= 0)\n            return 0;\n        if (BIO_printf(bp, \"%*spriv:\\n\", indent, \"\") \u003c= 0)\n            return 0;\n        if (ASN1_buf_print(bp, ecxkey-\u003eprivkey, KEYLEN(pkey),\n                           indent + 4) == 0)\n            return 0;\n    } else {\n        if (ecxkey == NULL) {\n            if (BIO_printf(bp, \"%*s\u003cINVALID PUBLIC KEY\u003e\\n\", indent, \"\") \u003c= 0)\n                return 0;\n            return 1;\n        }\n        if (BIO_printf(bp, \"%*s%s Public-Key:\\n\", indent, \"\", nm) \u003c= 0)\n            return 0;\n    }\n    if (BIO_printf(bp, \"%*spub:\\n\", indent, \"\") \u003c= 0)\n        return 0;\n\n    if (ASN1_buf_print(bp, ecxkey-\u003epubkey, KEYLEN(pkey),\n                       indent + 4) == 0)\n        return 0;\n    return 1;\n}","filepath":"crypto/ec/ecx_meth.c","line_number":267,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre5"},"269960224":{"score":0.9191085,"function_name":"validate_ecx_derive","code":"static int validate_ecx_derive(EVP_PKEY_CTX *ctx, unsigned char *key,\n                                          size_t *keylen,\n                                          const unsigned char **privkey,\n                                          const unsigned char **pubkey)\n{\n    const ECX_KEY *ecxkey, *peerkey;\n\n    if (ctx-\u003epkey == NULL || ctx-\u003epeerkey == NULL) {\n        ECerr(EC_F_VALIDATE_ECX_DERIVE, EC_R_KEYS_NOT_SET);\n        return 0;\n    }\n    ecxkey = ctx-\u003epkey-\u003epkey.ecx;\n    peerkey = ctx-\u003epeerkey-\u003epkey.ecx;\n    if (ecxkey == NULL || ecxkey-\u003eprivkey == NULL) {\n        ECerr(EC_F_VALIDATE_ECX_DERIVE, EC_R_INVALID_PRIVATE_KEY);\n        return 0;\n    }\n    if (peerkey == NULL) {\n        ECerr(EC_F_VALIDATE_ECX_DERIVE, EC_R_INVALID_PEER_KEY);\n        return 0;\n    }\n    *privkey = ecxkey-\u003eprivkey;\n    *pubkey = peerkey-\u003epubkey;\n\n    return 1;\n}","filepath":"crypto/ec/ecx_meth.c","line_number":597,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre5"},"269970160":{"score":0.7992486,"function_name":"tls1_prf_P_hash","code":"static int tls1_prf_P_hash(const EVP_MD *md,\n                           const unsigned char *sec, size_t sec_len,\n                           const unsigned char *seed, size_t seed_len,\n                           unsigned char *out, size_t olen)\n{\n    int chunk;\n    EVP_MD_CTX *ctx = NULL, *ctx_tmp = NULL, *ctx_init = NULL;\n    EVP_PKEY *mac_key = NULL;\n    unsigned char A1[EVP_MAX_MD_SIZE];\n    size_t A1_len;\n    int ret = 0;\n\n    chunk = EVP_MD_size(md);\n    if (!ossl_assert(chunk \u003e 0))\n        goto err;\n\n    ctx = EVP_MD_CTX_new();\n    ctx_tmp = EVP_MD_CTX_new();\n    ctx_init = EVP_MD_CTX_new();\n    if (ctx == NULL || ctx_tmp == NULL || ctx_init == NULL)\n        goto err;\n    EVP_MD_CTX_set_flags(ctx_init, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);\n    mac_key = EVP_PKEY_new_raw_private_key(EVP_PKEY_HMAC, NULL, sec, sec_len);\n    if (mac_key == NULL)\n        goto err;\n    if (!EVP_DigestSignInit(ctx_init, NULL, md, NULL, mac_key))\n        goto err;\n    if (!EVP_MD_CTX_copy_ex(ctx, ctx_init))\n        goto err;\n    if (seed != NULL \u0026\u0026 !EVP_DigestSignUpdate(ctx, seed, seed_len))\n        goto err;\n    if (!EVP_DigestSignFinal(ctx, A1, \u0026A1_len))\n        goto err;\n\n    for (;;) {\n        /* Reinit mac contexts */\n        if (!EVP_MD_CTX_copy_ex(ctx, ctx_init))\n            goto err;\n        if (!EVP_DigestSignUpdate(ctx, A1, A1_len))\n            goto err;\n        if (olen \u003e (size_t)chunk \u0026\u0026 !EVP_MD_CTX_copy_ex(ctx_tmp, ctx))\n            goto err;\n        if (seed \u0026\u0026 !EVP_DigestSignUpdate(ctx, seed, seed_len))\n            goto err;\n\n        if (olen \u003e (size_t)chunk) {\n            size_t mac_len;\n            if (!EVP_DigestSignFinal(ctx, out, \u0026mac_len))\n                goto err;\n            out += mac_len;\n            olen -= mac_len;\n            /* calc the next A1 value */\n            if (!EVP_DigestSignFinal(ctx_tmp, A1, \u0026A1_len))\n                goto err;\n        } else {                /* last one */\n\n            if (!EVP_DigestSignFinal(ctx, A1, \u0026A1_len))\n                goto err;\n            memcpy(out, A1, olen);\n            break;\n        }\n    }\n    ret = 1;\n err:\n    EVP_PKEY_free(mac_key);\n    EVP_MD_CTX_free(ctx);\n    EVP_MD_CTX_free(ctx_tmp);\n    EVP_MD_CTX_free(ctx_init);\n    OPENSSL_cleanse(A1, sizeof(A1));\n    return ret;\n}","filepath":"crypto/kdf/tls1_prf.c","line_number":175,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre5"},"269970768":{"score":0.9130374,"function_name":"tls1_prf_alg","code":"static int tls1_prf_alg(const EVP_MD *md,\n                        const unsigned char *sec, size_t slen,\n                        const unsigned char *seed, size_t seed_len,\n                        unsigned char *out, size_t olen)\n{\n\n    if (EVP_MD_type(md) == NID_md5_sha1) {\n        size_t i;\n        unsigned char *tmp;\n        if (!tls1_prf_P_hash(EVP_md5(), sec, slen/2 + (slen \u0026 1),\n                         seed, seed_len, out, olen))\n            return 0;\n\n        if ((tmp = OPENSSL_malloc(olen)) == NULL) {\n            KDFerr(KDF_F_TLS1_PRF_ALG, ERR_R_MALLOC_FAILURE);\n            return 0;\n        }\n        if (!tls1_prf_P_hash(EVP_sha1(), sec + slen/2, slen/2 + (slen \u0026 1),\n                         seed, seed_len, tmp, olen)) {\n            OPENSSL_clear_free(tmp, olen);\n            return 0;\n        }\n        for (i = 0; i \u003c olen; i++)\n            out[i] ^= tmp[i];\n        OPENSSL_clear_free(tmp, olen);\n        return 1;\n    }\n    if (!tls1_prf_P_hash(md, sec, slen, seed, seed_len, out, olen))\n        return 0;\n\n    return 1;\n}","filepath":"crypto/kdf/tls1_prf.c","line_number":247,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre5"},"269972560":{"score":0.5939519,"function_name":"pkey_tls1_prf_derive","code":"static int pkey_tls1_prf_derive(EVP_PKEY_CTX *ctx, unsigned char *key,\n                                size_t *keylen)\n{\n    TLS1_PRF_PKEY_CTX *kctx = ctx-\u003edata;\n    if (kctx-\u003emd == NULL) {\n        KDFerr(KDF_F_PKEY_TLS1_PRF_DERIVE, KDF_R_MISSING_MESSAGE_DIGEST);\n        return 0;\n    }\n    if (kctx-\u003esec == NULL) {\n        KDFerr(KDF_F_PKEY_TLS1_PRF_DERIVE, KDF_R_MISSING_SECRET);\n        return 0;\n    }\n    if (kctx-\u003eseedlen == 0) {\n        KDFerr(KDF_F_PKEY_TLS1_PRF_DERIVE, KDF_R_MISSING_SEED);\n        return 0;\n    }\n    return tls1_prf_alg(kctx-\u003emd, kctx-\u003esec, kctx-\u003eseclen,\n                        kctx-\u003eseed, kctx-\u003eseedlen,\n                        key, *keylen);\n}","filepath":"crypto/kdf/tls1_prf.c","line_number":124,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre5"},"269972976":{"score":0.67070013,"function_name":"HKDF_Expand","code":"static unsigned char *HKDF_Expand(const EVP_MD *evp_md,\n                                  const unsigned char *prk, size_t prk_len,\n                                  const unsigned char *info, size_t info_len,\n                                  unsigned char *okm, size_t okm_len)\n{\n    HMAC_CTX *hmac;\n    unsigned char *ret = NULL;\n\n    unsigned int i;\n\n    unsigned char prev[EVP_MAX_MD_SIZE];\n\n    size_t done_len = 0, dig_len = EVP_MD_size(evp_md);\n\n    size_t n = okm_len / dig_len;\n    if (okm_len % dig_len)\n        n++;\n\n    if (n \u003e 255 || okm == NULL)\n        return NULL;\n\n    if ((hmac = HMAC_CTX_new()) == NULL)\n        return NULL;\n\n    if (!HMAC_Init_ex(hmac, prk, prk_len, evp_md, NULL))\n        goto err;\n\n    for (i = 1; i \u003c= n; i++) {\n        size_t copy_len;\n        const unsigned char ctr = i;\n\n        if (i \u003e 1) {\n            if (!HMAC_Init_ex(hmac, NULL, 0, NULL, NULL))\n                goto err;\n\n            if (!HMAC_Update(hmac, prev, dig_len))\n                goto err;\n        }\n\n        if (!HMAC_Update(hmac, info, info_len))\n            goto err;\n\n        if (!HMAC_Update(hmac, \u0026ctr, 1))\n            goto err;\n\n        if (!HMAC_Final(hmac, prev, NULL))\n            goto err;\n\n        copy_len = (done_len + dig_len \u003e okm_len) ?\n                       okm_len - done_len :\n                       dig_len;\n\n        memcpy(okm + done_len, prev, copy_len);\n\n        done_len += copy_len;\n    }\n    ret = okm;\n\n err:\n    OPENSSL_cleanse(prev, sizeof(prev));\n    HMAC_CTX_free(hmac);\n    return ret;\n}","filepath":"deps/openssl/openssl/crypto/kdf/hkdf.c","line_number":293,"entry_url":"https://github.com/nodejs/node.git","slot_name":"v15.5.0"},"269973440":{"score":0.91111845,"function_name":"HKDF_Extract","code":"static unsigned char *HKDF_Extract(const EVP_MD *evp_md,\n                                   const unsigned char *salt, size_t salt_len,\n                                   const unsigned char *key, size_t key_len,\n                                   unsigned char *prk, size_t *prk_len)\n{\n    unsigned int tmp_len;\n\n    if (!HMAC(evp_md, salt, salt_len, key, key_len, prk, \u0026tmp_len))\n        return NULL;\n\n    *prk_len = tmp_len;\n    return prk;\n}","filepath":"deps/openssl/openssl/crypto/kdf/hkdf.c","line_number":279,"entry_url":"https://github.com/nodejs/node.git","slot_name":"v15.5.0"},"269975712":{"score":0.92990327,"function_name":"EVP_add_cipher","code":"int EVP_add_cipher(const EVP_CIPHER *c)\n{\n    int r;\n\n    if (c == NULL)\n        return 0;\n\n    r = OBJ_NAME_add(OBJ_nid2sn(c-\u003enid), OBJ_NAME_TYPE_CIPHER_METH,\n                     (const char *)c);\n    if (r == 0)\n        return 0;\n    r = OBJ_NAME_add(OBJ_nid2ln(c-\u003enid), OBJ_NAME_TYPE_CIPHER_METH,\n                     (const char *)c);\n    return r;\n}","filepath":"crypto/evp/names.c","line_number":17,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269975776":{"score":0.8442506,"function_name":"EVP_add_digest","code":"int EVP_add_digest(const EVP_MD *md)\n{\n    int r;\n    const char *name;\n\n    name = OBJ_nid2sn(md-\u003etype);\n    r = OBJ_NAME_add(name, OBJ_NAME_TYPE_MD_METH, (const char *)md);\n    if (r == 0)\n        return 0;\n    r = OBJ_NAME_add(OBJ_nid2ln(md-\u003etype), OBJ_NAME_TYPE_MD_METH,\n                     (const char *)md);\n    if (r == 0)\n        return 0;\n\n    if (md-\u003epkey_type \u0026\u0026 md-\u003etype != md-\u003epkey_type) {\n        r = OBJ_NAME_add(OBJ_nid2sn(md-\u003epkey_type),\n                         OBJ_NAME_TYPE_MD_METH | OBJ_NAME_ALIAS, name);\n        if (r == 0)\n            return 0;\n        r = OBJ_NAME_add(OBJ_nid2ln(md-\u003epkey_type),\n                         OBJ_NAME_TYPE_MD_METH | OBJ_NAME_ALIAS, name);\n    }\n    return r;\n}","filepath":"crypto/evp/names.c","line_number":33,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269975920":{"score":0.6642626,"function_name":"EVP_get_cipherbyname","code":"const EVP_CIPHER *EVP_get_cipherbyname(const char *name)\n{\n    const EVP_CIPHER *cp;\n\n    if (!OPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS, NULL))\n        return NULL;\n\n    cp = (const EVP_CIPHER *)OBJ_NAME_get(name, OBJ_NAME_TYPE_CIPHER_METH);\n    return cp;\n}","filepath":"crypto/evp/names.c","line_number":58,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269976016":{"score":0.6554887,"function_name":"evp_cleanup_int","code":"void evp_cleanup_int(void)\n{\n    OBJ_NAME_cleanup(OBJ_NAME_TYPE_CIPHER_METH);\n    OBJ_NAME_cleanup(OBJ_NAME_TYPE_MD_METH);\n    /*\n     * The above calls will only clean out the contents of the name hash\n     * table, but not the hash table itself.  The following line does that\n     * part.  -- Richard Levitte\n     */\n    OBJ_NAME_cleanup(-1);\n\n    EVP_PBE_cleanup();\n    OBJ_sigid_free();\n\n    evp_app_cleanup_int();\n}","filepath":"crypto/evp/names.c","line_number":80,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269976448":{"score":0.8434957,"function_name":"engine_list_add","code":"static int engine_list_add(ENGINE *e)\n{\n    int conflict = 0;\n    ENGINE *iterator = NULL;\n\n    if (e == NULL) {\n        ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ERR_R_PASSED_NULL_PARAMETER);\n        return 0;\n    }\n    iterator = engine_list_head;\n    while (iterator \u0026\u0026 !conflict) {\n        conflict = (strcmp(iterator-\u003eid, e-\u003eid) == 0);\n        iterator = iterator-\u003enext;\n    }\n    if (conflict) {\n        ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ENGINE_R_CONFLICTING_ENGINE_ID);\n        return 0;\n    }\n    if (engine_list_head == NULL) {\n        /* We are adding to an empty list. */\n        if (engine_list_tail) {\n            ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ENGINE_R_INTERNAL_LIST_ERROR);\n            return 0;\n        }\n        engine_list_head = e;\n        e-\u003eprev = NULL;\n        /*\n         * The first time the list allocates, we should register the cleanup.\n         */\n        engine_cleanup_add_last(engine_list_cleanup);\n    } else {\n        /* We are adding to the tail of an existing list. */\n        if ((engine_list_tail == NULL) || (engine_list_tail-\u003enext != NULL)) {\n            ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ENGINE_R_INTERNAL_LIST_ERROR);\n            return 0;\n        }\n        engine_list_tail-\u003enext = e;\n        e-\u003eprev = engine_list_tail;\n    }\n    /*\n     * Having the engine in the list assumes a structural reference.\n     */\n    e-\u003estruct_ref++;\n    engine_ref_debug(e, 0, 1);\n    /* However it came to be, e is the last item in the list. */\n    engine_list_tail = e;\n    e-\u003enext = NULL;\n    return 1;\n}","filepath":"crypto/engine/eng_list.c","line_number":53,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0j"},"269976800":{"score":0.8930443,"function_name":"ENGINE_by_id","code":"ENGINE *ENGINE_by_id(const char *id)\n{\n    ENGINE *iterator;\n    char *load_dir = NULL;\n    if (id == NULL) {\n        ENGINEerr(ENGINE_F_ENGINE_BY_ID, ERR_R_PASSED_NULL_PARAMETER);\n        return NULL;\n    }\n    if (!RUN_ONCE(\u0026engine_lock_init, do_engine_lock_init)) {\n        ENGINEerr(ENGINE_F_ENGINE_BY_ID, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    CRYPTO_THREAD_write_lock(global_engine_lock);\n    iterator = engine_list_head;\n    while (iterator \u0026\u0026 (strcmp(id, iterator-\u003eid) != 0))\n        iterator = iterator-\u003enext;\n    if (iterator != NULL) {\n        /*\n         * We need to return a structural reference. If this is an ENGINE\n         * type that returns copies, make a duplicate - otherwise increment\n         * the existing ENGINE's reference count.\n         */\n        if (iterator-\u003eflags \u0026 ENGINE_FLAGS_BY_ID_COPY) {\n            ENGINE *cp = ENGINE_new();\n            if (cp == NULL)\n                iterator = NULL;\n            else {\n                engine_cpy(cp, iterator);\n                iterator = cp;\n            }\n        } else {\n            iterator-\u003estruct_ref++;\n            engine_ref_debug(iterator, 0, 1);\n        }\n    }\n    CRYPTO_THREAD_unlock(global_engine_lock);\n    if (iterator != NULL)\n        return iterator;\n    /*\n     * Prevent infinite recursion if we're looking for the dynamic engine.\n     */\n    if (strcmp(id, \"dynamic\")) {\n        if ((load_dir = ossl_safe_getenv(\"OPENSSL_ENGINES\")) == NULL)\n            load_dir = ENGINESDIR;\n        iterator = ENGINE_by_id(\"dynamic\");\n        if (!iterator || !ENGINE_ctrl_cmd_string(iterator, \"ID\", id, 0) ||\n            !ENGINE_ctrl_cmd_string(iterator, \"DIR_LOAD\", \"2\", 0) ||\n            !ENGINE_ctrl_cmd_string(iterator, \"DIR_ADD\",\n                                    load_dir, 0) ||\n            !ENGINE_ctrl_cmd_string(iterator, \"LIST_ADD\", \"1\", 0) ||\n            !ENGINE_ctrl_cmd_string(iterator, \"LOAD\", NULL, 0))\n            goto notfound;\n        return iterator;\n    }\n notfound:\n    ENGINE_free(iterator);\n    ENGINEerr(ENGINE_F_ENGINE_BY_ID, ENGINE_R_NO_SUCH_ENGINE);\n    ERR_add_error_data(2, \"id=\", id);\n    return NULL;\n    /* EEK! Experimental code ends */\n}","filepath":"crypto/engine/eng_list.c","line_number":282,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0j"},"269977520":{"score":0.9151257,"function_name":"ENGINE_get_prev","code":"ENGINE *ENGINE_get_prev(ENGINE *e)\n{\n    ENGINE *ret = NULL;\n    if (e == NULL) {\n        ENGINEerr(ENGINE_F_ENGINE_GET_PREV, ERR_R_PASSED_NULL_PARAMETER);\n        return 0;\n    }\n    CRYPTO_THREAD_write_lock(global_engine_lock);\n    ret = e-\u003eprev;\n    if (ret) {\n        /* Return a valid structural reference to the next ENGINE */\n        ret-\u003estruct_ref++;\n        engine_ref_debug(ret, 0, 1);\n    }\n    CRYPTO_THREAD_unlock(global_engine_lock);\n    /* Release the structural reference to the previous ENGINE */\n    ENGINE_free(e);\n    return ret;\n}","filepath":"crypto/engine/eng_list.c","line_number":194,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0j"},"269977856":{"score":0.8540175,"function_name":"engine_table_cleanup","code":"void engine_table_cleanup(ENGINE_TABLE **table)\n{\n    CRYPTO_THREAD_write_lock(global_engine_lock);\n    if (*table) {\n        lh_ENGINE_PILE_doall(\u0026(*table)-\u003epiles, int_cleanup_cb_doall);\n        lh_ENGINE_PILE_free(\u0026(*table)-\u003epiles);\n        *table = NULL;\n    }\n    CRYPTO_THREAD_unlock(global_engine_lock);\n}","filepath":"crypto/engine/eng_table.c","line_number":180,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre3"},"269977936":{"score":0.77819395,"function_name":"engine_table_doall","code":"void engine_table_doall(ENGINE_TABLE *table, engine_table_doall_cb *cb,\n                        void *arg)\n{\n    ENGINE_PILE_DOALL dall;\n    dall.cb = cb;\n    dall.arg = arg;\n    if (table)\n        lh_ENGINE_PILE_doall_ENGINE_PILE_DOALL(\u0026table-\u003epiles, int_dall, \u0026dall);\n}","filepath":"crypto/engine/eng_table.c","line_number":300,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre3"},"269978000":{"score":0.88216835,"function_name":"engine_table_register","code":"int engine_table_register(ENGINE_TABLE **table, ENGINE_CLEANUP_CB *cleanup,\n                          ENGINE *e, const int *nids, int num_nids,\n                          int setdefault)\n{\n    int ret = 0, added = 0;\n    ENGINE_PILE tmplate, *fnd;\n    CRYPTO_THREAD_write_lock(global_engine_lock);\n    if (!(*table))\n        added = 1;\n    if (!int_table_check(table, 1))\n        goto end;\n    if (added)\n        /* The cleanup callback needs to be added */\n        engine_cleanup_add_first(cleanup);\n    while (num_nids--) {\n        tmplate.nid = *nids;\n        fnd = lh_ENGINE_PILE_retrieve(\u0026(*table)-\u003epiles, \u0026tmplate);\n        if (!fnd) {\n            fnd = OPENSSL_malloc(sizeof(*fnd));\n            if (fnd == NULL)\n                goto end;\n            fnd-\u003euptodate = 1;\n            fnd-\u003enid = *nids;\n            fnd-\u003esk = sk_ENGINE_new_null();\n            if (!fnd-\u003esk) {\n                OPENSSL_free(fnd);\n                goto end;\n            }\n            fnd-\u003efunct = NULL;\n            (void)lh_ENGINE_PILE_insert(\u0026(*table)-\u003epiles, fnd);\n            if (lh_ENGINE_PILE_retrieve(\u0026(*table)-\u003epiles, \u0026tmplate) != fnd) {\n                sk_ENGINE_free(fnd-\u003esk);\n                OPENSSL_free(fnd);\n                goto end;\n            }\n        }\n        /* A registration shouldn't add duplicate entries */\n        (void)sk_ENGINE_delete_ptr(fnd-\u003esk, e);\n        /*\n         * if 'setdefault', this ENGINE goes to the head of the list\n         */\n        if (!sk_ENGINE_push(fnd-\u003esk, e))\n            goto end;\n        /* \"touch\" this ENGINE_PILE */\n        fnd-\u003euptodate = 0;\n        if (setdefault) {\n            if (!engine_unlocked_init(e)) {\n                ENGINEerr(ENGINE_F_ENGINE_TABLE_REGISTER,\n                          ENGINE_R_INIT_FAILED);\n                goto end;\n            }\n            if (fnd-\u003efunct)\n                engine_unlocked_finish(fnd-\u003efunct, 0);\n            fnd-\u003efunct = e;\n            fnd-\u003euptodate = 1;\n        }\n        nids++;\n    }\n    ret = 1;\n end:\n    CRYPTO_THREAD_unlock(global_engine_lock);\n    return ret;\n}","filepath":"crypto/engine/eng_table.c","line_number":82,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre3"},"269978448":{"score":0.78926015,"function_name":"engine_table_select","code":"ENGINE *engine_table_select(ENGINE_TABLE **table, int nid)\n#else\nENGINE *engine_table_select_tmp(ENGINE_TABLE **table, int nid, const char *f,\n                                int l)\n#endif\n{\n    ENGINE *ret = NULL;\n    ENGINE_PILE tmplate, *fnd = NULL;\n    int initres, loop = 0;\n\n    if (!(*table)) {\n#ifdef ENGINE_TABLE_DEBUG\n        fprintf(stderr, \"engine_table_dbg: %s:%d, nid=%d, nothing \"\n                \"registered!\\n\", f, l, nid);\n#endif\n        return NULL;\n    }\n    ERR_set_mark();\n    CRYPTO_THREAD_write_lock(global_engine_lock);\n    /*\n     * Check again inside the lock otherwise we could race against cleanup\n     * operations. But don't worry about a fprintf(stderr).\n     */\n    if (!int_table_check(table, 0))\n        goto end;\n    tmplate.nid = nid;\n    fnd = lh_ENGINE_PILE_retrieve(\u0026(*table)-\u003epiles, \u0026tmplate);\n    if (!fnd)\n        goto end;\n    if (fnd-\u003efunct \u0026\u0026 engine_unlocked_init(fnd-\u003efunct)) {\n#ifdef ENGINE_TABLE_DEBUG\n        fprintf(stderr, \"engine_table_dbg: %s:%d, nid=%d, using \"\n                \"ENGINE '%s' cached\\n\", f, l, nid, fnd-\u003efunct-\u003eid);\n#endif\n        ret = fnd-\u003efunct;\n        goto end;\n    }\n    if (fnd-\u003euptodate) {\n        ret = fnd-\u003efunct;\n        goto end;\n    }\n trynext:\n    ret = sk_ENGINE_value(fnd-\u003esk, loop++);\n    if (!ret) {\n#ifdef ENGINE_TABLE_DEBUG\n        fprintf(stderr, \"engine_table_dbg: %s:%d, nid=%d, no \"\n                \"registered implementations would initialise\\n\", f, l, nid);\n#endif\n        goto end;\n    }\n    /* Try to initialise the ENGINE? */\n    if ((ret-\u003efunct_ref \u003e 0) || !(table_flags \u0026 ENGINE_TABLE_FLAG_NOINIT))\n        initres = engine_unlocked_init(ret);\n    else\n        initres = 0;\n    if (initres) {\n        /* Update 'funct' */\n        if ((fnd-\u003efunct != ret) \u0026\u0026 engine_unlocked_init(ret)) {\n            /* If there was a previous default we release it. */\n            if (fnd-\u003efunct)\n                engine_unlocked_finish(fnd-\u003efunct, 0);\n            fnd-\u003efunct = ret;\n#ifdef ENGINE_TABLE_DEBUG\n            fprintf(stderr, \"engine_table_dbg: %s:%d, nid=%d, \"\n                    \"setting default to '%s'\\n\", f, l, nid, ret-\u003eid);\n#endif\n        }\n#ifdef ENGINE_TABLE_DEBUG\n        fprintf(stderr, \"engine_table_dbg: %s:%d, nid=%d, using \"\n                \"newly initialised '%s'\\n\", f, l, nid, ret-\u003eid);\n#endif\n        goto end;\n    }\n    goto trynext;\n end:\n    /*\n     * If it failed, it is unlikely to succeed again until some future\n     * registrations have taken place. In all cases, we cache.\n     */\n    if (fnd)\n        fnd-\u003euptodate = 1;\n#ifdef ENGINE_TABLE_DEBUG\n    if (ret)\n        fprintf(stderr, \"engine_table_dbg: %s:%d, nid=%d, caching \"\n                \"ENGINE '%s'\\n\", f, l, nid, ret-\u003eid);\n    else\n        fprintf(stderr, \"engine_table_dbg: %s:%d, nid=%d, caching \"\n                \"'no matching ENGINE'\\n\", f, l, nid);\n#endif\n    CRYPTO_THREAD_unlock(global_engine_lock);\n    /*\n     * Whatever happened, any failed init()s are not failures in this\n     * context, so clear our error state.\n     */\n    ERR_pop_to_mark();\n    return ret;\n}","filepath":"crypto/engine/eng_table.c","line_number":193,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre3"},"269980672":{"score":0.8525169,"function_name":"DH_free","code":"void DH_free(DH *r)\n{\n    int i;\n\n    if (r == NULL)\n        return;\n\n    CRYPTO_DOWN_REF(\u0026r-\u003ereferences, \u0026i, r-\u003elock);\n    REF_PRINT_COUNT(\"DH\", r);\n    if (i \u003e 0)\n        return;\n    REF_ASSERT_ISNT(i \u003c 0);\n\n    if (r-\u003emeth-\u003efinish)\n        r-\u003emeth-\u003efinish(r);\n#ifndef OPENSSL_NO_ENGINE\n    ENGINE_finish(r-\u003eengine);\n#endif\n\n    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_DH, r, \u0026r-\u003eex_data);\n\n    CRYPTO_THREAD_lock_free(r-\u003elock);\n\n    BN_clear_free(r-\u003ep);\n    BN_clear_free(r-\u003eg);\n    BN_clear_free(r-\u003eq);\n    BN_clear_free(r-\u003ej);\n    OPENSSL_free(r-\u003eseed);\n    BN_clear_free(r-\u003ecounter);\n    BN_clear_free(r-\u003epub_key);\n    BN_clear_free(r-\u003epriv_key);\n    OPENSSL_free(r);\n}","filepath":"crypto/dh/dh_lib.c","line_number":94,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre1"},"269980864":{"score":0.85805404,"function_name":"DH_new_method","code":"DH *DH_new_method(ENGINE *engine)\n{\n    DH *ret = OPENSSL_zalloc(sizeof(*ret));\n\n    if (ret == NULL) {\n        DHerr(DH_F_DH_NEW_METHOD, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    ret-\u003ereferences = 1;\n    ret-\u003elock = CRYPTO_THREAD_lock_new();\n    if (ret-\u003elock == NULL) {\n        DHerr(DH_F_DH_NEW_METHOD, ERR_R_MALLOC_FAILURE);\n        OPENSSL_free(ret);\n        return NULL;\n    }\n\n    ret-\u003emeth = DH_get_default_method();\n#ifndef OPENSSL_NO_ENGINE\n    ret-\u003eflags = ret-\u003emeth-\u003eflags;  /* early default init */\n    if (engine) {\n        if (!ENGINE_init(engine)) {\n            DHerr(DH_F_DH_NEW_METHOD, ERR_R_ENGINE_LIB);\n            goto err;\n        }\n        ret-\u003eengine = engine;\n    } else\n        ret-\u003eengine = ENGINE_get_default_DH();\n    if (ret-\u003eengine) {\n        ret-\u003emeth = ENGINE_get_DH(ret-\u003eengine);\n        if (ret-\u003emeth == NULL) {\n            DHerr(DH_F_DH_NEW_METHOD, ERR_R_ENGINE_LIB);\n            goto err;\n        }\n    }\n#endif\n\n    ret-\u003eflags = ret-\u003emeth-\u003eflags;\n\n    if (!CRYPTO_new_ex_data(CRYPTO_EX_INDEX_DH, ret, \u0026ret-\u003eex_data))\n        goto err;\n\n    if ((ret-\u003emeth-\u003einit != NULL) \u0026\u0026 !ret-\u003emeth-\u003einit(ret)) {\n        DHerr(DH_F_DH_NEW_METHOD, ERR_R_INIT_FAIL);\nerr:\n        DH_free(ret);\n        ret = NULL;\n    }\n\n    return ret;\n}","filepath":"crypto/dh/dh_lib.c","line_number":42,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre1"},"269981312":{"score":0.87240636,"function_name":"DH_security_bits","code":"int DH_security_bits(const DH *dh)\n{\n    int N;\n    if (dh-\u003eq)\n        N = BN_num_bits(dh-\u003eq);\n    else if (dh-\u003elength)\n        N = dh-\u003elength;\n    else\n        N = -1;\n    return BN_security_bits(BN_num_bits(dh-\u003ep), N);\n}","filepath":"crypto/dh/dh_lib.c","line_number":160,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre1"},"269981376":{"score":0.9272281,"function_name":"DH_set0_key","code":"int DH_set0_key(DH *dh, BIGNUM *pub_key, BIGNUM *priv_key)\n{\n    if (pub_key != NULL) {\n        BN_free(dh-\u003epub_key);\n        dh-\u003epub_key = pub_key;\n    }\n    if (priv_key != NULL) {\n        BN_free(dh-\u003epriv_key);\n        dh-\u003epriv_key = priv_key;\n    }\n\n    return 1;\n}","filepath":"crypto/dh/dh_lib.c","line_number":232,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre1"},"269981440":{"score":0.9256965,"function_name":"DH_set0_pqg","code":"int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g)\n{\n    /* If the fields p and g in d are NULL, the corresponding input\n     * parameters MUST be non-NULL.  q may remain NULL.\n     */\n    if ((dh-\u003ep == NULL \u0026\u0026 p == NULL)\n        || (dh-\u003eg == NULL \u0026\u0026 g == NULL))\n        return 0;\n\n    if (p != NULL) {\n        BN_free(dh-\u003ep);\n        dh-\u003ep = p;\n    }\n    if (q != NULL) {\n        BN_free(dh-\u003eq);\n        dh-\u003eq = q;\n    }\n    if (g != NULL) {\n        BN_free(dh-\u003eg);\n        dh-\u003eg = g;\n    }\n\n    if (q != NULL) {\n        dh-\u003elength = BN_num_bits(q);\n    }\n\n    return 1;\n}","filepath":"crypto/dh/dh_lib.c","line_number":184,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre1"},"269983024":{"score":0.8020677,"function_name":"ASN1_OBJECT_free","code":"void ASN1_OBJECT_free(ASN1_OBJECT *a)\n{\n    if (a == NULL)\n        return;\n    if (a-\u003eflags \u0026 ASN1_OBJECT_FLAG_DYNAMIC_STRINGS) {\n#ifndef CONST_STRICT            /* disable purely for compile-time strict\n                                 * const checking. Doing this on a \"real\"\n                                 * compile will cause memory leaks */\n        OPENSSL_free((void*)a-\u003esn);\n        OPENSSL_free((void*)a-\u003eln);\n#endif\n        a-\u003esn = a-\u003eln = NULL;\n    }\n    if (a-\u003eflags \u0026 ASN1_OBJECT_FLAG_DYNAMIC_DATA) {\n        OPENSSL_free((void*)a-\u003edata);\n        a-\u003edata = NULL;\n        a-\u003elength = 0;\n    }\n    if (a-\u003eflags \u0026 ASN1_OBJECT_FLAG_DYNAMIC)\n        OPENSSL_free(a);\n}","filepath":"crypto/asn1/a_object.c","line_number":347,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269983168":{"score":0.93253183,"function_name":"ASN1_OBJECT_new","code":"ASN1_OBJECT *ASN1_OBJECT_new(void)\n{\n    ASN1_OBJECT *ret;\n\n    ret = OPENSSL_zalloc(sizeof(*ret));\n    if (ret == NULL) {\n        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    ret-\u003eflags = ASN1_OBJECT_FLAG_DYNAMIC;\n    return ret;\n}","filepath":"crypto/asn1/a_object.c","line_number":334,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269983232":{"score":0.8273318,"function_name":"a2d_ASN1_OBJECT","code":"int a2d_ASN1_OBJECT(unsigned char *out, int olen, const char *buf, int num)\n{\n    int i, first, len = 0, c, use_bn;\n    char ftmp[24], *tmp = ftmp;\n    int tmpsize = sizeof(ftmp);\n    const char *p;\n    unsigned long l;\n    BIGNUM *bl = NULL;\n\n    if (num == 0)\n        return 0;\n    else if (num == -1)\n        num = strlen(buf);\n\n    p = buf;\n    c = *(p++);\n    num--;\n    if ((c \u003e= '0') \u0026\u0026 (c \u003c= '2')) {\n        first = c - '0';\n    } else {\n        ERR_raise(ERR_LIB_ASN1, ASN1_R_FIRST_NUM_TOO_LARGE);\n        goto err;\n    }\n\n    if (num \u003c= 0) {\n        ERR_raise(ERR_LIB_ASN1, ASN1_R_MISSING_SECOND_NUMBER);\n        goto err;\n    }\n    c = *(p++);\n    num--;\n    for (;;) {\n        if (num \u003c= 0)\n            break;\n        if ((c != '.') \u0026\u0026 (c != ' ')) {\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_INVALID_SEPARATOR);\n            goto err;\n        }\n        l = 0;\n        use_bn = 0;\n        for (;;) {\n            if (num \u003c= 0)\n                break;\n            num--;\n            c = *(p++);\n            if ((c == ' ') || (c == '.'))\n                break;\n            if (!ossl_isdigit(c)) {\n                ERR_raise(ERR_LIB_ASN1, ASN1_R_INVALID_DIGIT);\n                goto err;\n            }\n            if (!use_bn \u0026\u0026 l \u003e= ((ULONG_MAX - 80) / 10L)) {\n                use_bn = 1;\n                if (bl == NULL)\n                    bl = BN_new();\n                if (bl == NULL || !BN_set_word(bl, l))\n                    goto err;\n            }\n            if (use_bn) {\n                if (!BN_mul_word(bl, 10L)\n                    || !BN_add_word(bl, c - '0'))\n                    goto err;\n            } else\n                l = l * 10L + (long)(c - '0');\n        }\n        if (len == 0) {\n            if ((first \u003c 2) \u0026\u0026 (l \u003e= 40)) {\n                ERR_raise(ERR_LIB_ASN1, ASN1_R_SECOND_NUMBER_TOO_LARGE);\n                goto err;\n            }\n            if (use_bn) {\n                if (!BN_add_word(bl, first * 40))\n                    goto err;\n            } else\n                l += (long)first *40;\n        }\n        i = 0;\n        if (use_bn) {\n            int blsize;\n            blsize = BN_num_bits(bl);\n            blsize = (blsize + 6) / 7;\n            if (blsize \u003e tmpsize) {\n                if (tmp != ftmp)\n                    OPENSSL_free(tmp);\n                tmpsize = blsize + 32;\n                tmp = OPENSSL_malloc(tmpsize);\n                if (tmp == NULL)\n                    goto err;\n            }\n            while (blsize--) {\n                BN_ULONG t = BN_div_word(bl, 0x80L);\n                if (t == (BN_ULONG)-1)\n                    goto err;\n                tmp[i++] = (unsigned char)t;\n            }\n        } else {\n\n            for (;;) {\n                tmp[i++] = (unsigned char)l \u0026 0x7f;\n                l \u003e\u003e= 7L;\n                if (l == 0L)\n                    break;\n            }\n\n        }\n        if (out != NULL) {\n            if (len + i \u003e olen) {\n                ERR_raise(ERR_LIB_ASN1, ASN1_R_BUFFER_TOO_SMALL);\n                goto err;\n            }\n            while (--i \u003e 0)\n                out[len++] = tmp[i] | 0x80;\n            out[len++] = tmp[0];\n        } else\n            len += i;\n    }\n    if (tmp != ftmp)\n        OPENSSL_free(tmp);\n    BN_free(bl);\n    return len;\n err:\n    if (tmp != ftmp)\n        OPENSSL_free(tmp);\n    BN_free(bl);\n    return 0;\n}","filepath":"crypto/asn1/a_object.c","line_number":53,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269984176":{"score":0.9313843,"function_name":"c2i_ASN1_OBJECT","code":"ASN1_OBJECT *c2i_ASN1_OBJECT(ASN1_OBJECT **a, const unsigned char **pp,\n                             long len)\n{\n    ASN1_OBJECT *ret = NULL, tobj;\n    const unsigned char *p;\n    unsigned char *data;\n    int i, length;\n\n    /*\n     * Sanity check OID encoding. Need at least one content octet. MSB must\n     * be clear in the last octet. can't have leading 0x80 in subidentifiers,\n     * see: X.690 8.19.2\n     */\n    if (len \u003c= 0 || len \u003e INT_MAX || pp == NULL || (p = *pp) == NULL ||\n        p[len - 1] \u0026 0x80) {\n        ERR_raise(ERR_LIB_ASN1, ASN1_R_INVALID_OBJECT_ENCODING);\n        return NULL;\n    }\n    /* Now 0 \u003c len \u003c= INT_MAX, so the cast is safe. */\n    length = (int)len;\n    /*\n     * Try to lookup OID in table: these are all valid encodings so if we get\n     * a match we know the OID is valid.\n     */\n    tobj.nid = NID_undef;\n    tobj.data = p;\n    tobj.length = length;\n    tobj.flags = 0;\n    i = OBJ_obj2nid(\u0026tobj);\n    if (i != NID_undef) {\n        /*\n         * Return shared registered OID object: this improves efficiency\n         * because we don't have to return a dynamically allocated OID\n         * and NID lookups can use the cached value.\n         */\n        ret = OBJ_nid2obj(i);\n        if (a) {\n            ASN1_OBJECT_free(*a);\n            *a = ret;\n        }\n        *pp += len;\n        return ret;\n    }\n    for (i = 0; i \u003c length; i++, p++) {\n        if (*p == 0x80 \u0026\u0026 (!i || !(p[-1] \u0026 0x80))) {\n            ERR_raise(ERR_LIB_ASN1, ASN1_R_INVALID_OBJECT_ENCODING);\n            return NULL;\n        }\n    }\n\n    /*\n     * only the ASN1_OBJECTs from the 'table' will have values for -\u003esn or\n     * -\u003eln\n     */\n    if ((a == NULL) || ((*a) == NULL) ||\n        !((*a)-\u003eflags \u0026 ASN1_OBJECT_FLAG_DYNAMIC)) {\n        if ((ret = ASN1_OBJECT_new()) == NULL)\n            return NULL;\n    } else\n        ret = (*a);\n\n    p = *pp;\n    /* detach data from object */\n    data = (unsigned char *)ret-\u003edata;\n    ret-\u003edata = NULL;\n    /* once detached we can change it */\n    if ((data == NULL) || (ret-\u003elength \u003c length)) {\n        ret-\u003elength = 0;\n        OPENSSL_free(data);\n        data = OPENSSL_malloc(length);\n        if (data == NULL) {\n            i = ERR_R_MALLOC_FAILURE;\n            goto err;\n        }\n        ret-\u003eflags |= ASN1_OBJECT_FLAG_DYNAMIC_DATA;\n    }\n    memcpy(data, p, length);\n    /* reattach data to object, after which it remains const */\n    ret-\u003edata = data;\n    ret-\u003elength = length;\n    ret-\u003esn = NULL;\n    ret-\u003eln = NULL;\n    /* ret-\u003eflags=ASN1_OBJECT_FLAG_DYNAMIC; we know it is dynamic */\n    p += length;\n\n    if (a != NULL)\n        (*a) = ret;\n    *pp = p;\n    return ret;\n err:\n    ERR_raise(ERR_LIB_ASN1, i);\n    if ((a == NULL) || (*a != ret))\n        ASN1_OBJECT_free(ret);\n    return NULL;\n}","filepath":"crypto/asn1/a_object.c","line_number":238,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269984752":{"score":0.86392856,"function_name":"d2i_ASN1_OBJECT","code":"ASN1_OBJECT *d2i_ASN1_OBJECT(ASN1_OBJECT **a, const unsigned char **pp,\n                             long length)\n{\n    const unsigned char *p;\n    long len;\n    int tag, xclass;\n    int inf, i;\n    ASN1_OBJECT *ret = NULL;\n    p = *pp;\n    inf = ASN1_get_object(\u0026p, \u0026len, \u0026tag, \u0026xclass, length);\n    if (inf \u0026 0x80) {\n        i = ASN1_R_BAD_OBJECT_HEADER;\n        goto err;\n    }\n\n    if (tag != V_ASN1_OBJECT) {\n        i = ASN1_R_EXPECTING_AN_OBJECT;\n        goto err;\n    }\n    ret = c2i_ASN1_OBJECT(a, \u0026p, len);\n    if (ret)\n        *pp = p;\n    return ret;\n err:\n    ERR_raise(ERR_LIB_ASN1, i);\n    return NULL;\n}","filepath":"crypto/asn1/a_object.c","line_number":210,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269984912":{"score":0.8125486,"function_name":"i2a_ASN1_OBJECT","code":"int i2a_ASN1_OBJECT(BIO *bp, const ASN1_OBJECT *a)\n{\n    char buf[80], *p = buf;\n    int i;\n\n    if ((a == NULL) || (a-\u003edata == NULL))\n        return BIO_write(bp, \"NULL\", 4);\n    i = i2t_ASN1_OBJECT(buf, sizeof(buf), a);\n    if (i \u003e (int)(sizeof(buf) - 1)) {\n        if ((p = OPENSSL_malloc(i + 1)) == NULL) {\n            ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);\n            return -1;\n        }\n        i2t_ASN1_OBJECT(p, i + 1, a);\n    }\n    if (i \u003c= 0) {\n        i = BIO_write(bp, \"\u003cINVALID\u003e\", 9);\n        i += BIO_dump(bp, (const char *)a-\u003edata, a-\u003elength);\n        return i;\n    }\n    BIO_write(bp, p, i);\n    if (p != buf)\n        OPENSSL_free(p);\n    return i;\n}","filepath":"crypto/asn1/a_object.c","line_number":184,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"269985360":{"score":0.7493641,"function_name":"ASN1_STRING_cmp","code":"int ASN1_STRING_cmp(const ASN1_STRING *a, const ASN1_STRING *b)\n{\n    int i;\n\n    i = (a-\u003elength - b-\u003elength);\n    if (i == 0) {\n        i = memcmp(a-\u003edata, b-\u003edata, a-\u003elength);\n        if (i == 0)\n            return a-\u003etype - b-\u003etype;\n        else\n            return i;\n    } else\n        return i;\n}","filepath":"crypto/asn1/asn1_lib.c","line_number":351,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269985488":{"score":0.8055992,"function_name":"ASN1_STRING_copy","code":"int ASN1_STRING_copy(ASN1_STRING *dst, const ASN1_STRING *str)\n{\n    if (str == NULL)\n        return 0;\n    dst-\u003etype = str-\u003etype;\n    if (!ASN1_STRING_set(dst, str-\u003edata, str-\u003elength))\n        return 0;\n    /* Copy flags but preserve embed value */\n    dst-\u003eflags \u0026= ASN1_STRING_FLAG_EMBED;\n    dst-\u003eflags |= str-\u003eflags \u0026 ~ASN1_STRING_FLAG_EMBED;\n    return 1;\n}","filepath":"crypto/asn1/asn1_lib.c","line_number":243,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269986144":{"score":0.92258555,"function_name":"ASN1_STRING_set","code":"int ASN1_STRING_set(ASN1_STRING *str, const void *_data, int len)\n{\n    unsigned char *c;\n    const char *data = _data;\n\n    if (len \u003c 0) {\n        if (data == NULL)\n            return 0;\n        else\n            len = strlen(data);\n    }\n    if ((str-\u003elength \u003c= len) || (str-\u003edata == NULL)) {\n        c = str-\u003edata;\n        str-\u003edata = OPENSSL_realloc(c, len + 1);\n        if (str-\u003edata == NULL) {\n            ASN1err(ASN1_F_ASN1_STRING_SET, ERR_R_MALLOC_FAILURE);\n            str-\u003edata = c;\n            return 0;\n        }\n    }\n    str-\u003elength = len;\n    if (data != NULL) {\n        memcpy(str-\u003edata, data, len);\n        /* an allowance for strings :-) */\n        str-\u003edata[len] = '\\0';\n    }\n    return 1;\n}","filepath":"crypto/asn1/asn1_lib.c","line_number":271,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269986368":{"score":0.9434497,"function_name":"ASN1_STRING_type_new","code":"ASN1_STRING *ASN1_STRING_type_new(int type)\n{\n    ASN1_STRING *ret;\n\n    ret = OPENSSL_zalloc(sizeof(*ret));\n    if (ret == NULL) {\n        ASN1err(ASN1_F_ASN1_STRING_TYPE_NEW, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    ret-\u003etype = type;\n    return ret;\n}","filepath":"crypto/asn1/asn1_lib.c","line_number":312,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269986448":{"score":0.7889405,"function_name":"ASN1_get_object","code":"int ASN1_get_object(const unsigned char **pp, long *plength, int *ptag,\n                    int *pclass, long omax)\n{\n    int i, ret;\n    long l;\n    const unsigned char *p = *pp;\n    int tag, xclass, inf;\n    long max = omax;\n\n    if (!max)\n        goto err;\n    ret = (*p \u0026 V_ASN1_CONSTRUCTED);\n    xclass = (*p \u0026 V_ASN1_PRIVATE);\n    i = *p \u0026 V_ASN1_PRIMITIVE_TAG;\n    if (i == V_ASN1_PRIMITIVE_TAG) { /* high-tag */\n        p++;\n        if (--max == 0)\n            goto err;\n        l = 0;\n        while (*p \u0026 0x80) {\n            l \u003c\u003c= 7L;\n            l |= *(p++) \u0026 0x7f;\n            if (--max == 0)\n                goto err;\n            if (l \u003e (INT_MAX \u003e\u003e 7L))\n                goto err;\n        }\n        l \u003c\u003c= 7L;\n        l |= *(p++) \u0026 0x7f;\n        tag = (int)l;\n        if (--max == 0)\n            goto err;\n    } else {\n        tag = i;\n        p++;\n        if (--max == 0)\n            goto err;\n    }\n    *ptag = tag;\n    *pclass = xclass;\n    if (!asn1_get_length(\u0026p, \u0026inf, plength, max))\n        goto err;\n\n    if (inf \u0026\u0026 !(ret \u0026 V_ASN1_CONSTRUCTED))\n        goto err;\n\n    if (*plength \u003e (omax - (p - *pp))) {\n        ASN1err(ASN1_F_ASN1_GET_OBJECT, ASN1_R_TOO_LONG);\n        /*\n         * Set this so that even if things are not long enough the values are\n         * set correctly\n         */\n        ret |= 0x80;\n    }\n    *pp = p;\n    return ret | inf;\n err:\n    ASN1err(ASN1_F_ASN1_GET_OBJECT, ASN1_R_HEADER_TOO_LONG);\n    return 0x80;\n}","filepath":"crypto/asn1/asn1_lib.c","line_number":44,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269986816":{"score":0.9420257,"function_name":"ASN1_object_size","code":"int ASN1_object_size(int constructed, int length, int tag)\n{\n    int ret = 1;\n    if (length \u003c 0)\n        return -1;\n    if (tag \u003e= 31) {\n        while (tag \u003e 0) {\n            tag \u003e\u003e= 7;\n            ret++;\n        }\n    }\n    if (constructed == 2) {\n        ret += 3;\n    } else {\n        ret++;\n        if (length \u003e 127) {\n            int tmplen = length;\n            while (tmplen \u003e 0) {\n                tmplen \u003e\u003e= 8;\n                ret++;\n            }\n        }\n    }\n    if (ret \u003e= INT_MAX - length)\n        return -1;\n    return ret + length;\n}","filepath":"crypto/asn1/asn1_lib.c","line_number":215,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269986912":{"score":0.8908011,"function_name":"ASN1_put_eoc","code":"int ASN1_put_eoc(unsigned char **pp)\n{\n    unsigned char *p = *pp;\n    *p++ = 0;\n    *p++ = 0;\n    *pp = p;\n    return 2;\n}","filepath":"crypto/asn1/asn1_lib.c","line_number":185,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269986944":{"score":0.9057499,"function_name":"ASN1_put_object","code":"void ASN1_put_object(unsigned char **pp, int constructed, int length, int tag,\n                     int xclass)\n{\n    unsigned char *p = *pp;\n    int i, ttag;\n\n    i = (constructed) ? V_ASN1_CONSTRUCTED : 0;\n    i |= (xclass \u0026 V_ASN1_PRIVATE);\n    if (tag \u003c 31)\n        *(p++) = i | (tag \u0026 V_ASN1_PRIMITIVE_TAG);\n    else {\n        *(p++) = i | V_ASN1_PRIMITIVE_TAG;\n        for (i = 0, ttag = tag; ttag \u003e 0; i++)\n            ttag \u003e\u003e= 7;\n        ttag = i;\n        while (i-- \u003e 0) {\n            p[i] = tag \u0026 0x7f;\n            if (i != (ttag - 1))\n                p[i] |= 0x80;\n            tag \u003e\u003e= 7;\n        }\n        p += ttag;\n    }\n    if (constructed == 2)\n        *(p++) = 0x80;\n    else\n        asn1_put_length(\u0026p, length);\n    *pp = p;\n}","filepath":"crypto/asn1/asn1_lib.c","line_number":155,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269987152":{"score":0.91583526,"function_name":"asn1_string_embed_free","code":"void asn1_string_embed_free(ASN1_STRING *a, int embed)\n{\n    if (a == NULL)\n        return;\n    if (!(a-\u003eflags \u0026 ASN1_STRING_FLAG_NDEF))\n        OPENSSL_free(a-\u003edata);\n    if (embed == 0)\n        OPENSSL_free(a);\n}","filepath":"crypto/asn1/asn1_lib.c","line_number":325,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"269987312":{"score":0.9282304,"function_name":"ASN1_BIT_STRING_set_bit","code":"int ASN1_BIT_STRING_set_bit(ASN1_BIT_STRING *a, int n, int value)\n{\n    int w, v, iv;\n    unsigned char *c;\n\n    w = n / 8;\n    v = 1 \u003c\u003c (7 - (n \u0026 0x07));\n    iv = ~v;\n    if (!value)\n        v = 0;\n\n    if (a == NULL)\n        return 0;\n\n    a-\u003eflags \u0026= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07); /* clear, set on write */\n\n    if ((a-\u003elength \u003c (w + 1)) || (a-\u003edata == NULL)) {\n        if (!value)\n            return (1);         /* Don't need to set */\n        if (a-\u003edata == NULL)\n            c = (unsigned char *)OPENSSL_malloc(w + 1);\n        else\n            c = (unsigned char *)OPENSSL_realloc_clean(a-\u003edata,\n                                                       a-\u003elength, w + 1);\n        if (c == NULL) {\n            ASN1err(ASN1_F_ASN1_BIT_STRING_SET_BIT, ERR_R_MALLOC_FAILURE);\n            return 0;\n        }\n        if (w + 1 - a-\u003elength \u003e 0)\n            memset(c + a-\u003elength, 0, w + 1 - a-\u003elength);\n        a-\u003edata = c;\n        a-\u003elength = w + 1;\n    }\n    a-\u003edata[w] = ((a-\u003edata[w]) \u0026 iv) | v;\n    while ((a-\u003elength \u003e 0) \u0026\u0026 (a-\u003edata[a-\u003elength - 1] == 0))\n        a-\u003elength--;\n    return (1);\n}","filepath":"crypto/asn1/a_bitstr.c","line_number":188,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_0_9_8-post-auto-reformat"},"269987584":{"score":0.89163923,"function_name":"c2i_ASN1_BIT_STRING","code":"ASN1_BIT_STRING *c2i_ASN1_BIT_STRING(ASN1_BIT_STRING **a,\n                                     const unsigned char **pp, long len)\n{\n    ASN1_BIT_STRING *ret = NULL;\n    const unsigned char *p;\n    unsigned char *s;\n    int i;\n\n    if (len \u003c 1) {\n        i = ASN1_R_STRING_TOO_SHORT;\n        goto err;\n    }\n\n    if ((a == NULL) || ((*a) == NULL)) {\n        if ((ret = M_ASN1_BIT_STRING_new()) == NULL)\n            return (NULL);\n    } else\n        ret = (*a);\n\n    p = *pp;\n    i = *(p++);\n    if (i \u003e 7) {\n        i = ASN1_R_INVALID_BIT_STRING_BITS_LEFT;\n        goto err;\n    }\n    /*\n     * We do this to preserve the settings.  If we modify the settings, via\n     * the _set_bit function, we will recalculate on output\n     */\n    ret-\u003eflags \u0026= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07); /* clear */\n    ret-\u003eflags |= (ASN1_STRING_FLAG_BITS_LEFT | i); /* set */\n\n    if (len-- \u003e 1) {            /* using one because of the bits left byte */\n        s = (unsigned char *)OPENSSL_malloc((int)len);\n        if (s == NULL) {\n            i = ERR_R_MALLOC_FAILURE;\n            goto err;\n        }\n        memcpy(s, p, (int)len);\n        s[len - 1] \u0026= (0xff \u003c\u003c i);\n        p += len;\n    } else\n        s = NULL;\n\n    ret-\u003elength = (int)len;\n    if (ret-\u003edata != NULL)\n        OPENSSL_free(ret-\u003edata);\n    ret-\u003edata = s;\n    ret-\u003etype = V_ASN1_BIT_STRING;\n    if (a != NULL)\n        (*a) = ret;\n    *pp = p;\n    return (ret);\n err:\n    ASN1err(ASN1_F_C2I_ASN1_BIT_STRING, i);\n    if ((ret != NULL) \u0026\u0026 ((a == NULL) || (*a != ret)))\n        M_ASN1_BIT_STRING_free(ret);\n    return (NULL);\n}","filepath":"crypto/asn1/a_bitstr.c","line_number":125,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_0_9_8-post-auto-reformat"},"269987872":{"score":0.9472013,"function_name":"i2c_ASN1_BIT_STRING","code":"int i2c_ASN1_BIT_STRING(ASN1_BIT_STRING *a, unsigned char **pp)\n{\n    int ret, j, bits, len;\n    unsigned char *p, *d;\n\n    if (a == NULL)\n        return (0);\n\n    len = a-\u003elength;\n\n    if (len \u003e 0) {\n        if (a-\u003eflags \u0026 ASN1_STRING_FLAG_BITS_LEFT) {\n            bits = (int)a-\u003eflags \u0026 0x07;\n        } else {\n            for (; len \u003e 0; len--) {\n                if (a-\u003edata[len - 1])\n                    break;\n            }\n            j = a-\u003edata[len - 1];\n            if (j \u0026 0x01)\n                bits = 0;\n            else if (j \u0026 0x02)\n                bits = 1;\n            else if (j \u0026 0x04)\n                bits = 2;\n            else if (j \u0026 0x08)\n                bits = 3;\n            else if (j \u0026 0x10)\n                bits = 4;\n            else if (j \u0026 0x20)\n                bits = 5;\n            else if (j \u0026 0x40)\n                bits = 6;\n            else if (j \u0026 0x80)\n                bits = 7;\n            else\n                bits = 0;       /* should not happen */\n        }\n    } else\n        bits = 0;\n\n    ret = 1 + len;\n    if (pp == NULL)\n        return (ret);\n\n    p = *pp;\n\n    *(p++) = (unsigned char)bits;\n    d = a-\u003edata;\n    memcpy(p, d, len);\n    p += len;\n    if (len \u003e 0)\n        p[-1] \u0026= (0xff \u003c\u003c bits);\n    *pp = p;\n    return (ret);\n}","filepath":"crypto/asn1/a_bitstr.c","line_number":68,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_0_9_8-post-auto-reformat"},"269988112":{"score":0.8843815,"function_name":"ASN1_ENUMERATED_get","code":"long ASN1_ENUMERATED_get(const ASN1_ENUMERATED *a)\n{\n    int i;\n    int64_t r;\n    if (a == NULL)\n        return 0;\n    if ((a-\u003etype \u0026 ~V_ASN1_NEG) != V_ASN1_ENUMERATED)\n        return -1;\n    if (a-\u003elength \u003e (int)sizeof(long))\n        return 0xffffffffL;\n    i = ASN1_ENUMERATED_get_int64(\u0026r, a);\n    if (i == 0)\n        return -1;\n    if (r \u003e LONG_MAX || r \u003c LONG_MIN)\n        return -1;\n    return (long)r;\n}","filepath":"crypto/asn1/a_int.c","line_number":577,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"269988256":{"score":0.9188825,"function_name":"ASN1_INTEGER_cmp","code":"int ASN1_INTEGER_cmp(const ASN1_INTEGER *x, const ASN1_INTEGER *y)\n{\n    int neg, ret;\n    /* Compare signs */\n    neg = x-\u003etype \u0026 V_ASN1_NEG;\n    if (neg != (y-\u003etype \u0026 V_ASN1_NEG)) {\n        if (neg)\n            return -1;\n        else\n            return 1;\n    }\n\n    ret = ASN1_STRING_cmp(x, y);\n\n    if (neg)\n        return -ret;\n    else\n        return ret;\n}","filepath":"crypto/asn1/a_int.c","line_number":23,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"269988320":{"score":0.7972622,"function_name":"ASN1_INTEGER_get","code":"long ASN1_INTEGER_get(const ASN1_INTEGER *a)\n{\n    int i;\n    int64_t r;\n    if (a == NULL)\n        return 0;\n    i = ASN1_INTEGER_get_int64(\u0026r, a);\n    if (i == 0)\n        return -1;\n    if (r \u003e LONG_MAX || r \u003c LONG_MIN)\n        return -1;\n    return (long)r;\n}","filepath":"crypto/asn1/a_int.c","line_number":538,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"269988672":{"score":0.8748873,"function_name":"asn1_get_uint64","code":"static int asn1_get_uint64(uint64_t *pr, const unsigned char *b, size_t blen)\n{\n    size_t i;\n    uint64_t r;\n\n    if (blen \u003e sizeof(*pr)) {\n        ASN1err(ASN1_F_ASN1_GET_UINT64, ASN1_R_TOO_LARGE);\n        return 0;\n    }\n    if (b == NULL)\n        return 0;\n    for (r = 0, i = 0; i \u003c blen; i++) {\n        r \u003c\u003c= 8;\n        r |= b[i];\n    }\n    *pr = r;\n    return 1;\n}","filepath":"crypto/asn1/a_int.c","line_number":207,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"269988816":{"score":0.6920966,"function_name":"asn1_string_get_uint64","code":"static int asn1_string_get_uint64(uint64_t *pr, const ASN1_STRING *a,\n                                  int itype)\n{\n    if (a == NULL) {\n        ASN1err(ASN1_F_ASN1_STRING_GET_UINT64, ERR_R_PASSED_NULL_PARAMETER);\n        return 0;\n    }\n    if ((a-\u003etype \u0026 ~V_ASN1_NEG) != itype) {\n        ASN1err(ASN1_F_ASN1_STRING_GET_UINT64, ASN1_R_WRONG_INTEGER_TYPE);\n        return 0;\n    }\n    if (a-\u003etype \u0026 V_ASN1_NEG) {\n        ASN1err(ASN1_F_ASN1_STRING_GET_UINT64, ASN1_R_ILLEGAL_NEGATIVE_VALUE);\n        return 0;\n    }\n    return asn1_get_uint64(pr, a-\u003edata, a-\u003elength);\n}","filepath":"crypto/asn1/a_int.c","line_number":353,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"269989136":{"score":0.6934265,"function_name":"asn1_string_set_int64","code":"static int asn1_string_set_int64(ASN1_STRING *a, int64_t r, int itype)\n{\n    unsigned char tbuf[sizeof(r)];\n    size_t off;\n\n    a-\u003etype = itype;\n    if (r \u003c 0) {\n        /* Most obvious '-r' triggers undefined behaviour for most\n         * common INT64_MIN. Even though below '0 - (uint64_t)r' can\n         * appear two's-complement centric, it does produce correct/\n         * expected result even on one's-complement. This is because\n         * cast to unsigned has to change bit pattern... */\n        off = asn1_put_uint64(tbuf, 0 - (uint64_t)r);\n        a-\u003etype |= V_ASN1_NEG;\n    } else {\n        off = asn1_put_uint64(tbuf, r);\n        a-\u003etype \u0026= ~V_ASN1_NEG;\n    }\n    return ASN1_STRING_set(a, tbuf + off, sizeof(tbuf) - off);\n}","filepath":"crypto/asn1/a_int.c","line_number":332,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"269989312":{"score":0.9250275,"function_name":"asn1_string_to_bn","code":"static BIGNUM *asn1_string_to_bn(const ASN1_INTEGER *ai, BIGNUM *bn,\n                                 int itype)\n{\n    BIGNUM *ret;\n\n    if ((ai-\u003etype \u0026 ~V_ASN1_NEG) != itype) {\n        ASN1err(ASN1_F_ASN1_STRING_TO_BN, ASN1_R_WRONG_INTEGER_TYPE);\n        return NULL;\n    }\n\n    ret = BN_bin2bn(ai-\u003edata, ai-\u003elength, bn);\n    if (ret == NULL) {\n        ASN1err(ASN1_F_ASN1_STRING_TO_BN, ASN1_R_BN_LIB);\n        return NULL;\n    }\n    if (ai-\u003etype \u0026 V_ASN1_NEG)\n        BN_set_negative(ret, 1);\n    return ret;\n}","filepath":"crypto/asn1/a_int.c","line_number":493,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"269989456":{"score":0.8849051,"function_name":"bn_to_asn1_string","code":"static ASN1_STRING *bn_to_asn1_string(const BIGNUM *bn, ASN1_STRING *ai,\n                                      int atype)\n{\n    ASN1_INTEGER *ret;\n    int len;\n\n    if (ai == NULL) {\n        ret = ASN1_STRING_type_new(atype);\n    } else {\n        ret = ai;\n        ret-\u003etype = atype;\n    }\n\n    if (ret == NULL) {\n        ASN1err(ASN1_F_BN_TO_ASN1_STRING, ERR_R_NESTED_ASN1_ERROR);\n        goto err;\n    }\n\n    if (BN_is_negative(bn) \u0026\u0026 !BN_is_zero(bn))\n        ret-\u003etype |= V_ASN1_NEG_INTEGER;\n\n    len = BN_num_bytes(bn);\n\n    if (len == 0)\n        len = 1;\n\n    if (ASN1_STRING_set(ret, NULL, len) == 0) {\n        ASN1err(ASN1_F_BN_TO_ASN1_STRING, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    /* Correct zero case */\n    if (BN_is_zero(bn))\n        ret-\u003edata[0] = 0;\n    else\n        len = BN_bn2bin(bn, ret-\u003edata);\n    ret-\u003elength = len;\n    return ret;\n err:\n    if (ret != ai)\n        ASN1_INTEGER_free(ret);\n    return NULL;\n}","filepath":"crypto/asn1/a_int.c","line_number":449,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"269989696":{"score":0.9007114,"function_name":"c2i_ASN1_INTEGER","code":"ASN1_INTEGER *c2i_ASN1_INTEGER(ASN1_INTEGER **a, const unsigned char **pp,\n                               long len)\n{\n    ASN1_INTEGER *ret = NULL;\n    size_t r;\n    int neg;\n\n    r = c2i_ibuf(NULL, NULL, *pp, len);\n\n    if (r == 0)\n        return NULL;\n\n    if ((a == NULL) || ((*a) == NULL)) {\n        ret = ASN1_INTEGER_new();\n        if (ret == NULL)\n            return NULL;\n        ret-\u003etype = V_ASN1_INTEGER;\n    } else\n        ret = *a;\n\n    if (ASN1_STRING_set(ret, NULL, r) == 0)\n        goto err;\n\n    c2i_ibuf(ret-\u003edata, \u0026neg, *pp, len);\n\n    if (neg)\n        ret-\u003etype |= V_ASN1_NEG;\n\n    *pp += len;\n    if (a != NULL)\n        (*a) = ret;\n    return ret;\n err:\n    ASN1err(ASN1_F_C2I_ASN1_INTEGER, ERR_R_MALLOC_FAILURE);\n    if ((a == NULL) || (*a != ret))\n        ASN1_INTEGER_free(ret);\n    return NULL;\n}","filepath":"crypto/asn1/a_int.c","line_number":280,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"269989904":{"score":0.8786522,"function_name":"c2i_ibuf","code":"static size_t c2i_ibuf(unsigned char *b, int *pneg,\n                       const unsigned char *p, size_t plen)\n{\n    int neg, pad;\n    /* Zero content length is illegal */\n    if (plen == 0) {\n        ASN1err(ASN1_F_C2I_IBUF, ASN1_R_ILLEGAL_ZERO_CONTENT);\n        return 0;\n    }\n    neg = p[0] \u0026 0x80;\n    if (pneg)\n        *pneg = neg;\n    /* Handle common case where length is 1 octet separately */\n    if (plen == 1) {\n        if (b != NULL) {\n            if (neg)\n                b[0] = (p[0] ^ 0xFF) + 1;\n            else\n                b[0] = p[0];\n        }\n        return 1;\n    }\n\n    pad = 0;\n    if (p[0] == 0) {\n        pad = 1;\n    } else if (p[0] == 0xFF) {\n        size_t i;\n\n        /*\n         * Special case [of \"one less minimal negative\" for given length]:\n         * if any other bytes non zero it was padded, otherwise not.\n         */\n        for (pad = 0, i = 1; i \u003c plen; i++)\n            pad |= p[i];\n        pad = pad != 0 ? 1 : 0;\n    }\n    /* reject illegal padding: first two octets MSB can't match */\n    if (pad \u0026\u0026 (neg == (p[1] \u0026 0x80))) {\n        ASN1err(ASN1_F_C2I_IBUF, ASN1_R_ILLEGAL_PADDING);\n        return 0;\n    }\n\n    /* skip over pad */\n    p += pad;\n    plen -= pad;\n\n    if (b != NULL)\n        twos_complement(b, p, plen, neg ? 0xffU : 0);\n\n    return plen;\n}","filepath":"crypto/asn1/a_int.c","line_number":148,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"269990288":{"score":0.69159615,"function_name":"c2i_uint64_int","code":"int c2i_uint64_int(uint64_t *ret, int *neg, const unsigned char **pp, long len)\n{\n    unsigned char buf[sizeof(uint64_t)];\n    size_t buflen;\n\n    buflen = c2i_ibuf(NULL, NULL, *pp, len);\n    if (buflen == 0)\n        return 0;\n    if (buflen \u003e sizeof(uint64_t)) {\n        ASN1err(ASN1_F_C2I_UINT64_INT, ASN1_R_TOO_LARGE);\n        return 0;\n    }\n    (void)c2i_ibuf(buf, neg, *pp, len);\n    return asn1_get_uint64(ret, buf, buflen);\n}","filepath":"crypto/asn1/a_int.c","line_number":606,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"269990496":{"score":0.9050456,"function_name":"i2c_ibuf","code":"static size_t i2c_ibuf(const unsigned char *b, size_t blen, int neg,\n                       unsigned char **pp)\n{\n    unsigned int pad = 0;\n    size_t ret, i;\n    unsigned char *p, pb = 0;\n\n    if (b != NULL \u0026\u0026 blen) {\n        ret = blen;\n        i = b[0];\n        if (!neg \u0026\u0026 (i \u003e 127)) {\n            pad = 1;\n            pb = 0;\n        } else if (neg) {\n            pb = 0xFF;\n            if (i \u003e 128) {\n                pad = 1;\n            } else if (i == 128) {\n                /*\n                 * Special case [of minimal negative for given length]:\n                 * if any other bytes non zero we pad, otherwise we don't.\n                 */\n                for (pad = 0, i = 1; i \u003c blen; i++)\n                    pad |= b[i];\n                pb = pad != 0 ? 0xffU : 0;\n                pad = pb \u0026 1;\n            }\n        }\n        ret += pad;\n    } else {\n        ret = 1;\n        blen = 0;   /* reduce '(b == NULL || blen == 0)' to '(blen == 0)' */\n    }\n\n    if (pp == NULL || (p = *pp) == NULL)\n        return ret;\n\n    /*\n     * This magically handles all corner cases, such as '(b == NULL ||\n     * blen == 0)', non-negative value, \"negative\" zero, 0x80 followed\n     * by any number of zeros...\n     */\n    *p = pb;\n    p += pad;       /* yes, p[0] can be written twice, but it's little\n                     * price to pay for eliminated branches */\n    twos_complement(p, b, blen, pb);\n\n    *pp += ret;\n    return ret;\n}","filepath":"crypto/asn1/a_int.c","line_number":91,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"269990928":{"score":0.8915235,"function_name":"twos_complement","code":"static void twos_complement(unsigned char *dst, const unsigned char *src,\n                            size_t len, unsigned char pad)\n{\n    unsigned int carry = pad \u0026 1;\n\n    /* Begin at the end of the encoding */\n    dst += len;\n    src += len;\n    /* two's complement value: ~value + 1 */\n    while (len-- != 0) {\n        *(--dst) = (unsigned char)(carry += *(--src) ^ pad);\n        carry \u003e\u003e= 8;\n    }\n}","filepath":"crypto/asn1/a_int.c","line_number":76,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"269991072":{"score":0.785456,"function_name":"EC_GROUP_clear_free","code":"void EC_GROUP_clear_free(EC_GROUP *group)\n{\n    if (!group)\n        return;\n\n    if (group-\u003emeth-\u003egroup_clear_finish != 0)\n        group-\u003emeth-\u003egroup_clear_finish(group);\n    else if (group-\u003emeth-\u003egroup_finish != 0)\n        group-\u003emeth-\u003egroup_finish(group);\n\n    EC_pre_comp_free(group);\n    BN_MONT_CTX_free(group-\u003emont_data);\n    EC_POINT_clear_free(group-\u003egenerator);\n    BN_clear_free(group-\u003eorder);\n    BN_clear_free(group-\u003ecofactor);\n    OPENSSL_clear_free(group-\u003eseed, group-\u003eseed_len);\n    OPENSSL_clear_free(group, sizeof(*group));\n}","filepath":"crypto/ec/ec_lib.c","line_number":111,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0l"},"269991280":{"score":0.7874657,"function_name":"EC_GROUP_cmp","code":"int EC_GROUP_cmp(const EC_GROUP *a, const EC_GROUP *b, BN_CTX *ctx)\n{\n    int r = 0;\n    BIGNUM *a1, *a2, *a3, *b1, *b2, *b3;\n    BN_CTX *ctx_new = NULL;\n\n    /* compare the field types */\n    if (EC_METHOD_get_field_type(EC_GROUP_method_of(a)) !=\n        EC_METHOD_get_field_type(EC_GROUP_method_of(b)))\n        return 1;\n    /* compare the curve name (if present in both) */\n    if (EC_GROUP_get_curve_name(a) \u0026\u0026 EC_GROUP_get_curve_name(b) \u0026\u0026\n        EC_GROUP_get_curve_name(a) != EC_GROUP_get_curve_name(b))\n        return 1;\n    if (a-\u003emeth-\u003eflags \u0026 EC_FLAGS_CUSTOM_CURVE)\n        return 0;\n\n    if (ctx == NULL)\n        ctx_new = ctx = BN_CTX_new();\n    if (ctx == NULL)\n        return -1;\n\n    BN_CTX_start(ctx);\n    a1 = BN_CTX_get(ctx);\n    a2 = BN_CTX_get(ctx);\n    a3 = BN_CTX_get(ctx);\n    b1 = BN_CTX_get(ctx);\n    b2 = BN_CTX_get(ctx);\n    b3 = BN_CTX_get(ctx);\n    if (b3 == NULL) {\n        BN_CTX_end(ctx);\n        BN_CTX_free(ctx_new);\n        return -1;\n    }\n\n    /*\n     * XXX This approach assumes that the external representation of curves\n     * over the same field type is the same.\n     */\n    if (!a-\u003emeth-\u003egroup_get_curve(a, a1, a2, a3, ctx) ||\n        !b-\u003emeth-\u003egroup_get_curve(b, b1, b2, b3, ctx))\n        r = 1;\n\n    if (r || BN_cmp(a1, b1) || BN_cmp(a2, b2) || BN_cmp(a3, b3))\n        r = 1;\n\n    /* XXX EC_POINT_cmp() assumes that the methods are equal */\n    if (r || EC_POINT_cmp(a, EC_GROUP_get0_generator(a),\n                          EC_GROUP_get0_generator(b), ctx))\n        r = 1;\n\n    if (!r) {\n        const BIGNUM *ao, *bo, *ac, *bc;\n        /* compare the order and cofactor */\n        ao = EC_GROUP_get0_order(a);\n        bo = EC_GROUP_get0_order(b);\n        ac = EC_GROUP_get0_cofactor(a);\n        bc = EC_GROUP_get0_cofactor(b);\n        if (ao == NULL || bo == NULL) {\n            BN_CTX_end(ctx);\n            BN_CTX_free(ctx_new);\n            return -1;\n        }\n        if (BN_cmp(ao, bo) || BN_cmp(ac, bc))\n            r = 1;\n    }\n\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx_new);\n\n    return r;\n}","filepath":"crypto/ec/ec_lib.c","line_number":561,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0l"},"269991856":{"score":0.93359125,"function_name":"EC_GROUP_copy","code":"int EC_GROUP_copy(EC_GROUP *dest, const EC_GROUP *src)\n{\n    if (dest-\u003emeth-\u003egroup_copy == 0) {\n        ECerr(EC_F_EC_GROUP_COPY, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return 0;\n    }\n    if (dest-\u003emeth != src-\u003emeth) {\n        ECerr(EC_F_EC_GROUP_COPY, EC_R_INCOMPATIBLE_OBJECTS);\n        return 0;\n    }\n    if (dest == src)\n        return 1;\n\n    dest-\u003ecurve_name = src-\u003ecurve_name;\n\n    /* Copy precomputed */\n    dest-\u003epre_comp_type = src-\u003epre_comp_type;\n    switch (src-\u003epre_comp_type) {\n    default:\n        dest-\u003epre_comp.ec = NULL;\n        break;\n#ifdef ECP_NISTZ256_REFERENCE_IMPLEMENTATION\n    case PCT_nistz256:\n        dest-\u003epre_comp.nistz256 = EC_nistz256_pre_comp_dup(src-\u003epre_comp.nistz256);\n        break;\n#endif\n#ifndef OPENSSL_NO_EC_NISTP_64_GCC_128\n    case PCT_nistp224:\n        dest-\u003epre_comp.nistp224 = EC_nistp224_pre_comp_dup(src-\u003epre_comp.nistp224);\n        break;\n    case PCT_nistp256:\n        dest-\u003epre_comp.nistp256 = EC_nistp256_pre_comp_dup(src-\u003epre_comp.nistp256);\n        break;\n    case PCT_nistp521:\n        dest-\u003epre_comp.nistp521 = EC_nistp521_pre_comp_dup(src-\u003epre_comp.nistp521);\n        break;\n#endif\n    case PCT_ec:\n        dest-\u003epre_comp.ec = EC_ec_pre_comp_dup(src-\u003epre_comp.ec);\n        break;\n    }\n\n    if (src-\u003emont_data != NULL) {\n        if (dest-\u003emont_data == NULL) {\n            dest-\u003emont_data = BN_MONT_CTX_new();\n            if (dest-\u003emont_data == NULL)\n                return 0;\n        }\n        if (!BN_MONT_CTX_copy(dest-\u003emont_data, src-\u003emont_data))\n            return 0;\n    } else {\n        /* src-\u003egenerator == NULL */\n        BN_MONT_CTX_free(dest-\u003emont_data);\n        dest-\u003emont_data = NULL;\n    }\n\n    if (src-\u003egenerator != NULL) {\n        if (dest-\u003egenerator == NULL) {\n            dest-\u003egenerator = EC_POINT_new(dest);\n            if (dest-\u003egenerator == NULL)\n                return 0;\n        }\n        if (!EC_POINT_copy(dest-\u003egenerator, src-\u003egenerator))\n            return 0;\n    } else {\n        /* src-\u003egenerator == NULL */\n        EC_POINT_clear_free(dest-\u003egenerator);\n        dest-\u003egenerator = NULL;\n    }\n\n    if ((src-\u003emeth-\u003eflags \u0026 EC_FLAGS_CUSTOM_CURVE) == 0) {\n        if (!BN_copy(dest-\u003eorder, src-\u003eorder))\n            return 0;\n        if (!BN_copy(dest-\u003ecofactor, src-\u003ecofactor))\n            return 0;\n    }\n\n    dest-\u003easn1_flag = src-\u003easn1_flag;\n    dest-\u003easn1_form = src-\u003easn1_form;\n\n    if (src-\u003eseed) {\n        OPENSSL_free(dest-\u003eseed);\n        dest-\u003eseed = OPENSSL_malloc(src-\u003eseed_len);\n        if (dest-\u003eseed == NULL)\n            return 0;\n        if (!memcpy(dest-\u003eseed, src-\u003eseed, src-\u003eseed_len))\n            return 0;\n        dest-\u003eseed_len = src-\u003eseed_len;\n    } else {\n        OPENSSL_free(dest-\u003eseed);\n        dest-\u003eseed = NULL;\n        dest-\u003eseed_len = 0;\n    }\n\n    return dest-\u003emeth-\u003egroup_copy(dest, src);\n}","filepath":"crypto/ec/ec_lib.c","line_number":130,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0l"},"269992992":{"score":0.85021573,"function_name":"EC_GROUP_get_cofactor","code":"int EC_GROUP_get_cofactor(const EC_GROUP *group, BIGNUM *cofactor,\n                          BN_CTX *ctx)\n{\n\n    if (group-\u003ecofactor == NULL)\n        return 0;\n    if (!BN_copy(cofactor, group-\u003ecofactor))\n        return 0;\n\n    return !BN_is_zero(group-\u003ecofactor);\n}","filepath":"crypto/ec/ec_lib.c","line_number":422,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0l"},"269993056":{"score":0.9300568,"function_name":"EC_GROUP_get_degree","code":"int EC_GROUP_get_degree(const EC_GROUP *group)\n{\n    if (group-\u003emeth-\u003egroup_get_degree == 0) {\n        ECerr(EC_F_EC_GROUP_GET_DEGREE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return 0;\n    }\n    return group-\u003emeth-\u003egroup_get_degree(group);\n}","filepath":"crypto/ec/ec_lib.c","line_number":542,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0l"},"269993200":{"score":0.85090494,"function_name":"EC_GROUP_get_order","code":"int EC_GROUP_get_order(const EC_GROUP *group, BIGNUM *order, BN_CTX *ctx)\n{\n    if (group-\u003eorder == NULL)\n        return 0;\n    if (!BN_copy(order, group-\u003eorder))\n        return 0;\n\n    return !BN_is_zero(order);\n}","filepath":"crypto/ec/ec_lib.c","line_number":401,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0l"},"269993296":{"score":0.9460894,"function_name":"EC_GROUP_new","code":"EC_GROUP *EC_GROUP_new(const EC_METHOD *meth)\n{\n    EC_GROUP *ret;\n\n    if (meth == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW, EC_R_SLOT_FULL);\n        return NULL;\n    }\n    if (meth-\u003egroup_init == 0) {\n        ECerr(EC_F_EC_GROUP_NEW, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return NULL;\n    }\n\n    ret = OPENSSL_zalloc(sizeof(*ret));\n    if (ret == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    ret-\u003emeth = meth;\n    if ((ret-\u003emeth-\u003eflags \u0026 EC_FLAGS_CUSTOM_CURVE) == 0) {\n        ret-\u003eorder = BN_new();\n        if (ret-\u003eorder == NULL)\n            goto err;\n        ret-\u003ecofactor = BN_new();\n        if (ret-\u003ecofactor == NULL)\n            goto err;\n    }\n    ret-\u003easn1_flag = OPENSSL_EC_NAMED_CURVE;\n    ret-\u003easn1_form = POINT_CONVERSION_UNCOMPRESSED;\n    if (!meth-\u003egroup_init(ret))\n        goto err;\n    return ret;\n\n err:\n    BN_free(ret-\u003eorder);\n    BN_free(ret-\u003ecofactor);\n    OPENSSL_free(ret);\n    return NULL;\n}","filepath":"crypto/ec/ec_lib.c","line_number":25,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0l"},"269993616":{"score":0.7885321,"function_name":"EC_GROUP_set_generator","code":"int EC_GROUP_set_generator(EC_GROUP *group, const EC_POINT *generator,\n                           const BIGNUM *order, const BIGNUM *cofactor)\n{\n    if (generator == NULL) {\n        ECerr(EC_F_EC_GROUP_SET_GENERATOR, ERR_R_PASSED_NULL_PARAMETER);\n        return 0;\n    }\n\n    /* require group-\u003efield \u003e= 1 */\n    if (group-\u003efield == NULL || BN_is_zero(group-\u003efield)\n        || BN_is_negative(group-\u003efield)) {\n        ECerr(EC_F_EC_GROUP_SET_GENERATOR, EC_R_INVALID_FIELD);\n        return 0;\n    }\n\n    /*-\n     * - require order \u003e= 1\n     * - enforce upper bound due to Hasse thm: order can be no more than one bit\n     *   longer than field cardinality\n     */\n    if (order == NULL || BN_is_zero(order) || BN_is_negative(order)\n        || BN_num_bits(order) \u003e BN_num_bits(group-\u003efield) + 1) {\n        ECerr(EC_F_EC_GROUP_SET_GENERATOR, EC_R_INVALID_GROUP_ORDER);\n        return 0;\n    }\n\n    /*-\n     * Unfortunately the cofactor is an optional field in many standards.\n     * Internally, the lib uses 0 cofactor as a marker for \"unknown cofactor\".\n     * So accept cofactor == NULL or cofactor \u003e= 0.\n     */\n    if (cofactor != NULL \u0026\u0026 BN_is_negative(cofactor)) {\n        ECerr(EC_F_EC_GROUP_SET_GENERATOR, EC_R_UNKNOWN_COFACTOR);\n        return 0;\n    }\n\n    if (group-\u003egenerator == NULL) {\n        group-\u003egenerator = EC_POINT_new(group);\n        if (group-\u003egenerator == NULL)\n            return 0;\n    }\n    if (!EC_POINT_copy(group-\u003egenerator, generator))\n        return 0;\n\n    if (!BN_copy(group-\u003eorder, order))\n        return 0;\n\n    /* Either take the provided positive cofactor, or try to compute it */\n    if (cofactor != NULL \u0026\u0026 !BN_is_zero(cofactor)) {\n        if (!BN_copy(group-\u003ecofactor, cofactor))\n            return 0;\n    } else if (!ec_guess_cofactor(group)) {\n        BN_zero(group-\u003ecofactor);\n        return 0;\n    }\n\n    /*\n     * Some groups have an order with\n     * factors of two, which makes the Montgomery setup fail.\n     * |group-\u003emont_data| will be NULL in this case.\n     */\n    if (BN_is_odd(group-\u003eorder)) {\n        return ec_precompute_mont_data(group);\n    }\n\n    BN_MONT_CTX_free(group-\u003emont_data);\n    group-\u003emont_data = NULL;\n    return 1;\n}","filepath":"crypto/ec/ec_lib.c","line_number":321,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0l"},"269994448":{"score":0.88839537,"function_name":"EC_GROUP_set_seed","code":"size_t EC_GROUP_set_seed(EC_GROUP *group, const unsigned char *p, size_t len)\n{\n    OPENSSL_free(group-\u003eseed);\n    group-\u003eseed = NULL;\n    group-\u003eseed_len = 0;\n\n    if (!len || !p)\n        return 1;\n\n    if ((group-\u003eseed = OPENSSL_malloc(len)) == NULL)\n        return 0;\n    memcpy(group-\u003eseed, p, len);\n    group-\u003eseed_len = len;\n\n    return len;\n}","filepath":"crypto/ec/ec_lib.c","line_number":471,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0l"},"269994592":{"score":0.9090744,"function_name":"EC_POINT_add","code":"int EC_POINT_add(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,\n                 const EC_POINT *b, BN_CTX *ctx)\n{\n    if (group-\u003emeth-\u003eadd == 0) {\n        ECerr(EC_F_EC_POINT_ADD, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return 0;\n    }\n    if (!ec_point_is_compat(r, group) || !ec_point_is_compat(a, group)\n        || !ec_point_is_compat(b, group)) {\n        ECerr(EC_F_EC_POINT_ADD, EC_R_INCOMPATIBLE_OBJECTS);\n        return 0;\n    }\n    return group-\u003emeth-\u003eadd(group, r, a, b, ctx);\n}","filepath":"crypto/ec/ec_lib.c","line_number":880,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0l"},"269994768":{"score":0.8709253,"function_name":"EC_POINT_clear_free","code":"void EC_POINT_clear_free(EC_POINT *point)\n{\n    if (!point)\n        return;\n\n    if (point-\u003emeth-\u003epoint_clear_finish != 0)\n        point-\u003emeth-\u003epoint_clear_finish(point);\n    else if (point-\u003emeth-\u003epoint_finish != 0)\n        point-\u003emeth-\u003epoint_finish(point);\n    OPENSSL_clear_free(point, sizeof(*point));\n}","filepath":"crypto/ec/ec_lib.c","line_number":676,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0l"},"269994832":{"score":0.8973056,"function_name":"EC_POINT_cmp","code":"int EC_POINT_cmp(const EC_GROUP *group, const EC_POINT *a, const EC_POINT *b,\n                 BN_CTX *ctx)\n{\n    if (group-\u003emeth-\u003epoint_cmp == 0) {\n        ECerr(EC_F_EC_POINT_CMP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return -1;\n    }\n    if (!ec_point_is_compat(a, group) || !ec_point_is_compat(b, group)) {\n        ECerr(EC_F_EC_POINT_CMP, EC_R_INCOMPATIBLE_OBJECTS);\n        return -1;\n    }\n    return group-\u003emeth-\u003epoint_cmp(group, a, b, ctx);\n}","filepath":"crypto/ec/ec_lib.c","line_number":957,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0l"},"269994976":{"score":0.94397587,"function_name":"EC_POINT_copy","code":"int EC_POINT_copy(EC_POINT *dest, const EC_POINT *src)\n{\n    if (dest-\u003emeth-\u003epoint_copy == 0) {\n        ECerr(EC_F_EC_POINT_COPY, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return 0;\n    }\n    if (dest-\u003emeth != src-\u003emeth\n            || (dest-\u003ecurve_name != src-\u003ecurve_name\n                \u0026\u0026 dest-\u003ecurve_name != 0\n                \u0026\u0026 src-\u003ecurve_name != 0)) {\n        ECerr(EC_F_EC_POINT_COPY, EC_R_INCOMPATIBLE_OBJECTS);\n        return 0;\n    }\n    if (dest == src)\n        return 1;\n    return dest-\u003emeth-\u003epoint_copy(dest, src);\n}","filepath":"crypto/ec/ec_lib.c","line_number":688,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0l"},"269995104":{"score":0.89777637,"function_name":"EC_POINT_dbl","code":"int EC_POINT_dbl(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,\n                 BN_CTX *ctx)\n{\n    if (group-\u003emeth-\u003edbl == 0) {\n        ECerr(EC_F_EC_POINT_DBL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return 0;\n    }\n    if (!ec_point_is_compat(r, group) || !ec_point_is_compat(a, group)) {\n        ECerr(EC_F_EC_POINT_DBL, EC_R_INCOMPATIBLE_OBJECTS);\n        return 0;\n    }\n    return group-\u003emeth-\u003edbl(group, r, a, ctx);\n}","filepath":"crypto/ec/ec_lib.c","line_number":895,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0l"},"269995248":{"score":0.884552,"function_name":"EC_POINT_free","code":"void EC_POINT_free(EC_POINT *point)\n{\n    if (!point)\n        return;\n\n    if (point-\u003emeth-\u003epoint_finish != 0)\n        point-\u003emeth-\u003epoint_finish(point);\n    OPENSSL_free(point);\n}","filepath":"crypto/ec/ec_lib.c","line_number":666,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0l"},"269996016":{"score":0.6189265,"function_name":"EC_POINT_mul","code":"int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *g_scalar,\n                 const EC_POINT *point, const BIGNUM *p_scalar, BN_CTX *ctx)\n{\n    /* just a convenient interface to EC_POINTs_mul() */\n\n    const EC_POINT *points[1];\n    const BIGNUM *scalars[1];\n\n    points[0] = point;\n    scalars[0] = p_scalar;\n\n    return EC_POINTs_mul(group, r, g_scalar,\n                         (point != NULL\n                          \u0026\u0026 p_scalar != NULL), points, scalars, ctx);\n}","filepath":"crypto/ec/ec_lib.c","line_number":1019,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0l"},"269996096":{"score":0.94927764,"function_name":"EC_POINT_new","code":"EC_POINT *EC_POINT_new(const EC_GROUP *group)\n{\n    EC_POINT *ret;\n\n    if (group == NULL) {\n        ECerr(EC_F_EC_POINT_NEW, ERR_R_PASSED_NULL_PARAMETER);\n        return NULL;\n    }\n    if (group-\u003emeth-\u003epoint_init == 0) {\n        ECerr(EC_F_EC_POINT_NEW, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return NULL;\n    }\n\n    ret = OPENSSL_zalloc(sizeof(*ret));\n    if (ret == NULL) {\n        ECerr(EC_F_EC_POINT_NEW, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    ret-\u003emeth = group-\u003emeth;\n    ret-\u003ecurve_name = group-\u003ecurve_name;\n\n    if (!ret-\u003emeth-\u003epoint_init(ret)) {\n        OPENSSL_free(ret);\n        return NULL;\n    }\n\n    return ret;\n}","filepath":"crypto/ec/ec_lib.c","line_number":636,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0l"},"269996416":{"score":0.8845405,"function_name":"EC_POINT_set_affine_coordinates_GF2m","code":"int EC_POINT_set_affine_coordinates_GF2m(const EC_GROUP *group,\n                                         EC_POINT *point, const BIGNUM *x,\n                                         const BIGNUM *y, BN_CTX *ctx)\n{\n    if (group-\u003emeth-\u003epoint_set_affine_coordinates == 0) {\n        ECerr(EC_F_EC_POINT_SET_AFFINE_COORDINATES_GF2M,\n              ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return 0;\n    }\n    if (!ec_point_is_compat(point, group)) {\n        ECerr(EC_F_EC_POINT_SET_AFFINE_COORDINATES_GF2M,\n              EC_R_INCOMPATIBLE_OBJECTS);\n        return 0;\n    }\n    if (!group-\u003emeth-\u003epoint_set_affine_coordinates(group, point, x, y, ctx))\n        return 0;\n\n    if (EC_POINT_is_on_curve(group, point, ctx) \u003c= 0) {\n        ECerr(EC_F_EC_POINT_SET_AFFINE_COORDINATES_GF2M,\n              EC_R_POINT_IS_NOT_ON_CURVE);\n        return 0;\n    }\n    return 1;\n}","filepath":"crypto/ec/ec_lib.c","line_number":808,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0l"},"269996688":{"score":0.91631204,"function_name":"EC_POINT_set_to_infinity","code":"int EC_POINT_set_to_infinity(const EC_GROUP *group, EC_POINT *point)\n{\n    if (group-\u003emeth-\u003epoint_set_to_infinity == 0) {\n        ECerr(EC_F_EC_POINT_SET_TO_INFINITY,\n              ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return 0;\n    }\n    if (group-\u003emeth != point-\u003emeth) {\n        ECerr(EC_F_EC_POINT_SET_TO_INFINITY, EC_R_INCOMPATIBLE_OBJECTS);\n        return 0;\n    }\n    return group-\u003emeth-\u003epoint_set_to_infinity(group, point);\n}","filepath":"crypto/ec/ec_lib.c","line_number":730,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0l"},"269996784":{"score":0.7663598,"function_name":"EC_POINTs_make_affine","code":"int EC_POINTs_make_affine(const EC_GROUP *group, size_t num,\n                          EC_POINT *points[], BN_CTX *ctx)\n{\n    size_t i;\n\n    if (group-\u003emeth-\u003epoints_make_affine == 0) {\n        ECerr(EC_F_EC_POINTS_MAKE_AFFINE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return 0;\n    }\n    for (i = 0; i \u003c num; i++) {\n        if (!ec_point_is_compat(points[i], group)) {\n            ECerr(EC_F_EC_POINTS_MAKE_AFFINE, EC_R_INCOMPATIBLE_OBJECTS);\n            return 0;\n        }\n    }\n    return group-\u003emeth-\u003epoints_make_affine(group, num, points, ctx);\n}","filepath":"crypto/ec/ec_lib.c","line_number":984,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0l"},"269997296":{"score":0.7775598,"function_name":"EC_pre_comp_free","code":"void EC_pre_comp_free(EC_GROUP *group)\n{\n    switch (group-\u003epre_comp_type) {\n    default:\n        break;\n#ifdef ECP_NISTZ256_REFERENCE_IMPLEMENTATION\n    case PCT_nistz256:\n        EC_nistz256_pre_comp_free(group-\u003epre_comp.nistz256);\n        break;\n#endif\n#ifndef OPENSSL_NO_EC_NISTP_64_GCC_128\n    case PCT_nistp224:\n        EC_nistp224_pre_comp_free(group-\u003epre_comp.nistp224);\n        break;\n    case PCT_nistp256:\n        EC_nistp256_pre_comp_free(group-\u003epre_comp.nistp256);\n        break;\n    case PCT_nistp521:\n        EC_nistp521_pre_comp_free(group-\u003epre_comp.nistp521);\n        break;\n#endif\n    case PCT_ec:\n        EC_ec_pre_comp_free(group-\u003epre_comp.ec);\n        break;\n    }\n    group-\u003epre_comp.ec = NULL;\n}","filepath":"crypto/ec/ec_lib.c","line_number":66,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0l"},"269999744":{"score":0.9383103,"function_name":"EC_POINT_set_compressed_coordinates_GF2m","code":"int EC_POINT_set_compressed_coordinates_GF2m(const EC_GROUP *group,\n                                             EC_POINT *point, const BIGNUM *x,\n                                             int y_bit, BN_CTX *ctx)\n{\n    if (group-\u003emeth-\u003epoint_set_compressed_coordinates == 0\n        \u0026\u0026 !(group-\u003emeth-\u003eflags \u0026 EC_FLAGS_DEFAULT_OCT)) {\n        ECerr(EC_F_EC_POINT_SET_COMPRESSED_COORDINATES_GF2M,\n              ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return 0;\n    }\n    if (group-\u003emeth != point-\u003emeth) {\n        ECerr(EC_F_EC_POINT_SET_COMPRESSED_COORDINATES_GF2M,\n              EC_R_INCOMPATIBLE_OBJECTS);\n        return 0;\n    }\n    if (group-\u003emeth-\u003eflags \u0026 EC_FLAGS_DEFAULT_OCT) {\n        if (group-\u003emeth-\u003efield_type == NID_X9_62_prime_field)\n            return ec_GFp_simple_set_compressed_coordinates(group, point, x,\n                                                            y_bit, ctx);\n        else\n            return ec_GF2m_simple_set_compressed_coordinates(group, point, x,\n                                                             y_bit, ctx);\n    }\n    return group-\u003emeth-\u003epoint_set_compressed_coordinates(group, point, x,\n                                                         y_bit, ctx);\n}","filepath":"crypto/ec/ec_oct.c","line_number":54,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre5"},"269999920":{"score":0.92556447,"function_name":"EC_POINT_point2buf","code":"size_t EC_POINT_point2buf(const EC_GROUP *group, const EC_POINT *point,\n                          point_conversion_form_t form,\n                          unsigned char **pbuf, BN_CTX *ctx)\n{\n    size_t len;\n    unsigned char *buf;\n\n    len = EC_POINT_point2oct(group, point, form, NULL, 0, NULL);\n    if (len == 0)\n        return 0;\n    if ((buf = OPENSSL_malloc(len)) == NULL) {\n        ECerr(EC_F_EC_POINT_POINT2BUF, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n    len = EC_POINT_point2oct(group, point, form, buf, len, ctx);\n    if (len == 0) {\n        OPENSSL_free(buf);\n        return 0;\n    }\n    *pbuf = buf;\n    return len;\n}","filepath":"crypto/ec/ec_oct.c","line_number":141,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre5"},"270000080":{"score":0.9331328,"function_name":"EC_POINT_point2oct","code":"size_t EC_POINT_point2oct(const EC_GROUP *group, const EC_POINT *point,\n                          point_conversion_form_t form, unsigned char *buf,\n                          size_t len, BN_CTX *ctx)\n{\n    if (group-\u003emeth-\u003epoint2oct == 0\n        \u0026\u0026 !(group-\u003emeth-\u003eflags \u0026 EC_FLAGS_DEFAULT_OCT)) {\n        ECerr(EC_F_EC_POINT_POINT2OCT, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return 0;\n    }\n    if (group-\u003emeth != point-\u003emeth) {\n        ECerr(EC_F_EC_POINT_POINT2OCT, EC_R_INCOMPATIBLE_OBJECTS);\n        return 0;\n    }\n    if (group-\u003emeth-\u003eflags \u0026 EC_FLAGS_DEFAULT_OCT) {\n        if (group-\u003emeth-\u003efield_type == NID_X9_62_prime_field)\n            return ec_GFp_simple_point2oct(group, point, form, buf, len, ctx);\n        else\n#ifdef OPENSSL_NO_EC2M\n        {\n            ECerr(EC_F_EC_POINT_POINT2OCT, EC_R_GF2M_NOT_SUPPORTED);\n            return 0;\n        }\n#else\n            return ec_GF2m_simple_point2oct(group, point,\n                                            form, buf, len, ctx);\n#endif\n    }\n\n    return group-\u003emeth-\u003epoint2oct(group, point, form, buf, len, ctx);\n}","filepath":"crypto/ec/ec_oct.c","line_number":82,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre5"},"270000976":{"score":0.9193451,"function_name":"dsa_do_sign","code":"static DSA_SIG *dsa_do_sign(const unsigned char *dgst, int dlen, DSA *dsa)\n{\n    BIGNUM *kinv = NULL;\n    BIGNUM *m, *blind, *blindm, *tmp;\n    BN_CTX *ctx = NULL;\n    int reason = ERR_R_BN_LIB;\n    DSA_SIG *ret = NULL;\n    int rv = 0;\n\n    if (dsa-\u003ep == NULL || dsa-\u003eq == NULL || dsa-\u003eg == NULL) {\n        reason = DSA_R_MISSING_PARAMETERS;\n        goto err;\n    }\n    if (dsa-\u003epriv_key == NULL) {\n        reason = DSA_R_MISSING_PRIVATE_KEY;\n        goto err;\n    }\n\n    ret = DSA_SIG_new();\n    if (ret == NULL)\n        goto err;\n    ret-\u003er = BN_new();\n    ret-\u003es = BN_new();\n    if (ret-\u003er == NULL || ret-\u003es == NULL)\n        goto err;\n\n    ctx = BN_CTX_new();\n    if (ctx == NULL)\n        goto err;\n    m = BN_CTX_get(ctx);\n    blind = BN_CTX_get(ctx);\n    blindm = BN_CTX_get(ctx);\n    tmp = BN_CTX_get(ctx);\n    if (tmp == NULL)\n        goto err;\n\n redo:\n    if (!dsa_sign_setup(dsa, ctx, \u0026kinv, \u0026ret-\u003er, dgst, dlen))\n        goto err;\n\n    if (dlen \u003e BN_num_bytes(dsa-\u003eq))\n        /*\n         * if the digest length is greater than the size of q use the\n         * BN_num_bits(dsa-\u003eq) leftmost bits of the digest, see fips 186-3,\n         * 4.2\n         */\n        dlen = BN_num_bytes(dsa-\u003eq);\n    if (BN_bin2bn(dgst, dlen, m) == NULL)\n        goto err;\n\n    /*\n     * The normal signature calculation is:\n     *\n     *   s := k^-1 * (m + r * priv_key) mod q\n     *\n     * We will blind this to protect against side channel attacks\n     *\n     *   s := blind^-1 * k^-1 * (blind * m + blind * r * priv_key) mod q\n     */\n\n    /* Generate a blinding value */\n    do {\n        if (!BN_priv_rand(blind, BN_num_bits(dsa-\u003eq) - 1,\n                          BN_RAND_TOP_ANY, BN_RAND_BOTTOM_ANY))\n            goto err;\n    } while (BN_is_zero(blind));\n    BN_set_flags(blind, BN_FLG_CONSTTIME);\n    BN_set_flags(blindm, BN_FLG_CONSTTIME);\n    BN_set_flags(tmp, BN_FLG_CONSTTIME);\n\n    /* tmp := blind * priv_key * r mod q */\n    if (!BN_mod_mul(tmp, blind, dsa-\u003epriv_key, dsa-\u003eq, ctx))\n        goto err;\n    if (!BN_mod_mul(tmp, tmp, ret-\u003er, dsa-\u003eq, ctx))\n        goto err;\n\n    /* blindm := blind * m mod q */\n    if (!BN_mod_mul(blindm, blind, m, dsa-\u003eq, ctx))\n        goto err;\n\n    /* s : = (blind * priv_key * r) + (blind * m) mod q */\n    if (!BN_mod_add_quick(ret-\u003es, tmp, blindm, dsa-\u003eq))\n        goto err;\n\n    /* s := s * k^-1 mod q */\n    if (!BN_mod_mul(ret-\u003es, ret-\u003es, kinv, dsa-\u003eq, ctx))\n        goto err;\n\n    /* s:= s * blind^-1 mod q */\n    if (BN_mod_inverse(blind, blind, dsa-\u003eq, ctx) == NULL)\n        goto err;\n    if (!BN_mod_mul(ret-\u003es, ret-\u003es, blind, dsa-\u003eq, ctx))\n        goto err;\n\n    /*\n     * Redo if r or s is zero as required by FIPS 186-3: this is very\n     * unlikely.\n     */\n    if (BN_is_zero(ret-\u003er) || BN_is_zero(ret-\u003es))\n        goto redo;\n\n    rv = 1;\n\n err:\n    if (rv == 0) {\n        DSAerr(DSA_F_DSA_DO_SIGN, reason);\n        DSA_SIG_free(ret);\n        ret = NULL;\n    }\n    BN_CTX_free(ctx);\n    BN_clear_free(kinv);\n    return ret;\n}","filepath":"crypto/dsa/dsa_ossl.c","line_number":62,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270001712":{"score":0.9450615,"function_name":"dsa_do_verify","code":"static int dsa_do_verify(const unsigned char *dgst, int dgst_len,\n                         DSA_SIG *sig, DSA *dsa)\n{\n    BN_CTX *ctx;\n    BIGNUM *u1, *u2, *t1;\n    BN_MONT_CTX *mont = NULL;\n    const BIGNUM *r, *s;\n    int ret = -1, i;\n    if (!dsa-\u003ep || !dsa-\u003eq || !dsa-\u003eg) {\n        DSAerr(DSA_F_DSA_DO_VERIFY, DSA_R_MISSING_PARAMETERS);\n        return -1;\n    }\n\n    i = BN_num_bits(dsa-\u003eq);\n    /* fips 186-3 allows only different sizes for q */\n    if (i != 160 \u0026\u0026 i != 224 \u0026\u0026 i != 256) {\n        DSAerr(DSA_F_DSA_DO_VERIFY, DSA_R_BAD_Q_VALUE);\n        return -1;\n    }\n\n    if (BN_num_bits(dsa-\u003ep) \u003e OPENSSL_DSA_MAX_MODULUS_BITS) {\n        DSAerr(DSA_F_DSA_DO_VERIFY, DSA_R_MODULUS_TOO_LARGE);\n        return -1;\n    }\n    u1 = BN_new();\n    u2 = BN_new();\n    t1 = BN_new();\n    ctx = BN_CTX_new();\n    if (u1 == NULL || u2 == NULL || t1 == NULL || ctx == NULL)\n        goto err;\n\n    DSA_SIG_get0(sig, \u0026r, \u0026s);\n\n    if (BN_is_zero(r) || BN_is_negative(r) ||\n        BN_ucmp(r, dsa-\u003eq) \u003e= 0) {\n        ret = 0;\n        goto err;\n    }\n    if (BN_is_zero(s) || BN_is_negative(s) ||\n        BN_ucmp(s, dsa-\u003eq) \u003e= 0) {\n        ret = 0;\n        goto err;\n    }\n\n    /*\n     * Calculate W = inv(S) mod Q save W in u2\n     */\n    if ((BN_mod_inverse(u2, s, dsa-\u003eq, ctx)) == NULL)\n        goto err;\n\n    /* save M in u1 */\n    if (dgst_len \u003e (i \u003e\u003e 3))\n        /*\n         * if the digest length is greater than the size of q use the\n         * BN_num_bits(dsa-\u003eq) leftmost bits of the digest, see fips 186-3,\n         * 4.2\n         */\n        dgst_len = (i \u003e\u003e 3);\n    if (BN_bin2bn(dgst, dgst_len, u1) == NULL)\n        goto err;\n\n    /* u1 = M * w mod q */\n    if (!BN_mod_mul(u1, u1, u2, dsa-\u003eq, ctx))\n        goto err;\n\n    /* u2 = r * w mod q */\n    if (!BN_mod_mul(u2, r, u2, dsa-\u003eq, ctx))\n        goto err;\n\n    if (dsa-\u003eflags \u0026 DSA_FLAG_CACHE_MONT_P) {\n        mont = BN_MONT_CTX_set_locked(\u0026dsa-\u003emethod_mont_p,\n                                      dsa-\u003elock, dsa-\u003ep, ctx);\n        if (!mont)\n            goto err;\n    }\n\n    if (dsa-\u003emeth-\u003edsa_mod_exp != NULL) {\n        if (!dsa-\u003emeth-\u003edsa_mod_exp(dsa, t1, dsa-\u003eg, u1, dsa-\u003epub_key, u2,\n                                    dsa-\u003ep, ctx, mont))\n            goto err;\n    } else {\n        if (!BN_mod_exp2_mont(t1, dsa-\u003eg, u1, dsa-\u003epub_key, u2, dsa-\u003ep, ctx,\n                              mont))\n            goto err;\n    }\n\n    /* let u1 = u1 mod q */\n    if (!BN_mod(u1, t1, dsa-\u003eq, ctx))\n        goto err;\n\n    /*\n     * V is now in u1.  If the signature is correct, it will be equal to R.\n     */\n    ret = (BN_ucmp(u1, r) == 0);\n\n err:\n    if (ret \u003c 0)\n        DSAerr(DSA_F_DSA_DO_VERIFY, ERR_R_BN_LIB);\n    BN_CTX_free(ctx);\n    BN_free(u1);\n    BN_free(u2);\n    BN_free(t1);\n    return ret;\n}","filepath":"crypto/dsa/dsa_ossl.c","line_number":299,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270002496":{"score":0.87563163,"function_name":"dsa_sign_setup","code":"static int dsa_sign_setup(DSA *dsa, BN_CTX *ctx_in,\n                          BIGNUM **kinvp, BIGNUM **rp,\n                          const unsigned char *dgst, int dlen)\n{\n    BN_CTX *ctx = NULL;\n    BIGNUM *k, *kinv = NULL, *r = *rp;\n    BIGNUM *l;\n    int ret = 0;\n    int q_bits, q_words;\n\n    if (!dsa-\u003ep || !dsa-\u003eq || !dsa-\u003eg) {\n        DSAerr(DSA_F_DSA_SIGN_SETUP, DSA_R_MISSING_PARAMETERS);\n        return 0;\n    }\n\n    /* Reject obviously invalid parameters */\n    if (BN_is_zero(dsa-\u003ep) || BN_is_zero(dsa-\u003eq) || BN_is_zero(dsa-\u003eg)) {\n        DSAerr(DSA_F_DSA_SIGN_SETUP, DSA_R_INVALID_PARAMETERS);\n        return 0;\n    }\n    if (dsa-\u003epriv_key == NULL) {\n        DSAerr(DSA_F_DSA_SIGN_SETUP, DSA_R_MISSING_PRIVATE_KEY);\n        return 0;\n    }\n\n    k = BN_new();\n    l = BN_new();\n    if (k == NULL || l == NULL)\n        goto err;\n\n    if (ctx_in == NULL) {\n        if ((ctx = BN_CTX_new()) == NULL)\n            goto err;\n    } else\n        ctx = ctx_in;\n\n    /* Preallocate space */\n    q_bits = BN_num_bits(dsa-\u003eq);\n    q_words = bn_get_top(dsa-\u003eq);\n    if (!bn_wexpand(k, q_words + 2)\n        || !bn_wexpand(l, q_words + 2))\n        goto err;\n\n    /* Get random k */\n    do {\n        if (dgst != NULL) {\n            /*\n             * We calculate k from SHA512(private_key + H(message) + random).\n             * This protects the private key from a weak PRNG.\n             */\n            if (!BN_generate_dsa_nonce(k, dsa-\u003eq, dsa-\u003epriv_key, dgst,\n                                       dlen, ctx))\n                goto err;\n        } else if (!BN_priv_rand_range(k, dsa-\u003eq))\n            goto err;\n    } while (BN_is_zero(k));\n\n    BN_set_flags(k, BN_FLG_CONSTTIME);\n    BN_set_flags(l, BN_FLG_CONSTTIME);\n\n    if (dsa-\u003eflags \u0026 DSA_FLAG_CACHE_MONT_P) {\n        if (!BN_MONT_CTX_set_locked(\u0026dsa-\u003emethod_mont_p,\n                                    dsa-\u003elock, dsa-\u003ep, ctx))\n            goto err;\n    }\n\n    /* Compute r = (g^k mod p) mod q */\n\n    /*\n     * We do not want timing information to leak the length of k, so we\n     * compute G^k using an equivalent scalar of fixed bit-length.\n     *\n     * We unconditionally perform both of these additions to prevent a\n     * small timing information leakage.  We then choose the sum that is\n     * one bit longer than the modulus.\n     *\n     * There are some concerns about the efficacy of doing this.  More\n     * specifically refer to the discussion starting with:\n     *     https://github.com/openssl/openssl/pull/7486#discussion_r228323705\n     * The fix is to rework BN so these gymnastics aren't required.\n     */\n    if (!BN_add(l, k, dsa-\u003eq)\n        || !BN_add(k, l, dsa-\u003eq))\n        goto err;\n\n    BN_consttime_swap(BN_is_bit_set(l, q_bits), k, l, q_words + 2);\n\n    if ((dsa)-\u003emeth-\u003ebn_mod_exp != NULL) {\n            if (!dsa-\u003emeth-\u003ebn_mod_exp(dsa, r, dsa-\u003eg, k, dsa-\u003ep, ctx,\n                                       dsa-\u003emethod_mont_p))\n                goto err;\n    } else {\n            if (!BN_mod_exp_mont(r, dsa-\u003eg, k, dsa-\u003ep, ctx, dsa-\u003emethod_mont_p))\n                goto err;\n    }\n\n    if (!BN_mod(r, r, dsa-\u003eq, ctx))\n        goto err;\n\n    /* Compute part of 's = inv(k) (m + xr) mod q' */\n    if ((kinv = dsa_mod_inverse_fermat(k, dsa-\u003eq, ctx)) == NULL)\n        goto err;\n\n    BN_clear_free(*kinvp);\n    *kinvp = kinv;\n    kinv = NULL;\n    ret = 1;\n err:\n    if (!ret)\n        DSAerr(DSA_F_DSA_SIGN_SETUP, ERR_R_BN_LIB);\n    if (ctx != ctx_in)\n        BN_CTX_free(ctx);\n    BN_clear_free(k);\n    BN_clear_free(l);\n    return ret;\n}","filepath":"crypto/dsa/dsa_ossl.c","line_number":182,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270004096":{"score":0.68569267,"function_name":"x509_name_ex_i2d","code":"static int x509_name_ex_i2d(const ASN1_VALUE **val, unsigned char **out,\n                            const ASN1_ITEM *it, int tag, int aclass)\n{\n    int ret;\n    X509_NAME *a = (X509_NAME *)*val;\n\n    if (a-\u003emodified) {\n        ret = x509_name_encode(a);\n        if (ret \u003c 0)\n            return ret;\n        ret = x509_name_canon(a);\n        if (!ret)\n            return -1;\n    }\n    ret = a-\u003ebytes-\u003elength;\n    if (out != NULL) {\n        memcpy(*out, a-\u003ebytes-\u003edata, ret);\n        *out += ret;\n    }\n    return ret;\n}","filepath":"crypto/x509/x_name.c","line_number":211,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.7"},"270004960":{"score":0.9216418,"function_name":"X509_NAME_print","code":"int X509_NAME_print(BIO *bp, const X509_NAME *name, int obase)\n{\n    char *s, *c, *b;\n    int i;\n\n    b = X509_NAME_oneline(name, NULL, 0);\n    if (b == NULL)\n        return 0;\n    if (*b == '\\0') {\n        OPENSSL_free(b);\n        return 1;\n    }\n    s = b + 1;                  /* skip the first slash */\n\n    c = s;\n    for (;;) {\n        if (((*s == '/') \u0026\u0026\n             (ossl_isupper(s[1]) \u0026\u0026 ((s[2] == '=') ||\n                                (ossl_isupper(s[2]) \u0026\u0026 (s[3] == '='))\n              ))) || (*s == '\\0'))\n        {\n            i = s - c;\n            if (BIO_write(bp, c, i) != i)\n                goto err;\n            c = s + 1;          /* skip following slash */\n            if (*s != '\\0') {\n                if (BIO_write(bp, \", \", 2) != 2)\n                    goto err;\n            }\n        }\n        if (*s == '\\0')\n            break;\n        s++;\n    }\n\n    OPENSSL_free(b);\n    return 1;\n err:\n    ERR_raise(ERR_LIB_X509, ERR_R_BUF_LIB);\n    OPENSSL_free(b);\n    return 0;\n}","filepath":"crypto/x509/x_name.c","line_number":499,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.7"},"270005264":{"score":0.82908976,"function_name":"i2d_name_canon","code":"static int i2d_name_canon(const STACK_OF(STACK_OF_X509_NAME_ENTRY) * _intname,\n                          unsigned char **in)\n{\n    int i, len, ltmp;\n    const ASN1_VALUE *v;\n    STACK_OF(ASN1_VALUE) *intname = (STACK_OF(ASN1_VALUE) *)_intname;\n\n    len = 0;\n    for (i = 0; i \u003c sk_ASN1_VALUE_num(intname); i++) {\n        v = sk_ASN1_VALUE_value(intname, i);\n        ltmp = ASN1_item_ex_i2d(\u0026v, in,\n                                ASN1_ITEM_rptr(X509_NAME_ENTRIES), -1, -1);\n        if (ltmp \u003c 0)\n            return ltmp;\n        len += ltmp;\n    }\n    return len;\n}","filepath":"crypto/x509/x_name.c","line_number":467,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.7"},"270005408":{"score":0.9332215,"function_name":"x509_name_canon","code":"static int x509_name_canon(X509_NAME *a)\n{\n    unsigned char *p;\n    STACK_OF(STACK_OF_X509_NAME_ENTRY) *intname;\n    STACK_OF(X509_NAME_ENTRY) *entries = NULL;\n    X509_NAME_ENTRY *entry, *tmpentry = NULL;\n    int i, set = -1, ret = 0, len;\n\n    OPENSSL_free(a-\u003ecanon_enc);\n    a-\u003ecanon_enc = NULL;\n    /* Special case: empty X509_NAME =\u003e null encoding */\n    if (sk_X509_NAME_ENTRY_num(a-\u003eentries) == 0) {\n        a-\u003ecanon_enclen = 0;\n        return 1;\n    }\n    intname = sk_STACK_OF_X509_NAME_ENTRY_new_null();\n    if (intname == NULL) {\n        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    for (i = 0; i \u003c sk_X509_NAME_ENTRY_num(a-\u003eentries); i++) {\n        entry = sk_X509_NAME_ENTRY_value(a-\u003eentries, i);\n        if (entry-\u003eset != set) {\n            entries = sk_X509_NAME_ENTRY_new_null();\n            if (entries == NULL)\n                goto err;\n            if (!sk_STACK_OF_X509_NAME_ENTRY_push(intname, entries)) {\n                sk_X509_NAME_ENTRY_free(entries);\n                ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n            set = entry-\u003eset;\n        }\n        tmpentry = X509_NAME_ENTRY_new();\n        if (tmpentry == NULL) {\n            ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        tmpentry-\u003eobject = OBJ_dup(entry-\u003eobject);\n        if (tmpentry-\u003eobject == NULL) {\n            ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        if (!asn1_string_canon(tmpentry-\u003evalue, entry-\u003evalue))\n            goto err;\n        if (!sk_X509_NAME_ENTRY_push(entries, tmpentry)) {\n            ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        tmpentry = NULL;\n    }\n\n    /* Finally generate encoding */\n    len = i2d_name_canon(intname, NULL);\n    if (len \u003c 0)\n        goto err;\n    a-\u003ecanon_enclen = len;\n\n    p = OPENSSL_malloc(a-\u003ecanon_enclen);\n    if (p == NULL) {\n        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    a-\u003ecanon_enc = p;\n\n    i2d_name_canon(intname, \u0026p);\n\n    ret = 1;\n\n err:\n    X509_NAME_ENTRY_free(tmpentry);\n    sk_STACK_OF_X509_NAME_ENTRY_pop_free(intname,\n                                         local_sk_X509_NAME_ENTRY_pop_free);\n    return ret;\n}","filepath":"crypto/x509/x_name.c","line_number":304,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.7"},"270007008":{"score":0.8945394,"function_name":"PKCS7_SIGNER_INFO_sign","code":"int PKCS7_SIGNER_INFO_sign(PKCS7_SIGNER_INFO *si)\n{\n    EVP_MD_CTX *mctx;\n    EVP_PKEY_CTX *pctx;\n    unsigned char *abuf = NULL;\n    int alen;\n    size_t siglen;\n    const EVP_MD *md = NULL;\n\n    md = EVP_get_digestbyobj(si-\u003edigest_alg-\u003ealgorithm);\n    if (md == NULL)\n        return 0;\n\n    mctx = EVP_MD_CTX_new();\n    if (mctx == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_SIGNER_INFO_SIGN, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (EVP_DigestSignInit(mctx, \u0026pctx, md, NULL, si-\u003epkey) \u003c= 0)\n        goto err;\n\n    if (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_SIGN,\n                          EVP_PKEY_CTRL_PKCS7_SIGN, 0, si) \u003c= 0) {\n        PKCS7err(PKCS7_F_PKCS7_SIGNER_INFO_SIGN, PKCS7_R_CTRL_ERROR);\n        goto err;\n    }\n\n    alen = ASN1_item_i2d((ASN1_VALUE *)si-\u003eauth_attr, \u0026abuf,\n                         ASN1_ITEM_rptr(PKCS7_ATTR_SIGN));\n    if (!abuf)\n        goto err;\n    if (EVP_DigestSignUpdate(mctx, abuf, alen) \u003c= 0)\n        goto err;\n    OPENSSL_free(abuf);\n    abuf = NULL;\n    if (EVP_DigestSignFinal(mctx, NULL, \u0026siglen) \u003c= 0)\n        goto err;\n    abuf = OPENSSL_malloc(siglen);\n    if (abuf == NULL)\n        goto err;\n    if (EVP_DigestSignFinal(mctx, abuf, \u0026siglen) \u003c= 0)\n        goto err;\n\n    if (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_SIGN,\n                          EVP_PKEY_CTRL_PKCS7_SIGN, 1, si) \u003c= 0) {\n        PKCS7err(PKCS7_F_PKCS7_SIGNER_INFO_SIGN, PKCS7_R_CTRL_ERROR);\n        goto err;\n    }\n\n    EVP_MD_CTX_free(mctx);\n\n    ASN1_STRING_set0(si-\u003eenc_digest, abuf, siglen);\n\n    return 1;\n\n err:\n    OPENSSL_free(abuf);\n    EVP_MD_CTX_free(mctx);\n    return 0;\n\n}","filepath":"crypto/pkcs7/pk7_doit.c","line_number":859,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre3"},"270007472":{"score":0.8838616,"function_name":"add_attribute","code":"static int add_attribute(STACK_OF(X509_ATTRIBUTE) **sk, int nid, int atrtype,\n                         void *value)\n{\n    X509_ATTRIBUTE *attr = NULL;\n\n    if (*sk == NULL) {\n        if ((*sk = sk_X509_ATTRIBUTE_new_null()) == NULL)\n            return 0;\n new_attrib:\n        if ((attr = X509_ATTRIBUTE_create(nid, atrtype, value)) == NULL)\n            return 0;\n        if (!sk_X509_ATTRIBUTE_push(*sk, attr)) {\n            X509_ATTRIBUTE_free(attr);\n            return 0;\n        }\n    } else {\n        int i;\n\n        for (i = 0; i \u003c sk_X509_ATTRIBUTE_num(*sk); i++) {\n            attr = sk_X509_ATTRIBUTE_value(*sk, i);\n            if (OBJ_obj2nid(X509_ATTRIBUTE_get0_object(attr)) == nid) {\n                X509_ATTRIBUTE_free(attr);\n                attr = X509_ATTRIBUTE_create(nid, atrtype, value);\n                if (attr == NULL)\n                    return 0;\n                if (!sk_X509_ATTRIBUTE_set(*sk, i, attr)) {\n                    X509_ATTRIBUTE_free(attr);\n                    return 0;\n                }\n                goto end;\n            }\n        }\n        goto new_attrib;\n    }\n end:\n    return (1);\n}","filepath":"crypto/pkcs7/pk7_doit.c","line_number":1188,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre3"},"270007488":{"score":0.8241633,"function_name":"PKCS7_bio_add_digest","code":"static int PKCS7_bio_add_digest(BIO **pbio, X509_ALGOR *alg)\n{\n    BIO *btmp;\n    const EVP_MD *md;\n    if ((btmp = BIO_new(BIO_f_md())) == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_BIO_ADD_DIGEST, ERR_R_BIO_LIB);\n        goto err;\n    }\n\n    md = EVP_get_digestbyobj(alg-\u003ealgorithm);\n    if (md == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_BIO_ADD_DIGEST, PKCS7_R_UNKNOWN_DIGEST_TYPE);\n        goto err;\n    }\n\n    BIO_set_md(btmp, md);\n    if (*pbio == NULL)\n        *pbio = btmp;\n    else if (!BIO_push(*pbio, btmp)) {\n        PKCS7err(PKCS7_F_PKCS7_BIO_ADD_DIGEST, ERR_R_BIO_LIB);\n        goto err;\n    }\n    btmp = NULL;\n\n    return 1;\n\n err:\n    BIO_free(btmp);\n    return 0;\n\n}","filepath":"crypto/pkcs7/pk7_doit.c","line_number":103,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre3"},"270007648":{"score":0.8200854,"function_name":"PKCS7_dataFinal","code":"int PKCS7_dataFinal(PKCS7 *p7, BIO *bio)\n{\n    int ret = 0;\n    int i, j;\n    BIO *btmp;\n    PKCS7_SIGNER_INFO *si;\n    EVP_MD_CTX *mdc, *ctx_tmp;\n    STACK_OF(X509_ATTRIBUTE) *sk;\n    STACK_OF(PKCS7_SIGNER_INFO) *si_sk = NULL;\n    ASN1_OCTET_STRING *os = NULL;\n\n    if (p7 == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATAFINAL, PKCS7_R_INVALID_NULL_POINTER);\n        return 0;\n    }\n\n    if (p7-\u003ed.ptr == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATAFINAL, PKCS7_R_NO_CONTENT);\n        return 0;\n    }\n\n    ctx_tmp = EVP_MD_CTX_new();\n    if (ctx_tmp == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATAFINAL, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n\n    i = OBJ_obj2nid(p7-\u003etype);\n    p7-\u003estate = PKCS7_S_HEADER;\n\n    switch (i) {\n    case NID_pkcs7_data:\n        os = p7-\u003ed.data;\n        break;\n    case NID_pkcs7_signedAndEnveloped:\n        /* XXXXXXXXXXXXXXXX */\n        si_sk = p7-\u003ed.signed_and_enveloped-\u003esigner_info;\n        os = p7-\u003ed.signed_and_enveloped-\u003eenc_data-\u003eenc_data;\n        if (os == NULL) {\n            os = ASN1_OCTET_STRING_new();\n            if (os == NULL) {\n                PKCS7err(PKCS7_F_PKCS7_DATAFINAL, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n            p7-\u003ed.signed_and_enveloped-\u003eenc_data-\u003eenc_data = os;\n        }\n        break;\n    case NID_pkcs7_enveloped:\n        /* XXXXXXXXXXXXXXXX */\n        os = p7-\u003ed.enveloped-\u003eenc_data-\u003eenc_data;\n        if (os == NULL) {\n            os = ASN1_OCTET_STRING_new();\n            if (os == NULL) {\n                PKCS7err(PKCS7_F_PKCS7_DATAFINAL, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n            p7-\u003ed.enveloped-\u003eenc_data-\u003eenc_data = os;\n        }\n        break;\n    case NID_pkcs7_signed:\n        si_sk = p7-\u003ed.sign-\u003esigner_info;\n        os = PKCS7_get_octet_string(p7-\u003ed.sign-\u003econtents);\n        /* If detached data then the content is excluded */\n        if (PKCS7_type_is_data(p7-\u003ed.sign-\u003econtents) \u0026\u0026 p7-\u003edetached) {\n            ASN1_OCTET_STRING_free(os);\n            os = NULL;\n            p7-\u003ed.sign-\u003econtents-\u003ed.data = NULL;\n        }\n        break;\n\n    case NID_pkcs7_digest:\n        os = PKCS7_get_octet_string(p7-\u003ed.digest-\u003econtents);\n        /* If detached data then the content is excluded */\n        if (PKCS7_type_is_data(p7-\u003ed.digest-\u003econtents) \u0026\u0026 p7-\u003edetached) {\n            ASN1_OCTET_STRING_free(os);\n            os = NULL;\n            p7-\u003ed.digest-\u003econtents-\u003ed.data = NULL;\n        }\n        break;\n\n    default:\n        PKCS7err(PKCS7_F_PKCS7_DATAFINAL, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);\n        goto err;\n    }\n\n    if (si_sk != NULL) {\n        for (i = 0; i \u003c sk_PKCS7_SIGNER_INFO_num(si_sk); i++) {\n            si = sk_PKCS7_SIGNER_INFO_value(si_sk, i);\n            if (si-\u003epkey == NULL)\n                continue;\n\n            j = OBJ_obj2nid(si-\u003edigest_alg-\u003ealgorithm);\n\n            btmp = bio;\n\n            btmp = PKCS7_find_digest(\u0026mdc, btmp, j);\n\n            if (btmp == NULL)\n                goto err;\n\n            /*\n             * We now have the EVP_MD_CTX, lets do the signing.\n             */\n            if (!EVP_MD_CTX_copy_ex(ctx_tmp, mdc))\n                goto err;\n\n            sk = si-\u003eauth_attr;\n\n            /*\n             * If there are attributes, we add the digest attribute and only\n             * sign the attributes\n             */\n            if (sk_X509_ATTRIBUTE_num(sk) \u003e 0) {\n                if (!do_pkcs7_signed_attrib(si, ctx_tmp))\n                    goto err;\n            } else {\n                unsigned char *abuf = NULL;\n                unsigned int abuflen;\n                abuflen = EVP_PKEY_size(si-\u003epkey);\n                abuf = OPENSSL_malloc(abuflen);\n                if (abuf == NULL)\n                    goto err;\n\n                if (!EVP_SignFinal(ctx_tmp, abuf, \u0026abuflen, si-\u003epkey)) {\n                    PKCS7err(PKCS7_F_PKCS7_DATAFINAL, ERR_R_EVP_LIB);\n                    goto err;\n                }\n                ASN1_STRING_set0(si-\u003eenc_digest, abuf, abuflen);\n            }\n        }\n    } else if (i == NID_pkcs7_digest) {\n        unsigned char md_data[EVP_MAX_MD_SIZE];\n        unsigned int md_len;\n        if (!PKCS7_find_digest(\u0026mdc, bio,\n                               OBJ_obj2nid(p7-\u003ed.digest-\u003emd-\u003ealgorithm)))\n            goto err;\n        if (!EVP_DigestFinal_ex(mdc, md_data, \u0026md_len))\n            goto err;\n        ASN1_OCTET_STRING_set(p7-\u003ed.digest-\u003edigest, md_data, md_len);\n    }\n\n    if (!PKCS7_is_detached(p7)) {\n        /*\n         * NOTE(emilia): I think we only reach os == NULL here because detached\n         * digested data support is broken.\n         */\n        if (os == NULL)\n            goto err;\n        if (!(os-\u003eflags \u0026 ASN1_STRING_FLAG_NDEF)) {\n            char *cont;\n            long contlen;\n            btmp = BIO_find_type(bio, BIO_TYPE_MEM);\n            if (btmp == NULL) {\n                PKCS7err(PKCS7_F_PKCS7_DATAFINAL, PKCS7_R_UNABLE_TO_FIND_MEM_BIO);\n                goto err;\n            }\n            contlen = BIO_get_mem_data(btmp, \u0026cont);\n            /*\n             * Mark the BIO read only then we can use its copy of the data\n             * instead of making an extra copy.\n             */\n            BIO_set_flags(btmp, BIO_FLAGS_MEM_RDONLY);\n            BIO_set_mem_eof_return(btmp, 0);\n            ASN1_STRING_set0(os, (unsigned char *)cont, contlen);\n        }\n    }\n    ret = 1;\n err:\n    EVP_MD_CTX_free(ctx_tmp);\n    return (ret);\n}","filepath":"crypto/pkcs7/pk7_doit.c","line_number":687,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre3"},"270009008":{"score":0.7771292,"function_name":"PKCS7_dataInit","code":"BIO *PKCS7_dataInit(PKCS7 *p7, BIO *bio)\n{\n    int i;\n    BIO *out = NULL, *btmp = NULL;\n    X509_ALGOR *xa = NULL;\n    const EVP_CIPHER *evp_cipher = NULL;\n    STACK_OF(X509_ALGOR) *md_sk = NULL;\n    STACK_OF(PKCS7_RECIP_INFO) *rsk = NULL;\n    X509_ALGOR *xalg = NULL;\n    PKCS7_RECIP_INFO *ri = NULL;\n    ASN1_OCTET_STRING *os = NULL;\n\n    if (p7 == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_INVALID_NULL_POINTER);\n        return NULL;\n    }\n    /*\n     * The content field in the PKCS7 ContentInfo is optional, but that really\n     * only applies to inner content (precisely, detached signatures).\n     *\n     * When reading content, missing outer content is therefore treated as an\n     * error.\n     *\n     * When creating content, PKCS7_content_new() must be called before\n     * calling this method, so a NULL p7-\u003ed is always an error.\n     */\n    if (p7-\u003ed.ptr == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_NO_CONTENT);\n        return NULL;\n    }\n\n    i = OBJ_obj2nid(p7-\u003etype);\n    p7-\u003estate = PKCS7_S_HEADER;\n\n    switch (i) {\n    case NID_pkcs7_signed:\n        md_sk = p7-\u003ed.sign-\u003emd_algs;\n        os = PKCS7_get_octet_string(p7-\u003ed.sign-\u003econtents);\n        break;\n    case NID_pkcs7_signedAndEnveloped:\n        rsk = p7-\u003ed.signed_and_enveloped-\u003erecipientinfo;\n        md_sk = p7-\u003ed.signed_and_enveloped-\u003emd_algs;\n        xalg = p7-\u003ed.signed_and_enveloped-\u003eenc_data-\u003ealgorithm;\n        evp_cipher = p7-\u003ed.signed_and_enveloped-\u003eenc_data-\u003ecipher;\n        if (evp_cipher == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_CIPHER_NOT_INITIALIZED);\n            goto err;\n        }\n        break;\n    case NID_pkcs7_enveloped:\n        rsk = p7-\u003ed.enveloped-\u003erecipientinfo;\n        xalg = p7-\u003ed.enveloped-\u003eenc_data-\u003ealgorithm;\n        evp_cipher = p7-\u003ed.enveloped-\u003eenc_data-\u003ecipher;\n        if (evp_cipher == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_CIPHER_NOT_INITIALIZED);\n            goto err;\n        }\n        break;\n    case NID_pkcs7_digest:\n        xa = p7-\u003ed.digest-\u003emd;\n        os = PKCS7_get_octet_string(p7-\u003ed.digest-\u003econtents);\n        break;\n    case NID_pkcs7_data:\n        break;\n    default:\n        PKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);\n        goto err;\n    }\n\n    for (i = 0; i \u003c sk_X509_ALGOR_num(md_sk); i++)\n        if (!PKCS7_bio_add_digest(\u0026out, sk_X509_ALGOR_value(md_sk, i)))\n            goto err;\n\n    if (xa \u0026\u0026 !PKCS7_bio_add_digest(\u0026out, xa))\n        goto err;\n\n    if (evp_cipher != NULL) {\n        unsigned char key[EVP_MAX_KEY_LENGTH];\n        unsigned char iv[EVP_MAX_IV_LENGTH];\n        int keylen, ivlen;\n        EVP_CIPHER_CTX *ctx;\n\n        if ((btmp = BIO_new(BIO_f_cipher())) == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATAINIT, ERR_R_BIO_LIB);\n            goto err;\n        }\n        BIO_get_cipher_ctx(btmp, \u0026ctx);\n        keylen = EVP_CIPHER_key_length(evp_cipher);\n        ivlen = EVP_CIPHER_iv_length(evp_cipher);\n        xalg-\u003ealgorithm = OBJ_nid2obj(EVP_CIPHER_type(evp_cipher));\n        if (ivlen \u003e 0)\n            if (RAND_bytes(iv, ivlen) \u003c= 0)\n                goto err;\n        if (EVP_CipherInit_ex(ctx, evp_cipher, NULL, NULL, NULL, 1) \u003c= 0)\n            goto err;\n        if (EVP_CIPHER_CTX_rand_key(ctx, key) \u003c= 0)\n            goto err;\n        if (EVP_CipherInit_ex(ctx, NULL, NULL, key, iv, 1) \u003c= 0)\n            goto err;\n\n        if (ivlen \u003e 0) {\n            if (xalg-\u003eparameter == NULL) {\n                xalg-\u003eparameter = ASN1_TYPE_new();\n                if (xalg-\u003eparameter == NULL)\n                    goto err;\n            }\n            if (EVP_CIPHER_param_to_asn1(ctx, xalg-\u003eparameter) \u003c 0)\n                goto err;\n        }\n\n        /* Lets do the pub key stuff :-) */\n        for (i = 0; i \u003c sk_PKCS7_RECIP_INFO_num(rsk); i++) {\n            ri = sk_PKCS7_RECIP_INFO_value(rsk, i);\n            if (pkcs7_encode_rinfo(ri, key, keylen) \u003c= 0)\n                goto err;\n        }\n        OPENSSL_cleanse(key, keylen);\n\n        if (out == NULL)\n            out = btmp;\n        else\n            BIO_push(out, btmp);\n        btmp = NULL;\n    }\n\n    if (bio == NULL) {\n        if (PKCS7_is_detached(p7))\n            bio = BIO_new(BIO_s_null());\n        else if (os \u0026\u0026 os-\u003elength \u003e 0)\n            bio = BIO_new_mem_buf(os-\u003edata, os-\u003elength);\n        if (bio == NULL) {\n            bio = BIO_new(BIO_s_mem());\n            if (bio == NULL)\n                goto err;\n            BIO_set_mem_eof_return(bio, 0);\n        }\n    }\n    if (out)\n        BIO_push(out, bio);\n    else\n        out = bio;\n    return out;\n\n err:\n    BIO_free_all(out);\n    BIO_free_all(btmp);\n    return NULL;\n}","filepath":"crypto/pkcs7/pk7_doit.c","line_number":241,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre3"},"270010416":{"score":0.88152176,"function_name":"PKCS7_find_digest","code":"static BIO *PKCS7_find_digest(EVP_MD_CTX **pmd, BIO *bio, int nid)\n{\n    for (;;) {\n        bio = BIO_find_type(bio, BIO_TYPE_MD);\n        if (bio == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_FIND_DIGEST,\n                     PKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);\n            return NULL;\n        }\n        BIO_get_md_ctx(bio, pmd);\n        if (*pmd == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_FIND_DIGEST, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n        if (EVP_MD_CTX_type(*pmd) == nid)\n            return bio;\n        bio = BIO_next(bio);\n    }\n    return NULL;\n}","filepath":"crypto/pkcs7/pk7_doit.c","line_number":636,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre3"},"270010592":{"score":0.7057858,"function_name":"PKCS7_get_octet_string","code":"static ASN1_OCTET_STRING *PKCS7_get_octet_string(PKCS7 *p7)\n{\n    if (PKCS7_type_is_data(p7))\n        return p7-\u003ed.data;\n    if (PKCS7_type_is_other(p7) \u0026\u0026 p7-\u003ed.other\n        \u0026\u0026 (p7-\u003ed.other-\u003etype == V_ASN1_OCTET_STRING))\n        return p7-\u003ed.other-\u003evalue.octet_string;\n    return NULL;\n}","filepath":"crypto/pkcs7/pk7_doit.c","line_number":93,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre3"},"270011344":{"score":0.73423016,"function_name":"ASN1_TIME_adj","code":"ASN1_TIME *ASN1_TIME_adj(ASN1_TIME *s, time_t t,\n                         int offset_day, long offset_sec)\n{\n    struct tm *ts;\n    struct tm data;\n\n    ts = OPENSSL_gmtime(\u0026t, \u0026data);\n    if (ts == NULL) {\n        ASN1err(ASN1_F_ASN1_TIME_ADJ, ASN1_R_ERROR_GETTING_TIME);\n        return NULL;\n    }\n    if (offset_day || offset_sec) {\n        if (!OPENSSL_gmtime_adj(ts, offset_day, offset_sec))\n            return NULL;\n    }\n    return asn1_time_from_tm(s, ts, V_ASN1_UNDEF);\n}","filepath":"openssl/crypto/asn1/a_time.c","line_number":322,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.81"},"270011504":{"score":0.7964528,"function_name":"ASN1_TIME_check","code":"int ASN1_TIME_check(const ASN1_TIME *t)\n{\n    if (t-\u003etype == V_ASN1_GENERALIZEDTIME)\n        return ASN1_GENERALIZEDTIME_check(t);\n    else if (t-\u003etype == V_ASN1_UTCTIME)\n        return ASN1_UTCTIME_check(t);\n    return 0;\n}","filepath":"openssl/crypto/asn1/a_time.c","line_number":340,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.81"},"270011600":{"score":0.9067247,"function_name":"ASN1_TIME_print","code":"int ASN1_TIME_print(BIO *bp, const ASN1_TIME *tm)\n{\n    char *v;\n    int gmt = 0, l;\n    struct tm stm;\n    const char upper_z = 0x5A, period = 0x2E;\n\n    if (!asn1_time_to_tm(\u0026stm, tm)) {\n        /* asn1_time_to_tm will check the time type */\n        goto err;\n    }\n\n    l = tm-\u003elength;\n    v = (char *)tm-\u003edata;\n    if (v[l - 1] == upper_z)\n        gmt = 1;\n\n    if (tm-\u003etype == V_ASN1_GENERALIZEDTIME) {\n        char *f = NULL;\n        int f_len = 0;\n\n        /*\n         * Try to parse fractional seconds. '14' is the place of\n         * 'fraction point' in a GeneralizedTime string.\n         */\n        if (tm-\u003elength \u003e 15 \u0026\u0026 v[14] == period) {\n            f = \u0026v[14];\n            f_len = 1;\n            while (14 + f_len \u003c l \u0026\u0026 ascii_isdigit(f[f_len]))\n                ++f_len;\n        }\n\n        return BIO_printf(bp, \"%s %2d %02d:%02d:%02d%.*s %d%s\",\n                          _asn1_mon[stm.tm_mon], stm.tm_mday, stm.tm_hour,\n                          stm.tm_min, stm.tm_sec, f_len, f, stm.tm_year + 1900,\n                          (gmt ? \" GMT\" : \"\")) \u003e 0;\n    } else {\n        return BIO_printf(bp, \"%s %2d %02d:%02d:%02d %d%s\",\n                          _asn1_mon[stm.tm_mon], stm.tm_mday, stm.tm_hour,\n                          stm.tm_min, stm.tm_sec, stm.tm_year + 1900,\n                          (gmt ? \" GMT\" : \"\")) \u003e 0;\n    }\n err:\n    BIO_write(bp, \"Bad time value\", 14);\n    return 0;\n}","filepath":"openssl/crypto/asn1/a_time.c","line_number":469,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.81"},"270011936":{"score":0.93474114,"function_name":"asn1_time_from_tm","code":"ASN1_TIME *asn1_time_from_tm(ASN1_TIME *s, struct tm *ts, int type)\n{\n    char* p;\n    ASN1_TIME *tmps = NULL;\n    const size_t len = 20;\n\n    if (type == V_ASN1_UNDEF) {\n        if (is_utc(ts-\u003etm_year))\n            type = V_ASN1_UTCTIME;\n        else\n            type = V_ASN1_GENERALIZEDTIME;\n    } else if (type == V_ASN1_UTCTIME) {\n        if (!is_utc(ts-\u003etm_year))\n            goto err;\n    } else if (type != V_ASN1_GENERALIZEDTIME) {\n        goto err;\n    }\n\n    if (s == NULL)\n        tmps = ASN1_STRING_new();\n    else\n        tmps = s;\n    if (tmps == NULL)\n        return NULL;\n\n    if (!ASN1_STRING_set(tmps, NULL, len))\n        goto err;\n\n    tmps-\u003etype = type;\n    p = (char*)tmps-\u003edata;\n\n    if (type == V_ASN1_GENERALIZEDTIME)\n        tmps-\u003elength = BIO_snprintf(p, len, \"%04d%02d%02d%02d%02d%02dZ\",\n                                    ts-\u003etm_year + 1900, ts-\u003etm_mon + 1,\n                                    ts-\u003etm_mday, ts-\u003etm_hour, ts-\u003etm_min,\n                                    ts-\u003etm_sec);\n    else\n        tmps-\u003elength = BIO_snprintf(p, len, \"%02d%02d%02d%02d%02d%02dZ\",\n                                    ts-\u003etm_year % 100, ts-\u003etm_mon + 1,\n                                    ts-\u003etm_mday, ts-\u003etm_hour, ts-\u003etm_min,\n                                    ts-\u003etm_sec);\n\n#ifdef CHARSET_EBCDIC\n    ebcdic2ascii(tmps-\u003edata, tmps-\u003edata, tmps-\u003elength);\n#endif\n    return tmps;\n err:\n    if (tmps != s)\n        ASN1_STRING_free(tmps);\n    return NULL;\n}","filepath":"openssl/crypto/asn1/a_time.c","line_number":265,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.81"},"270012144":{"score":0.783581,"function_name":"asn1_time_to_tm","code":"int asn1_time_to_tm(struct tm *tm, const ASN1_TIME *d)\n{\n    static const int min[9] = { 0, 0, 1, 1, 0, 0, 0, 0, 0 };\n    static const int max[9] = { 99, 99, 12, 31, 23, 59, 59, 12, 59 };\n    static const int mdays[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n    char *a;\n    int n, i, i2, l, o, min_l = 11, strict = 0, end = 6, btz = 5, md;\n    struct tm tmp;\n#if defined(CHARSET_EBCDIC)\n    const char upper_z = 0x5A, num_zero = 0x30, period = 0x2E, minus = 0x2D, plus = 0x2B;\n#else\n    const char upper_z = 'Z', num_zero = '0', period = '.', minus = '-', plus = '+';\n#endif\n    /*\n     * ASN1_STRING_FLAG_X509_TIME is used to enforce RFC 5280\n     * time string format, in which:\n     *\n     * 1. \"seconds\" is a 'MUST'\n     * 2. \"Zulu\" timezone is a 'MUST'\n     * 3. \"+|-\" is not allowed to indicate a time zone\n     */\n    if (d-\u003etype == V_ASN1_UTCTIME) {\n        if (d-\u003eflags \u0026 ASN1_STRING_FLAG_X509_TIME) {\n            min_l = 13;\n            strict = 1;\n        }\n    } else if (d-\u003etype == V_ASN1_GENERALIZEDTIME) {\n        end = 7;\n        btz = 6;\n        if (d-\u003eflags \u0026 ASN1_STRING_FLAG_X509_TIME) {\n            min_l = 15;\n            strict = 1;\n        } else {\n            min_l = 13;\n        }\n    } else {\n        return 0;\n    }\n\n    l = d-\u003elength;\n    a = (char *)d-\u003edata;\n    o = 0;\n    memset(\u0026tmp, 0, sizeof(tmp));\n\n    /*\n     * GENERALIZEDTIME is similar to UTCTIME except the year is represented\n     * as YYYY. This stuff treats everything as a two digit field so make\n     * first two fields 00 to 99\n     */\n\n    if (l \u003c min_l)\n        goto err;\n    for (i = 0; i \u003c end; i++) {\n        if (!strict \u0026\u0026 (i == btz) \u0026\u0026 ((a[o] == upper_z) || (a[o] == plus) || (a[o] == minus))) {\n            i++;\n            break;\n        }\n        if (!ascii_isdigit(a[o]))\n            goto err;\n        n = a[o] - num_zero;\n        /* incomplete 2-digital number */\n        if (++o == l)\n            goto err;\n\n        if (!ascii_isdigit(a[o]))\n            goto err;\n        n = (n * 10) + a[o] - num_zero;\n        /* no more bytes to read, but we haven't seen time-zone yet */\n        if (++o == l)\n            goto err;\n\n        i2 = (d-\u003etype == V_ASN1_UTCTIME) ? i + 1 : i;\n\n        if ((n \u003c min[i2]) || (n \u003e max[i2]))\n            goto err;\n        switch (i2) {\n        case 0:\n            /* UTC will never be here */\n            tmp.tm_year = n * 100 - 1900;\n            break;\n        case 1:\n            if (d-\u003etype == V_ASN1_UTCTIME)\n                tmp.tm_year = n \u003c 50 ? n + 100 : n;\n            else\n                tmp.tm_year += n;\n            break;\n        case 2:\n            tmp.tm_mon = n - 1;\n            break;\n        case 3:\n            /* check if tm_mday is valid in tm_mon */\n            if (tmp.tm_mon == 1) {\n                /* it's February */\n                md = mdays[1] + leap_year(tmp.tm_year + 1900);\n            } else {\n                md = mdays[tmp.tm_mon];\n            }\n            if (n \u003e md)\n                goto err;\n            tmp.tm_mday = n;\n            determine_days(\u0026tmp);\n            break;\n        case 4:\n            tmp.tm_hour = n;\n            break;\n        case 5:\n            tmp.tm_min = n;\n            break;\n        case 6:\n            tmp.tm_sec = n;\n            break;\n        }\n    }\n\n    /*\n     * Optional fractional seconds: decimal point followed by one or more\n     * digits.\n     */\n    if (d-\u003etype == V_ASN1_GENERALIZEDTIME \u0026\u0026 a[o] == period) {\n        if (strict)\n            /* RFC 5280 forbids fractional seconds */\n            goto err;\n        if (++o == l)\n            goto err;\n        i = o;\n        while ((o \u003c l) \u0026\u0026 ascii_isdigit(a[o]))\n            o++;\n        /* Must have at least one digit after decimal point */\n        if (i == o)\n            goto err;\n        /* no more bytes to read, but we haven't seen time-zone yet */\n        if (o == l)\n            goto err;\n    }\n\n    /*\n     * 'o' will never point to '\\0' at this point, the only chance\n     * 'o' can point to '\\0' is either the subsequent if or the first\n     * else if is true.\n     */\n    if (a[o] == upper_z) {\n        o++;\n    } else if (!strict \u0026\u0026 ((a[o] == plus) || (a[o] == minus))) {\n        int offsign = a[o] == minus ? 1 : -1;\n        int offset = 0;\n\n        o++;\n        /*\n         * if not equal, no need to do subsequent checks\n         * since the following for-loop will add 'o' by 4\n         * and the final return statement will check if 'l'\n         * and 'o' are equal.\n         */\n        if (o + 4 != l)\n            goto err;\n        for (i = end; i \u003c end + 2; i++) {\n            if (!ascii_isdigit(a[o]))\n                goto err;\n            n = a[o] - num_zero;\n            o++;\n            if (!ascii_isdigit(a[o]))\n                goto err;\n            n = (n * 10) + a[o] - num_zero;\n            i2 = (d-\u003etype == V_ASN1_UTCTIME) ? i + 1 : i;\n            if ((n \u003c min[i2]) || (n \u003e max[i2]))\n                goto err;\n            /* if tm is NULL, no need to adjust */\n            if (tm != NULL) {\n                if (i == end)\n                    offset = n * 3600;\n                else if (i == end + 1)\n                    offset += n * 60;\n            }\n            o++;\n        }\n        if (offset \u0026\u0026 !OPENSSL_gmtime_adj(\u0026tmp, 0, offset * offsign))\n            goto err;\n    } else {\n        /* not Z, or not +/- in non-strict mode */\n        goto err;\n    }\n    if (o == l) {\n        /* success, check if tm should be filled */\n        if (tm != NULL)\n            *tm = tmp;\n        return 1;\n    }\n err:\n    return 0;\n}","filepath":"openssl/crypto/asn1/a_time.c","line_number":74,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.81"},"270016512":{"score":0.8853483,"function_name":"v2i_crld","code":"static void *v2i_crld(const X509V3_EXT_METHOD *method,\n                      X509V3_CTX *ctx, STACK_OF(CONF_VALUE) *nval)\n{\n    STACK_OF(DIST_POINT) *crld;\n    GENERAL_NAMES *gens = NULL;\n    GENERAL_NAME *gen = NULL;\n    CONF_VALUE *cnf;\n    const int num = sk_CONF_VALUE_num(nval);\n    int i;\n\n    crld = sk_DIST_POINT_new_reserve(NULL, num);\n    if (crld == NULL)\n        goto merr;\n    for (i = 0; i \u003c num; i++) {\n        DIST_POINT *point;\n\n        cnf = sk_CONF_VALUE_value(nval, i);\n        if (!cnf-\u003evalue) {\n            STACK_OF(CONF_VALUE) *dpsect;\n            dpsect = X509V3_get_section(ctx, cnf-\u003ename);\n            if (!dpsect)\n                goto err;\n            point = crldp_from_section(ctx, dpsect);\n            X509V3_section_free(ctx, dpsect);\n            if (!point)\n                goto err;\n            sk_DIST_POINT_push(crld, point); /* no failure as it was reserved */\n        } else {\n            if ((gen = v2i_GENERAL_NAME(method, ctx, cnf)) == NULL)\n                goto err;\n            if ((gens = GENERAL_NAMES_new()) == NULL)\n                goto merr;\n            if (!sk_GENERAL_NAME_push(gens, gen))\n                goto merr;\n            gen = NULL;\n            if ((point = DIST_POINT_new()) == NULL)\n                goto merr;\n            sk_DIST_POINT_push(crld, point); /* no failure as it was reserved */\n            if ((point-\u003edistpoint = DIST_POINT_NAME_new()) == NULL)\n                goto merr;\n            point-\u003edistpoint-\u003ename.fullname = gens;\n            point-\u003edistpoint-\u003etype = 0;\n            gens = NULL;\n        }\n    }\n    return crld;\n\n merr:\n    X509V3err(X509V3_F_V2I_CRLD, ERR_R_MALLOC_FAILURE);\n err:\n    GENERAL_NAME_free(gen);\n    GENERAL_NAMES_free(gens);\n    sk_DIST_POINT_pop_free(crld, DIST_POINT_free);\n    return NULL;\n}","filepath":"crypto/x509v3/v3_crld.c","line_number":237,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270018272":{"score":0.88188624,"function_name":"DIST_POINT_set_dpname","code":"int DIST_POINT_set_dpname(DIST_POINT_NAME *dpn, X509_NAME *iname)\n{\n    int i;\n    STACK_OF(X509_NAME_ENTRY) *frag;\n    X509_NAME_ENTRY *ne;\n    if (!dpn || (dpn-\u003etype != 1))\n        return 1;\n    frag = dpn-\u003ename.relativename;\n    dpn-\u003edpname = X509_NAME_dup(iname);\n    if (!dpn-\u003edpname)\n        return 0;\n    for (i = 0; i \u003c sk_X509_NAME_ENTRY_num(frag); i++) {\n        ne = sk_X509_NAME_ENTRY_value(frag, i);\n        if (!X509_NAME_add_entry(dpn-\u003edpname, ne, -1, i ? 0 : 1)) {\n            X509_NAME_free(dpn-\u003edpname);\n            dpn-\u003edpname = NULL;\n            return 0;\n        }\n    }\n    /* generate cached encoding of name */\n    if (i2d_X509_NAME(dpn-\u003edpname, NULL) \u003c 0) {\n        X509_NAME_free(dpn-\u003edpname);\n        dpn-\u003edpname = NULL;\n        return 0;\n    }\n    return 1;\n}","filepath":"crypto/x509v3/v3_crld.c","line_number":480,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270018464":{"score":0.85734904,"function_name":"gnames_from_sectname","code":"static STACK_OF(GENERAL_NAME) *gnames_from_sectname(X509V3_CTX *ctx,\n                                                    char *sect)\n{\n    STACK_OF(CONF_VALUE) *gnsect;\n    STACK_OF(GENERAL_NAME) *gens;\n    if (*sect == '@')\n        gnsect = X509V3_get_section(ctx, sect + 1);\n    else\n        gnsect = X509V3_parse_list(sect);\n    if (!gnsect) {\n        X509V3err(X509V3_F_GNAMES_FROM_SECTNAME, X509V3_R_SECTION_NOT_FOUND);\n        return NULL;\n    }\n    gens = v2i_GENERAL_NAMES(NULL, ctx, gnsect);\n    if (*sect == '@')\n        X509V3_section_free(ctx, gnsect);\n    else\n        sk_CONF_VALUE_pop_free(gnsect, X509V3_conf_free);\n    return gens;\n}","filepath":"crypto/x509v3/v3_crld.c","line_number":45,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270018608":{"score":0.95110756,"function_name":"print_distpoint","code":"static int print_distpoint(BIO *out, DIST_POINT_NAME *dpn, int indent)\n{\n    if (dpn-\u003etype == 0) {\n        BIO_printf(out, \"%*sFull Name:\\n\", indent, \"\");\n        print_gens(out, dpn-\u003ename.fullname, indent);\n    } else {\n        X509_NAME ntmp;\n        ntmp.entries = dpn-\u003ename.relativename;\n        BIO_printf(out, \"%*sRelative Name:\\n%*s\", indent, \"\", indent + 2, \"\");\n        X509_NAME_print_ex(out, \u0026ntmp, 0, XN_FLAG_ONELINE);\n        BIO_puts(out, \"\\n\");\n    }\n    return 1;\n}","filepath":"crypto/x509v3/v3_crld.c","line_number":420,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270018768":{"score":0.9156161,"function_name":"print_gens","code":"static int print_gens(BIO *out, STACK_OF(GENERAL_NAME) *gens, int indent)\n{\n    int i;\n    for (i = 0; i \u003c sk_GENERAL_NAME_num(gens); i++) {\n        BIO_printf(out, \"%*s\", indent + 2, \"\");\n        GENERAL_NAME_print(out, sk_GENERAL_NAME_value(gens, i));\n        BIO_puts(out, \"\\n\");\n    }\n    return 1;\n}","filepath":"crypto/x509v3/v3_crld.c","line_number":409,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270019040":{"score":0.92780113,"function_name":"set_dist_point_name","code":"static int set_dist_point_name(DIST_POINT_NAME **pdp, X509V3_CTX *ctx,\n                               CONF_VALUE *cnf)\n{\n    STACK_OF(GENERAL_NAME) *fnm = NULL;\n    STACK_OF(X509_NAME_ENTRY) *rnm = NULL;\n\n    if (strncmp(cnf-\u003ename, \"fullname\", 9) == 0) {\n        fnm = gnames_from_sectname(ctx, cnf-\u003evalue);\n        if (!fnm)\n            goto err;\n    } else if (strcmp(cnf-\u003ename, \"relativename\") == 0) {\n        int ret;\n        STACK_OF(CONF_VALUE) *dnsect;\n        X509_NAME *nm;\n        nm = X509_NAME_new();\n        if (nm == NULL)\n            return -1;\n        dnsect = X509V3_get_section(ctx, cnf-\u003evalue);\n        if (!dnsect) {\n            X509V3err(X509V3_F_SET_DIST_POINT_NAME,\n                      X509V3_R_SECTION_NOT_FOUND);\n            return -1;\n        }\n        ret = X509V3_NAME_from_section(nm, dnsect, MBSTRING_ASC);\n        X509V3_section_free(ctx, dnsect);\n        rnm = nm-\u003eentries;\n        nm-\u003eentries = NULL;\n        X509_NAME_free(nm);\n        if (!ret || sk_X509_NAME_ENTRY_num(rnm) \u003c= 0)\n            goto err;\n        /*\n         * Since its a name fragment can't have more than one RDNSequence\n         */\n        if (sk_X509_NAME_ENTRY_value(rnm,\n                                     sk_X509_NAME_ENTRY_num(rnm) - 1)-\u003eset) {\n            X509V3err(X509V3_F_SET_DIST_POINT_NAME,\n                      X509V3_R_INVALID_MULTIPLE_RDNS);\n            goto err;\n        }\n    } else\n        return 0;\n\n    if (*pdp) {\n        X509V3err(X509V3_F_SET_DIST_POINT_NAME,\n                  X509V3_R_DISTPOINT_ALREADY_SET);\n        goto err;\n    }\n\n    *pdp = DIST_POINT_NAME_new();\n    if (*pdp == NULL)\n        goto err;\n    if (fnm) {\n        (*pdp)-\u003etype = 0;\n        (*pdp)-\u003ename.fullname = fnm;\n    } else {\n        (*pdp)-\u003etype = 1;\n        (*pdp)-\u003ename.relativename = rnm;\n    }\n\n    return 1;\n\n err:\n    sk_GENERAL_NAME_pop_free(fnm, GENERAL_NAME_free);\n    sk_X509_NAME_ENTRY_pop_free(rnm, X509_NAME_ENTRY_free);\n    return -1;\n}","filepath":"crypto/x509v3/v3_crld.c","line_number":66,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270019488":{"score":0.85927206,"function_name":"set_reasons","code":"static int set_reasons(ASN1_BIT_STRING **preas, char *value)\n{\n    STACK_OF(CONF_VALUE) *rsk = NULL;\n    const BIT_STRING_BITNAME *pbn;\n    const char *bnam;\n    int i, ret = 0;\n    rsk = X509V3_parse_list(value);\n    if (rsk == NULL)\n        return 0;\n    if (*preas != NULL)\n        goto err;\n    for (i = 0; i \u003c sk_CONF_VALUE_num(rsk); i++) {\n        bnam = sk_CONF_VALUE_value(rsk, i)-\u003ename;\n        if (*preas == NULL) {\n            *preas = ASN1_BIT_STRING_new();\n            if (*preas == NULL)\n                goto err;\n        }\n        for (pbn = reason_flags; pbn-\u003elname; pbn++) {\n            if (strcmp(pbn-\u003esname, bnam) == 0) {\n                if (!ASN1_BIT_STRING_set_bit(*preas, pbn-\u003ebitnum, 1))\n                    goto err;\n                break;\n            }\n        }\n        if (!pbn-\u003elname)\n            goto err;\n    }\n    ret = 1;\n\n err:\n    sk_CONF_VALUE_pop_free(rsk, X509V3_conf_free);\n    return ret;\n}","filepath":"crypto/x509v3/v3_crld.c","line_number":146,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270024624":{"score":0.92893237,"function_name":"EVP_CIPHER_CTX_copy","code":"int EVP_CIPHER_CTX_copy(EVP_CIPHER_CTX *out, const EVP_CIPHER_CTX *in)\n{\n    if ((in == NULL) || (in-\u003ecipher == NULL)) {\n        EVPerr(EVP_F_EVP_CIPHER_CTX_COPY, EVP_R_INPUT_NOT_INITIALIZED);\n        return 0;\n    }\n#ifndef OPENSSL_NO_ENGINE\n    /* Make sure it's safe to copy a cipher context using an ENGINE */\n    if (in-\u003eengine \u0026\u0026 !ENGINE_init(in-\u003eengine)) {\n        EVPerr(EVP_F_EVP_CIPHER_CTX_COPY, ERR_R_ENGINE_LIB);\n        return 0;\n    }\n#endif\n\n    EVP_CIPHER_CTX_reset(out);\n    memcpy(out, in, sizeof(*out));\n\n    if (in-\u003ecipher_data \u0026\u0026 in-\u003ecipher-\u003ectx_size) {\n        out-\u003ecipher_data = OPENSSL_malloc(in-\u003ecipher-\u003ectx_size);\n        if (out-\u003ecipher_data == NULL) {\n            out-\u003ecipher = NULL;\n            EVPerr(EVP_F_EVP_CIPHER_CTX_COPY, ERR_R_MALLOC_FAILURE);\n            return 0;\n        }\n        memcpy(out-\u003ecipher_data, in-\u003ecipher_data, in-\u003ecipher-\u003ectx_size);\n    }\n\n    if (in-\u003ecipher-\u003eflags \u0026 EVP_CIPH_CUSTOM_COPY)\n        if (!in-\u003ecipher-\u003ectrl((EVP_CIPHER_CTX *)in, EVP_CTRL_COPY, 0, out)) {\n            out-\u003ecipher = NULL;\n            EVPerr(EVP_F_EVP_CIPHER_CTX_COPY, EVP_R_INITIALIZATION_ERROR);\n            return 0;\n        }\n    return 1;\n}","filepath":"crypto/evp/evp_enc.c","line_number":683,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1k"},"270024912":{"score":0.9218482,"function_name":"EVP_CIPHER_CTX_ctrl","code":"int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr)\n{\n    int ret;\n\n    if (!ctx-\u003ecipher) {\n        EVPerr(EVP_F_EVP_CIPHER_CTX_CTRL, EVP_R_NO_CIPHER_SET);\n        return 0;\n    }\n\n    if (!ctx-\u003ecipher-\u003ectrl) {\n        EVPerr(EVP_F_EVP_CIPHER_CTX_CTRL, EVP_R_CTRL_NOT_IMPLEMENTED);\n        return 0;\n    }\n\n    ret = ctx-\u003ecipher-\u003ectrl(ctx, type, arg, ptr);\n    if (ret == -1) {\n        EVPerr(EVP_F_EVP_CIPHER_CTX_CTRL,\n               EVP_R_CTRL_OPERATION_NOT_IMPLEMENTED);\n        return 0;\n    }\n    return ret;\n}","filepath":"crypto/evp/evp_enc.c","line_number":651,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1k"},"270025120":{"score":0.82731587,"function_name":"EVP_CIPHER_CTX_rand_key","code":"int EVP_CIPHER_CTX_rand_key(EVP_CIPHER_CTX *ctx, unsigned char *key)\n{\n    if (ctx-\u003ecipher-\u003eflags \u0026 EVP_CIPH_RAND_KEY)\n        return EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_RAND_KEY, 0, key);\n    if (RAND_priv_bytes(key, ctx-\u003ekey_len) \u003c= 0)\n        return 0;\n    return 1;\n}","filepath":"crypto/evp/evp_enc.c","line_number":674,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1k"},"270025184":{"score":0.95064497,"function_name":"EVP_CIPHER_CTX_reset","code":"int EVP_CIPHER_CTX_reset(EVP_CIPHER_CTX *c)\n{\n    if (c == NULL)\n        return 1;\n    if (c-\u003ecipher != NULL) {\n        if (c-\u003ecipher-\u003ecleanup \u0026\u0026 !c-\u003ecipher-\u003ecleanup(c))\n            return 0;\n        /* Cleanse cipher context data */\n        if (c-\u003ecipher_data \u0026\u0026 c-\u003ecipher-\u003ectx_size)\n            OPENSSL_cleanse(c-\u003ecipher_data, c-\u003ecipher-\u003ectx_size);\n    }\n    OPENSSL_free(c-\u003ecipher_data);\n#ifndef OPENSSL_NO_ENGINE\n    ENGINE_finish(c-\u003eengine);\n#endif\n    memset(c, 0, sizeof(*c));\n    return 1;\n}","filepath":"crypto/evp/evp_enc.c","line_number":22,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1k"},"270025296":{"score":0.9451815,"function_name":"EVP_CIPHER_CTX_set_key_length","code":"int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *c, int keylen)\n{\n    if (c-\u003ecipher-\u003eflags \u0026 EVP_CIPH_CUSTOM_KEY_LENGTH)\n        return EVP_CIPHER_CTX_ctrl(c, EVP_CTRL_SET_KEY_LENGTH, keylen, NULL);\n    if (c-\u003ekey_len == keylen)\n        return 1;\n    if ((keylen \u003e 0) \u0026\u0026 (c-\u003ecipher-\u003eflags \u0026 EVP_CIPH_VARIABLE_LENGTH)) {\n        c-\u003ekey_len = keylen;\n        return 1;\n    }\n    EVPerr(EVP_F_EVP_CIPHER_CTX_SET_KEY_LENGTH, EVP_R_INVALID_KEY_LENGTH);\n    return 0;\n}","filepath":"crypto/evp/evp_enc.c","line_number":628,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1k"},"270025392":{"score":0.9325753,"function_name":"EVP_CIPHER_CTX_set_padding","code":"int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *ctx, int pad)\n{\n    if (pad)\n        ctx-\u003eflags \u0026= ~EVP_CIPH_NO_PADDING;\n    else\n        ctx-\u003eflags |= EVP_CIPH_NO_PADDING;\n    return 1;\n}","filepath":"crypto/evp/evp_enc.c","line_number":642,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1k"},"270025440":{"score":0.9069774,"function_name":"EVP_EncryptFinal_ex","code":"int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)\n{\n    int n, ret;\n    unsigned int i, b, bl;\n\n    /* Prevent accidental use of decryption context when encrypting */\n    if (!ctx-\u003eencrypt) {\n        EVPerr(EVP_F_EVP_ENCRYPTFINAL_EX, EVP_R_INVALID_OPERATION);\n        return 0;\n    }\n\n    if (ctx-\u003ecipher-\u003eflags \u0026 EVP_CIPH_FLAG_CUSTOM_CIPHER) {\n        ret = ctx-\u003ecipher-\u003edo_cipher(ctx, out, NULL, 0);\n        if (ret \u003c 0)\n            return 0;\n        else\n            *outl = ret;\n        return 1;\n    }\n\n    b = ctx-\u003ecipher-\u003eblock_size;\n    OPENSSL_assert(b \u003c= sizeof(ctx-\u003ebuf));\n    if (b == 1) {\n        *outl = 0;\n        return 1;\n    }\n    bl = ctx-\u003ebuf_len;\n    if (ctx-\u003eflags \u0026 EVP_CIPH_NO_PADDING) {\n        if (bl) {\n            EVPerr(EVP_F_EVP_ENCRYPTFINAL_EX,\n                   EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH);\n            return 0;\n        }\n        *outl = 0;\n        return 1;\n    }\n\n    n = b - bl;\n    for (i = bl; i \u003c b; i++)\n        ctx-\u003ebuf[i] = n;\n    ret = ctx-\u003ecipher-\u003edo_cipher(ctx, out, ctx-\u003ebuf, b);\n\n    if (ret)\n        *outl = b;\n\n    return ret;\n}","filepath":"crypto/evp/evp_enc.c","line_number":416,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1k"},"270026224":{"score":0.7888986,"function_name":"EVP_CipherUpdate","code":"int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\n                     const unsigned char *in, int inl)\n{\n    if (ctx-\u003eencrypt)\n        return EVP_EncryptUpdate(ctx, out, outl, in, inl);\n    else\n        return EVP_DecryptUpdate(ctx, out, outl, in, inl);\n}","filepath":"crypto/evp/evp_enc.c","line_number":210,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1k"},"270026256":{"score":0.92349344,"function_name":"EVP_DecryptFinal_ex","code":"int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)\n{\n    int i, n;\n    unsigned int b;\n\n    /* Prevent accidental use of encryption context when decrypting */\n    if (ctx-\u003eencrypt) {\n        EVPerr(EVP_F_EVP_DECRYPTFINAL_EX, EVP_R_INVALID_OPERATION);\n        return 0;\n    }\n\n    *outl = 0;\n\n    if (ctx-\u003ecipher-\u003eflags \u0026 EVP_CIPH_FLAG_CUSTOM_CIPHER) {\n        i = ctx-\u003ecipher-\u003edo_cipher(ctx, out, NULL, 0);\n        if (i \u003c 0)\n            return 0;\n        else\n            *outl = i;\n        return 1;\n    }\n\n    b = ctx-\u003ecipher-\u003eblock_size;\n    if (ctx-\u003eflags \u0026 EVP_CIPH_NO_PADDING) {\n        if (ctx-\u003ebuf_len) {\n            EVPerr(EVP_F_EVP_DECRYPTFINAL_EX,\n                   EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH);\n            return 0;\n        }\n        *outl = 0;\n        return 1;\n    }\n    if (b \u003e 1) {\n        if (ctx-\u003ebuf_len || !ctx-\u003efinal_used) {\n            EVPerr(EVP_F_EVP_DECRYPTFINAL_EX, EVP_R_WRONG_FINAL_BLOCK_LENGTH);\n            return 0;\n        }\n        OPENSSL_assert(b \u003c= sizeof(ctx-\u003efinal));\n\n        /*\n         * The following assumes that the ciphertext has been authenticated.\n         * Otherwise it provides a padding oracle.\n         */\n        n = ctx-\u003efinal[b - 1];\n        if (n == 0 || n \u003e (int)b) {\n            EVPerr(EVP_F_EVP_DECRYPTFINAL_EX, EVP_R_BAD_DECRYPT);\n            return 0;\n        }\n        for (i = 0; i \u003c n; i++) {\n            if (ctx-\u003efinal[--b] != n) {\n                EVPerr(EVP_F_EVP_DECRYPTFINAL_EX, EVP_R_BAD_DECRYPT);\n                return 0;\n            }\n        }\n        n = ctx-\u003ecipher-\u003eblock_size - n;\n        for (i = 0; i \u003c n; i++)\n            out[i] = ctx-\u003efinal[i];\n        *outl = n;\n    } else\n        *outl = 0;\n    return 1;\n}","filepath":"crypto/evp/evp_enc.c","line_number":565,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1k"},"270026672":{"score":0.9430682,"function_name":"EVP_DecryptUpdate","code":"int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\n                      const unsigned char *in, int inl)\n{\n    int fix_len, cmpl = inl;\n    unsigned int b;\n\n    /* Prevent accidental use of encryption context when decrypting */\n    if (ctx-\u003eencrypt) {\n        EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_INVALID_OPERATION);\n        return 0;\n    }\n\n    b = ctx-\u003ecipher-\u003eblock_size;\n\n    if (EVP_CIPHER_CTX_test_flags(ctx, EVP_CIPH_FLAG_LENGTH_BITS))\n        cmpl = (cmpl + 7) / 8;\n\n    /*\n     * CCM mode needs to know about the case where inl == 0 - it means the\n     * plaintext/ciphertext length is 0\n     */\n    if (inl \u003c 0\n            || (inl == 0\n                \u0026\u0026 EVP_CIPHER_mode(ctx-\u003ecipher) != EVP_CIPH_CCM_MODE)) {\n        *outl = 0;\n        return inl == 0;\n    }\n\n    if (ctx-\u003ecipher-\u003eflags \u0026 EVP_CIPH_FLAG_CUSTOM_CIPHER) {\n        if (b == 1 \u0026\u0026 is_partially_overlapping(out, in, cmpl)) {\n            EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_PARTIALLY_OVERLAPPING);\n            return 0;\n        }\n\n        fix_len = ctx-\u003ecipher-\u003edo_cipher(ctx, out, in, inl);\n        if (fix_len \u003c 0) {\n            *outl = 0;\n            return 0;\n        } else\n            *outl = fix_len;\n        return 1;\n    }\n\n    if (ctx-\u003eflags \u0026 EVP_CIPH_NO_PADDING)\n        return evp_EncryptDecryptUpdate(ctx, out, outl, in, inl);\n\n    OPENSSL_assert(b \u003c= sizeof(ctx-\u003efinal));\n\n    if (ctx-\u003efinal_used) {\n        /* see comment about PTRDIFF_T comparison above */\n        if (((PTRDIFF_T)out == (PTRDIFF_T)in)\n            || is_partially_overlapping(out, in, b)) {\n            EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_PARTIALLY_OVERLAPPING);\n            return 0;\n        }\n        /*\n         * final_used is only ever set if buf_len is 0. Therefore the maximum\n         * length output we will ever see from evp_EncryptDecryptUpdate is\n         * the maximum multiple of the block length that is \u003c= inl, or just:\n         * inl \u0026 ~(b - 1)\n         * Since final_used has been set then the final output length is:\n         * (inl \u0026 ~(b - 1)) + b\n         * This must never exceed INT_MAX\n         */\n        if ((inl \u0026 ~(b - 1)) \u003e INT_MAX - b) {\n            EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_OUTPUT_WOULD_OVERFLOW);\n            return 0;\n        }\n        memcpy(out, ctx-\u003efinal, b);\n        out += b;\n        fix_len = 1;\n    } else\n        fix_len = 0;\n\n    if (!evp_EncryptDecryptUpdate(ctx, out, outl, in, inl))\n        return 0;\n\n    /*\n     * if we have 'decrypted' a multiple of block size, make sure we have a\n     * copy of this last block\n     */\n    if (b \u003e 1 \u0026\u0026 !ctx-\u003ebuf_len) {\n        *outl -= b;\n        ctx-\u003efinal_used = 1;\n        memcpy(ctx-\u003efinal, \u0026out[*outl], b);\n    } else\n        ctx-\u003efinal_used = 0;\n\n    if (fix_len)\n        *outl += b;\n\n    return 1;\n}","filepath":"crypto/evp/evp_enc.c","line_number":464,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1k"},"270027488":{"score":0.84200686,"function_name":"EVP_EncryptUpdate","code":"int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\n                      const unsigned char *in, int inl)\n{\n    /* Prevent accidental use of decryption context when encrypting */\n    if (!ctx-\u003eencrypt) {\n        EVPerr(EVP_F_EVP_ENCRYPTUPDATE, EVP_R_INVALID_OPERATION);\n        return 0;\n    }\n\n    return evp_EncryptDecryptUpdate(ctx, out, outl, in, inl);\n}","filepath":"crypto/evp/evp_enc.c","line_number":397,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1k"},"270027552":{"score":0.8999148,"function_name":"evp_EncryptDecryptUpdate","code":"static int evp_EncryptDecryptUpdate(EVP_CIPHER_CTX *ctx,\n                                    unsigned char *out, int *outl,\n                                    const unsigned char *in, int inl)\n{\n    int i, j, bl, cmpl = inl;\n\n    if (EVP_CIPHER_CTX_test_flags(ctx, EVP_CIPH_FLAG_LENGTH_BITS))\n        cmpl = (cmpl + 7) / 8;\n\n    bl = ctx-\u003ecipher-\u003eblock_size;\n\n    /*\n     * CCM mode needs to know about the case where inl == 0 \u0026\u0026 in == NULL - it\n     * means the plaintext/ciphertext length is 0\n     */\n    if (inl \u003c 0\n            || (inl == 0\n                \u0026\u0026 EVP_CIPHER_mode(ctx-\u003ecipher) != EVP_CIPH_CCM_MODE)) {\n        *outl = 0;\n        return inl == 0;\n    }\n\n    if (ctx-\u003ecipher-\u003eflags \u0026 EVP_CIPH_FLAG_CUSTOM_CIPHER) {\n        /* If block size \u003e 1 then the cipher will have to do this check */\n        if (bl == 1 \u0026\u0026 is_partially_overlapping(out, in, cmpl)) {\n            EVPerr(EVP_F_EVP_ENCRYPTDECRYPTUPDATE, EVP_R_PARTIALLY_OVERLAPPING);\n            return 0;\n        }\n\n        i = ctx-\u003ecipher-\u003edo_cipher(ctx, out, in, inl);\n        if (i \u003c 0)\n            return 0;\n        else\n            *outl = i;\n        return 1;\n    }\n\n    if (is_partially_overlapping(out + ctx-\u003ebuf_len, in, cmpl)) {\n        EVPerr(EVP_F_EVP_ENCRYPTDECRYPTUPDATE, EVP_R_PARTIALLY_OVERLAPPING);\n        return 0;\n    }\n\n    if (ctx-\u003ebuf_len == 0 \u0026\u0026 (inl \u0026 (ctx-\u003eblock_mask)) == 0) {\n        if (ctx-\u003ecipher-\u003edo_cipher(ctx, out, in, inl)) {\n            *outl = inl;\n            return 1;\n        } else {\n            *outl = 0;\n            return 0;\n        }\n    }\n    i = ctx-\u003ebuf_len;\n    OPENSSL_assert(bl \u003c= (int)sizeof(ctx-\u003ebuf));\n    if (i != 0) {\n        if (bl - i \u003e inl) {\n            memcpy(\u0026(ctx-\u003ebuf[i]), in, inl);\n            ctx-\u003ebuf_len += inl;\n            *outl = 0;\n            return 1;\n        } else {\n            j = bl - i;\n\n            /*\n             * Once we've processed the first j bytes from in, the amount of\n             * data left that is a multiple of the block length is:\n             * (inl - j) \u0026 ~(bl - 1)\n             * We must ensure that this amount of data, plus the one block that\n             * we process from ctx-\u003ebuf does not exceed INT_MAX\n             */\n            if (((inl - j) \u0026 ~(bl - 1)) \u003e INT_MAX - bl) {\n                EVPerr(EVP_F_EVP_ENCRYPTDECRYPTUPDATE,\n                       EVP_R_OUTPUT_WOULD_OVERFLOW);\n                return 0;\n            }\n            memcpy(\u0026(ctx-\u003ebuf[i]), in, j);\n            inl -= j;\n            in += j;\n            if (!ctx-\u003ecipher-\u003edo_cipher(ctx, out, ctx-\u003ebuf, bl))\n                return 0;\n            out += bl;\n            *outl = bl;\n        }\n    } else\n        *outl = 0;\n    i = inl \u0026 (bl - 1);\n    inl -= i;\n    if (inl \u003e 0) {\n        if (!ctx-\u003ecipher-\u003edo_cipher(ctx, out, in, inl))\n            return 0;\n        *outl += inl;\n    }\n\n    if (i != 0)\n        memcpy(ctx-\u003ebuf, \u0026(in[inl]), i);\n    ctx-\u003ebuf_len = i;\n    return 1;\n}","filepath":"crypto/evp/evp_enc.c","line_number":298,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1k"},"270028352":{"score":0.7127363,"function_name":"RAND_DRBG_get0_public","code":"RAND_DRBG *RAND_DRBG_get0_public(void)\n{\n    RAND_DRBG *drbg;\n\n    if (!RUN_ONCE(\u0026rand_drbg_init, do_rand_drbg_init))\n        return NULL;\n\n    drbg = CRYPTO_THREAD_get_local(\u0026public_drbg);\n    if (drbg == NULL) {\n        if (!ossl_init_thread_start(OPENSSL_INIT_THREAD_RAND))\n            return NULL;\n        drbg = drbg_setup(master_drbg);\n        CRYPTO_THREAD_set_local(\u0026public_drbg, drbg);\n    }\n    return drbg;\n}","filepath":"openssl/crypto/rand/drbg_lib.c","line_number":1109,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.0"},"270033136":{"score":0.76011413,"function_name":"RAND_DRBG_bytes","code":"int RAND_DRBG_bytes(RAND_DRBG *drbg, unsigned char *out, size_t outlen)\n{\n    unsigned char *additional = NULL;\n    size_t additional_len;\n    size_t chunk;\n    size_t ret = 0;\n\n    if (drbg-\u003eadin_pool == NULL) {\n        if (drbg-\u003etype == 0)\n            goto err;\n        drbg-\u003eadin_pool = rand_pool_new(0, 0, drbg-\u003emax_adinlen);\n        if (drbg-\u003eadin_pool == NULL)\n            goto err;\n    }\n\n    additional_len = rand_drbg_get_additional_data(drbg-\u003eadin_pool,\n                                                   \u0026additional);\n\n    for ( ; outlen \u003e 0; outlen -= chunk, out += chunk) {\n        chunk = outlen;\n        if (chunk \u003e drbg-\u003emax_request)\n            chunk = drbg-\u003emax_request;\n        ret = RAND_DRBG_generate(drbg, out, chunk, 0, additional, additional_len);\n        if (!ret)\n            goto err;\n    }\n    ret = 1;\n\n err:\n    if (additional != NULL)\n        rand_drbg_cleanup_additional_data(drbg-\u003eadin_pool, additional);\n\n    return ret;\n}","filepath":"openssl/crypto/rand/drbg_lib.c","line_number":657,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.0"},"270033648":{"score":0.9063817,"function_name":"RAND_DRBG_free","code":"void RAND_DRBG_free(RAND_DRBG *drbg)\n{\n    if (drbg == NULL)\n        return;\n\n    if (drbg-\u003emeth != NULL)\n        drbg-\u003emeth-\u003euninstantiate(drbg);\n    rand_pool_free(drbg-\u003eadin_pool);\n    CRYPTO_THREAD_lock_free(drbg-\u003elock);\n    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_DRBG, drbg, \u0026drbg-\u003eex_data);\n\n    if (drbg-\u003esecure)\n        OPENSSL_secure_clear_free(drbg, sizeof(*drbg));\n    else\n        OPENSSL_clear_free(drbg, sizeof(*drbg));\n}","filepath":"openssl/crypto/rand/drbg_lib.c","line_number":263,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.0"},"270033776":{"score":0.88995266,"function_name":"RAND_DRBG_generate","code":"int RAND_DRBG_generate(RAND_DRBG *drbg, unsigned char *out, size_t outlen,\n                       int prediction_resistance,\n                       const unsigned char *adin, size_t adinlen)\n{\n    int reseed_required = 0;\n\n    if (drbg-\u003estate != DRBG_READY) {\n        /* try to recover from previous errors */\n        rand_drbg_restart(drbg, NULL, 0, 0);\n\n        if (drbg-\u003estate == DRBG_ERROR) {\n            RANDerr(RAND_F_RAND_DRBG_GENERATE, RAND_R_IN_ERROR_STATE);\n            return 0;\n        }\n        if (drbg-\u003estate == DRBG_UNINITIALISED) {\n            RANDerr(RAND_F_RAND_DRBG_GENERATE, RAND_R_NOT_INSTANTIATED);\n            return 0;\n        }\n    }\n\n    if (outlen \u003e drbg-\u003emax_request) {\n        RANDerr(RAND_F_RAND_DRBG_GENERATE, RAND_R_REQUEST_TOO_LARGE_FOR_DRBG);\n        return 0;\n    }\n    if (adinlen \u003e drbg-\u003emax_adinlen) {\n        RANDerr(RAND_F_RAND_DRBG_GENERATE, RAND_R_ADDITIONAL_INPUT_TOO_LONG);\n        return 0;\n    }\n\n    if (drbg-\u003efork_count != rand_fork_count) {\n        drbg-\u003efork_count = rand_fork_count;\n        reseed_required = 1;\n    }\n\n    if (drbg-\u003ereseed_interval \u003e 0) {\n        if (drbg-\u003ereseed_gen_counter \u003e= drbg-\u003ereseed_interval)\n            reseed_required = 1;\n    }\n    if (drbg-\u003ereseed_time_interval \u003e 0) {\n        time_t now = time(NULL);\n        if (now \u003c drbg-\u003ereseed_time\n            || now - drbg-\u003ereseed_time \u003e= drbg-\u003ereseed_time_interval)\n            reseed_required = 1;\n    }\n    if (drbg-\u003eparent != NULL) {\n        unsigned int reseed_counter = tsan_load(\u0026drbg-\u003ereseed_prop_counter);\n        if (reseed_counter \u003e 0\n                \u0026\u0026 tsan_load(\u0026drbg-\u003eparent-\u003ereseed_prop_counter)\n                   != reseed_counter)\n            reseed_required = 1;\n    }\n\n    if (reseed_required || prediction_resistance) {\n        if (!RAND_DRBG_reseed(drbg, adin, adinlen, prediction_resistance)) {\n            RANDerr(RAND_F_RAND_DRBG_GENERATE, RAND_R_RESEED_ERROR);\n            return 0;\n        }\n        adin = NULL;\n        adinlen = 0;\n    }\n\n    if (!drbg-\u003emeth-\u003egenerate(drbg, out, outlen, adin, adinlen)) {\n        drbg-\u003estate = DRBG_ERROR;\n        RANDerr(RAND_F_RAND_DRBG_GENERATE, RAND_R_GENERATE_ERROR);\n        return 0;\n    }\n\n    drbg-\u003ereseed_gen_counter++;\n\n    return 1;\n}","filepath":"openssl/crypto/rand/drbg_lib.c","line_number":577,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.0"},"270034208":{"score":0.66955113,"function_name":"RAND_DRBG_get0_private","code":"RAND_DRBG *RAND_DRBG_get0_private(void)\n{\n    RAND_DRBG *drbg;\n\n    if (!RUN_ONCE(\u0026rand_drbg_init, do_rand_drbg_init))\n        return NULL;\n\n    drbg = CRYPTO_THREAD_get_local(\u0026private_drbg);\n    if (drbg == NULL) {\n        if (!ossl_init_thread_start(OPENSSL_INIT_THREAD_RAND))\n            return NULL;\n        drbg = drbg_setup(master_drbg);\n        CRYPTO_THREAD_set_local(\u0026private_drbg, drbg);\n    }\n    return drbg;\n}","filepath":"openssl/crypto/rand/drbg_lib.c","line_number":1130,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.0"},"270034320":{"score":0.81972617,"function_name":"RAND_DRBG_instantiate","code":"int RAND_DRBG_instantiate(RAND_DRBG *drbg,\n                          const unsigned char *pers, size_t perslen)\n{\n    unsigned char *nonce = NULL, *entropy = NULL;\n    size_t noncelen = 0, entropylen = 0;\n    size_t min_entropy = drbg-\u003estrength;\n    size_t min_entropylen = drbg-\u003emin_entropylen;\n    size_t max_entropylen = drbg-\u003emax_entropylen;\n\n    if (perslen \u003e drbg-\u003emax_perslen) {\n        RANDerr(RAND_F_RAND_DRBG_INSTANTIATE,\n                RAND_R_PERSONALISATION_STRING_TOO_LONG);\n        goto end;\n    }\n\n    if (drbg-\u003emeth == NULL) {\n        RANDerr(RAND_F_RAND_DRBG_INSTANTIATE,\n                RAND_R_NO_DRBG_IMPLEMENTATION_SELECTED);\n        goto end;\n    }\n\n    if (drbg-\u003estate != DRBG_UNINITIALISED) {\n        RANDerr(RAND_F_RAND_DRBG_INSTANTIATE,\n                drbg-\u003estate == DRBG_ERROR ? RAND_R_IN_ERROR_STATE\n                                          : RAND_R_ALREADY_INSTANTIATED);\n        goto end;\n    }\n\n    drbg-\u003estate = DRBG_ERROR;\n\n    /*\n     * NIST SP800-90Ar1 section 9.1 says you can combine getting the entropy\n     * and nonce in 1 call by increasing the entropy with 50% and increasing\n     * the minimum length to accomadate the length of the nonce.\n     * We do this in case a nonce is require and get_nonce is NULL.\n     */\n    if (drbg-\u003emin_noncelen \u003e 0 \u0026\u0026 drbg-\u003eget_nonce == NULL) {\n        min_entropy += drbg-\u003estrength / 2;\n        min_entropylen += drbg-\u003emin_noncelen;\n        max_entropylen += drbg-\u003emax_noncelen;\n    }\n\n    drbg-\u003ereseed_next_counter = tsan_load(\u0026drbg-\u003ereseed_prop_counter);\n    if (drbg-\u003ereseed_next_counter) {\n        drbg-\u003ereseed_next_counter++;\n        if(!drbg-\u003ereseed_next_counter)\n            drbg-\u003ereseed_next_counter = 1;\n    }\n\n    if (drbg-\u003eget_entropy != NULL)\n        entropylen = drbg-\u003eget_entropy(drbg, \u0026entropy, min_entropy,\n                                       min_entropylen, max_entropylen, 0);\n    if (entropylen \u003c min_entropylen\n            || entropylen \u003e max_entropylen) {\n        RANDerr(RAND_F_RAND_DRBG_INSTANTIATE, RAND_R_ERROR_RETRIEVING_ENTROPY);\n        goto end;\n    }\n\n    if (drbg-\u003emin_noncelen \u003e 0 \u0026\u0026 drbg-\u003eget_nonce != NULL) {\n        noncelen = drbg-\u003eget_nonce(drbg, \u0026nonce, drbg-\u003estrength / 2,\n                                   drbg-\u003emin_noncelen, drbg-\u003emax_noncelen);\n        if (noncelen \u003c drbg-\u003emin_noncelen || noncelen \u003e drbg-\u003emax_noncelen) {\n            RANDerr(RAND_F_RAND_DRBG_INSTANTIATE, RAND_R_ERROR_RETRIEVING_NONCE);\n            goto end;\n        }\n    }\n\n    if (!drbg-\u003emeth-\u003einstantiate(drbg, entropy, entropylen,\n                         nonce, noncelen, pers, perslen)) {\n        RANDerr(RAND_F_RAND_DRBG_INSTANTIATE, RAND_R_ERROR_INSTANTIATING_DRBG);\n        goto end;\n    }\n\n    drbg-\u003estate = DRBG_READY;\n    drbg-\u003ereseed_gen_counter = 1;\n    drbg-\u003ereseed_time = time(NULL);\n    tsan_store(\u0026drbg-\u003ereseed_prop_counter, drbg-\u003ereseed_next_counter);\n\n end:\n    if (entropy != NULL \u0026\u0026 drbg-\u003ecleanup_entropy != NULL)\n        drbg-\u003ecleanup_entropy(drbg, entropy, entropylen);\n    if (nonce != NULL \u0026\u0026 drbg-\u003ecleanup_nonce != NULL)\n        drbg-\u003ecleanup_nonce(drbg, nonce, noncelen);\n    if (drbg-\u003estate == DRBG_READY)\n        return 1;\n    return 0;\n}","filepath":"openssl/crypto/rand/drbg_lib.c","line_number":288,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.0"},"270034848":{"score":0.83471847,"function_name":"RAND_DRBG_reseed","code":"int RAND_DRBG_reseed(RAND_DRBG *drbg,\n                     const unsigned char *adin, size_t adinlen,\n                     int prediction_resistance)\n{\n    unsigned char *entropy = NULL;\n    size_t entropylen = 0;\n\n    if (drbg-\u003estate == DRBG_ERROR) {\n        RANDerr(RAND_F_RAND_DRBG_RESEED, RAND_R_IN_ERROR_STATE);\n        return 0;\n    }\n    if (drbg-\u003estate == DRBG_UNINITIALISED) {\n        RANDerr(RAND_F_RAND_DRBG_RESEED, RAND_R_NOT_INSTANTIATED);\n        return 0;\n    }\n\n    if (adin == NULL) {\n        adinlen = 0;\n    } else if (adinlen \u003e drbg-\u003emax_adinlen) {\n        RANDerr(RAND_F_RAND_DRBG_RESEED, RAND_R_ADDITIONAL_INPUT_TOO_LONG);\n        return 0;\n    }\n\n    drbg-\u003estate = DRBG_ERROR;\n\n    drbg-\u003ereseed_next_counter = tsan_load(\u0026drbg-\u003ereseed_prop_counter);\n    if (drbg-\u003ereseed_next_counter) {\n        drbg-\u003ereseed_next_counter++;\n        if(!drbg-\u003ereseed_next_counter)\n            drbg-\u003ereseed_next_counter = 1;\n    }\n\n    if (drbg-\u003eget_entropy != NULL)\n        entropylen = drbg-\u003eget_entropy(drbg, \u0026entropy, drbg-\u003estrength,\n                                       drbg-\u003emin_entropylen,\n                                       drbg-\u003emax_entropylen,\n                                       prediction_resistance);\n    if (entropylen \u003c drbg-\u003emin_entropylen\n            || entropylen \u003e drbg-\u003emax_entropylen) {\n        RANDerr(RAND_F_RAND_DRBG_RESEED, RAND_R_ERROR_RETRIEVING_ENTROPY);\n        goto end;\n    }\n\n    if (!drbg-\u003emeth-\u003ereseed(drbg, entropy, entropylen, adin, adinlen))\n        goto end;\n\n    drbg-\u003estate = DRBG_READY;\n    drbg-\u003ereseed_gen_counter = 1;\n    drbg-\u003ereseed_time = time(NULL);\n    tsan_store(\u0026drbg-\u003ereseed_prop_counter, drbg-\u003ereseed_next_counter);\n\n end:\n    if (entropy != NULL \u0026\u0026 drbg-\u003ecleanup_entropy != NULL)\n        drbg-\u003ecleanup_entropy(drbg, entropy, entropylen);\n    if (drbg-\u003estate == DRBG_READY)\n        return 1;\n    return 0;\n}","filepath":"openssl/crypto/rand/drbg_lib.c","line_number":407,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.0"},"270035216":{"score":0.9112069,"function_name":"RAND_DRBG_set","code":"int RAND_DRBG_set(RAND_DRBG *drbg, int type, unsigned int flags)\n{\n    int ret = 1;\n\n    if (type == 0 \u0026\u0026 flags == 0) {\n        type = rand_drbg_type;\n        flags = rand_drbg_flags;\n    }\n\n    /* If set is called multiple times - clear the old one */\n    if (drbg-\u003etype != 0 \u0026\u0026 (type != drbg-\u003etype || flags != drbg-\u003eflags)) {\n        drbg-\u003emeth-\u003euninstantiate(drbg);\n        rand_pool_free(drbg-\u003eadin_pool);\n        drbg-\u003eadin_pool = NULL;\n    }\n\n    drbg-\u003estate = DRBG_UNINITIALISED;\n    drbg-\u003eflags = flags;\n    drbg-\u003etype = type;\n\n    switch (type) {\n    default:\n        drbg-\u003etype = 0;\n        drbg-\u003eflags = 0;\n        drbg-\u003emeth = NULL;\n        RANDerr(RAND_F_RAND_DRBG_SET, RAND_R_UNSUPPORTED_DRBG_TYPE);\n        return 0;\n    case 0:\n        /* Uninitialized; that's okay. */\n        drbg-\u003emeth = NULL;\n        return 1;\n    case NID_aes_128_ctr:\n    case NID_aes_192_ctr:\n    case NID_aes_256_ctr:\n        ret = drbg_ctr_init(drbg);\n        break;\n    }\n\n    if (ret == 0) {\n        drbg-\u003estate = DRBG_ERROR;\n        RANDerr(RAND_F_RAND_DRBG_SET, RAND_R_ERROR_INITIALISING_DRBG);\n    }\n    return ret;\n}","filepath":"openssl/crypto/rand/drbg_lib.c","line_number":103,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.0"},"270035600":{"score":0.7442769,"function_name":"drbg_delete_thread_state","code":"void drbg_delete_thread_state(void)\n{\n    RAND_DRBG *drbg;\n\n    drbg = CRYPTO_THREAD_get_local(\u0026public_drbg);\n    CRYPTO_THREAD_set_local(\u0026public_drbg, NULL);\n    RAND_DRBG_free(drbg);\n\n    drbg = CRYPTO_THREAD_get_local(\u0026private_drbg);\n    CRYPTO_THREAD_set_local(\u0026private_drbg, NULL);\n    RAND_DRBG_free(drbg);\n}","filepath":"openssl/crypto/rand/drbg_lib.c","line_number":946,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.0"},"270035680":{"score":0.76729685,"function_name":"drbg_setup","code":"static RAND_DRBG *drbg_setup(RAND_DRBG *parent)\n{\n    RAND_DRBG *drbg;\n\n    drbg = RAND_DRBG_secure_new(rand_drbg_type, rand_drbg_flags, parent);\n    if (drbg == NULL)\n        return NULL;\n\n    /* Only the master DRBG needs to have a lock */\n    if (parent == NULL \u0026\u0026 rand_drbg_enable_locking(drbg) == 0)\n        goto err;\n\n    /* enable seed propagation */\n    tsan_store(\u0026drbg-\u003ereseed_prop_counter, 1);\n\n    /*\n     * Ignore instantiation error to support just-in-time instantiation.\n     *\n     * The state of the drbg will be checked in RAND_DRBG_generate() and\n     * an automatic recovery is attempted.\n     */\n    (void)RAND_DRBG_instantiate(drbg,\n                                (const unsigned char *) ossl_pers_string,\n                                sizeof(ossl_pers_string) - 1);\n    return drbg;\n\nerr:\n    RAND_DRBG_free(drbg);\n    return NULL;\n}","filepath":"openssl/crypto/rand/drbg_lib.c","line_number":871,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.0"},"270035856":{"score":0.8439193,"function_name":"rand_drbg_cleanup_int","code":"void rand_drbg_cleanup_int(void)\n{\n    if (master_drbg != NULL) {\n        RAND_DRBG_free(master_drbg);\n        master_drbg = NULL;\n\n        CRYPTO_THREAD_cleanup_local(\u0026private_drbg);\n        CRYPTO_THREAD_cleanup_local(\u0026public_drbg);\n    }\n}","filepath":"openssl/crypto/rand/drbg_lib.c","line_number":935,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.0"},"270035952":{"score":0.87931126,"function_name":"rand_drbg_new","code":"static RAND_DRBG *rand_drbg_new(int secure,\n                                int type,\n                                unsigned int flags,\n                                RAND_DRBG *parent)\n{\n    RAND_DRBG *drbg = secure ? OPENSSL_secure_zalloc(sizeof(*drbg))\n                             : OPENSSL_zalloc(sizeof(*drbg));\n\n    if (drbg == NULL) {\n        RANDerr(RAND_F_RAND_DRBG_NEW, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    drbg-\u003esecure = secure \u0026\u0026 CRYPTO_secure_allocated(drbg);\n    drbg-\u003efork_count = rand_fork_count;\n    drbg-\u003eparent = parent;\n\n    if (parent == NULL) {\n        drbg-\u003eget_entropy = rand_drbg_get_entropy;\n        drbg-\u003ecleanup_entropy = rand_drbg_cleanup_entropy;\n#ifndef RAND_DRBG_GET_RANDOM_NONCE\n        drbg-\u003eget_nonce = rand_drbg_get_nonce;\n        drbg-\u003ecleanup_nonce = rand_drbg_cleanup_nonce;\n#endif\n\n        drbg-\u003ereseed_interval = master_reseed_interval;\n        drbg-\u003ereseed_time_interval = master_reseed_time_interval;\n    } else {\n        drbg-\u003eget_entropy = rand_drbg_get_entropy;\n        drbg-\u003ecleanup_entropy = rand_drbg_cleanup_entropy;\n        /*\n         * Do not provide nonce callbacks, the child DRBGs will\n         * obtain their nonce using random bits from the parent.\n         */\n\n        drbg-\u003ereseed_interval = slave_reseed_interval;\n        drbg-\u003ereseed_time_interval = slave_reseed_time_interval;\n    }\n\n    if (RAND_DRBG_set(drbg, type, flags) == 0)\n        goto err;\n\n    if (parent != NULL) {\n        rand_drbg_lock(parent);\n        if (drbg-\u003estrength \u003e parent-\u003estrength) {\n            /*\n             * We currently don't support the algorithm from NIST SP 800-90C\n             * 10.1.2 to use a weaker DRBG as source\n             */\n            rand_drbg_unlock(parent);\n            RANDerr(RAND_F_RAND_DRBG_NEW, RAND_R_PARENT_STRENGTH_TOO_WEAK);\n            goto err;\n        }\n        rand_drbg_unlock(parent);\n    }\n\n    return drbg;\n\n err:\n    RAND_DRBG_free(drbg);\n\n    return NULL;\n}","filepath":"openssl/crypto/rand/drbg_lib.c","line_number":186,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.0"},"270036288":{"score":0.81950617,"function_name":"rand_drbg_restart","code":"int rand_drbg_restart(RAND_DRBG *drbg,\n                      const unsigned char *buffer, size_t len, size_t entropy)\n{\n    int reseeded = 0;\n    const unsigned char *adin = NULL;\n    size_t adinlen = 0;\n\n    if (drbg-\u003eseed_pool != NULL) {\n        RANDerr(RAND_F_RAND_DRBG_RESTART, ERR_R_INTERNAL_ERROR);\n        drbg-\u003estate = DRBG_ERROR;\n        rand_pool_free(drbg-\u003eseed_pool);\n        drbg-\u003eseed_pool = NULL;\n        return 0;\n    }\n\n    if (buffer != NULL) {\n        if (entropy \u003e 0) {\n            if (drbg-\u003emax_entropylen \u003c len) {\n                RANDerr(RAND_F_RAND_DRBG_RESTART,\n                    RAND_R_ENTROPY_INPUT_TOO_LONG);\n                drbg-\u003estate = DRBG_ERROR;\n                return 0;\n            }\n\n            if (entropy \u003e 8 * len) {\n                RANDerr(RAND_F_RAND_DRBG_RESTART, RAND_R_ENTROPY_OUT_OF_RANGE);\n                drbg-\u003estate = DRBG_ERROR;\n                return 0;\n            }\n\n            /* will be picked up by the rand_drbg_get_entropy() callback */\n            drbg-\u003eseed_pool = rand_pool_attach(buffer, len, entropy);\n            if (drbg-\u003eseed_pool == NULL)\n                return 0;\n        } else {\n            if (drbg-\u003emax_adinlen \u003c len) {\n                RANDerr(RAND_F_RAND_DRBG_RESTART,\n                        RAND_R_ADDITIONAL_INPUT_TOO_LONG);\n                drbg-\u003estate = DRBG_ERROR;\n                return 0;\n            }\n            adin = buffer;\n            adinlen = len;\n        }\n    }\n\n    /* repair error state */\n    if (drbg-\u003estate == DRBG_ERROR)\n        RAND_DRBG_uninstantiate(drbg);\n\n    /* repair uninitialized state */\n    if (drbg-\u003estate == DRBG_UNINITIALISED) {\n        /* reinstantiate drbg */\n        RAND_DRBG_instantiate(drbg,\n                              (const unsigned char *) ossl_pers_string,\n                              sizeof(ossl_pers_string) - 1);\n        /* already reseeded. prevent second reseeding below */\n        reseeded = (drbg-\u003estate == DRBG_READY);\n    }\n\n    /* refresh current state if entropy or additional input has been provided */\n    if (drbg-\u003estate == DRBG_READY) {\n        if (adin != NULL) {\n            /*\n             * mix in additional input without reseeding\n             *\n             * Similar to RAND_DRBG_reseed(), but the provided additional\n             * data |adin| is mixed into the current state without pulling\n             * entropy from the trusted entropy source using get_entropy().\n             * This is not a reseeding in the strict sense of NIST SP 800-90A.\n             */\n            drbg-\u003emeth-\u003ereseed(drbg, adin, adinlen, NULL, 0);\n        } else if (reseeded == 0) {\n            /* do a full reseeding if it has not been done yet above */\n            RAND_DRBG_reseed(drbg, NULL, 0, 0);\n        }\n    }\n\n    rand_pool_free(drbg-\u003eseed_pool);\n    drbg-\u003eseed_pool = NULL;\n\n    return drbg-\u003estate == DRBG_READY;\n}","filepath":"openssl/crypto/rand/drbg_lib.c","line_number":483,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.0"},"270039824":{"score":0.75529945,"function_name":"CONF_modules_finish","code":"void CONF_modules_finish(void)\n{\n    CONF_IMODULE *imod;\n    while (sk_CONF_IMODULE_num(initialized_modules) \u003e 0) {\n        imod = sk_CONF_IMODULE_pop(initialized_modules);\n        module_finish(imod);\n    }\n    sk_CONF_IMODULE_free(initialized_modules);\n    initialized_modules = NULL;\n}","filepath":"crypto/conf/conf_mod.c","line_number":386,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre1"},"270039984":{"score":0.8701557,"function_name":"CONF_modules_load_file","code":"int CONF_modules_load_file(const char *filename, const char *appname,\n                           unsigned long flags)\n{\n    char *file = NULL;\n    CONF *conf = NULL;\n    int ret = 0;\n    conf = NCONF_new(NULL);\n    if (conf == NULL)\n        goto err;\n\n    if (filename == NULL) {\n        file = CONF_get1_default_config_file();\n        if (!file)\n            goto err;\n    } else\n        file = (char *)filename;\n\n    if (NCONF_load(conf, file, NULL) \u003c= 0) {\n        if ((flags \u0026 CONF_MFLAGS_IGNORE_MISSING_FILE) \u0026\u0026\n            (ERR_GET_REASON(ERR_peek_last_error()) == CONF_R_NO_SUCH_FILE)) {\n            ERR_clear_error();\n            ret = 1;\n        }\n        goto err;\n    }\n\n    ret = CONF_modules_load(conf, appname, flags);\n\n err:\n    if (filename == NULL)\n        OPENSSL_free(file);\n    NCONF_free(conf);\n\n    return ret;\n}","filepath":"crypto/conf/conf_mod.c","line_number":112,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre1"},"270040480":{"score":0.9646552,"function_name":"CONF_parse_list","code":"int CONF_parse_list(const char *list_, int sep, int nospc,\n                    int (*list_cb) (const char *elem, int len, void *usr),\n                    void *arg)\n{\n    int ret;\n    const char *lstart, *tmpend, *p;\n\n    if (list_ == NULL) {\n        CONFerr(CONF_F_CONF_PARSE_LIST, CONF_R_LIST_CANNOT_BE_NULL);\n        return 0;\n    }\n\n    lstart = list_;\n    for (;;) {\n        if (nospc) {\n            while (*lstart \u0026\u0026 isspace((unsigned char)*lstart))\n                lstart++;\n        }\n        p = strchr(lstart, sep);\n        if (p == lstart || !*lstart)\n            ret = list_cb(NULL, 0, arg);\n        else {\n            if (p)\n                tmpend = p - 1;\n            else\n                tmpend = lstart + strlen(lstart) - 1;\n            if (nospc) {\n                while (isspace((unsigned char)*tmpend))\n                    tmpend--;\n            }\n            ret = list_cb(lstart, tmpend - lstart + 1, arg);\n        }\n        if (ret \u003c= 0)\n            return ret;\n        if (p == NULL)\n            return 1;\n        lstart = p + 1;\n    }\n}","filepath":"crypto/conf/conf_mod.c","line_number":510,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre1"},"270040880":{"score":0.86706483,"function_name":"module_add","code":"static CONF_MODULE *module_add(DSO *dso, const char *name,\n                               conf_init_func *ifunc, conf_finish_func *ffunc)\n{\n    CONF_MODULE *tmod = NULL;\n    if (supported_modules == NULL)\n        supported_modules = sk_CONF_MODULE_new_null();\n    if (supported_modules == NULL)\n        return NULL;\n    tmod = OPENSSL_zalloc(sizeof(*tmod));\n    if (tmod == NULL)\n        return NULL;\n\n    tmod-\u003edso = dso;\n    tmod-\u003ename = OPENSSL_strdup(name);\n    tmod-\u003einit = ifunc;\n    tmod-\u003efinish = ffunc;\n    if (tmod-\u003ename == NULL) {\n        OPENSSL_free(tmod);\n        return NULL;\n    }\n\n    if (!sk_CONF_MODULE_push(supported_modules, tmod)) {\n        OPENSSL_free(tmod-\u003ename);\n        OPENSSL_free(tmod);\n        return NULL;\n    }\n\n    return tmod;\n}","filepath":"crypto/conf/conf_mod.c","line_number":227,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre1"},"270041104":{"score":0.55390704,"function_name":"module_run","code":"static int module_run(const CONF *cnf, const char *name, const char *value,\n                      unsigned long flags)\n{\n    CONF_MODULE *md;\n    int ret;\n\n    md = module_find(name);\n\n    /* Module not found: try to load DSO */\n    if (!md \u0026\u0026 !(flags \u0026 CONF_MFLAGS_NO_DSO))\n        md = module_load_dso(cnf, name, value);\n\n    if (!md) {\n        if (!(flags \u0026 CONF_MFLAGS_SILENT)) {\n            CONFerr(CONF_F_MODULE_RUN, CONF_R_UNKNOWN_MODULE_NAME);\n            ERR_add_error_data(2, \"module=\", name);\n        }\n        return -1;\n    }\n\n    ret = module_init(md, name, value, cnf);\n\n    if (ret \u003c= 0) {\n        if (!(flags \u0026 CONF_MFLAGS_SILENT)) {\n            char rcode[DECIMAL_SIZE(ret) + 1];\n            CONFerr(CONF_F_MODULE_RUN, CONF_R_MODULE_INITIALIZATION_ERROR);\n            BIO_snprintf(rcode, sizeof(rcode), \"%-8d\", ret);\n            ERR_add_error_data(6, \"module=\", name, \", value=\", value,\n                               \", retcode=\", rcode);\n        }\n    }\n\n    return ret;\n}"},"270043120":{"score":0.73897374,"function_name":"engine_dynamic","code":"static ENGINE *engine_dynamic(void)\n{\n    ENGINE *ret = ENGINE_new();\n    if (ret == NULL)\n        return NULL;\n    if (!ENGINE_set_id(ret, engine_dynamic_id) ||\n        !ENGINE_set_name(ret, engine_dynamic_name) ||\n        !ENGINE_set_init_function(ret, dynamic_init) ||\n        !ENGINE_set_finish_function(ret, dynamic_finish) ||\n        !ENGINE_set_ctrl_function(ret, dynamic_ctrl) ||\n        !ENGINE_set_flags(ret, ENGINE_FLAGS_BY_ID_COPY) ||\n        !ENGINE_set_cmd_defns(ret, dynamic_cmd_defns)) {\n        ENGINE_free(ret);\n        return NULL;\n    }\n    return ret;\n}","filepath":"crypto/engine/eng_dyn.c","line_number":240,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.1"},"270044864":{"score":0.85254836,"function_name":"dynamic_ctrl","code":"static int dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void))\n{\n    dynamic_data_ctx *ctx = dynamic_get_data_ctx(e);\n    int initialised;\n\n    if (!ctx) {\n        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_NOT_LOADED);\n        return 0;\n    }\n    initialised = ((ctx-\u003edynamic_dso == NULL) ? 0 : 1);\n    /* All our control commands require the ENGINE to be uninitialised */\n    if (initialised) {\n        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_ALREADY_LOADED);\n        return 0;\n    }\n    switch (cmd) {\n    case DYNAMIC_CMD_SO_PATH:\n        /* a NULL 'p' or a string of zero-length is the same thing */\n        if (p \u0026\u0026 (strlen((const char *)p) \u003c 1))\n            p = NULL;\n        OPENSSL_free(ctx-\u003eDYNAMIC_LIBNAME);\n        if (p)\n            ctx-\u003eDYNAMIC_LIBNAME = OPENSSL_strdup(p);\n        else\n            ctx-\u003eDYNAMIC_LIBNAME = NULL;\n        return (ctx-\u003eDYNAMIC_LIBNAME ? 1 : 0);\n    case DYNAMIC_CMD_NO_VCHECK:\n        ctx-\u003eno_vcheck = ((i == 0) ? 0 : 1);\n        return 1;\n    case DYNAMIC_CMD_ID:\n        /* a NULL 'p' or a string of zero-length is the same thing */\n        if (p \u0026\u0026 (strlen((const char *)p) \u003c 1))\n            p = NULL;\n        OPENSSL_free(ctx-\u003eengine_id);\n        if (p)\n            ctx-\u003eengine_id = OPENSSL_strdup(p);\n        else\n            ctx-\u003eengine_id = NULL;\n        return (ctx-\u003eengine_id ? 1 : 0);\n    case DYNAMIC_CMD_LIST_ADD:\n        if ((i \u003c 0) || (i \u003e 2)) {\n            ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INVALID_ARGUMENT);\n            return 0;\n        }\n        ctx-\u003elist_add_value = (int)i;\n        return 1;\n    case DYNAMIC_CMD_LOAD:\n        return dynamic_load(e, ctx);\n    case DYNAMIC_CMD_DIR_LOAD:\n        if ((i \u003c 0) || (i \u003e 2)) {\n            ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INVALID_ARGUMENT);\n            return 0;\n        }\n        ctx-\u003edir_load = (int)i;\n        return 1;\n    case DYNAMIC_CMD_DIR_ADD:\n        /* a NULL 'p' or a string of zero-length is the same thing */\n        if (p == NULL || (strlen((const char *)p) \u003c 1)) {\n            ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INVALID_ARGUMENT);\n            return 0;\n        }\n        {\n            char *tmp_str = OPENSSL_strdup(p);\n            if (tmp_str == NULL) {\n                ERR_raise(ERR_LIB_ENGINE, ERR_R_MALLOC_FAILURE);\n                return 0;\n            }\n            if (!sk_OPENSSL_STRING_push(ctx-\u003edirs, tmp_str)) {\n                OPENSSL_free(tmp_str);\n                ERR_raise(ERR_LIB_ENGINE, ERR_R_MALLOC_FAILURE);\n                return 0;\n            }\n        }\n        return 1;\n    default:\n        break;\n    }\n    ERR_raise(ERR_LIB_ENGINE, ENGINE_R_CTRL_COMMAND_NOT_IMPLEMENTED);\n    return 0;\n}","filepath":"crypto/engine/eng_dyn.c","line_number":297,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.1"},"270046048":{"score":0.8446615,"function_name":"dynamic_load","code":"static int dynamic_load(ENGINE *e, dynamic_data_ctx *ctx)\n{\n    ENGINE cpy;\n    dynamic_fns fns;\n\n    if (ctx-\u003edynamic_dso == NULL)\n        ctx-\u003edynamic_dso = DSO_new();\n    if (ctx-\u003edynamic_dso == NULL)\n        return 0;\n    if (!ctx-\u003eDYNAMIC_LIBNAME) {\n        if (!ctx-\u003eengine_id)\n            return 0;\n        DSO_ctrl(ctx-\u003edynamic_dso, DSO_CTRL_SET_FLAGS,\n                 DSO_FLAG_NAME_TRANSLATION_EXT_ONLY, NULL);\n        ctx-\u003eDYNAMIC_LIBNAME =\n            DSO_convert_filename(ctx-\u003edynamic_dso, ctx-\u003eengine_id);\n    }\n    if (!int_load(ctx)) {\n        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_DSO_NOT_FOUND);\n        DSO_free(ctx-\u003edynamic_dso);\n        ctx-\u003edynamic_dso = NULL;\n        return 0;\n    }\n    /* We have to find a bind function otherwise it'll always end badly */\n    if (!\n        (ctx-\u003ebind_engine =\n         (dynamic_bind_engine) DSO_bind_func(ctx-\u003edynamic_dso,\n                                             ctx-\u003eDYNAMIC_F2))) {\n        ctx-\u003ebind_engine = NULL;\n        DSO_free(ctx-\u003edynamic_dso);\n        ctx-\u003edynamic_dso = NULL;\n        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_DSO_FAILURE);\n        return 0;\n    }\n    /* Do we perform version checking? */\n    if (!ctx-\u003eno_vcheck) {\n        unsigned long vcheck_res = 0;\n        /*\n         * Now we try to find a version checking function and decide how to\n         * cope with failure if/when it fails.\n         */\n        ctx-\u003ev_check =\n            (dynamic_v_check_fn) DSO_bind_func(ctx-\u003edynamic_dso,\n                                               ctx-\u003eDYNAMIC_F1);\n        if (ctx-\u003ev_check)\n            vcheck_res = ctx-\u003ev_check(OSSL_DYNAMIC_VERSION);\n        /*\n         * We fail if the version checker veto'd the load *or* if it is\n         * deferring to us (by returning its version) and we think it is too\n         * old.\n         */\n        if (vcheck_res \u003c OSSL_DYNAMIC_OLDEST) {\n            /* Fail */\n            ctx-\u003ebind_engine = NULL;\n            ctx-\u003ev_check = NULL;\n            DSO_free(ctx-\u003edynamic_dso);\n            ctx-\u003edynamic_dso = NULL;\n            ERR_raise(ERR_LIB_ENGINE, ENGINE_R_VERSION_INCOMPATIBILITY);\n            return 0;\n        }\n    }\n    /*\n     * First binary copy the ENGINE structure so that we can roll back if the\n     * hand-over fails\n     */\n    memcpy(\u0026cpy, e, sizeof(ENGINE));\n    /*\n     * Provide the ERR, \"ex_data\", memory, and locking callbacks so the\n     * loaded library uses our state rather than its own. FIXME: As noted in\n     * engine.h, much of this would be simplified if each area of code\n     * provided its own \"summary\" structure of all related callbacks. It\n     * would also increase opaqueness.\n     */\n    fns.static_state = ENGINE_get_static_state();\n    CRYPTO_get_mem_functions(\u0026fns.mem_fns.malloc_fn, \u0026fns.mem_fns.realloc_fn,\n                             \u0026fns.mem_fns.free_fn);\n    /*\n     * Now that we've loaded the dynamic engine, make sure no \"dynamic\"\n     * ENGINE elements will show through.\n     */\n    engine_set_all_null(e);\n\n    /* Try to bind the ENGINE onto our own ENGINE structure */\n    if (!engine_add_dynamic_id(e, (ENGINE_DYNAMIC_ID)ctx-\u003ebind_engine, 1)\n            || !ctx-\u003ebind_engine(e, ctx-\u003eengine_id, \u0026fns)) {\n        engine_remove_dynamic_id(e, 1);\n        ctx-\u003ebind_engine = NULL;\n        ctx-\u003ev_check = NULL;\n        DSO_free(ctx-\u003edynamic_dso);\n        ctx-\u003edynamic_dso = NULL;\n        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INIT_FAILED);\n        /* Copy the original ENGINE structure back */\n        memcpy(e, \u0026cpy, sizeof(ENGINE));\n        return 0;\n    }\n    /* Do we try to add this ENGINE to the internal list too? */\n    if (ctx-\u003elist_add_value \u003e 0) {\n        if (!ENGINE_add(e)) {\n            /* Do we tolerate this or fail? */\n            if (ctx-\u003elist_add_value \u003e 1) {\n                /*\n                 * Fail - NB: By this time, it's too late to rollback, and\n                 * trying to do so allows the bind_engine() code to have\n                 * created leaks. We just have to fail where we are, after\n                 * the ENGINE has changed.\n                 */\n                ERR_raise(ERR_LIB_ENGINE, ENGINE_R_CONFLICTING_ENGINE_ID);\n                return 0;\n            }\n            /* Tolerate */\n            ERR_clear_error();\n        }\n    }\n    return 1;\n}","filepath":"crypto/engine/eng_dyn.c","line_number":404,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.1"},"270048976":{"score":0.67607844,"function_name":"SHA512","code":"unsigned char *SHA512(const unsigned char *d, size_t n, unsigned char *md)\n{\n    SHA512_CTX c;\n    static unsigned char m[SHA512_DIGEST_LENGTH];\n\n    if (md == NULL)\n        md = m;\n    SHA512_Init(\u0026c);\n    SHA512_Update(\u0026c, d, n);\n    SHA512_Final(md, \u0026c);\n    OPENSSL_cleanse(\u0026c, sizeof(c));\n    return (md);\n}","filepath":"crypto/sha/sha512.c","line_number":261,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre1"},"270049264":{"score":0.87623316,"function_name":"SHA512_Final","code":"int SHA512_Final(unsigned char *md, SHA512_CTX *c)\n{\n    unsigned char *p = (unsigned char *)c-\u003eu.p;\n    size_t n = c-\u003enum;\n\n    p[n] = 0x80;                /* There always is a room for one */\n    n++;\n    if (n \u003e (sizeof(c-\u003eu) - 16)) {\n        memset(p + n, 0, sizeof(c-\u003eu) - n);\n        n = 0;\n        sha512_block_data_order(c, p, 1);\n    }\n\n    memset(p + n, 0, sizeof(c-\u003eu) - 16 - n);\n#ifdef  B_ENDIAN\n    c-\u003eu.d[SHA_LBLOCK - 2] = c-\u003eNh;\n    c-\u003eu.d[SHA_LBLOCK - 1] = c-\u003eNl;\n#else\n    p[sizeof(c-\u003eu) - 1] = (unsigned char)(c-\u003eNl);\n    p[sizeof(c-\u003eu) - 2] = (unsigned char)(c-\u003eNl \u003e\u003e 8);\n    p[sizeof(c-\u003eu) - 3] = (unsigned char)(c-\u003eNl \u003e\u003e 16);\n    p[sizeof(c-\u003eu) - 4] = (unsigned char)(c-\u003eNl \u003e\u003e 24);\n    p[sizeof(c-\u003eu) - 5] = (unsigned char)(c-\u003eNl \u003e\u003e 32);\n    p[sizeof(c-\u003eu) - 6] = (unsigned char)(c-\u003eNl \u003e\u003e 40);\n    p[sizeof(c-\u003eu) - 7] = (unsigned char)(c-\u003eNl \u003e\u003e 48);\n    p[sizeof(c-\u003eu) - 8] = (unsigned char)(c-\u003eNl \u003e\u003e 56);\n    p[sizeof(c-\u003eu) - 9] = (unsigned char)(c-\u003eNh);\n    p[sizeof(c-\u003eu) - 10] = (unsigned char)(c-\u003eNh \u003e\u003e 8);\n    p[sizeof(c-\u003eu) - 11] = (unsigned char)(c-\u003eNh \u003e\u003e 16);\n    p[sizeof(c-\u003eu) - 12] = (unsigned char)(c-\u003eNh \u003e\u003e 24);\n    p[sizeof(c-\u003eu) - 13] = (unsigned char)(c-\u003eNh \u003e\u003e 32);\n    p[sizeof(c-\u003eu) - 14] = (unsigned char)(c-\u003eNh \u003e\u003e 40);\n    p[sizeof(c-\u003eu) - 15] = (unsigned char)(c-\u003eNh \u003e\u003e 48);\n    p[sizeof(c-\u003eu) - 16] = (unsigned char)(c-\u003eNh \u003e\u003e 56);\n#endif\n\n    sha512_block_data_order(c, p, 1);\n\n    if (md == 0)\n        return 0;\n\n    switch (c-\u003emd_len) {\n        /* Let compiler decide if it's appropriate to unroll... */\n    case SHA384_DIGEST_LENGTH:\n        for (n = 0; n \u003c SHA384_DIGEST_LENGTH / 8; n++) {\n            SHA_LONG64 t = c-\u003eh[n];\n\n            *(md++) = (unsigned char)(t \u003e\u003e 56);\n            *(md++) = (unsigned char)(t \u003e\u003e 48);\n            *(md++) = (unsigned char)(t \u003e\u003e 40);\n            *(md++) = (unsigned char)(t \u003e\u003e 32);\n            *(md++) = (unsigned char)(t \u003e\u003e 24);\n            *(md++) = (unsigned char)(t \u003e\u003e 16);\n            *(md++) = (unsigned char)(t \u003e\u003e 8);\n            *(md++) = (unsigned char)(t);\n        }\n        break;\n    case SHA512_DIGEST_LENGTH:\n        for (n = 0; n \u003c SHA512_DIGEST_LENGTH / 8; n++) {\n            SHA_LONG64 t = c-\u003eh[n];\n\n            *(md++) = (unsigned char)(t \u003e\u003e 56);\n            *(md++) = (unsigned char)(t \u003e\u003e 48);\n            *(md++) = (unsigned char)(t \u003e\u003e 40);\n            *(md++) = (unsigned char)(t \u003e\u003e 32);\n            *(md++) = (unsigned char)(t \u003e\u003e 24);\n            *(md++) = (unsigned char)(t \u003e\u003e 16);\n            *(md++) = (unsigned char)(t \u003e\u003e 8);\n            *(md++) = (unsigned char)(t);\n        }\n        break;\n        /* ... as well as make sure md_len is not abused. */\n    default:\n        return 0;\n    }\n\n    return 1;\n}","filepath":"crypto/sha/sha512.c","line_number":101,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre1"},"270051104":{"score":0.9493135,"function_name":"SHA512_Init","code":"int SHA512_Init(SHA512_CTX *c)\n{\n    c-\u003eh[0] = U64(0x6a09e667f3bcc908);\n    c-\u003eh[1] = U64(0xbb67ae8584caa73b);\n    c-\u003eh[2] = U64(0x3c6ef372fe94f82b);\n    c-\u003eh[3] = U64(0xa54ff53a5f1d36f1);\n    c-\u003eh[4] = U64(0x510e527fade682d1);\n    c-\u003eh[5] = U64(0x9b05688c2b3e6c1f);\n    c-\u003eh[6] = U64(0x1f83d9abfb41bd6b);\n    c-\u003eh[7] = U64(0x5be0cd19137e2179);\n\n    c-\u003eNl = 0;\n    c-\u003eNh = 0;\n    c-\u003enum = 0;\n    c-\u003emd_len = SHA512_DIGEST_LENGTH;\n    return 1;\n}","filepath":"crypto/sha/sha512.c","line_number":78,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre1"},"270051856":{"score":0.8628528,"function_name":"BN_RECP_CTX_free","code":"void BN_RECP_CTX_free(BN_RECP_CTX *recp)\n{\n    if (recp == NULL)\n        return;\n    BN_free(\u0026recp-\u003eN);\n    BN_free(\u0026recp-\u003eNr);\n    if (recp-\u003eflags \u0026 BN_FLG_MALLOCED)\n        OPENSSL_free(recp);\n}","filepath":"crypto/bn/bn_recp.c","line_number":35,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270051968":{"score":0.8358896,"function_name":"BN_RECP_CTX_set","code":"int BN_RECP_CTX_set(BN_RECP_CTX *recp, const BIGNUM *d, BN_CTX *ctx)\n{\n    if (!BN_copy(\u0026(recp-\u003eN), d))\n        return 0;\n    BN_zero(\u0026(recp-\u003eNr));\n    recp-\u003enum_bits = BN_num_bits(d);\n    recp-\u003eshift = 0;\n    return 1;\n}","filepath":"crypto/bn/bn_recp.c","line_number":45,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270052032":{"score":0.84844494,"function_name":"BN_div_recp","code":"int BN_div_recp(BIGNUM *dv, BIGNUM *rem, const BIGNUM *m,\n                BN_RECP_CTX *recp, BN_CTX *ctx)\n{\n    int i, j, ret = 0;\n    BIGNUM *a, *b, *d, *r;\n\n    BN_CTX_start(ctx);\n    d = (dv != NULL) ? dv : BN_CTX_get(ctx);\n    r = (rem != NULL) ? rem : BN_CTX_get(ctx);\n    a = BN_CTX_get(ctx);\n    b = BN_CTX_get(ctx);\n    if (b == NULL)\n        goto err;\n\n    if (BN_ucmp(m, \u0026(recp-\u003eN)) \u003c 0) {\n        BN_zero(d);\n        if (!BN_copy(r, m)) {\n            BN_CTX_end(ctx);\n            return 0;\n        }\n        BN_CTX_end(ctx);\n        return 1;\n    }\n\n    /*\n     * We want the remainder Given input of ABCDEF / ab we need multiply\n     * ABCDEF by 3 digests of the reciprocal of ab\n     */\n\n    /* i := max(BN_num_bits(m), 2*BN_num_bits(N)) */\n    i = BN_num_bits(m);\n    j = recp-\u003enum_bits \u003c\u003c 1;\n    if (j \u003e i)\n        i = j;\n\n    /* Nr := round(2^i / N) */\n    if (i != recp-\u003eshift)\n        recp-\u003eshift = BN_reciprocal(\u0026(recp-\u003eNr), \u0026(recp-\u003eN), i, ctx);\n    /* BN_reciprocal could have returned -1 for an error */\n    if (recp-\u003eshift == -1)\n        goto err;\n\n    /*-\n     * d := |round(round(m / 2^BN_num_bits(N)) * recp-\u003eNr / 2^(i - BN_num_bits(N)))|\n     *    = |round(round(m / 2^BN_num_bits(N)) * round(2^i / N) / 2^(i - BN_num_bits(N)))|\n     *   \u003c= |(m / 2^BN_num_bits(N)) * (2^i / N) * (2^BN_num_bits(N) / 2^i)|\n     *    = |m/N|\n     */\n    if (!BN_rshift(a, m, recp-\u003enum_bits))\n        goto err;\n    if (!BN_mul(b, a, \u0026(recp-\u003eNr), ctx))\n        goto err;\n    if (!BN_rshift(d, b, i - recp-\u003enum_bits))\n        goto err;\n    d-\u003eneg = 0;\n\n    if (!BN_mul(b, \u0026(recp-\u003eN), d, ctx))\n        goto err;\n    if (!BN_usub(r, m, b))\n        goto err;\n    r-\u003eneg = 0;\n\n    j = 0;\n    while (BN_ucmp(r, \u0026(recp-\u003eN)) \u003e= 0) {\n        if (j++ \u003e 2) {\n            BNerr(BN_F_BN_DIV_RECP, BN_R_BAD_RECIPROCAL);\n            goto err;\n        }\n        if (!BN_usub(r, r, \u0026(recp-\u003eN)))\n            goto err;\n        if (!BN_add_word(d, 1))\n            goto err;\n    }\n\n    r-\u003eneg = BN_is_zero(r) ? 0 : m-\u003eneg;\n    d-\u003eneg = m-\u003eneg ^ recp-\u003eN.neg;\n    ret = 1;\n err:\n    BN_CTX_end(ctx);\n    bn_check_top(dv);\n    bn_check_top(rem);\n    return ret;\n}","filepath":"crypto/bn/bn_recp.c","line_number":84,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270052688":{"score":0.82296276,"function_name":"BN_mod_mul_reciprocal","code":"int BN_mod_mul_reciprocal(BIGNUM *r, const BIGNUM *x, const BIGNUM *y,\n                          BN_RECP_CTX *recp, BN_CTX *ctx)\n{\n    int ret = 0;\n    BIGNUM *a;\n    const BIGNUM *ca;\n\n    BN_CTX_start(ctx);\n    if ((a = BN_CTX_get(ctx)) == NULL)\n        goto err;\n    if (y != NULL) {\n        if (x == y) {\n            if (!BN_sqr(a, x, ctx))\n                goto err;\n        } else {\n            if (!BN_mul(a, x, y, ctx))\n                goto err;\n        }\n        ca = a;\n    } else\n        ca = x;                 /* Just do the mod */\n\n    ret = BN_div_recp(NULL, r, ca, recp, ctx);\n err:\n    BN_CTX_end(ctx);\n    bn_check_top(r);\n    return ret;\n}","filepath":"crypto/bn/bn_recp.c","line_number":55,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270052928":{"score":0.91335094,"function_name":"BN_bn2dec","code":"char *BN_bn2dec(const BIGNUM *a)\n{\n    int i = 0, num, ok = 0, n, tbytes;\n    char *buf = NULL;\n    char *p;\n    BIGNUM *t = NULL;\n    BN_ULONG *bn_data = NULL, *lp;\n    int bn_data_num;\n\n    /*-\n     * get an upper bound for the length of the decimal integer\n     * num \u003c= (BN_num_bits(a) + 1) * log(2)\n     *     \u003c= 3 * BN_num_bits(a) * 0.101 + log(2) + 1     (rounding error)\n     *     \u003c= 3 * BN_num_bits(a) / 10 + 3 * BN_num_bits / 1000 + 1 + 1\n     */\n    i = BN_num_bits(a) * 3;\n    num = (i / 10 + i / 1000 + 1) + 1;\n    tbytes = num + 3;   /* negative and terminator and one spare? */\n    bn_data_num = num / BN_DEC_NUM + 1;\n    bn_data = OPENSSL_malloc(bn_data_num * sizeof(BN_ULONG));\n    buf = OPENSSL_malloc(tbytes);\n    if (buf == NULL || bn_data == NULL) {\n        BNerr(BN_F_BN_BN2DEC, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    if ((t = BN_dup(a)) == NULL)\n        goto err;\n\n    p = buf;\n    lp = bn_data;\n    if (BN_is_zero(t)) {\n        *p++ = '0';\n        *p++ = '\\0';\n    } else {\n        if (BN_is_negative(t))\n            *p++ = '-';\n\n        while (!BN_is_zero(t)) {\n            if (lp - bn_data \u003e= bn_data_num)\n                goto err;\n            *lp = BN_div_word(t, BN_DEC_CONV);\n            if (*lp == (BN_ULONG)-1)\n                goto err;\n            lp++;\n        }\n        lp--;\n        /*\n         * We now have a series of blocks, BN_DEC_NUM chars in length, where\n         * the last one needs truncation. The blocks need to be reversed in\n         * order.\n         */\n        n = BIO_snprintf(p, tbytes - (size_t)(p - buf), BN_DEC_FMT1, *lp);\n        if (n \u003c 0)\n            goto err;\n        p += n;\n        while (lp != bn_data) {\n            lp--;\n            n = BIO_snprintf(p, tbytes - (size_t)(p - buf), BN_DEC_FMT2, *lp);\n            if (n \u003c 0)\n                goto err;\n            p += n;\n        }\n    }\n    ok = 1;\n err:\n    OPENSSL_free(bn_data);\n    BN_free(t);\n    if (ok)\n        return buf;\n    OPENSSL_free(buf);\n    return NULL;\n}","filepath":"crypto/bn/bn_print.c","line_number":53,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre1"},"270053456":{"score":0.9612725,"function_name":"BN_bn2hex","code":"char *BN_bn2hex(const BIGNUM *a)\n{\n    int i, j, v, z = 0;\n    char *buf;\n    char *p;\n\n    if (BN_is_zero(a))\n        return OPENSSL_strdup(\"0\");\n    buf = OPENSSL_malloc(a-\u003etop * BN_BYTES * 2 + 2);\n    if (buf == NULL) {\n        BNerr(BN_F_BN_BN2HEX, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    p = buf;\n    if (a-\u003eneg)\n        *p++ = '-';\n    for (i = a-\u003etop - 1; i \u003e= 0; i--) {\n        for (j = BN_BITS2 - 8; j \u003e= 0; j -= 8) {\n            /* strip leading zeros */\n            v = (int)((a-\u003ed[i] \u003e\u003e j) \u0026 0xff);\n            if (z || v != 0) {\n                *p++ = Hex[v \u003e\u003e 4];\n                *p++ = Hex[v \u0026 0x0f];\n                z = 1;\n            }\n        }\n    }\n    *p = '\\0';\n err:\n    return buf;\n}","filepath":"crypto/bn/bn_print.c","line_number":20,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre1"},"270053696":{"score":0.88927674,"function_name":"BN_dec2bn","code":"int BN_dec2bn(BIGNUM **bn, const char *a)\n{\n    BIGNUM *ret = NULL;\n    BN_ULONG l = 0;\n    int neg = 0, i, j;\n    int num;\n\n    if (a == NULL || *a == '\\0')\n        return 0;\n    if (*a == '-') {\n        neg = 1;\n        a++;\n    }\n\n    for (i = 0; i \u003c= INT_MAX / 4 \u0026\u0026 ossl_isdigit(a[i]); i++)\n        continue;\n\n    if (i == 0 || i \u003e INT_MAX / 4)\n        goto err;\n\n    num = i + neg;\n    if (bn == NULL)\n        return num;\n\n    /*\n     * a is the start of the digits, and it is 'i' long. We chop it into\n     * BN_DEC_NUM digits at a time\n     */\n    if (*bn == NULL) {\n        if ((ret = BN_new()) == NULL)\n            return 0;\n    } else {\n        ret = *bn;\n        BN_zero(ret);\n    }\n\n    /* i is the number of digits, a bit of an over expand */\n    if (bn_expand(ret, i * 4) == NULL)\n        goto err;\n\n    j = BN_DEC_NUM - i % BN_DEC_NUM;\n    if (j == BN_DEC_NUM)\n        j = 0;\n    l = 0;\n    while (--i \u003e= 0) {\n        l *= 10;\n        l += *a - '0';\n        a++;\n        if (++j == BN_DEC_NUM) {\n            if (!BN_mul_word(ret, BN_DEC_CONV)\n                || !BN_add_word(ret, l))\n                goto err;\n            l = 0;\n            j = 0;\n        }\n    }\n\n    bn_correct_top(ret);\n    *bn = ret;\n    bn_check_top(ret);\n    /* Don't set the negative flag if it's zero. */\n    if (ret-\u003etop != 0)\n        ret-\u003eneg = neg;\n    return num;\n err:\n    if (*bn == NULL)\n        BN_free(ret);\n    return 0;\n}","filepath":"crypto/bn/bn_print.c","line_number":199,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre1"},"270054096":{"score":0.9289276,"function_name":"BN_hex2bn","code":"int BN_hex2bn(BIGNUM **bn, const char *a)\n{\n    BIGNUM *ret = NULL;\n    BN_ULONG l = 0;\n    int neg = 0, h, m, i, j, k, c;\n    int num;\n\n    if (a == NULL || *a == '\\0')\n        return 0;\n\n    if (*a == '-') {\n        neg = 1;\n        a++;\n    }\n\n    for (i = 0; i \u003c= INT_MAX / 4 \u0026\u0026 ossl_isxdigit(a[i]); i++)\n        continue;\n\n    if (i == 0 || i \u003e INT_MAX / 4)\n        goto err;\n\n    num = i + neg;\n    if (bn == NULL)\n        return num;\n\n    /* a is the start of the hex digits, and it is 'i' long */\n    if (*bn == NULL) {\n        if ((ret = BN_new()) == NULL)\n            return 0;\n    } else {\n        ret = *bn;\n        BN_zero(ret);\n    }\n\n    /* i is the number of hex digits */\n    if (bn_expand(ret, i * 4) == NULL)\n        goto err;\n\n    j = i;                      /* least significant 'hex' */\n    m = 0;\n    h = 0;\n    while (j \u003e 0) {\n        m = (BN_BYTES * 2 \u003c= j) ? BN_BYTES * 2 : j;\n        l = 0;\n        for (;;) {\n            c = a[j - m];\n            k = OPENSSL_hexchar2int(c);\n            if (k \u003c 0)\n                k = 0;          /* paranoia */\n            l = (l \u003c\u003c 4) | k;\n\n            if (--m \u003c= 0) {\n                ret-\u003ed[h++] = l;\n                break;\n            }\n        }\n        j -= BN_BYTES * 2;\n    }\n    ret-\u003etop = h;\n    bn_correct_top(ret);\n\n    *bn = ret;\n    bn_check_top(ret);\n    /* Don't set the negative flag if it's zero. */\n    if (ret-\u003etop != 0)\n        ret-\u003eneg = neg;\n    return num;\n err:\n    if (*bn == NULL)\n        BN_free(ret);\n    return 0;\n}","filepath":"crypto/bn/bn_print.c","line_number":126,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre1"},"270054528":{"score":0.9183686,"function_name":"BN_print","code":"int BN_print(BIO *bp, const BIGNUM *a)\n{\n    int i, j, v, z = 0;\n    int ret = 0;\n\n    if ((a-\u003eneg) \u0026\u0026 BIO_write(bp, \"-\", 1) != 1)\n        goto end;\n    if (BN_is_zero(a) \u0026\u0026 BIO_write(bp, \"0\", 1) != 1)\n        goto end;\n    for (i = a-\u003etop - 1; i \u003e= 0; i--) {\n        for (j = BN_BITS2 - 4; j \u003e= 0; j -= 4) {\n            /* strip leading zeros */\n            v = (int)((a-\u003ed[i] \u003e\u003e j) \u0026 0x0f);\n            if (z || v != 0) {\n                if (BIO_write(bp, \u0026Hex[v], 1) != 1)\n                    goto end;\n                z = 1;\n            }\n        }\n    }\n    ret = 1;\n end:\n    return ret;\n}","filepath":"crypto/bn/bn_print.c","line_number":304,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre1"},"270055056":{"score":0.81989634,"function_name":"EVP_Digest","code":"int EVP_Digest(const void *data, size_t count,\n               unsigned char *md, unsigned int *size, const EVP_MD *type,\n               ENGINE *impl)\n{\n    EVP_MD_CTX *ctx = EVP_MD_CTX_new();\n    int ret;\n\n    if (ctx == NULL)\n        return 0;\n    EVP_MD_CTX_set_flags(ctx, EVP_MD_CTX_FLAG_ONESHOT);\n    ret = EVP_DigestInit_ex(ctx, type, impl)\n        \u0026\u0026 EVP_DigestUpdate(ctx, data, count)\n        \u0026\u0026 EVP_DigestFinal_ex(ctx, md, size);\n    EVP_MD_CTX_free(ctx);\n\n    return ret;\n}","filepath":"crypto/evp/digest.c","line_number":274,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270055248":{"score":0.8523691,"function_name":"EVP_DigestFinalXOF","code":"int EVP_DigestFinalXOF(EVP_MD_CTX *ctx, unsigned char *md, size_t size)\n{\n    int ret = 0;\n\n    if (ctx-\u003edigest-\u003eflags \u0026 EVP_MD_FLAG_XOF\n        \u0026\u0026 size \u003c= INT_MAX\n        \u0026\u0026 ctx-\u003edigest-\u003emd_ctrl(ctx, EVP_MD_CTRL_XOF_LEN, (int)size, NULL)) {\n        ret = ctx-\u003edigest-\u003efinal(ctx, md);\n\n        if (ctx-\u003edigest-\u003ecleanup != NULL) {\n            ctx-\u003edigest-\u003ecleanup(ctx);\n            EVP_MD_CTX_set_flags(ctx, EVP_MD_CTX_FLAG_CLEANED);\n        }\n        OPENSSL_cleanse(ctx-\u003emd_data, ctx-\u003edigest-\u003ectx_size);\n    } else {\n        EVPerr(EVP_F_EVP_DIGESTFINALXOF, EVP_R_NOT_XOF_OR_INVALID_LENGTH);\n    }\n\n    return ret;\n}","filepath":"crypto/evp/digest.c","line_number":185,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270055392":{"score":0.940724,"function_name":"EVP_DigestFinal_ex","code":"int EVP_DigestFinal_ex(EVP_MD_CTX *ctx, unsigned char *md, unsigned int *size)\n{\n    int ret;\n\n    OPENSSL_assert(ctx-\u003edigest-\u003emd_size \u003c= EVP_MAX_MD_SIZE);\n    ret = ctx-\u003edigest-\u003efinal(ctx, md);\n    if (size != NULL)\n        *size = ctx-\u003edigest-\u003emd_size;\n    if (ctx-\u003edigest-\u003ecleanup) {\n        ctx-\u003edigest-\u003ecleanup(ctx);\n        EVP_MD_CTX_set_flags(ctx, EVP_MD_CTX_FLAG_CLEANED);\n    }\n    OPENSSL_cleanse(ctx-\u003emd_data, ctx-\u003edigest-\u003ectx_size);\n    return ret;\n}","filepath":"crypto/evp/digest.c","line_number":169,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270056416":{"score":0.8963876,"function_name":"EVP_MD_CTX_reset","code":"int EVP_MD_CTX_reset(EVP_MD_CTX *ctx)\n{\n    if (ctx == NULL)\n        return 1;\n\n    /*\n     * Don't assume ctx-\u003emd_data was cleaned in EVP_Digest_Final, because\n     * sometimes only copies of the context are ever finalised.\n     */\n    if (ctx-\u003edigest \u0026\u0026 ctx-\u003edigest-\u003ecleanup\n        \u0026\u0026 !EVP_MD_CTX_test_flags(ctx, EVP_MD_CTX_FLAG_CLEANED))\n        ctx-\u003edigest-\u003ecleanup(ctx);\n    if (ctx-\u003edigest \u0026\u0026 ctx-\u003edigest-\u003ectx_size \u0026\u0026 ctx-\u003emd_data\n        \u0026\u0026 !EVP_MD_CTX_test_flags(ctx, EVP_MD_CTX_FLAG_REUSE)) {\n        OPENSSL_clear_free(ctx-\u003emd_data, ctx-\u003edigest-\u003ectx_size);\n    }\n    /*\n     * pctx should be freed by the user of EVP_MD_CTX\n     * if EVP_MD_CTX_FLAG_KEEP_PKEY_CTX is set\n     */\n    if (!EVP_MD_CTX_test_flags(ctx, EVP_MD_CTX_FLAG_KEEP_PKEY_CTX))\n        EVP_PKEY_CTX_free(ctx-\u003epctx);\n#ifndef OPENSSL_NO_ENGINE\n    ENGINE_finish(ctx-\u003eengine);\n#endif\n    OPENSSL_cleanse(ctx, sizeof(*ctx));\n\n    return 1;\n}","filepath":"crypto/evp/digest.c","line_number":19,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270056592":{"score":0.84469277,"function_name":"ASN1_TYPE_get","code":"int ASN1_TYPE_get(const ASN1_TYPE *a)\n{\n    if (a-\u003etype == V_ASN1_BOOLEAN\n            || a-\u003etype == V_ASN1_NULL\n            || a-\u003evalue.ptr != NULL)\n        return a-\u003etype;\n    else\n        return 0;\n}","filepath":"crypto/asn1/a_type.c","line_number":16,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1d"},"270056624":{"score":0.8353833,"function_name":"ASN1_TYPE_pack_sequence","code":"ASN1_TYPE *ASN1_TYPE_pack_sequence(const ASN1_ITEM *it, void *s, ASN1_TYPE **t)\n{\n    ASN1_OCTET_STRING *oct;\n    ASN1_TYPE *rt;\n\n    oct = ASN1_item_pack(s, it, NULL);\n    if (oct == NULL)\n        return NULL;\n\n    if (t \u0026\u0026 *t) {\n        rt = *t;\n    } else {\n        rt = ASN1_TYPE_new();\n        if (rt == NULL) {\n            ASN1_OCTET_STRING_free(oct);\n            return NULL;\n        }\n        if (t)\n            *t = rt;\n    }\n    ASN1_TYPE_set(rt, V_ASN1_SEQUENCE, oct);\n    return rt;\n}","filepath":"crypto/asn1/a_type.c","line_number":109,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1d"},"270056784":{"score":0.8579336,"function_name":"ASN1_TYPE_set","code":"void ASN1_TYPE_set(ASN1_TYPE *a, int type, void *value)\n{\n    if (a-\u003etype != V_ASN1_BOOLEAN\n            \u0026\u0026 a-\u003etype != V_ASN1_NULL\n            \u0026\u0026 a-\u003evalue.ptr != NULL) {\n        ASN1_TYPE **tmp_a = \u0026a;\n        asn1_primitive_free((ASN1_VALUE **)tmp_a, NULL, 0);\n    }\n    a-\u003etype = type;\n    if (type == V_ASN1_BOOLEAN)\n        a-\u003evalue.boolean = value ? 0xff : 0;\n    else\n        a-\u003evalue.ptr = value;\n}","filepath":"crypto/asn1/a_type.c","line_number":26,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1d"},"270056864":{"score":0.7995797,"function_name":"ASN1_TYPE_set1","code":"int ASN1_TYPE_set1(ASN1_TYPE *a, int type, const void *value)\n{\n    if (!value || (type == V_ASN1_BOOLEAN)) {\n        void *p = (void *)value;\n        ASN1_TYPE_set(a, type, p);\n    } else if (type == V_ASN1_OBJECT) {\n        ASN1_OBJECT *odup;\n        odup = OBJ_dup(value);\n        if (!odup)\n            return 0;\n        ASN1_TYPE_set(a, type, odup);\n    } else {\n        ASN1_STRING *sdup;\n        sdup = ASN1_STRING_dup(value);\n        if (!sdup)\n            return 0;\n        ASN1_TYPE_set(a, type, sdup);\n    }\n    return 1;\n}","filepath":"crypto/asn1/a_type.c","line_number":41,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1d"},"270057088":{"score":0.90091705,"function_name":"asn1_do_adb","code":"const ASN1_TEMPLATE *asn1_do_adb(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt,\n                                 int nullerr)\n{\n    const ASN1_ADB *adb;\n    const ASN1_ADB_TABLE *atbl;\n    long selector;\n    ASN1_VALUE **sfld;\n    int i;\n    if (!(tt-\u003eflags \u0026 ASN1_TFLG_ADB_MASK))\n        return tt;\n\n    /* Else ANY DEFINED BY ... get the table */\n    adb = ASN1_ADB_ptr(tt-\u003eitem);\n\n    /* Get the selector field */\n    sfld = offset2ptr(*pval, adb-\u003eoffset);\n\n    /* Check if NULL */\n    if (*sfld == NULL) {\n        if (!adb-\u003enull_tt)\n            goto err;\n        return adb-\u003enull_tt;\n    }\n\n    /*\n     * Convert type to a long: NB: don't check for NID_undef here because it\n     * might be a legitimate value in the table\n     */\n    if (tt-\u003eflags \u0026 ASN1_TFLG_ADB_OID)\n        selector = OBJ_obj2nid((ASN1_OBJECT *)*sfld);\n    else\n        selector = ASN1_INTEGER_get((ASN1_INTEGER *)*sfld);\n\n    /* Let application callback translate value */\n    if (adb-\u003eadb_cb != NULL \u0026\u0026 adb-\u003eadb_cb(\u0026selector) == 0) {\n        ASN1err(ASN1_F_ASN1_DO_ADB, ASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE);\n        return NULL;\n    }\n\n    /*\n     * Try to find matching entry in table Maybe should check application\n     * types first to allow application override? Might also be useful to\n     * have a flag which indicates table is sorted and we can do a binary\n     * search. For now stick to a linear search.\n     */\n\n    for (atbl = adb-\u003etbl, i = 0; i \u003c adb-\u003etblcount; i++, atbl++)\n        if (atbl-\u003evalue == selector)\n            return \u0026atbl-\u003ett;\n\n    /* FIXME: need to search application table too */\n\n    /* No match, return default type */\n    if (!adb-\u003edefault_tt)\n        goto err;\n    return adb-\u003edefault_tt;\n\n err:\n    /* FIXME: should log the value or OID of unsupported type */\n    if (nullerr)\n        ASN1err(ASN1_F_ASN1_DO_ADB, ASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE);\n    return NULL;\n}","filepath":"crypto/asn1/tasn_utl.c","line_number":191,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270057280":{"score":0.86587906,"function_name":"asn1_do_lock","code":"int asn1_do_lock(ASN1_VALUE **pval, int op, const ASN1_ITEM *it)\n{\n    const ASN1_AUX *aux;\n    CRYPTO_REF_COUNT *lck;\n    CRYPTO_RWLOCK **lock;\n    int ret = -1;\n\n    if ((it-\u003eitype != ASN1_ITYPE_SEQUENCE)\n        \u0026\u0026 (it-\u003eitype != ASN1_ITYPE_NDEF_SEQUENCE))\n        return 0;\n    aux = it-\u003efuncs;\n    if (!aux || !(aux-\u003eflags \u0026 ASN1_AFLG_REFCOUNT))\n        return 0;\n    lck = offset2ptr(*pval, aux-\u003eref_offset);\n    lock = offset2ptr(*pval, aux-\u003eref_lock);\n\n    switch (op) {\n    case 0:\n        *lck = ret = 1;\n        *lock = CRYPTO_THREAD_lock_new();\n        if (*lock == NULL) {\n            ASN1err(ASN1_F_ASN1_DO_LOCK, ERR_R_MALLOC_FAILURE);\n            return -1;\n        }\n        break;\n    case 1:\n        if (!CRYPTO_UP_REF(lck, \u0026ret, *lock))\n            return -1;\n        break;\n    case -1:\n        if (!CRYPTO_DOWN_REF(lck, \u0026ret, *lock))\n            return -1;  /* failed */\n#ifdef REF_PRINT\n        fprintf(stderr, \"%p:%4d:%s\\n\", it, ret, it-\u003esname);\n#endif\n        REF_ASSERT_ISNT(ret \u003c 0);\n        if (ret == 0) {\n            CRYPTO_THREAD_lock_free(*lock);\n            *lock = NULL;\n        }\n        break;\n    }\n\n    return ret;\n}","filepath":"crypto/asn1/tasn_utl.c","line_number":58,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270057552":{"score":0.6762996,"function_name":"asn1_get_enc_ptr","code":"static ASN1_ENCODING *asn1_get_enc_ptr(ASN1_VALUE **pval, const ASN1_ITEM *it)\n{\n    const ASN1_AUX *aux;\n    if (!pval || !*pval)\n        return NULL;\n    aux = it-\u003efuncs;\n    if (!aux || !(aux-\u003eflags \u0026 ASN1_AFLG_ENCODING))\n        return NULL;\n    return offset2ptr(*pval, aux-\u003eenc_offset);\n}","filepath":"crypto/asn1/tasn_utl.c","line_number":104,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270057616":{"score":0.86420226,"function_name":"asn1_enc_restore","code":"int asn1_enc_restore(int *len, unsigned char **out, ASN1_VALUE **pval,\n                     const ASN1_ITEM *it)\n{\n    ASN1_ENCODING *enc;\n    enc = asn1_get_enc_ptr(pval, it);\n    if (!enc || enc-\u003emodified)\n        return 0;\n    if (out) {\n        memcpy(*out, enc-\u003eenc, enc-\u003elen);\n        *out += enc-\u003elen;\n    }\n    if (len)\n        *len = enc-\u003elen;\n    return 1;\n}","filepath":"crypto/asn1/tasn_utl.c","line_number":158,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270057728":{"score":0.67740333,"function_name":"asn1_enc_save","code":"int asn1_enc_save(ASN1_VALUE **pval, const unsigned char *in, int inlen,\n                  const ASN1_ITEM *it)\n{\n    ASN1_ENCODING *enc;\n    enc = asn1_get_enc_ptr(pval, it);\n    if (!enc)\n        return 1;\n\n    OPENSSL_free(enc-\u003eenc);\n    if ((enc-\u003eenc = OPENSSL_malloc(inlen)) == NULL) {\n        ASN1err(ASN1_F_ASN1_ENC_SAVE, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n    memcpy(enc-\u003eenc, in, inlen);\n    enc-\u003elen = inlen;\n    enc-\u003emodified = 0;\n\n    return 1;\n}","filepath":"crypto/asn1/tasn_utl.c","line_number":138,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270057952":{"score":0.8328634,"function_name":"asn1_set_choice_selector","code":"int asn1_set_choice_selector(ASN1_VALUE **pval, int value,\n                             const ASN1_ITEM *it)\n{\n    int *sel, ret;\n    sel = offset2ptr(*pval, it-\u003eutype);\n    ret = *sel;\n    *sel = value;\n    return ret;\n}","filepath":"crypto/asn1/tasn_utl.c","line_number":39,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270058400":{"score":0.94578433,"function_name":"generate_key","code":"static int generate_key(DH *dh)\n{\n    int ok = 0;\n    int generate_new_key = 0;\n    unsigned l;\n    BN_CTX *ctx = NULL;\n    BN_MONT_CTX *mont = NULL;\n    BIGNUM *pub_key = NULL, *priv_key = NULL;\n\n    if (BN_num_bits(dh-\u003ep) \u003e OPENSSL_DH_MAX_MODULUS_BITS) {\n        DHerr(DH_F_GENERATE_KEY, DH_R_MODULUS_TOO_LARGE);\n        return 0;\n    }\n\n    ctx = BN_CTX_new();\n    if (ctx == NULL)\n        goto err;\n\n    if (dh-\u003epriv_key == NULL) {\n        priv_key = BN_secure_new();\n        if (priv_key == NULL)\n            goto err;\n        generate_new_key = 1;\n    } else\n        priv_key = dh-\u003epriv_key;\n\n    if (dh-\u003epub_key == NULL) {\n        pub_key = BN_new();\n        if (pub_key == NULL)\n            goto err;\n    } else\n        pub_key = dh-\u003epub_key;\n\n    if (dh-\u003eflags \u0026 DH_FLAG_CACHE_MONT_P) {\n        mont = BN_MONT_CTX_set_locked(\u0026dh-\u003emethod_mont_p,\n                                      dh-\u003elock, dh-\u003ep, ctx);\n        if (!mont)\n            goto err;\n    }\n\n    if (generate_new_key) {\n        if (dh-\u003eq) {\n            do {\n                if (!BN_priv_rand_range(priv_key, dh-\u003eq))\n                    goto err;\n            }\n            while (BN_is_zero(priv_key) || BN_is_one(priv_key));\n        } else {\n            /* secret exponent length */\n            l = dh-\u003elength ? dh-\u003elength : BN_num_bits(dh-\u003ep) - 1;\n            if (!BN_priv_rand(priv_key, l, BN_RAND_TOP_ONE, BN_RAND_BOTTOM_ANY))\n                goto err;\n            /*\n             * We handle just one known case where g is a quadratic non-residue:\n             * for g = 2: p % 8 == 3\n             */\n            if (BN_is_word(dh-\u003eg, DH_GENERATOR_2) \u0026\u0026 !BN_is_bit_set(dh-\u003ep, 2)) {\n                /* clear bit 0, since it won't be a secret anyway */\n                if (!BN_clear_bit(priv_key, 0))\n                    goto err;\n            }\n        }\n    }\n\n    {\n        BIGNUM *prk = BN_new();\n\n        if (prk == NULL)\n            goto err;\n        BN_with_flags(prk, priv_key, BN_FLG_CONSTTIME);\n\n        if (!dh-\u003emeth-\u003ebn_mod_exp(dh, pub_key, dh-\u003eg, prk, dh-\u003ep, ctx, mont)) {\n            BN_clear_free(prk);\n            goto err;\n        }\n        /* We MUST free prk before any further use of priv_key */\n        BN_clear_free(prk);\n    }\n\n    dh-\u003epub_key = pub_key;\n    dh-\u003epriv_key = priv_key;\n    ok = 1;\n err:\n    if (ok != 1)\n        DHerr(DH_F_GENERATE_KEY, ERR_R_BN_LIB);\n\n    if (pub_key != dh-\u003epub_key)\n        BN_free(pub_key);\n    if (priv_key != dh-\u003epriv_key)\n        BN_free(priv_key);\n    BN_CTX_free(ctx);\n    return ok;\n}","filepath":"crypto/dh/dh_key.c","line_number":76,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270058896":{"score":0.9171121,"function_name":"compute_key","code":"static int compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh)\n{\n    BN_CTX *ctx = NULL;\n    BN_MONT_CTX *mont = NULL;\n    BIGNUM *tmp;\n    int ret = -1;\n    int check_result;\n\n    if (BN_num_bits(dh-\u003ep) \u003e OPENSSL_DH_MAX_MODULUS_BITS) {\n        DHerr(DH_F_COMPUTE_KEY, DH_R_MODULUS_TOO_LARGE);\n        goto err;\n    }\n\n    ctx = BN_CTX_new();\n    if (ctx == NULL)\n        goto err;\n    BN_CTX_start(ctx);\n    tmp = BN_CTX_get(ctx);\n    if (tmp == NULL)\n        goto err;\n\n    if (dh-\u003epriv_key == NULL) {\n        DHerr(DH_F_COMPUTE_KEY, DH_R_NO_PRIVATE_VALUE);\n        goto err;\n    }\n\n    if (dh-\u003eflags \u0026 DH_FLAG_CACHE_MONT_P) {\n        mont = BN_MONT_CTX_set_locked(\u0026dh-\u003emethod_mont_p,\n                                      dh-\u003elock, dh-\u003ep, ctx);\n        BN_set_flags(dh-\u003epriv_key, BN_FLG_CONSTTIME);\n        if (!mont)\n            goto err;\n    }\n\n    if (!DH_check_pub_key(dh, pub_key, \u0026check_result) || check_result) {\n        DHerr(DH_F_COMPUTE_KEY, DH_R_INVALID_PUBKEY);\n        goto err;\n    }\n\n    if (!dh-\u003e\n        meth-\u003ebn_mod_exp(dh, tmp, pub_key, dh-\u003epriv_key, dh-\u003ep, ctx, mont)) {\n        DHerr(DH_F_COMPUTE_KEY, ERR_R_BN_LIB);\n        goto err;\n    }\n\n    ret = BN_bn2bin(tmp, key);\n err:\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    return ret;\n}","filepath":"crypto/dh/dh_key.c","line_number":170,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270059312":{"score":0.8823303,"function_name":"DH_compute_key_padded","code":"int DH_compute_key_padded(unsigned char *key, const BIGNUM *pub_key, DH *dh)\n{\n    int rv, pad;\n    rv = dh-\u003emeth-\u003ecompute_key(key, pub_key, dh);\n    if (rv \u003c= 0)\n        return rv;\n    pad = BN_num_bytes(dh-\u003ep) - rv;\n    if (pad \u003e 0) {\n        memmove(key + pad, key, rv);\n        memset(key, 0, pad);\n    }\n    return rv + pad;\n}","filepath":"crypto/dh/dh_key.c","line_number":33,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270066464":{"score":0.8365807,"function_name":"sm2_compute_z_digest","code":"int sm2_compute_z_digest(uint8_t *out,\n                         const EVP_MD *digest,\n                         const uint8_t *id,\n                         const size_t id_len,\n                         const EC_KEY *key)\n{\n    int rc = 0;\n    const EC_GROUP *group = EC_KEY_get0_group(key);\n    BN_CTX *ctx = NULL;\n    EVP_MD_CTX *hash = NULL;\n    BIGNUM *p = NULL;\n    BIGNUM *a = NULL;\n    BIGNUM *b = NULL;\n    BIGNUM *xG = NULL;\n    BIGNUM *yG = NULL;\n    BIGNUM *xA = NULL;\n    BIGNUM *yA = NULL;\n    int p_bytes = 0;\n    uint8_t *buf = NULL;\n    uint16_t entl = 0;\n    uint8_t e_byte = 0;\n\n    hash = EVP_MD_CTX_new();\n    ctx = BN_CTX_new_ex(ec_key_get_libctx(key));\n    if (hash == NULL || ctx == NULL) {\n        ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);\n        goto done;\n    }\n\n    p = BN_CTX_get(ctx);\n    a = BN_CTX_get(ctx);\n    b = BN_CTX_get(ctx);\n    xG = BN_CTX_get(ctx);\n    yG = BN_CTX_get(ctx);\n    xA = BN_CTX_get(ctx);\n    yA = BN_CTX_get(ctx);\n\n    if (yA == NULL) {\n        ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);\n        goto done;\n    }\n\n    if (!EVP_DigestInit(hash, digest)) {\n        ERR_raise(ERR_LIB_SM2, ERR_R_EVP_LIB);\n        goto done;\n    }\n\n    /* Z = h(ENTL || ID || a || b || xG || yG || xA || yA) */\n\n    if (id_len \u003e= (UINT16_MAX / 8)) {\n        /* too large */\n        ERR_raise(ERR_LIB_SM2, SM2_R_ID_TOO_LARGE);\n        goto done;\n    }\n\n    entl = (uint16_t)(8 * id_len);\n\n    e_byte = entl \u003e\u003e 8;\n    if (!EVP_DigestUpdate(hash, \u0026e_byte, 1)) {\n        ERR_raise(ERR_LIB_SM2, ERR_R_EVP_LIB);\n        goto done;\n    }\n    e_byte = entl \u0026 0xFF;\n    if (!EVP_DigestUpdate(hash, \u0026e_byte, 1)) {\n        ERR_raise(ERR_LIB_SM2, ERR_R_EVP_LIB);\n        goto done;\n    }\n\n    if (id_len \u003e 0 \u0026\u0026 !EVP_DigestUpdate(hash, id, id_len)) {\n        ERR_raise(ERR_LIB_SM2, ERR_R_EVP_LIB);\n        goto done;\n    }\n\n    if (!EC_GROUP_get_curve(group, p, a, b, ctx)) {\n        ERR_raise(ERR_LIB_SM2, ERR_R_EC_LIB);\n        goto done;\n    }\n\n    p_bytes = BN_num_bytes(p);\n    buf = OPENSSL_zalloc(p_bytes);\n    if (buf == NULL) {\n        ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);\n        goto done;\n    }\n\n    if (BN_bn2binpad(a, buf, p_bytes) \u003c 0\n            || !EVP_DigestUpdate(hash, buf, p_bytes)\n            || BN_bn2binpad(b, buf, p_bytes) \u003c 0\n            || !EVP_DigestUpdate(hash, buf, p_bytes)\n            || !EC_POINT_get_affine_coordinates(group,\n                                                EC_GROUP_get0_generator(group),\n                                                xG, yG, ctx)\n            || BN_bn2binpad(xG, buf, p_bytes) \u003c 0\n            || !EVP_DigestUpdate(hash, buf, p_bytes)\n            || BN_bn2binpad(yG, buf, p_bytes) \u003c 0\n            || !EVP_DigestUpdate(hash, buf, p_bytes)\n            || !EC_POINT_get_affine_coordinates(group,\n                                                EC_KEY_get0_public_key(key),\n                                                xA, yA, ctx)\n            || BN_bn2binpad(xA, buf, p_bytes) \u003c 0\n            || !EVP_DigestUpdate(hash, buf, p_bytes)\n            || BN_bn2binpad(yA, buf, p_bytes) \u003c 0\n            || !EVP_DigestUpdate(hash, buf, p_bytes)\n            || !EVP_DigestFinal(hash, out, NULL)) {\n        ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);\n        goto done;\n    }\n\n    rc = 1;\n\n done:\n    OPENSSL_free(buf);\n    BN_CTX_free(ctx);\n    EVP_MD_CTX_free(hash);\n    return rc;\n}","filepath":"crypto/sm2/sm2_sign.c","line_number":24,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha11"},"270067328":{"score":0.8419685,"function_name":"sm2_sig_gen","code":"static ECDSA_SIG *sm2_sig_gen(const EC_KEY *key, const BIGNUM *e)\n{\n    const BIGNUM *dA = EC_KEY_get0_private_key(key);\n    const EC_GROUP *group = EC_KEY_get0_group(key);\n    const BIGNUM *order = EC_GROUP_get0_order(group);\n    ECDSA_SIG *sig = NULL;\n    EC_POINT *kG = NULL;\n    BN_CTX *ctx = NULL;\n    BIGNUM *k = NULL;\n    BIGNUM *rk = NULL;\n    BIGNUM *r = NULL;\n    BIGNUM *s = NULL;\n    BIGNUM *x1 = NULL;\n    BIGNUM *tmp = NULL;\n    OSSL_LIB_CTX *libctx = ec_key_get_libctx(key);\n\n    kG = EC_POINT_new(group);\n    ctx = BN_CTX_new_ex(libctx);\n    if (kG == NULL || ctx == NULL) {\n        ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);\n        goto done;\n    }\n\n    BN_CTX_start(ctx);\n    k = BN_CTX_get(ctx);\n    rk = BN_CTX_get(ctx);\n    x1 = BN_CTX_get(ctx);\n    tmp = BN_CTX_get(ctx);\n    if (tmp == NULL) {\n        ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);\n        goto done;\n    }\n\n    /*\n     * These values are returned and so should not be allocated out of the\n     * context\n     */\n    r = BN_new();\n    s = BN_new();\n\n    if (r == NULL || s == NULL) {\n        ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);\n        goto done;\n    }\n\n    for (;;) {\n        if (!BN_priv_rand_range_ex(k, order, ctx)) {\n            ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);\n            goto done;\n        }\n\n        if (!EC_POINT_mul(group, kG, k, NULL, NULL, ctx)\n                || !EC_POINT_get_affine_coordinates(group, kG, x1, NULL,\n                                                    ctx)\n                || !BN_mod_add(r, e, x1, order, ctx)) {\n            ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);\n            goto done;\n        }\n\n        /* try again if r == 0 or r+k == n */\n        if (BN_is_zero(r))\n            continue;\n\n        if (!BN_add(rk, r, k)) {\n            ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);\n            goto done;\n        }\n\n        if (BN_cmp(rk, order) == 0)\n            continue;\n\n        if (!BN_add(s, dA, BN_value_one())\n                || !ec_group_do_inverse_ord(group, s, s, ctx)\n                || !BN_mod_mul(tmp, dA, r, order, ctx)\n                || !BN_sub(tmp, k, tmp)\n                || !BN_mod_mul(s, s, tmp, order, ctx)) {\n            ERR_raise(ERR_LIB_SM2, ERR_R_BN_LIB);\n            goto done;\n        }\n\n        sig = ECDSA_SIG_new();\n        if (sig == NULL) {\n            ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);\n            goto done;\n        }\n\n         /* takes ownership of r and s */\n        ECDSA_SIG_set0(sig, r, s);\n        break;\n    }\n\n done:\n    if (sig == NULL) {\n        BN_free(r);\n        BN_free(s);\n    }\n\n    BN_CTX_free(ctx);\n    EC_POINT_free(kG);\n    return sig;\n}","filepath":"crypto/sm2/sm2_sign.c","line_number":197,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha11"},"270067968":{"score":0.82286465,"function_name":"sm2_sig_verify","code":"static int sm2_sig_verify(const EC_KEY *key, const ECDSA_SIG *sig,\n                          const BIGNUM *e)\n{\n    int ret = 0;\n    const EC_GROUP *group = EC_KEY_get0_group(key);\n    const BIGNUM *order = EC_GROUP_get0_order(group);\n    BN_CTX *ctx = NULL;\n    EC_POINT *pt = NULL;\n    BIGNUM *t = NULL;\n    BIGNUM *x1 = NULL;\n    const BIGNUM *r = NULL;\n    const BIGNUM *s = NULL;\n    OSSL_LIB_CTX *libctx = ec_key_get_libctx(key);\n\n    ctx = BN_CTX_new_ex(libctx);\n    pt = EC_POINT_new(group);\n    if (ctx == NULL || pt == NULL) {\n        ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);\n        goto done;\n    }\n\n    BN_CTX_start(ctx);\n    t = BN_CTX_get(ctx);\n    x1 = BN_CTX_get(ctx);\n    if (x1 == NULL) {\n        ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);\n        goto done;\n    }\n\n    /*\n     * B1: verify whether r' in [1,n-1], verification failed if not\n     * B2: verify whether s' in [1,n-1], verification failed if not\n     * B3: set M'~=ZA || M'\n     * B4: calculate e'=Hv(M'~)\n     * B5: calculate t = (r' + s') modn, verification failed if t=0\n     * B6: calculate the point (x1', y1')=[s']G + [t]PA\n     * B7: calculate R=(e'+x1') modn, verification pass if yes, otherwise failed\n     */\n\n    ECDSA_SIG_get0(sig, \u0026r, \u0026s);\n\n    if (BN_cmp(r, BN_value_one()) \u003c 0\n            || BN_cmp(s, BN_value_one()) \u003c 0\n            || BN_cmp(order, r) \u003c= 0\n            || BN_cmp(order, s) \u003c= 0) {\n        ERR_raise(ERR_LIB_SM2, SM2_R_BAD_SIGNATURE);\n        goto done;\n    }\n\n    if (!BN_mod_add(t, r, s, order, ctx)) {\n        ERR_raise(ERR_LIB_SM2, ERR_R_BN_LIB);\n        goto done;\n    }\n\n    if (BN_is_zero(t)) {\n        ERR_raise(ERR_LIB_SM2, SM2_R_BAD_SIGNATURE);\n        goto done;\n    }\n\n    if (!EC_POINT_mul(group, pt, s, EC_KEY_get0_public_key(key), t, ctx)\n            || !EC_POINT_get_affine_coordinates(group, pt, x1, NULL, ctx)) {\n        ERR_raise(ERR_LIB_SM2, ERR_R_EC_LIB);\n        goto done;\n    }\n\n    if (!BN_mod_add(t, e, x1, order, ctx)) {\n        ERR_raise(ERR_LIB_SM2, ERR_R_BN_LIB);\n        goto done;\n    }\n\n    if (BN_cmp(r, t) == 0)\n        ret = 1;\n\n done:\n    EC_POINT_free(pt);\n    BN_CTX_free(ctx);\n    return ret;\n}","filepath":"crypto/sm2/sm2_sign.c","line_number":299,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha11"},"270068496":{"score":0.88179034,"function_name":"sm2_internal_sign","code":"int sm2_internal_sign(const unsigned char *dgst, int dgstlen,\n                      unsigned char *sig, unsigned int *siglen, EC_KEY *eckey)\n{\n    BIGNUM *e = NULL;\n    ECDSA_SIG *s = NULL;\n    int sigleni;\n    int ret = -1;\n\n    e = BN_bin2bn(dgst, dgstlen, NULL);\n    if (e == NULL) {\n       ERR_raise(ERR_LIB_SM2, ERR_R_BN_LIB);\n       goto done;\n    }\n\n    s = sm2_sig_gen(eckey, e);\n    if (s == NULL) {\n        ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);\n        goto done;\n    }\n\n    sigleni = i2d_ECDSA_SIG(s, \u0026sig);\n    if (sigleni \u003c 0) {\n       ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);\n       goto done;\n    }\n    *siglen = (unsigned int)sigleni;\n\n    ret = 1;\n\n done:\n    ECDSA_SIG_free(s);\n    BN_free(e);\n    return ret;\n}","filepath":"crypto/sm2/sm2_sign.c","line_number":423,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha11"},"270068656":{"score":0.8218394,"function_name":"sm2_internal_verify","code":"int sm2_internal_verify(const unsigned char *dgst, int dgstlen,\n                        const unsigned char *sig, int sig_len, EC_KEY *eckey)\n{\n    ECDSA_SIG *s = NULL;\n    BIGNUM *e = NULL;\n    const unsigned char *p = sig;\n    unsigned char *der = NULL;\n    int derlen = -1;\n    int ret = -1;\n\n    s = ECDSA_SIG_new();\n    if (s == NULL) {\n        ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);\n        goto done;\n    }\n    if (d2i_ECDSA_SIG(\u0026s, \u0026p, sig_len) == NULL) {\n        ERR_raise(ERR_LIB_SM2, SM2_R_INVALID_ENCODING);\n        goto done;\n    }\n    /* Ensure signature uses DER and doesn't have trailing garbage */\n    derlen = i2d_ECDSA_SIG(s, \u0026der);\n    if (derlen != sig_len || memcmp(sig, der, derlen) != 0) {\n        ERR_raise(ERR_LIB_SM2, SM2_R_INVALID_ENCODING);\n        goto done;\n    }\n\n    e = BN_bin2bn(dgst, dgstlen, NULL);\n    if (e == NULL) {\n        ERR_raise(ERR_LIB_SM2, ERR_R_BN_LIB);\n        goto done;\n    }\n\n    ret = sm2_sig_verify(eckey, s, e);\n\n done:\n    OPENSSL_free(der);\n    BN_free(e);\n    ECDSA_SIG_free(s);\n    return ret;\n}","filepath":"crypto/sm2/sm2_sign.c","line_number":458,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha11"},"270072848":{"score":0.71831167,"function_name":"EVP_DigestSignFinal","code":"int EVP_DigestSignFinal(EVP_MD_CTX *ctx, unsigned char *sigret,\n                        size_t *siglen)\n{\n    int sctx = 0, r = 0;\n    EVP_PKEY_CTX *pctx = ctx-\u003epctx;\n    if (pctx-\u003epmeth-\u003eflags \u0026 EVP_PKEY_FLAG_SIGCTX_CUSTOM) {\n        if (!sigret)\n            return pctx-\u003epmeth-\u003esignctx(pctx, sigret, siglen, ctx);\n        if (ctx-\u003eflags \u0026 EVP_MD_CTX_FLAG_FINALISE)\n            r = pctx-\u003epmeth-\u003esignctx(pctx, sigret, siglen, ctx);\n        else {\n            EVP_PKEY_CTX *dctx = EVP_PKEY_CTX_dup(ctx-\u003epctx);\n            if (!dctx)\n                return 0;\n            r = dctx-\u003epmeth-\u003esignctx(dctx, sigret, siglen, ctx);\n            EVP_PKEY_CTX_free(dctx);\n        }\n        return r;\n    }\n    if (pctx-\u003epmeth-\u003esignctx)\n        sctx = 1;\n    else\n        sctx = 0;\n    if (sigret) {\n        unsigned char md[EVP_MAX_MD_SIZE];\n        unsigned int mdlen = 0;\n        if (ctx-\u003eflags \u0026 EVP_MD_CTX_FLAG_FINALISE) {\n            if (sctx)\n                r = ctx-\u003epctx-\u003epmeth-\u003esignctx(ctx-\u003epctx, sigret, siglen, ctx);\n            else\n                r = EVP_DigestFinal_ex(ctx, md, \u0026mdlen);\n        } else {\n            EVP_MD_CTX *tmp_ctx = EVP_MD_CTX_new();\n            if (tmp_ctx == NULL || !EVP_MD_CTX_copy_ex(tmp_ctx, ctx))\n                return 0;\n            if (sctx)\n                r = tmp_ctx-\u003epctx-\u003epmeth-\u003esignctx(tmp_ctx-\u003epctx,\n                                                  sigret, siglen, tmp_ctx);\n            else\n                r = EVP_DigestFinal_ex(tmp_ctx, md, \u0026mdlen);\n            EVP_MD_CTX_free(tmp_ctx);\n        }\n        if (sctx || !r)\n            return r;\n        if (EVP_PKEY_sign(ctx-\u003epctx, sigret, siglen, md, mdlen) \u003c= 0)\n            return 0;\n    } else {\n        if (sctx) {\n            if (pctx-\u003epmeth-\u003esignctx(pctx, sigret, siglen, ctx) \u003c= 0)\n                return 0;\n        } else {\n            int s = EVP_MD_size(ctx-\u003edigest);\n            if (s \u003c 0 || EVP_PKEY_sign(pctx, sigret, siglen, NULL, s) \u003c= 0)\n                return 0;\n        }\n    }\n    return 1;\n}","filepath":"crypto/evp/m_sigver.c","line_number":79,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre6"},"270073408":{"score":0.62539196,"function_name":"EVP_DigestVerifyFinal","code":"int EVP_DigestVerifyFinal(EVP_MD_CTX *ctx, const unsigned char *sig,\n                          size_t siglen)\n{\n    unsigned char md[EVP_MAX_MD_SIZE];\n    int r = 0;\n    unsigned int mdlen = 0;\n    int vctx = 0;\n\n    if (ctx-\u003epctx-\u003epmeth-\u003everifyctx)\n        vctx = 1;\n    else\n        vctx = 0;\n    if (ctx-\u003eflags \u0026 EVP_MD_CTX_FLAG_FINALISE) {\n        if (vctx) {\n            r = ctx-\u003epctx-\u003epmeth-\u003everifyctx(ctx-\u003epctx, sig, siglen, ctx);\n        } else\n            r = EVP_DigestFinal_ex(ctx, md, \u0026mdlen);\n    } else {\n        EVP_MD_CTX *tmp_ctx = EVP_MD_CTX_new();\n        if (tmp_ctx == NULL || !EVP_MD_CTX_copy_ex(tmp_ctx, ctx))\n            return -1;\n        if (vctx) {\n            r = tmp_ctx-\u003epctx-\u003epmeth-\u003everifyctx(tmp_ctx-\u003epctx,\n                                                sig, siglen, tmp_ctx);\n        } else\n            r = EVP_DigestFinal_ex(tmp_ctx, md, \u0026mdlen);\n        EVP_MD_CTX_free(tmp_ctx);\n    }\n    if (vctx || !r)\n        return r;\n    return EVP_PKEY_verify(ctx-\u003epctx, sig, siglen, md, mdlen);\n}","filepath":"crypto/evp/m_sigver.c","line_number":138,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre6"},"270073808":{"score":0.89644897,"function_name":"do_sigver_init","code":"static int do_sigver_init(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,\n                          const EVP_MD *type, ENGINE *e, EVP_PKEY *pkey,\n                          int ver)\n{\n    if (ctx-\u003epctx == NULL)\n        ctx-\u003epctx = EVP_PKEY_CTX_new(pkey, e);\n    if (ctx-\u003epctx == NULL)\n        return 0;\n\n    if (!(ctx-\u003epctx-\u003epmeth-\u003eflags \u0026 EVP_PKEY_FLAG_SIGCTX_CUSTOM)) {\n\n        if (type == NULL) {\n            int def_nid;\n            if (EVP_PKEY_get_default_digest_nid(pkey, \u0026def_nid) \u003e 0)\n                type = EVP_get_digestbynid(def_nid);\n        }\n\n        if (type == NULL) {\n            EVPerr(EVP_F_DO_SIGVER_INIT, EVP_R_NO_DEFAULT_DIGEST);\n            return 0;\n        }\n    }\n\n    if (ver) {\n        if (ctx-\u003epctx-\u003epmeth-\u003everifyctx_init) {\n            if (ctx-\u003epctx-\u003epmeth-\u003everifyctx_init(ctx-\u003epctx, ctx) \u003c= 0)\n                return 0;\n            ctx-\u003epctx-\u003eoperation = EVP_PKEY_OP_VERIFYCTX;\n        } else if (EVP_PKEY_verify_init(ctx-\u003epctx) \u003c= 0)\n            return 0;\n    } else {\n        if (ctx-\u003epctx-\u003epmeth-\u003esignctx_init) {\n            if (ctx-\u003epctx-\u003epmeth-\u003esignctx_init(ctx-\u003epctx, ctx) \u003c= 0)\n                return 0;\n            ctx-\u003epctx-\u003eoperation = EVP_PKEY_OP_SIGNCTX;\n        } else if (EVP_PKEY_sign_init(ctx-\u003epctx) \u003c= 0)\n            return 0;\n    }\n    if (EVP_PKEY_CTX_set_signature_md(ctx-\u003epctx, type) \u003c= 0)\n        return 0;\n    if (pctx)\n        *pctx = ctx-\u003epctx;\n    if (ctx-\u003epctx-\u003epmeth-\u003eflags \u0026 EVP_PKEY_FLAG_SIGCTX_CUSTOM)\n        return 1;\n    if (!EVP_DigestInit_ex(ctx, type, e))\n        return 0;\n    return 1;\n}","filepath":"crypto/evp/m_sigver.c","line_number":18,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre6"},"270074528":{"score":0.7498997,"function_name":"ED25519_public_from_private","code":"void ED25519_public_from_private(uint8_t out_public_key[32],\n                                 const uint8_t private_key[32])\n{\n    uint8_t az[SHA512_DIGEST_LENGTH];\n    ge_p3 A;\n\n    SHA512(private_key, 32, az);\n\n    az[0] \u0026= 248;\n    az[31] \u0026= 63;\n    az[31] |= 64;\n\n    ge_scalarmult_base(\u0026A, az);\n    ge_p3_tobytes(out_public_key, \u0026A);\n\n    OPENSSL_cleanse(az, sizeof(az));\n}","filepath":"libs-ext/openssl/crypto/ec/curve25519.c","line_number":5544,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"270074688":{"score":0.6865356,"function_name":"ED25519_sign","code":"int ED25519_sign(uint8_t *out_sig, const uint8_t *message, size_t message_len,\n                 const uint8_t public_key[32], const uint8_t private_key[32])\n{\n    uint8_t az[SHA512_DIGEST_LENGTH];\n    uint8_t nonce[SHA512_DIGEST_LENGTH];\n    ge_p3 R;\n    uint8_t hram[SHA512_DIGEST_LENGTH];\n    SHA512_CTX hash_ctx;\n\n    SHA512_Init(\u0026hash_ctx);\n    SHA512_Update(\u0026hash_ctx, private_key, 32);\n    SHA512_Final(az, \u0026hash_ctx);\n\n    az[0] \u0026= 248;\n    az[31] \u0026= 63;\n    az[31] |= 64;\n\n    SHA512_Init(\u0026hash_ctx);\n    SHA512_Update(\u0026hash_ctx, az + 32, 32);\n    SHA512_Update(\u0026hash_ctx, message, message_len);\n    SHA512_Final(nonce, \u0026hash_ctx);\n\n    x25519_sc_reduce(nonce);\n    ge_scalarmult_base(\u0026R, nonce);\n    ge_p3_tobytes(out_sig, \u0026R);\n\n    SHA512_Init(\u0026hash_ctx);\n    SHA512_Update(\u0026hash_ctx, out_sig, 32);\n    SHA512_Update(\u0026hash_ctx, public_key, 32);\n    SHA512_Update(\u0026hash_ctx, message, message_len);\n    SHA512_Final(hram, \u0026hash_ctx);\n\n    x25519_sc_reduce(hram);\n    sc_muladd(out_sig + 32, hram, az, nonce);\n\n    OPENSSL_cleanse(\u0026hash_ctx, sizeof(hash_ctx));\n    OPENSSL_cleanse(nonce, sizeof(nonce));\n    OPENSSL_cleanse(az, sizeof(az));\n\n    return 1;\n}","filepath":"libs-ext/openssl/crypto/ec/curve25519.c","line_number":5432,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"270075136":{"score":0.7363952,"function_name":"ED25519_verify","code":"int ED25519_verify(const uint8_t *message, size_t message_len,\n                   const uint8_t signature[64], const uint8_t public_key[32])\n{\n    int i;\n    ge_p3 A;\n    const uint8_t *r, *s;\n    SHA512_CTX hash_ctx;\n    ge_p2 R;\n    uint8_t rcheck[32];\n    uint8_t h[SHA512_DIGEST_LENGTH];\n    /* 27742317777372353535851937790883648493 in little endian format */\n    const uint8_t l_low[16] = {\n        0xED, 0xD3, 0xF5, 0x5C, 0x1A, 0x63, 0x12, 0x58, 0xD6, 0x9C, 0xF7, 0xA2,\n        0xDE, 0xF9, 0xDE, 0x14\n    };\n\n    r = signature;\n    s = signature + 32;\n\n    /*\n     * Check 0 \u003c= s \u003c L where L = 2^252 + 27742317777372353535851937790883648493\n     *\n     * If not the signature is publicly invalid. Since it's public we can do the\n     * check in variable time.\n     *\n     * First check the most significant byte\n     */\n    if (s[31] \u003e 0x10)\n        return 0;\n    if (s[31] == 0x10) {\n        /*\n         * Most significant byte indicates a value close to 2^252 so check the\n         * rest\n         */\n        if (memcmp(s + 16, allzeroes, sizeof(allzeroes)) != 0)\n            return 0;\n        for (i = 15; i \u003e= 0; i--) {\n            if (s[i] \u003c l_low[i])\n                break;\n            if (s[i] \u003e l_low[i])\n                return 0;\n        }\n        if (i \u003c 0)\n            return 0;\n    }\n\n    if (ge_frombytes_vartime(\u0026A, public_key) != 0) {\n        return 0;\n    }\n\n    fe_neg(A.X, A.X);\n    fe_neg(A.T, A.T);\n\n    SHA512_Init(\u0026hash_ctx);\n    SHA512_Update(\u0026hash_ctx, r, 32);\n    SHA512_Update(\u0026hash_ctx, public_key, 32);\n    SHA512_Update(\u0026hash_ctx, message, message_len);\n    SHA512_Final(h, \u0026hash_ctx);\n\n    x25519_sc_reduce(h);\n\n    ge_double_scalarmult_vartime(\u0026R, h, \u0026A, s);\n\n    ge_tobytes(rcheck, \u0026R);\n\n    return CRYPTO_memcmp(rcheck, r, sizeof(rcheck)) == 0;\n}","filepath":"libs-ext/openssl/crypto/ec/curve25519.c","line_number":5476,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"270075760":{"score":0.7862078,"function_name":"X25519_public_from_private","code":"void X25519_public_from_private(uint8_t out_public_value[32],\n                                const uint8_t private_key[32])\n{\n    uint8_t e[32];\n    ge_p3 A;\n    fe zplusy, zminusy, zminusy_inv;\n\n    memcpy(e, private_key, 32);\n    e[0] \u0026= 248;\n    e[31] \u0026= 127;\n    e[31] |= 64;\n\n    ge_scalarmult_base(\u0026A, e);\n\n    /*\n     * We only need the u-coordinate of the curve25519 point.\n     * The map is u=(y+1)/(1-y). Since y=Y/Z, this gives\n     * u=(Z+Y)/(Z-Y).\n     */\n    fe_add(zplusy, A.Z, A.Y);\n    fe_sub(zminusy, A.Z, A.Y);\n    fe_invert(zminusy_inv, zminusy);\n    fe_mul(zplusy, zplusy, zminusy_inv);\n    fe_tobytes(out_public_value, zplusy);\n\n    OPENSSL_cleanse(e, sizeof(e));\n}","filepath":"libs-ext/openssl/crypto/ec/curve25519.c","line_number":5571,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"270076272":{"score":0.8639239,"function_name":"fe_cmov","code":"static void fe_cmov(fe f, const fe g, unsigned b)\n{\n    size_t i;\n\n    b = 0-b;\n    for (i = 0; i \u003c 10; i++) {\n        int32_t x = f[i] ^ g[i];\n        x \u0026= b;\n        f[i] ^= x;\n    }\n}","filepath":"libs-ext/openssl/crypto/ec/curve25519.c","line_number":1517,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"270076400":{"score":0.8640276,"function_name":"fe_cswap","code":"static void fe_cswap(fe f, fe g, unsigned int b)\n{\n    size_t i;\n\n    b = 0-b;\n    for (i = 0; i \u003c 10; i++) {\n        int32_t x = f[i] ^ g[i];\n        x \u0026= b;\n        f[i] ^= x;\n        g[i] ^= x;\n    }\n}","filepath":"libs-ext/openssl/crypto/ec/curve25519.c","line_number":4286,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"270076608":{"score":0.8524128,"function_name":"fe_frombytes","code":"static void fe_frombytes(fe h, const uint8_t *s)\n{\n    /* Ignores top bit of h. */\n    int64_t h0 =  load_4(s);\n    int64_t h1 =  load_3(s +  4) \u003c\u003c 6;\n    int64_t h2 =  load_3(s +  7) \u003c\u003c 5;\n    int64_t h3 =  load_3(s + 10) \u003c\u003c 3;\n    int64_t h4 =  load_3(s + 13) \u003c\u003c 2;\n    int64_t h5 =  load_4(s + 16);\n    int64_t h6 =  load_3(s + 20) \u003c\u003c 7;\n    int64_t h7 =  load_3(s + 23) \u003c\u003c 5;\n    int64_t h8 =  load_3(s + 26) \u003c\u003c 4;\n    int64_t h9 = (load_3(s + 29) \u0026 0x7fffff) \u003c\u003c 2;\n    int64_t carry0;\n    int64_t carry1;\n    int64_t carry2;\n    int64_t carry3;\n    int64_t carry4;\n    int64_t carry5;\n    int64_t carry6;\n    int64_t carry7;\n    int64_t carry8;\n    int64_t carry9;\n\n    carry9 = h9 + (1 \u003c\u003c 24); h0 += (carry9 \u003e\u003e 25) * 19; h9 -= carry9 \u0026 kTop39Bits;\n    carry1 = h1 + (1 \u003c\u003c 24); h2 += carry1 \u003e\u003e 25; h1 -= carry1 \u0026 kTop39Bits;\n    carry3 = h3 + (1 \u003c\u003c 24); h4 += carry3 \u003e\u003e 25; h3 -= carry3 \u0026 kTop39Bits;\n    carry5 = h5 + (1 \u003c\u003c 24); h6 += carry5 \u003e\u003e 25; h5 -= carry5 \u0026 kTop39Bits;\n    carry7 = h7 + (1 \u003c\u003c 24); h8 += carry7 \u003e\u003e 25; h7 -= carry7 \u0026 kTop39Bits;\n\n    carry0 = h0 + (1 \u003c\u003c 25); h1 += carry0 \u003e\u003e 26; h0 -= carry0 \u0026 kTop38Bits;\n    carry2 = h2 + (1 \u003c\u003c 25); h3 += carry2 \u003e\u003e 26; h2 -= carry2 \u0026 kTop38Bits;\n    carry4 = h4 + (1 \u003c\u003c 25); h5 += carry4 \u003e\u003e 26; h4 -= carry4 \u0026 kTop38Bits;\n    carry6 = h6 + (1 \u003c\u003c 25); h7 += carry6 \u003e\u003e 26; h6 -= carry6 \u0026 kTop38Bits;\n    carry8 = h8 + (1 \u003c\u003c 25); h9 += carry8 \u003e\u003e 26; h8 -= carry8 \u0026 kTop38Bits;\n\n    h[0] = (int32_t)h0;\n    h[1] = (int32_t)h1;\n    h[2] = (int32_t)h2;\n    h[3] = (int32_t)h3;\n    h[4] = (int32_t)h4;\n    h[5] = (int32_t)h5;\n    h[6] = (int32_t)h6;\n    h[7] = (int32_t)h7;\n    h[8] = (int32_t)h8;\n    h[9] = (int32_t)h9;\n}","filepath":"libs-ext/openssl/crypto/ec/curve25519.c","line_number":790,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"270077696":{"score":0.7354506,"function_name":"fe_invert","code":"static void fe_invert(fe out, const fe z)\n{\n    fe t0;\n    fe t1;\n    fe t2;\n    fe t3;\n    int i;\n\n    /*\n     * Compute z ** -1 = z ** (2 ** 255 - 19 - 2) with the exponent as\n     * 2 ** 255 - 21 = (2 ** 5) * (2 ** 250 - 1) + 11.\n     */\n\n    /* t0 = z ** 2 */\n    fe_sq(t0, z);\n\n    /* t1 = t0 ** (2 ** 2) = z ** 8 */\n    fe_sq(t1, t0);\n    fe_sq(t1, t1);\n\n    /* t1 = z * t1 = z ** 9 */\n    fe_mul(t1, z, t1);\n    /* t0 = t0 * t1 = z ** 11 -- stash t0 away for the end. */\n    fe_mul(t0, t0, t1);\n\n    /* t2 = t0 ** 2 = z ** 22 */\n    fe_sq(t2, t0);\n\n    /* t1 = t1 * t2 = z ** (2 ** 5 - 1) */\n    fe_mul(t1, t1, t2);\n\n    /* t2 = t1 ** (2 ** 5) = z ** ((2 ** 5) * (2 ** 5 - 1)) */\n    fe_sq(t2, t1);\n    for (i = 1; i \u003c 5; ++i) {\n        fe_sq(t2, t2);\n    }\n\n    /* t1 = t1 * t2 = z ** ((2 ** 5 + 1) * (2 ** 5 - 1)) = z ** (2 ** 10 - 1) */\n    fe_mul(t1, t2, t1);\n\n    /* Continuing similarly... */\n\n    /* t2 = z ** (2 ** 20 - 1) */\n    fe_sq(t2, t1);\n    for (i = 1; i \u003c 10; ++i) {\n        fe_sq(t2, t2);\n    }\n    fe_mul(t2, t2, t1);\n\n    /* t2 = z ** (2 ** 40 - 1) */\n    fe_sq(t3, t2);\n    for (i = 1; i \u003c 20; ++i) {\n        fe_sq(t3, t3);\n    }\n    fe_mul(t2, t3, t2);\n\n    /* t2 = z ** (2 ** 10) * (2 ** 40 - 1) */\n    for (i = 0; i \u003c 10; ++i) {\n        fe_sq(t2, t2);\n    }\n    /* t1 = z ** (2 ** 50 - 1) */\n    fe_mul(t1, t2, t1);\n\n    /* t2 = z ** (2 ** 100 - 1) */\n    fe_sq(t2, t1);\n    for (i = 1; i \u003c 50; ++i) {\n        fe_sq(t2, t2);\n    }\n    fe_mul(t2, t2, t1);\n\n    /* t2 = z ** (2 ** 200 - 1) */\n    fe_sq(t3, t2);\n    for (i = 1; i \u003c 100; ++i) {\n        fe_sq(t3, t3);\n    }\n    fe_mul(t2, t3, t2);\n\n    /* t2 = z ** ((2 ** 50) * (2 ** 200 - 1) */\n    fe_sq(t2, t2);\n    for (i = 1; i \u003c 50; ++i) {\n        fe_sq(t2, t2);\n    }\n\n    /* t1 = z ** (2 ** 250 - 1) */\n    fe_mul(t1, t2, t1);\n\n    /* t1 = z ** ((2 ** 5) * (2 ** 250 - 1)) */\n    fe_sq(t1, t1);\n    for (i = 1; i \u003c 5; ++i) {\n        fe_sq(t1, t1);\n    }\n\n    /* Recall t0 = z ** 11; out = z ** (2 ** 255 - 21) */\n    fe_mul(out, t1, t0);\n}","filepath":"libs-ext/openssl/crypto/ec/curve25519.c","line_number":1397,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"270078336":{"score":0.8648093,"function_name":"fe_mul","code":"static void fe_mul(fe h, const fe f, const fe g)\n{\n    int32_t f0 = f[0];\n    int32_t f1 = f[1];\n    int32_t f2 = f[2];\n    int32_t f3 = f[3];\n    int32_t f4 = f[4];\n    int32_t f5 = f[5];\n    int32_t f6 = f[6];\n    int32_t f7 = f[7];\n    int32_t f8 = f[8];\n    int32_t f9 = f[9];\n    int32_t g0 = g[0];\n    int32_t g1 = g[1];\n    int32_t g2 = g[2];\n    int32_t g3 = g[3];\n    int32_t g4 = g[4];\n    int32_t g5 = g[5];\n    int32_t g6 = g[6];\n    int32_t g7 = g[7];\n    int32_t g8 = g[8];\n    int32_t g9 = g[9];\n    int32_t g1_19 = 19 * g1; /* 1.959375*2^29 */\n    int32_t g2_19 = 19 * g2; /* 1.959375*2^30; still ok */\n    int32_t g3_19 = 19 * g3;\n    int32_t g4_19 = 19 * g4;\n    int32_t g5_19 = 19 * g5;\n    int32_t g6_19 = 19 * g6;\n    int32_t g7_19 = 19 * g7;\n    int32_t g8_19 = 19 * g8;\n    int32_t g9_19 = 19 * g9;\n    int32_t f1_2 = 2 * f1;\n    int32_t f3_2 = 2 * f3;\n    int32_t f5_2 = 2 * f5;\n    int32_t f7_2 = 2 * f7;\n    int32_t f9_2 = 2 * f9;\n    int64_t f0g0    = f0   * (int64_t) g0;\n    int64_t f0g1    = f0   * (int64_t) g1;\n    int64_t f0g2    = f0   * (int64_t) g2;\n    int64_t f0g3    = f0   * (int64_t) g3;\n    int64_t f0g4    = f0   * (int64_t) g4;\n    int64_t f0g5    = f0   * (int64_t) g5;\n    int64_t f0g6    = f0   * (int64_t) g6;\n    int64_t f0g7    = f0   * (int64_t) g7;\n    int64_t f0g8    = f0   * (int64_t) g8;\n    int64_t f0g9    = f0   * (int64_t) g9;\n    int64_t f1g0    = f1   * (int64_t) g0;\n    int64_t f1g1_2  = f1_2 * (int64_t) g1;\n    int64_t f1g2    = f1   * (int64_t) g2;\n    int64_t f1g3_2  = f1_2 * (int64_t) g3;\n    int64_t f1g4    = f1   * (int64_t) g4;\n    int64_t f1g5_2  = f1_2 * (int64_t) g5;\n    int64_t f1g6    = f1   * (int64_t) g6;\n    int64_t f1g7_2  = f1_2 * (int64_t) g7;\n    int64_t f1g8    = f1   * (int64_t) g8;\n    int64_t f1g9_38 = f1_2 * (int64_t) g9_19;\n    int64_t f2g0    = f2   * (int64_t) g0;\n    int64_t f2g1    = f2   * (int64_t) g1;\n    int64_t f2g2    = f2   * (int64_t) g2;\n    int64_t f2g3    = f2   * (int64_t) g3;\n    int64_t f2g4    = f2   * (int64_t) g4;\n    int64_t f2g5    = f2   * (int64_t) g5;\n    int64_t f2g6    = f2   * (int64_t) g6;\n    int64_t f2g7    = f2   * (int64_t) g7;\n    int64_t f2g8_19 = f2   * (int64_t) g8_19;\n    int64_t f2g9_19 = f2   * (int64_t) g9_19;\n    int64_t f3g0    = f3   * (int64_t) g0;\n    int64_t f3g1_2  = f3_2 * (int64_t) g1;\n    int64_t f3g2    = f3   * (int64_t) g2;\n    int64_t f3g3_2  = f3_2 * (int64_t) g3;\n    int64_t f3g4    = f3   * (int64_t) g4;\n    int64_t f3g5_2  = f3_2 * (int64_t) g5;\n    int64_t f3g6    = f3   * (int64_t) g6;\n    int64_t f3g7_38 = f3_2 * (int64_t) g7_19;\n    int64_t f3g8_19 = f3   * (int64_t) g8_19;\n    int64_t f3g9_38 = f3_2 * (int64_t) g9_19;\n    int64_t f4g0    = f4   * (int64_t) g0;\n    int64_t f4g1    = f4   * (int64_t) g1;\n    int64_t f4g2    = f4   * (int64_t) g2;\n    int64_t f4g3    = f4   * (int64_t) g3;\n    int64_t f4g4    = f4   * (int64_t) g4;\n    int64_t f4g5    = f4   * (int64_t) g5;\n    int64_t f4g6_19 = f4   * (int64_t) g6_19;\n    int64_t f4g7_19 = f4   * (int64_t) g7_19;\n    int64_t f4g8_19 = f4   * (int64_t) g8_19;\n    int64_t f4g9_19 = f4   * (int64_t) g9_19;\n    int64_t f5g0    = f5   * (int64_t) g0;\n    int64_t f5g1_2  = f5_2 * (int64_t) g1;\n    int64_t f5g2    = f5   * (int64_t) g2;\n    int64_t f5g3_2  = f5_2 * (int64_t) g3;\n    int64_t f5g4    = f5   * (int64_t) g4;\n    int64_t f5g5_38 = f5_2 * (int64_t) g5_19;\n    int64_t f5g6_19 = f5   * (int64_t) g6_19;\n    int64_t f5g7_38 = f5_2 * (int64_t) g7_19;\n    int64_t f5g8_19 = f5   * (int64_t) g8_19;\n    int64_t f5g9_38 = f5_2 * (int64_t) g9_19;\n    int64_t f6g0    = f6   * (int64_t) g0;\n    int64_t f6g1    = f6   * (int64_t) g1;\n    int64_t f6g2    = f6   * (int64_t) g2;\n    int64_t f6g3    = f6   * (int64_t) g3;\n    int64_t f6g4_19 = f6   * (int64_t) g4_19;\n    int64_t f6g5_19 = f6   * (int64_t) g5_19;\n    int64_t f6g6_19 = f6   * (int64_t) g6_19;\n    int64_t f6g7_19 = f6   * (int64_t) g7_19;\n    int64_t f6g8_19 = f6   * (int64_t) g8_19;\n    int64_t f6g9_19 = f6   * (int64_t) g9_19;\n    int64_t f7g0    = f7   * (int64_t) g0;\n    int64_t f7g1_2  = f7_2 * (int64_t) g1;\n    int64_t f7g2    = f7   * (int64_t) g2;\n    int64_t f7g3_38 = f7_2 * (int64_t) g3_19;\n    int64_t f7g4_19 = f7   * (int64_t) g4_19;\n    int64_t f7g5_38 = f7_2 * (int64_t) g5_19;\n    int64_t f7g6_19 = f7   * (int64_t) g6_19;\n    int64_t f7g7_38 = f7_2 * (int64_t) g7_19;\n    int64_t f7g8_19 = f7   * (int64_t) g8_19;\n    int64_t f7g9_38 = f7_2 * (int64_t) g9_19;\n    int64_t f8g0    = f8   * (int64_t) g0;\n    int64_t f8g1    = f8   * (int64_t) g1;\n    int64_t f8g2_19 = f8   * (int64_t) g2_19;\n    int64_t f8g3_19 = f8   * (int64_t) g3_19;\n    int64_t f8g4_19 = f8   * (int64_t) g4_19;\n    int64_t f8g5_19 = f8   * (int64_t) g5_19;\n    int64_t f8g6_19 = f8   * (int64_t) g6_19;\n    int64_t f8g7_19 = f8   * (int64_t) g7_19;\n    int64_t f8g8_19 = f8   * (int64_t) g8_19;\n    int64_t f8g9_19 = f8   * (int64_t) g9_19;\n    int64_t f9g0    = f9   * (int64_t) g0;\n    int64_t f9g1_38 = f9_2 * (int64_t) g1_19;\n    int64_t f9g2_19 = f9   * (int64_t) g2_19;\n    int64_t f9g3_38 = f9_2 * (int64_t) g3_19;\n    int64_t f9g4_19 = f9   * (int64_t) g4_19;\n    int64_t f9g5_38 = f9_2 * (int64_t) g5_19;\n    int64_t f9g6_19 = f9   * (int64_t) g6_19;\n    int64_t f9g7_38 = f9_2 * (int64_t) g7_19;\n    int64_t f9g8_19 = f9   * (int64_t) g8_19;\n    int64_t f9g9_38 = f9_2 * (int64_t) g9_19;\n    int64_t h0 = f0g0 + f1g9_38 + f2g8_19 + f3g7_38 + f4g6_19 + f5g5_38 + f6g4_19 + f7g3_38 + f8g2_19 + f9g1_38;\n    int64_t h1 = f0g1 + f1g0    + f2g9_19 + f3g8_19 + f4g7_19 + f5g6_19 + f6g5_19 + f7g4_19 + f8g3_19 + f9g2_19;\n    int64_t h2 = f0g2 + f1g1_2  + f2g0    + f3g9_38 + f4g8_19 + f5g7_38 + f6g6_19 + f7g5_38 + f8g4_19 + f9g3_38;\n    int64_t h3 = f0g3 + f1g2    + f2g1    + f3g0    + f4g9_19 + f5g8_19 + f6g7_19 + f7g6_19 + f8g5_19 + f9g4_19;\n    int64_t h4 = f0g4 + f1g3_2  + f2g2    + f3g1_2  + f4g0    + f5g9_38 + f6g8_19 + f7g7_38 + f8g6_19 + f9g5_38;\n    int64_t h5 = f0g5 + f1g4    + f2g3    + f3g2    + f4g1    + f5g0    + f6g9_19 + f7g8_19 + f8g7_19 + f9g6_19;\n    int64_t h6 = f0g6 + f1g5_2  + f2g4    + f3g3_2  + f4g2    + f5g1_2  + f6g0    + f7g9_38 + f8g8_19 + f9g7_38;\n    int64_t h7 = f0g7 + f1g6    + f2g5    + f3g4    + f4g3    + f5g2    + f6g1    + f7g0    + f8g9_19 + f9g8_19;\n    int64_t h8 = f0g8 + f1g7_2  + f2g6    + f3g5_2  + f4g4    + f5g3_2  + f6g2    + f7g1_2  + f8g0    + f9g9_38;\n    int64_t h9 = f0g9 + f1g8    + f2g7    + f3g6    + f4g5    + f5g4    + f6g3    + f7g2    + f8g1    + f9g0   ;\n    int64_t carry0;\n    int64_t carry1;\n    int64_t carry2;\n    int64_t carry3;\n    int64_t carry4;\n    int64_t carry5;\n    int64_t carry6;\n    int64_t carry7;\n    int64_t carry8;\n    int64_t carry9;\n\n    /* |h0| \u003c= (1.65*1.65*2^52*(1+19+19+19+19)+1.65*1.65*2^50*(38+38+38+38+38))\n     *   i.e. |h0| \u003c= 1.4*2^60; narrower ranges for h2, h4, h6, h8\n     * |h1| \u003c= (1.65*1.65*2^51*(1+1+19+19+19+19+19+19+19+19))\n     *   i.e. |h1| \u003c= 1.7*2^59; narrower ranges for h3, h5, h7, h9 */\n\n    carry0 = h0 + (1 \u003c\u003c 25); h1 += carry0 \u003e\u003e 26; h0 -= carry0 \u0026 kTop38Bits;\n    carry4 = h4 + (1 \u003c\u003c 25); h5 += carry4 \u003e\u003e 26; h4 -= carry4 \u0026 kTop38Bits;\n    /* |h0| \u003c= 2^25 */\n    /* |h4| \u003c= 2^25 */\n    /* |h1| \u003c= 1.71*2^59 */\n    /* |h5| \u003c= 1.71*2^59 */\n\n    carry1 = h1 + (1 \u003c\u003c 24); h2 += carry1 \u003e\u003e 25; h1 -= carry1 \u0026 kTop39Bits;\n    carry5 = h5 + (1 \u003c\u003c 24); h6 += carry5 \u003e\u003e 25; h5 -= carry5 \u0026 kTop39Bits;\n    /* |h1| \u003c= 2^24; from now on fits into int32 */\n    /* |h5| \u003c= 2^24; from now on fits into int32 */\n    /* |h2| \u003c= 1.41*2^60 */\n    /* |h6| \u003c= 1.41*2^60 */\n\n    carry2 = h2 + (1 \u003c\u003c 25); h3 += carry2 \u003e\u003e 26; h2 -= carry2 \u0026 kTop38Bits;\n    carry6 = h6 + (1 \u003c\u003c 25); h7 += carry6 \u003e\u003e 26; h6 -= carry6 \u0026 kTop38Bits;\n    /* |h2| \u003c= 2^25; from now on fits into int32 unchanged */\n    /* |h6| \u003c= 2^25; from now on fits into int32 unchanged */\n    /* |h3| \u003c= 1.71*2^59 */\n    /* |h7| \u003c= 1.71*2^59 */\n\n    carry3 = h3 + (1 \u003c\u003c 24); h4 += carry3 \u003e\u003e 25; h3 -= carry3 \u0026 kTop39Bits;\n    carry7 = h7 + (1 \u003c\u003c 24); h8 += carry7 \u003e\u003e 25; h7 -= carry7 \u0026 kTop39Bits;\n    /* |h3| \u003c= 2^24; from now on fits into int32 unchanged */\n    /* |h7| \u003c= 2^24; from now on fits into int32 unchanged */\n    /* |h4| \u003c= 1.72*2^34 */\n    /* |h8| \u003c= 1.41*2^60 */\n\n    carry4 = h4 + (1 \u003c\u003c 25); h5 += carry4 \u003e\u003e 26; h4 -= carry4 \u0026 kTop38Bits;\n    carry8 = h8 + (1 \u003c\u003c 25); h9 += carry8 \u003e\u003e 26; h8 -= carry8 \u0026 kTop38Bits;\n    /* |h4| \u003c= 2^25; from now on fits into int32 unchanged */\n    /* |h8| \u003c= 2^25; from now on fits into int32 unchanged */\n    /* |h5| \u003c= 1.01*2^24 */\n    /* |h9| \u003c= 1.71*2^59 */\n\n    carry9 = h9 + (1 \u003c\u003c 24); h0 += (carry9 \u003e\u003e 25) * 19; h9 -= carry9 \u0026 kTop39Bits;\n    /* |h9| \u003c= 2^24; from now on fits into int32 unchanged */\n    /* |h0| \u003c= 1.1*2^39 */\n\n    carry0 = h0 + (1 \u003c\u003c 25); h1 += carry0 \u003e\u003e 26; h0 -= carry0 \u0026 kTop38Bits;\n    /* |h0| \u003c= 2^25; from now on fits into int32 unchanged */\n    /* |h1| \u003c= 1.01*2^24 */\n\n    h[0] = (int32_t)h0;\n    h[1] = (int32_t)h1;\n    h[2] = (int32_t)h2;\n    h[3] = (int32_t)h3;\n    h[4] = (int32_t)h4;\n    h[5] = (int32_t)h5;\n    h[6] = (int32_t)h6;\n    h[7] = (int32_t)h7;\n    h[8] = (int32_t)h8;\n    h[9] = (int32_t)h9;\n}","filepath":"libs-ext/openssl/crypto/ec/curve25519.c","line_number":1035,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"270080688":{"score":0.88603115,"function_name":"fe_mul121666","code":"static void fe_mul121666(fe h, fe f)\n{\n    int32_t f0 = f[0];\n    int32_t f1 = f[1];\n    int32_t f2 = f[2];\n    int32_t f3 = f[3];\n    int32_t f4 = f[4];\n    int32_t f5 = f[5];\n    int32_t f6 = f[6];\n    int32_t f7 = f[7];\n    int32_t f8 = f[8];\n    int32_t f9 = f[9];\n    int64_t h0 = f0 * (int64_t) 121666;\n    int64_t h1 = f1 * (int64_t) 121666;\n    int64_t h2 = f2 * (int64_t) 121666;\n    int64_t h3 = f3 * (int64_t) 121666;\n    int64_t h4 = f4 * (int64_t) 121666;\n    int64_t h5 = f5 * (int64_t) 121666;\n    int64_t h6 = f6 * (int64_t) 121666;\n    int64_t h7 = f7 * (int64_t) 121666;\n    int64_t h8 = f8 * (int64_t) 121666;\n    int64_t h9 = f9 * (int64_t) 121666;\n    int64_t carry0;\n    int64_t carry1;\n    int64_t carry2;\n    int64_t carry3;\n    int64_t carry4;\n    int64_t carry5;\n    int64_t carry6;\n    int64_t carry7;\n    int64_t carry8;\n    int64_t carry9;\n\n    carry9 = h9 + (1 \u003c\u003c 24); h0 += (carry9 \u003e\u003e 25) * 19; h9 -= carry9 \u0026 kTop39Bits;\n    carry1 = h1 + (1 \u003c\u003c 24); h2 += carry1 \u003e\u003e 25; h1 -= carry1 \u0026 kTop39Bits;\n    carry3 = h3 + (1 \u003c\u003c 24); h4 += carry3 \u003e\u003e 25; h3 -= carry3 \u0026 kTop39Bits;\n    carry5 = h5 + (1 \u003c\u003c 24); h6 += carry5 \u003e\u003e 25; h5 -= carry5 \u0026 kTop39Bits;\n    carry7 = h7 + (1 \u003c\u003c 24); h8 += carry7 \u003e\u003e 25; h7 -= carry7 \u0026 kTop39Bits;\n\n    carry0 = h0 + (1 \u003c\u003c 25); h1 += carry0 \u003e\u003e 26; h0 -= carry0 \u0026 kTop38Bits;\n    carry2 = h2 + (1 \u003c\u003c 25); h3 += carry2 \u003e\u003e 26; h2 -= carry2 \u0026 kTop38Bits;\n    carry4 = h4 + (1 \u003c\u003c 25); h5 += carry4 \u003e\u003e 26; h4 -= carry4 \u0026 kTop38Bits;\n    carry6 = h6 + (1 \u003c\u003c 25); h7 += carry6 \u003e\u003e 26; h6 -= carry6 \u0026 kTop38Bits;\n    carry8 = h8 + (1 \u003c\u003c 25); h9 += carry8 \u003e\u003e 26; h8 -= carry8 \u0026 kTop38Bits;\n\n    h[0] = (int32_t)h0;\n    h[1] = (int32_t)h1;\n    h[2] = (int32_t)h2;\n    h[3] = (int32_t)h3;\n    h[4] = (int32_t)h4;\n    h[5] = (int32_t)h5;\n    h[6] = (int32_t)h6;\n    h[7] = (int32_t)h7;\n    h[8] = (int32_t)h8;\n    h[9] = (int32_t)h9;\n}","filepath":"libs-ext/openssl/crypto/ec/curve25519.c","line_number":4310,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"270082064":{"score":0.86146545,"function_name":"fe_sq","code":"static void fe_sq(fe h, const fe f)\n{\n    int32_t f0 = f[0];\n    int32_t f1 = f[1];\n    int32_t f2 = f[2];\n    int32_t f3 = f[3];\n    int32_t f4 = f[4];\n    int32_t f5 = f[5];\n    int32_t f6 = f[6];\n    int32_t f7 = f[7];\n    int32_t f8 = f[8];\n    int32_t f9 = f[9];\n    int32_t f0_2 = 2 * f0;\n    int32_t f1_2 = 2 * f1;\n    int32_t f2_2 = 2 * f2;\n    int32_t f3_2 = 2 * f3;\n    int32_t f4_2 = 2 * f4;\n    int32_t f5_2 = 2 * f5;\n    int32_t f6_2 = 2 * f6;\n    int32_t f7_2 = 2 * f7;\n    int32_t f5_38 = 38 * f5; /* 1.959375*2^30 */\n    int32_t f6_19 = 19 * f6; /* 1.959375*2^30 */\n    int32_t f7_38 = 38 * f7; /* 1.959375*2^30 */\n    int32_t f8_19 = 19 * f8; /* 1.959375*2^30 */\n    int32_t f9_38 = 38 * f9; /* 1.959375*2^30 */\n    int64_t f0f0    = f0   * (int64_t) f0;\n    int64_t f0f1_2  = f0_2 * (int64_t) f1;\n    int64_t f0f2_2  = f0_2 * (int64_t) f2;\n    int64_t f0f3_2  = f0_2 * (int64_t) f3;\n    int64_t f0f4_2  = f0_2 * (int64_t) f4;\n    int64_t f0f5_2  = f0_2 * (int64_t) f5;\n    int64_t f0f6_2  = f0_2 * (int64_t) f6;\n    int64_t f0f7_2  = f0_2 * (int64_t) f7;\n    int64_t f0f8_2  = f0_2 * (int64_t) f8;\n    int64_t f0f9_2  = f0_2 * (int64_t) f9;\n    int64_t f1f1_2  = f1_2 * (int64_t) f1;\n    int64_t f1f2_2  = f1_2 * (int64_t) f2;\n    int64_t f1f3_4  = f1_2 * (int64_t) f3_2;\n    int64_t f1f4_2  = f1_2 * (int64_t) f4;\n    int64_t f1f5_4  = f1_2 * (int64_t) f5_2;\n    int64_t f1f6_2  = f1_2 * (int64_t) f6;\n    int64_t f1f7_4  = f1_2 * (int64_t) f7_2;\n    int64_t f1f8_2  = f1_2 * (int64_t) f8;\n    int64_t f1f9_76 = f1_2 * (int64_t) f9_38;\n    int64_t f2f2    = f2   * (int64_t) f2;\n    int64_t f2f3_2  = f2_2 * (int64_t) f3;\n    int64_t f2f4_2  = f2_2 * (int64_t) f4;\n    int64_t f2f5_2  = f2_2 * (int64_t) f5;\n    int64_t f2f6_2  = f2_2 * (int64_t) f6;\n    int64_t f2f7_2  = f2_2 * (int64_t) f7;\n    int64_t f2f8_38 = f2_2 * (int64_t) f8_19;\n    int64_t f2f9_38 = f2   * (int64_t) f9_38;\n    int64_t f3f3_2  = f3_2 * (int64_t) f3;\n    int64_t f3f4_2  = f3_2 * (int64_t) f4;\n    int64_t f3f5_4  = f3_2 * (int64_t) f5_2;\n    int64_t f3f6_2  = f3_2 * (int64_t) f6;\n    int64_t f3f7_76 = f3_2 * (int64_t) f7_38;\n    int64_t f3f8_38 = f3_2 * (int64_t) f8_19;\n    int64_t f3f9_76 = f3_2 * (int64_t) f9_38;\n    int64_t f4f4    = f4   * (int64_t) f4;\n    int64_t f4f5_2  = f4_2 * (int64_t) f5;\n    int64_t f4f6_38 = f4_2 * (int64_t) f6_19;\n    int64_t f4f7_38 = f4   * (int64_t) f7_38;\n    int64_t f4f8_38 = f4_2 * (int64_t) f8_19;\n    int64_t f4f9_38 = f4   * (int64_t) f9_38;\n    int64_t f5f5_38 = f5   * (int64_t) f5_38;\n    int64_t f5f6_38 = f5_2 * (int64_t) f6_19;\n    int64_t f5f7_76 = f5_2 * (int64_t) f7_38;\n    int64_t f5f8_38 = f5_2 * (int64_t) f8_19;\n    int64_t f5f9_76 = f5_2 * (int64_t) f9_38;\n    int64_t f6f6_19 = f6   * (int64_t) f6_19;\n    int64_t f6f7_38 = f6   * (int64_t) f7_38;\n    int64_t f6f8_38 = f6_2 * (int64_t) f8_19;\n    int64_t f6f9_38 = f6   * (int64_t) f9_38;\n    int64_t f7f7_38 = f7   * (int64_t) f7_38;\n    int64_t f7f8_38 = f7_2 * (int64_t) f8_19;\n    int64_t f7f9_76 = f7_2 * (int64_t) f9_38;\n    int64_t f8f8_19 = f8   * (int64_t) f8_19;\n    int64_t f8f9_38 = f8   * (int64_t) f9_38;\n    int64_t f9f9_38 = f9   * (int64_t) f9_38;\n    int64_t h0 = f0f0   + f1f9_76 + f2f8_38 + f3f7_76 + f4f6_38 + f5f5_38;\n    int64_t h1 = f0f1_2 + f2f9_38 + f3f8_38 + f4f7_38 + f5f6_38;\n    int64_t h2 = f0f2_2 + f1f1_2  + f3f9_76 + f4f8_38 + f5f7_76 + f6f6_19;\n    int64_t h3 = f0f3_2 + f1f2_2  + f4f9_38 + f5f8_38 + f6f7_38;\n    int64_t h4 = f0f4_2 + f1f3_4  + f2f2    + f5f9_76 + f6f8_38 + f7f7_38;\n    int64_t h5 = f0f5_2 + f1f4_2  + f2f3_2  + f6f9_38 + f7f8_38;\n    int64_t h6 = f0f6_2 + f1f5_4  + f2f4_2  + f3f3_2  + f7f9_76 + f8f8_19;\n    int64_t h7 = f0f7_2 + f1f6_2  + f2f5_2  + f3f4_2  + f8f9_38;\n    int64_t h8 = f0f8_2 + f1f7_4  + f2f6_2  + f3f5_4  + f4f4    + f9f9_38;\n    int64_t h9 = f0f9_2 + f1f8_2  + f2f7_2  + f3f6_2  + f4f5_2;\n    int64_t carry0;\n    int64_t carry1;\n    int64_t carry2;\n    int64_t carry3;\n    int64_t carry4;\n    int64_t carry5;\n    int64_t carry6;\n    int64_t carry7;\n    int64_t carry8;\n    int64_t carry9;\n\n    carry0 = h0 + (1 \u003c\u003c 25); h1 += carry0 \u003e\u003e 26; h0 -= carry0 \u0026 kTop38Bits;\n    carry4 = h4 + (1 \u003c\u003c 25); h5 += carry4 \u003e\u003e 26; h4 -= carry4 \u0026 kTop38Bits;\n\n    carry1 = h1 + (1 \u003c\u003c 24); h2 += carry1 \u003e\u003e 25; h1 -= carry1 \u0026 kTop39Bits;\n    carry5 = h5 + (1 \u003c\u003c 24); h6 += carry5 \u003e\u003e 25; h5 -= carry5 \u0026 kTop39Bits;\n\n    carry2 = h2 + (1 \u003c\u003c 25); h3 += carry2 \u003e\u003e 26; h2 -= carry2 \u0026 kTop38Bits;\n    carry6 = h6 + (1 \u003c\u003c 25); h7 += carry6 \u003e\u003e 26; h6 -= carry6 \u0026 kTop38Bits;\n\n    carry3 = h3 + (1 \u003c\u003c 24); h4 += carry3 \u003e\u003e 25; h3 -= carry3 \u0026 kTop39Bits;\n    carry7 = h7 + (1 \u003c\u003c 24); h8 += carry7 \u003e\u003e 25; h7 -= carry7 \u0026 kTop39Bits;\n\n    carry4 = h4 + (1 \u003c\u003c 25); h5 += carry4 \u003e\u003e 26; h4 -= carry4 \u0026 kTop38Bits;\n    carry8 = h8 + (1 \u003c\u003c 25); h9 += carry8 \u003e\u003e 26; h8 -= carry8 \u0026 kTop38Bits;\n\n    carry9 = h9 + (1 \u003c\u003c 24); h0 += (carry9 \u003e\u003e 25) * 19; h9 -= carry9 \u0026 kTop39Bits;\n\n    carry0 = h0 + (1 \u003c\u003c 25); h1 += carry0 \u003e\u003e 26; h0 -= carry0 \u0026 kTop38Bits;\n\n    h[0] = (int32_t)h0;\n    h[1] = (int32_t)h1;\n    h[2] = (int32_t)h2;\n    h[3] = (int32_t)h3;\n    h[4] = (int32_t)h4;\n    h[5] = (int32_t)h5;\n    h[6] = (int32_t)h6;\n    h[7] = (int32_t)h7;\n    h[8] = (int32_t)h8;\n    h[9] = (int32_t)h9;\n}","filepath":"libs-ext/openssl/crypto/ec/curve25519.c","line_number":1265,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"270083632":{"score":0.85787845,"function_name":"fe_sq2","code":"static void fe_sq2(fe h, const fe f)\n{\n    int32_t f0 = f[0];\n    int32_t f1 = f[1];\n    int32_t f2 = f[2];\n    int32_t f3 = f[3];\n    int32_t f4 = f[4];\n    int32_t f5 = f[5];\n    int32_t f6 = f[6];\n    int32_t f7 = f[7];\n    int32_t f8 = f[8];\n    int32_t f9 = f[9];\n    int32_t f0_2 = 2 * f0;\n    int32_t f1_2 = 2 * f1;\n    int32_t f2_2 = 2 * f2;\n    int32_t f3_2 = 2 * f3;\n    int32_t f4_2 = 2 * f4;\n    int32_t f5_2 = 2 * f5;\n    int32_t f6_2 = 2 * f6;\n    int32_t f7_2 = 2 * f7;\n    int32_t f5_38 = 38 * f5; /* 1.959375*2^30 */\n    int32_t f6_19 = 19 * f6; /* 1.959375*2^30 */\n    int32_t f7_38 = 38 * f7; /* 1.959375*2^30 */\n    int32_t f8_19 = 19 * f8; /* 1.959375*2^30 */\n    int32_t f9_38 = 38 * f9; /* 1.959375*2^30 */\n    int64_t f0f0    = f0   * (int64_t) f0;\n    int64_t f0f1_2  = f0_2 * (int64_t) f1;\n    int64_t f0f2_2  = f0_2 * (int64_t) f2;\n    int64_t f0f3_2  = f0_2 * (int64_t) f3;\n    int64_t f0f4_2  = f0_2 * (int64_t) f4;\n    int64_t f0f5_2  = f0_2 * (int64_t) f5;\n    int64_t f0f6_2  = f0_2 * (int64_t) f6;\n    int64_t f0f7_2  = f0_2 * (int64_t) f7;\n    int64_t f0f8_2  = f0_2 * (int64_t) f8;\n    int64_t f0f9_2  = f0_2 * (int64_t) f9;\n    int64_t f1f1_2  = f1_2 * (int64_t) f1;\n    int64_t f1f2_2  = f1_2 * (int64_t) f2;\n    int64_t f1f3_4  = f1_2 * (int64_t) f3_2;\n    int64_t f1f4_2  = f1_2 * (int64_t) f4;\n    int64_t f1f5_4  = f1_2 * (int64_t) f5_2;\n    int64_t f1f6_2  = f1_2 * (int64_t) f6;\n    int64_t f1f7_4  = f1_2 * (int64_t) f7_2;\n    int64_t f1f8_2  = f1_2 * (int64_t) f8;\n    int64_t f1f9_76 = f1_2 * (int64_t) f9_38;\n    int64_t f2f2    = f2   * (int64_t) f2;\n    int64_t f2f3_2  = f2_2 * (int64_t) f3;\n    int64_t f2f4_2  = f2_2 * (int64_t) f4;\n    int64_t f2f5_2  = f2_2 * (int64_t) f5;\n    int64_t f2f6_2  = f2_2 * (int64_t) f6;\n    int64_t f2f7_2  = f2_2 * (int64_t) f7;\n    int64_t f2f8_38 = f2_2 * (int64_t) f8_19;\n    int64_t f2f9_38 = f2   * (int64_t) f9_38;\n    int64_t f3f3_2  = f3_2 * (int64_t) f3;\n    int64_t f3f4_2  = f3_2 * (int64_t) f4;\n    int64_t f3f5_4  = f3_2 * (int64_t) f5_2;\n    int64_t f3f6_2  = f3_2 * (int64_t) f6;\n    int64_t f3f7_76 = f3_2 * (int64_t) f7_38;\n    int64_t f3f8_38 = f3_2 * (int64_t) f8_19;\n    int64_t f3f9_76 = f3_2 * (int64_t) f9_38;\n    int64_t f4f4    = f4   * (int64_t) f4;\n    int64_t f4f5_2  = f4_2 * (int64_t) f5;\n    int64_t f4f6_38 = f4_2 * (int64_t) f6_19;\n    int64_t f4f7_38 = f4   * (int64_t) f7_38;\n    int64_t f4f8_38 = f4_2 * (int64_t) f8_19;\n    int64_t f4f9_38 = f4   * (int64_t) f9_38;\n    int64_t f5f5_38 = f5   * (int64_t) f5_38;\n    int64_t f5f6_38 = f5_2 * (int64_t) f6_19;\n    int64_t f5f7_76 = f5_2 * (int64_t) f7_38;\n    int64_t f5f8_38 = f5_2 * (int64_t) f8_19;\n    int64_t f5f9_76 = f5_2 * (int64_t) f9_38;\n    int64_t f6f6_19 = f6   * (int64_t) f6_19;\n    int64_t f6f7_38 = f6   * (int64_t) f7_38;\n    int64_t f6f8_38 = f6_2 * (int64_t) f8_19;\n    int64_t f6f9_38 = f6   * (int64_t) f9_38;\n    int64_t f7f7_38 = f7   * (int64_t) f7_38;\n    int64_t f7f8_38 = f7_2 * (int64_t) f8_19;\n    int64_t f7f9_76 = f7_2 * (int64_t) f9_38;\n    int64_t f8f8_19 = f8   * (int64_t) f8_19;\n    int64_t f8f9_38 = f8   * (int64_t) f9_38;\n    int64_t f9f9_38 = f9   * (int64_t) f9_38;\n    int64_t h0 = f0f0   + f1f9_76 + f2f8_38 + f3f7_76 + f4f6_38 + f5f5_38;\n    int64_t h1 = f0f1_2 + f2f9_38 + f3f8_38 + f4f7_38 + f5f6_38;\n    int64_t h2 = f0f2_2 + f1f1_2  + f3f9_76 + f4f8_38 + f5f7_76 + f6f6_19;\n    int64_t h3 = f0f3_2 + f1f2_2  + f4f9_38 + f5f8_38 + f6f7_38;\n    int64_t h4 = f0f4_2 + f1f3_4  + f2f2    + f5f9_76 + f6f8_38 + f7f7_38;\n    int64_t h5 = f0f5_2 + f1f4_2  + f2f3_2  + f6f9_38 + f7f8_38;\n    int64_t h6 = f0f6_2 + f1f5_4  + f2f4_2  + f3f3_2  + f7f9_76 + f8f8_19;\n    int64_t h7 = f0f7_2 + f1f6_2  + f2f5_2  + f3f4_2  + f8f9_38;\n    int64_t h8 = f0f8_2 + f1f7_4  + f2f6_2  + f3f5_4  + f4f4    + f9f9_38;\n    int64_t h9 = f0f9_2 + f1f8_2  + f2f7_2  + f3f6_2  + f4f5_2;\n    int64_t carry0;\n    int64_t carry1;\n    int64_t carry2;\n    int64_t carry3;\n    int64_t carry4;\n    int64_t carry5;\n    int64_t carry6;\n    int64_t carry7;\n    int64_t carry8;\n    int64_t carry9;\n\n    h0 += h0;\n    h1 += h1;\n    h2 += h2;\n    h3 += h3;\n    h4 += h4;\n    h5 += h5;\n    h6 += h6;\n    h7 += h7;\n    h8 += h8;\n    h9 += h9;\n\n    carry0 = h0 + (1 \u003c\u003c 25); h1 += carry0 \u003e\u003e 26; h0 -= carry0 \u0026 kTop38Bits;\n    carry4 = h4 + (1 \u003c\u003c 25); h5 += carry4 \u003e\u003e 26; h4 -= carry4 \u0026 kTop38Bits;\n\n    carry1 = h1 + (1 \u003c\u003c 24); h2 += carry1 \u003e\u003e 25; h1 -= carry1 \u0026 kTop39Bits;\n    carry5 = h5 + (1 \u003c\u003c 24); h6 += carry5 \u003e\u003e 25; h5 -= carry5 \u0026 kTop39Bits;\n\n    carry2 = h2 + (1 \u003c\u003c 25); h3 += carry2 \u003e\u003e 26; h2 -= carry2 \u0026 kTop38Bits;\n    carry6 = h6 + (1 \u003c\u003c 25); h7 += carry6 \u003e\u003e 26; h6 -= carry6 \u0026 kTop38Bits;\n\n    carry3 = h3 + (1 \u003c\u003c 24); h4 += carry3 \u003e\u003e 25; h3 -= carry3 \u0026 kTop39Bits;\n    carry7 = h7 + (1 \u003c\u003c 24); h8 += carry7 \u003e\u003e 25; h7 -= carry7 \u0026 kTop39Bits;\n\n    carry4 = h4 + (1 \u003c\u003c 25); h5 += carry4 \u003e\u003e 26; h4 -= carry4 \u0026 kTop38Bits;\n    carry8 = h8 + (1 \u003c\u003c 25); h9 += carry8 \u003e\u003e 26; h8 -= carry8 \u0026 kTop38Bits;\n\n    carry9 = h9 + (1 \u003c\u003c 24); h0 += (carry9 \u003e\u003e 25) * 19; h9 -= carry9 \u0026 kTop39Bits;\n\n    carry0 = h0 + (1 \u003c\u003c 25); h1 += carry0 \u003e\u003e 26; h0 -= carry0 \u0026 kTop38Bits;\n\n    h[0] = (int32_t)h0;\n    h[1] = (int32_t)h1;\n    h[2] = (int32_t)h2;\n    h[3] = (int32_t)h3;\n    h[4] = (int32_t)h4;\n    h[5] = (int32_t)h5;\n    h[6] = (int32_t)h6;\n    h[7] = (int32_t)h7;\n    h[8] = (int32_t)h8;\n    h[9] = (int32_t)h9;\n}","filepath":"libs-ext/openssl/crypto/ec/curve25519.c","line_number":1574,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"270085280":{"score":0.947698,"function_name":"fe_tobytes","code":"static void fe_tobytes(uint8_t *s, const fe h)\n{\n    int32_t h0 = h[0];\n    int32_t h1 = h[1];\n    int32_t h2 = h[2];\n    int32_t h3 = h[3];\n    int32_t h4 = h[4];\n    int32_t h5 = h[5];\n    int32_t h6 = h[6];\n    int32_t h7 = h[7];\n    int32_t h8 = h[8];\n    int32_t h9 = h[9];\n    int32_t q;\n\n    q = (19 * h9 + (((int32_t) 1) \u003c\u003c 24)) \u003e\u003e 25;\n    q = (h0 + q) \u003e\u003e 26;\n    q = (h1 + q) \u003e\u003e 25;\n    q = (h2 + q) \u003e\u003e 26;\n    q = (h3 + q) \u003e\u003e 25;\n    q = (h4 + q) \u003e\u003e 26;\n    q = (h5 + q) \u003e\u003e 25;\n    q = (h6 + q) \u003e\u003e 26;\n    q = (h7 + q) \u003e\u003e 25;\n    q = (h8 + q) \u003e\u003e 26;\n    q = (h9 + q) \u003e\u003e 25;\n\n    /* Goal: Output h-(2^255-19)q, which is between 0 and 2^255-20. */\n    h0 += 19 * q;\n    /* Goal: Output h-2^255 q, which is between 0 and 2^255-20. */\n\n    h1 += h0 \u003e\u003e 26; h0 \u0026= kBottom26Bits;\n    h2 += h1 \u003e\u003e 25; h1 \u0026= kBottom25Bits;\n    h3 += h2 \u003e\u003e 26; h2 \u0026= kBottom26Bits;\n    h4 += h3 \u003e\u003e 25; h3 \u0026= kBottom25Bits;\n    h5 += h4 \u003e\u003e 26; h4 \u0026= kBottom26Bits;\n    h6 += h5 \u003e\u003e 25; h5 \u0026= kBottom25Bits;\n    h7 += h6 \u003e\u003e 26; h6 \u0026= kBottom26Bits;\n    h8 += h7 \u003e\u003e 25; h7 \u0026= kBottom25Bits;\n    h9 += h8 \u003e\u003e 26; h8 \u0026= kBottom26Bits;\n                    h9 \u0026= kBottom25Bits;\n    /* h10 = carry9 */\n\n    /*\n     * Goal: Output h0+...+2^255 h10-2^255 q, which is between 0 and 2^255-20.\n     * Have h0+...+2^230 h9 between 0 and 2^255-1;\n     * evidently 2^255 h10-2^255 q = 0.\n     * Goal: Output h0+...+2^230 h9.\n     */\n    s[ 0] = (uint8_t) (h0 \u003e\u003e  0);\n    s[ 1] = (uint8_t) (h0 \u003e\u003e  8);\n    s[ 2] = (uint8_t) (h0 \u003e\u003e 16);\n    s[ 3] = (uint8_t)((h0 \u003e\u003e 24) | ((uint32_t)(h1) \u003c\u003c 2));\n    s[ 4] = (uint8_t) (h1 \u003e\u003e  6);\n    s[ 5] = (uint8_t) (h1 \u003e\u003e 14);\n    s[ 6] = (uint8_t)((h1 \u003e\u003e 22) | ((uint32_t)(h2) \u003c\u003c 3));\n    s[ 7] = (uint8_t) (h2 \u003e\u003e  5);\n    s[ 8] = (uint8_t) (h2 \u003e\u003e 13);\n    s[ 9] = (uint8_t)((h2 \u003e\u003e 21) | ((uint32_t)(h3) \u003c\u003c 5));\n    s[10] = (uint8_t) (h3 \u003e\u003e  3);\n    s[11] = (uint8_t) (h3 \u003e\u003e 11);\n    s[12] = (uint8_t)((h3 \u003e\u003e 19) | ((uint32_t)(h4) \u003c\u003c 6));\n    s[13] = (uint8_t) (h4 \u003e\u003e  2);\n    s[14] = (uint8_t) (h4 \u003e\u003e 10);\n    s[15] = (uint8_t) (h4 \u003e\u003e 18);\n    s[16] = (uint8_t) (h5 \u003e\u003e  0);\n    s[17] = (uint8_t) (h5 \u003e\u003e  8);\n    s[18] = (uint8_t) (h5 \u003e\u003e 16);\n    s[19] = (uint8_t)((h5 \u003e\u003e 24) | ((uint32_t)(h6) \u003c\u003c 1));\n    s[20] = (uint8_t) (h6 \u003e\u003e  7);\n    s[21] = (uint8_t) (h6 \u003e\u003e 15);\n    s[22] = (uint8_t)((h6 \u003e\u003e 23) | ((uint32_t)(h7) \u003c\u003c 3));\n    s[23] = (uint8_t) (h7 \u003e\u003e  5);\n    s[24] = (uint8_t) (h7 \u003e\u003e 13);\n    s[25] = (uint8_t)((h7 \u003e\u003e 21) | ((uint32_t)(h8) \u003c\u003c 4));\n    s[26] = (uint8_t) (h8 \u003e\u003e  4);\n    s[27] = (uint8_t) (h8 \u003e\u003e 12);\n    s[28] = (uint8_t)((h8 \u003e\u003e 20) | ((uint32_t)(h9) \u003c\u003c 6));\n    s[29] = (uint8_t) (h9 \u003e\u003e  2);\n    s[30] = (uint8_t) (h9 \u003e\u003e 10);\n    s[31] = (uint8_t) (h9 \u003e\u003e 18);\n}","filepath":"libs-ext/openssl/crypto/ec/curve25519.c","line_number":862,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"270086848":{"score":0.7688234,"function_name":"ge_double_scalarmult_vartime","code":"static void ge_double_scalarmult_vartime(ge_p2 *r, const uint8_t *a,\n                                         const ge_p3 *A, const uint8_t *b)\n{\n    signed char aslide[256];\n    signed char bslide[256];\n    ge_cached Ai[8]; /* A,3A,5A,7A,9A,11A,13A,15A */\n    ge_p1p1 t;\n    ge_p3 u;\n    ge_p3 A2;\n    int i;\n\n    slide(aslide, a);\n    slide(bslide, b);\n\n    ge_p3_to_cached(\u0026Ai[0], A);\n    ge_p3_dbl(\u0026t, A);\n    ge_p1p1_to_p3(\u0026A2, \u0026t);\n    ge_add(\u0026t, \u0026A2, \u0026Ai[0]);\n    ge_p1p1_to_p3(\u0026u, \u0026t);\n    ge_p3_to_cached(\u0026Ai[1], \u0026u);\n    ge_add(\u0026t, \u0026A2, \u0026Ai[1]);\n    ge_p1p1_to_p3(\u0026u, \u0026t);\n    ge_p3_to_cached(\u0026Ai[2], \u0026u);\n    ge_add(\u0026t, \u0026A2, \u0026Ai[2]);\n    ge_p1p1_to_p3(\u0026u, \u0026t);\n    ge_p3_to_cached(\u0026Ai[3], \u0026u);\n    ge_add(\u0026t, \u0026A2, \u0026Ai[3]);\n    ge_p1p1_to_p3(\u0026u, \u0026t);\n    ge_p3_to_cached(\u0026Ai[4], \u0026u);\n    ge_add(\u0026t, \u0026A2, \u0026Ai[4]);\n    ge_p1p1_to_p3(\u0026u, \u0026t);\n    ge_p3_to_cached(\u0026Ai[5], \u0026u);\n    ge_add(\u0026t, \u0026A2, \u0026Ai[5]);\n    ge_p1p1_to_p3(\u0026u, \u0026t);\n    ge_p3_to_cached(\u0026Ai[6], \u0026u);\n    ge_add(\u0026t, \u0026A2, \u0026Ai[6]);\n    ge_p1p1_to_p3(\u0026u, \u0026t);\n    ge_p3_to_cached(\u0026Ai[7], \u0026u);\n\n    ge_p2_0(r);\n\n    for (i = 255; i \u003e= 0; --i) {\n        if (aslide[i] || bslide[i]) {\n            break;\n        }\n    }\n\n    for (; i \u003e= 0; --i) {\n        ge_p2_dbl(\u0026t, r);\n\n        if (aslide[i] \u003e 0) {\n            ge_p1p1_to_p3(\u0026u, \u0026t);\n            ge_add(\u0026t, \u0026u, \u0026Ai[aslide[i] / 2]);\n        } else if (aslide[i] \u003c 0) {\n            ge_p1p1_to_p3(\u0026u, \u0026t);\n            ge_sub(\u0026t, \u0026u, \u0026Ai[(-aslide[i]) / 2]);\n        }\n\n        if (bslide[i] \u003e 0) {\n            ge_p1p1_to_p3(\u0026u, \u0026t);\n            ge_madd(\u0026t, \u0026u, \u0026Bi[bslide[i] / 2]);\n        } else if (bslide[i] \u003c 0) {\n            ge_p1p1_to_p3(\u0026u, \u0026t);\n            ge_msub(\u0026t, \u0026u, \u0026Bi[(-bslide[i]) / 2]);\n        }\n\n        ge_p1p1_to_p2(r, \u0026t);\n    }\n}","filepath":"libs-ext/openssl/crypto/ec/curve25519.c","line_number":4533,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"270090032":{"score":0.67537296,"function_name":"ge_madd","code":"static void ge_madd(ge_p1p1 *r, const ge_p3 *p, const ge_precomp *q)\n{\n    fe t0;\n\n    fe_add(r-\u003eX, p-\u003eY, p-\u003eX);\n    fe_sub(r-\u003eY, p-\u003eY, p-\u003eX);\n    fe_mul(r-\u003eZ, r-\u003eX, q-\u003eyplusx);\n    fe_mul(r-\u003eY, r-\u003eY, q-\u003eyminusx);\n    fe_mul(r-\u003eT, q-\u003exy2d, p-\u003eT);\n    fe_add(t0, p-\u003eZ, p-\u003eZ);\n    fe_sub(r-\u003eX, r-\u003eZ, r-\u003eY);\n    fe_add(r-\u003eY, r-\u003eZ, r-\u003eY);\n    fe_add(r-\u003eZ, t0, r-\u003eT);\n    fe_sub(r-\u003eT, t0, r-\u003eT);\n}","filepath":"libs-ext/openssl/crypto/ec/curve25519.c","line_number":1987,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"270091664":{"score":0.76532096,"function_name":"ge_p2_dbl","code":"static void ge_p2_dbl(ge_p1p1 *r, const ge_p2 *p)\n{\n    fe t0;\n\n    fe_sq(r-\u003eX, p-\u003eX);\n    fe_sq(r-\u003eZ, p-\u003eY);\n    fe_sq2(r-\u003eT, p-\u003eZ);\n    fe_add(r-\u003eY, p-\u003eX, p-\u003eY);\n    fe_sq(t0, r-\u003eY);\n    fe_add(r-\u003eY, r-\u003eZ, r-\u003eX);\n    fe_sub(r-\u003eZ, r-\u003eZ, r-\u003eX);\n    fe_sub(r-\u003eX, t0, r-\u003eY);\n    fe_sub(r-\u003eT, r-\u003eT, r-\u003eZ);\n}","filepath":"libs-ext/openssl/crypto/ec/curve25519.c","line_number":1963,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"270092608":{"score":0.9073678,"function_name":"ge_p3_tobytes","code":"static void ge_p3_tobytes(uint8_t *s, const ge_p3 *h)\n{\n    fe recip;\n    fe x;\n    fe y;\n\n    fe_invert(recip, h-\u003eZ);\n    fe_mul(x, h-\u003eX, recip);\n    fe_mul(y, h-\u003eY, recip);\n    fe_tobytes(s, y);\n    s[31] ^= fe_isnegative(x) \u003c\u003c 7;\n}","filepath":"libs-ext/openssl/crypto/ec/curve25519.c","line_number":1834,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"270092736":{"score":0.682059,"function_name":"ge_scalarmult_base","code":"static void ge_scalarmult_base(ge_p3 *h, const uint8_t *a)\n{\n    signed char e[64];\n    signed char carry;\n    ge_p1p1 r;\n    ge_p2 s;\n    ge_precomp t;\n    int i;\n\n    for (i = 0; i \u003c 32; ++i) {\n        e[2 * i + 0] = (a[i] \u003e\u003e 0) \u0026 15;\n        e[2 * i + 1] = (a[i] \u003e\u003e 4) \u0026 15;\n    }\n    /* each e[i] is between 0 and 15 */\n    /* e[63] is between 0 and 7 */\n\n    carry = 0;\n    for (i = 0; i \u003c 63; ++i) {\n        e[i] += carry;\n        carry = e[i] + 8;\n        carry \u003e\u003e= 4;\n        e[i] -= carry \u003c\u003c 4;\n    }\n    e[63] += carry;\n    /* each e[i] is between -8 and 8 */\n\n    ge_p3_0(h);\n    for (i = 1; i \u003c 64; i += 2) {\n        table_select(\u0026t, i / 2, e[i]);\n        ge_madd(\u0026r, h, \u0026t);\n        ge_p1p1_to_p3(h, \u0026r);\n    }\n\n    ge_p3_dbl(\u0026r, h);\n    ge_p1p1_to_p2(\u0026s, \u0026r);\n    ge_p2_dbl(\u0026r, \u0026s);\n    ge_p1p1_to_p2(\u0026s, \u0026r);\n    ge_p2_dbl(\u0026r, \u0026s);\n    ge_p1p1_to_p2(\u0026s, \u0026r);\n    ge_p2_dbl(\u0026r, \u0026s);\n    ge_p1p1_to_p3(h, \u0026r);\n\n    for (i = 0; i \u003c 64; i += 2) {\n        table_select(\u0026t, i / 2, e[i]);\n        ge_madd(\u0026r, h, \u0026t);\n        ge_p1p1_to_p3(h, \u0026r);\n    }\n\n    OPENSSL_cleanse(e, sizeof(e));\n}","filepath":"libs-ext/openssl/crypto/ec/curve25519.c","line_number":4228,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"270094592":{"score":0.83486867,"function_name":"sc_muladd","code":"static void sc_muladd(uint8_t *s, const uint8_t *a, const uint8_t *b,\n                      const uint8_t *c)\n{\n    int64_t a0  = kBottom21Bits \u0026  load_3(a);\n    int64_t a1  = kBottom21Bits \u0026 (load_4(a +  2) \u003e\u003e 5);\n    int64_t a2  = kBottom21Bits \u0026 (load_3(a +  5) \u003e\u003e 2);\n    int64_t a3  = kBottom21Bits \u0026 (load_4(a +  7) \u003e\u003e 7);\n    int64_t a4  = kBottom21Bits \u0026 (load_4(a + 10) \u003e\u003e 4);\n    int64_t a5  = kBottom21Bits \u0026 (load_3(a + 13) \u003e\u003e 1);\n    int64_t a6  = kBottom21Bits \u0026 (load_4(a + 15) \u003e\u003e 6);\n    int64_t a7  = kBottom21Bits \u0026 (load_3(a + 18) \u003e\u003e 3);\n    int64_t a8  = kBottom21Bits \u0026  load_3(a + 21);\n    int64_t a9  = kBottom21Bits \u0026 (load_4(a + 23) \u003e\u003e 5);\n    int64_t a10 = kBottom21Bits \u0026 (load_3(a + 26) \u003e\u003e 2);\n    int64_t a11 =                 (load_4(a + 28) \u003e\u003e 7);\n    int64_t b0  = kBottom21Bits \u0026  load_3(b);\n    int64_t b1  = kBottom21Bits \u0026 (load_4(b +  2) \u003e\u003e 5);\n    int64_t b2  = kBottom21Bits \u0026 (load_3(b +  5) \u003e\u003e 2);\n    int64_t b3  = kBottom21Bits \u0026 (load_4(b +  7) \u003e\u003e 7);\n    int64_t b4  = kBottom21Bits \u0026 (load_4(b + 10) \u003e\u003e 4);\n    int64_t b5  = kBottom21Bits \u0026 (load_3(b + 13) \u003e\u003e 1);\n    int64_t b6  = kBottom21Bits \u0026 (load_4(b + 15) \u003e\u003e 6);\n    int64_t b7  = kBottom21Bits \u0026 (load_3(b + 18) \u003e\u003e 3);\n    int64_t b8  = kBottom21Bits \u0026  load_3(b + 21);\n    int64_t b9  = kBottom21Bits \u0026 (load_4(b + 23) \u003e\u003e 5);\n    int64_t b10 = kBottom21Bits \u0026 (load_3(b + 26) \u003e\u003e 2);\n    int64_t b11 =                 (load_4(b + 28) \u003e\u003e 7);\n    int64_t c0  = kBottom21Bits \u0026  load_3(c);\n    int64_t c1  = kBottom21Bits \u0026 (load_4(c +  2) \u003e\u003e 5);\n    int64_t c2  = kBottom21Bits \u0026 (load_3(c +  5) \u003e\u003e 2);\n    int64_t c3  = kBottom21Bits \u0026 (load_4(c +  7) \u003e\u003e 7);\n    int64_t c4  = kBottom21Bits \u0026 (load_4(c + 10) \u003e\u003e 4);\n    int64_t c5  = kBottom21Bits \u0026 (load_3(c + 13) \u003e\u003e 1);\n    int64_t c6  = kBottom21Bits \u0026 (load_4(c + 15) \u003e\u003e 6);\n    int64_t c7  = kBottom21Bits \u0026 (load_3(c + 18) \u003e\u003e 3);\n    int64_t c8  = kBottom21Bits \u0026  load_3(c + 21);\n    int64_t c9  = kBottom21Bits \u0026 (load_4(c + 23) \u003e\u003e 5);\n    int64_t c10 = kBottom21Bits \u0026 (load_3(c + 26) \u003e\u003e 2);\n    int64_t c11 =                 (load_4(c + 28) \u003e\u003e 7);\n    int64_t s0;\n    int64_t s1;\n    int64_t s2;\n    int64_t s3;\n    int64_t s4;\n    int64_t s5;\n    int64_t s6;\n    int64_t s7;\n    int64_t s8;\n    int64_t s9;\n    int64_t s10;\n    int64_t s11;\n    int64_t s12;\n    int64_t s13;\n    int64_t s14;\n    int64_t s15;\n    int64_t s16;\n    int64_t s17;\n    int64_t s18;\n    int64_t s19;\n    int64_t s20;\n    int64_t s21;\n    int64_t s22;\n    int64_t s23;\n    int64_t carry0;\n    int64_t carry1;\n    int64_t carry2;\n    int64_t carry3;\n    int64_t carry4;\n    int64_t carry5;\n    int64_t carry6;\n    int64_t carry7;\n    int64_t carry8;\n    int64_t carry9;\n    int64_t carry10;\n    int64_t carry11;\n    int64_t carry12;\n    int64_t carry13;\n    int64_t carry14;\n    int64_t carry15;\n    int64_t carry16;\n    int64_t carry17;\n    int64_t carry18;\n    int64_t carry19;\n    int64_t carry20;\n    int64_t carry21;\n    int64_t carry22;\n\n    s0  = c0   +   a0 * b0;\n    s1  = c1   +   a0 * b1   +   a1 * b0;\n    s2  = c2   +   a0 * b2   +   a1 * b1   +   a2 * b0;\n    s3  = c3   +   a0 * b3   +   a1 * b2   +   a2 * b1  +   a3 * b0;\n    s4  = c4   +   a0 * b4   +   a1 * b3   +   a2 * b2  +   a3 * b1  +   a4 * b0;\n    s5  = c5   +   a0 * b5   +   a1 * b4   +   a2 * b3  +   a3 * b2  +   a4 * b1  +   a5 * b0;\n    s6  = c6   +   a0 * b6   +   a1 * b5   +   a2 * b4  +   a3 * b3  +   a4 * b2  +   a5 * b1 +   a6 * b0;\n    s7  = c7   +   a0 * b7   +   a1 * b6   +   a2 * b5  +   a3 * b4  +   a4 * b3  +   a5 * b2 +   a6 * b1   +   a7 * b0;\n    s8  = c8   +   a0 * b8   +   a1 * b7   +   a2 * b6  +   a3 * b5  +   a4 * b4  +   a5 * b3 +   a6 * b2   +   a7 * b1   +   a8 * b0;\n    s9  = c9   +   a0 * b9   +   a1 * b8   +   a2 * b7  +   a3 * b6  +   a4 * b5  +   a5 * b4 +   a6 * b3   +   a7 * b2   +   a8 * b1  +   a9 * b0;\n    s10 = c10  +   a0 * b10  +   a1 * b9   +   a2 * b8  +   a3 * b7  +   a4 * b6  +   a5 * b5 +   a6 * b4   +   a7 * b3   +   a8 * b2  +   a9 * b1  +  a10 * b0;\n    s11 = c11  +   a0 * b11  +   a1 * b10  +   a2 * b9  +   a3 * b8  +   a4 * b7  +   a5 * b6 +   a6 * b5   +   a7 * b4   +   a8 * b3  +   a9 * b2  +  a10 * b1  +  a11 * b0;\n    s12 =          a1 * b11  +   a2 * b10  +   a3 * b9  +   a4 * b8  +   a5 * b7  +   a6 * b6 +   a7 * b5   +   a8 * b4   +   a9 * b3  +  a10 * b2  +  a11 * b1;\n    s13 =          a2 * b11  +   a3 * b10  +   a4 * b9  +   a5 * b8  +   a6 * b7  +   a7 * b6 +   a8 * b5   +   a9 * b4   +  a10 * b3  +  a11 * b2;\n    s14 =          a3 * b11  +   a4 * b10  +   a5 * b9  +   a6 * b8  +   a7 * b7  +   a8 * b6 +   a9 * b5   +  a10 * b4   +  a11 * b3;\n    s15 =          a4 * b11  +   a5 * b10  +   a6 * b9  +   a7 * b8  +   a8 * b7  +   a9 * b6 +  a10 * b5   +  a11 * b4;\n    s16 =          a5 * b11  +   a6 * b10  +   a7 * b9  +   a8 * b8  +   a9 * b7  +  a10 * b6 +  a11 * b5;\n    s17 =          a6 * b11  +   a7 * b10  +   a8 * b9  +   a9 * b8  +  a10 * b7  +  a11 * b6;\n    s18 =          a7 * b11  +   a8 * b10  +   a9 * b9  +  a10 * b8  +  a11 * b7;\n    s19 =          a8 * b11  +   a9 * b10  +  a10 * b9  +  a11 * b8;\n    s20 =          a9 * b11  +  a10 * b10  +  a11 * b9;\n    s21 =         a10 * b11  +  a11 * b10;\n    s22 =         a11 * b11;\n    s23 =         0;\n\n    carry0 = (s0 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s1  += carry0;\n    s0  -= carry0 * (1 \u003c\u003c 21);\n    carry2 = (s2 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s3  += carry2;\n    s2  -= carry2 * (1 \u003c\u003c 21);\n    carry4 = (s4 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s5  += carry4;\n    s4  -= carry4 * (1 \u003c\u003c 21);\n    carry6 = (s6 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s7  += carry6;\n    s6  -= carry6 * (1 \u003c\u003c 21);\n    carry8 = (s8 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s9  += carry8;\n    s8  -= carry8 * (1 \u003c\u003c 21);\n    carry10 = (s10 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s11 += carry10;\n    s10 -= carry10 * (1 \u003c\u003c 21);\n    carry12 = (s12 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s13 += carry12;\n    s12 -= carry12 * (1 \u003c\u003c 21);\n    carry14 = (s14 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s15 += carry14;\n    s14 -= carry14 * (1 \u003c\u003c 21);\n    carry16 = (s16 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s17 += carry16;\n    s16 -= carry16 * (1 \u003c\u003c 21);\n    carry18 = (s18 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s19 += carry18;\n    s18 -= carry18 * (1 \u003c\u003c 21);\n    carry20 = (s20 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s21 += carry20;\n    s20 -= carry20 * (1 \u003c\u003c 21);\n    carry22 = (s22 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s23 += carry22;\n    s22 -= carry22 * (1 \u003c\u003c 21);\n\n    carry1 = (s1 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s2  += carry1;\n    s1  -= carry1 * (1 \u003c\u003c 21);\n    carry3 = (s3 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s4  += carry3;\n    s3  -= carry3 * (1 \u003c\u003c 21);\n    carry5 = (s5 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s6  += carry5;\n    s5  -= carry5 * (1 \u003c\u003c 21);\n    carry7 = (s7 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s8  += carry7;\n    s7  -= carry7 * (1 \u003c\u003c 21);\n    carry9 = (s9 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s10 += carry9;\n    s9  -= carry9 * (1 \u003c\u003c 21);\n    carry11 = (s11 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s12 += carry11;\n    s11 -= carry11 * (1 \u003c\u003c 21);\n    carry13 = (s13 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s14 += carry13;\n    s13 -= carry13 * (1 \u003c\u003c 21);\n    carry15 = (s15 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s16 += carry15;\n    s15 -= carry15 * (1 \u003c\u003c 21);\n    carry17 = (s17 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s18 += carry17;\n    s17 -= carry17 * (1 \u003c\u003c 21);\n    carry19 = (s19 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s20 += carry19;\n    s19 -= carry19 * (1 \u003c\u003c 21);\n    carry21 = (s21 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s22 += carry21;\n    s21 -= carry21 * (1 \u003c\u003c 21);\n\n    s11 += s23 * 666643;\n    s12 += s23 * 470296;\n    s13 += s23 * 654183;\n    s14 -= s23 * 997805;\n    s15 += s23 * 136657;\n    s16 -= s23 * 683901;\n    s23  = 0;\n\n    s10 += s22 * 666643;\n    s11 += s22 * 470296;\n    s12 += s22 * 654183;\n    s13 -= s22 * 997805;\n    s14 += s22 * 136657;\n    s15 -= s22 * 683901;\n    s22  = 0;\n\n    s9  += s21 * 666643;\n    s10 += s21 * 470296;\n    s11 += s21 * 654183;\n    s12 -= s21 * 997805;\n    s13 += s21 * 136657;\n    s14 -= s21 * 683901;\n    s21  = 0;\n\n    s8  += s20 * 666643;\n    s9  += s20 * 470296;\n    s10 += s20 * 654183;\n    s11 -= s20 * 997805;\n    s12 += s20 * 136657;\n    s13 -= s20 * 683901;\n    s20  = 0;\n\n    s7  += s19 * 666643;\n    s8  += s19 * 470296;\n    s9  += s19 * 654183;\n    s10 -= s19 * 997805;\n    s11 += s19 * 136657;\n    s12 -= s19 * 683901;\n    s19  = 0;\n\n    s6  += s18 * 666643;\n    s7  += s18 * 470296;\n    s8  += s18 * 654183;\n    s9  -= s18 * 997805;\n    s10 += s18 * 136657;\n    s11 -= s18 * 683901;\n    s18  = 0;\n\n    carry6 = (s6 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s7  += carry6;\n    s6  -= carry6 * (1 \u003c\u003c 21);\n    carry8 = (s8 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s9  += carry8;\n    s8  -= carry8 * (1 \u003c\u003c 21);\n    carry10 = (s10 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s11 += carry10;\n    s10 -= carry10 * (1 \u003c\u003c 21);\n    carry12 = (s12 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s13 += carry12;\n    s12 -= carry12 * (1 \u003c\u003c 21);\n    carry14 = (s14 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s15 += carry14;\n    s14 -= carry14 * (1 \u003c\u003c 21);\n    carry16 = (s16 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s17 += carry16;\n    s16 -= carry16 * (1 \u003c\u003c 21);\n\n    carry7 = (s7 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s8  += carry7;\n    s7  -= carry7 * (1 \u003c\u003c 21);\n    carry9 = (s9 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s10 += carry9;\n    s9  -= carry9 * (1 \u003c\u003c 21);\n    carry11 = (s11 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s12 += carry11;\n    s11 -= carry11 * (1 \u003c\u003c 21);\n    carry13 = (s13 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s14 += carry13;\n    s13 -= carry13 * (1 \u003c\u003c 21);\n    carry15 = (s15 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s16 += carry15;\n    s15 -= carry15 * (1 \u003c\u003c 21);\n\n    s5  += s17 * 666643;\n    s6  += s17 * 470296;\n    s7  += s17 * 654183;\n    s8  -= s17 * 997805;\n    s9  += s17 * 136657;\n    s10 -= s17 * 683901;\n    s17  = 0;\n\n    s4  += s16 * 666643;\n    s5  += s16 * 470296;\n    s6  += s16 * 654183;\n    s7  -= s16 * 997805;\n    s8  += s16 * 136657;\n    s9  -= s16 * 683901;\n    s16  = 0;\n\n    s3  += s15 * 666643;\n    s4  += s15 * 470296;\n    s5  += s15 * 654183;\n    s6  -= s15 * 997805;\n    s7  += s15 * 136657;\n    s8  -= s15 * 683901;\n    s15  = 0;\n\n    s2  += s14 * 666643;\n    s3  += s14 * 470296;\n    s4  += s14 * 654183;\n    s5  -= s14 * 997805;\n    s6  += s14 * 136657;\n    s7  -= s14 * 683901;\n    s14  = 0;\n\n    s1  += s13 * 666643;\n    s2  += s13 * 470296;\n    s3  += s13 * 654183;\n    s4  -= s13 * 997805;\n    s5  += s13 * 136657;\n    s6  -= s13 * 683901;\n    s13  = 0;\n\n    s0  += s12 * 666643;\n    s1  += s12 * 470296;\n    s2  += s12 * 654183;\n    s3  -= s12 * 997805;\n    s4  += s12 * 136657;\n    s5  -= s12 * 683901;\n    s12 = 0;\n\n    carry0 = (s0 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s1  += carry0;\n    s0  -= carry0 * (1 \u003c\u003c 21);\n    carry2 = (s2 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s3  += carry2;\n    s2  -= carry2 * (1 \u003c\u003c 21);\n    carry4 = (s4 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s5  += carry4;\n    s4  -= carry4 * (1 \u003c\u003c 21);\n    carry6 = (s6 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s7  += carry6;\n    s6  -= carry6 * (1 \u003c\u003c 21);\n    carry8 = (s8 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s9  += carry8;\n    s8  -= carry8 * (1 \u003c\u003c 21);\n    carry10 = (s10 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s11 += carry10;\n    s10 -= carry10 * (1 \u003c\u003c 21);\n\n    carry1 = (s1 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s2  += carry1;\n    s1  -= carry1 * (1 \u003c\u003c 21);\n    carry3 = (s3 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s4  += carry3;\n    s3  -= carry3 * (1 \u003c\u003c 21);\n    carry5 = (s5 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s6  += carry5;\n    s5  -= carry5 * (1 \u003c\u003c 21);\n    carry7 = (s7 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s8  += carry7;\n    s7  -= carry7 * (1 \u003c\u003c 21);\n    carry9 = (s9 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s10 += carry9;\n    s9  -= carry9 * (1 \u003c\u003c 21);\n    carry11 = (s11 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s12 += carry11;\n    s11 -= carry11 * (1 \u003c\u003c 21);\n\n    s0  += s12 * 666643;\n    s1  += s12 * 470296;\n    s2  += s12 * 654183;\n    s3  -= s12 * 997805;\n    s4  += s12 * 136657;\n    s5  -= s12 * 683901;\n    s12  = 0;\n\n    carry0 = s0 \u003e\u003e 21;\n    s1  += carry0;\n    s0  -= carry0 * (1 \u003c\u003c 21);\n    carry1 = s1 \u003e\u003e 21;\n    s2  += carry1;\n    s1  -= carry1 * (1 \u003c\u003c 21);\n    carry2 = s2 \u003e\u003e 21;\n    s3  += carry2;\n    s2  -= carry2 * (1 \u003c\u003c 21);\n    carry3 = s3 \u003e\u003e 21;\n    s4  += carry3;\n    s3  -= carry3 * (1 \u003c\u003c 21);\n    carry4 = s4 \u003e\u003e 21;\n    s5  += carry4;\n    s4  -= carry4 * (1 \u003c\u003c 21);\n    carry5 = s5 \u003e\u003e 21;\n    s6  += carry5;\n    s5  -= carry5 * (1 \u003c\u003c 21);\n    carry6 = s6 \u003e\u003e 21;\n    s7  += carry6;\n    s6  -= carry6 * (1 \u003c\u003c 21);\n    carry7 = s7 \u003e\u003e 21;\n    s8  += carry7;\n    s7  -= carry7 * (1 \u003c\u003c 21);\n    carry8 = s8 \u003e\u003e 21;\n    s9  += carry8;\n    s8  -= carry8 * (1 \u003c\u003c 21);\n    carry9 = s9 \u003e\u003e 21;\n    s10 += carry9;\n    s9  -= carry9 * (1 \u003c\u003c 21);\n    carry10 = s10 \u003e\u003e 21;\n    s11 += carry10;\n    s10 -= carry10 * (1 \u003c\u003c 21);\n    carry11 = s11 \u003e\u003e 21;\n    s12 += carry11;\n    s11 -= carry11 * (1 \u003c\u003c 21);\n\n    s0  += s12 * 666643;\n    s1  += s12 * 470296;\n    s2  += s12 * 654183;\n    s3  -= s12 * 997805;\n    s4  += s12 * 136657;\n    s5  -= s12 * 683901;\n    s12  = 0;\n\n    carry0 = s0 \u003e\u003e 21;\n    s1  += carry0;\n    s0  -= carry0 * (1 \u003c\u003c 21);\n    carry1 = s1 \u003e\u003e 21;\n    s2  += carry1;\n    s1  -= carry1 * (1 \u003c\u003c 21);\n    carry2 = s2 \u003e\u003e 21;\n    s3  += carry2;\n    s2  -= carry2 * (1 \u003c\u003c 21);\n    carry3 = s3 \u003e\u003e 21;\n    s4  += carry3;\n    s3  -= carry3 * (1 \u003c\u003c 21);\n    carry4 = s4 \u003e\u003e 21;\n    s5  += carry4;\n    s4  -= carry4 * (1 \u003c\u003c 21);\n    carry5 = s5 \u003e\u003e 21;\n    s6  += carry5;\n    s5  -= carry5 * (1 \u003c\u003c 21);\n    carry6 = s6 \u003e\u003e 21;\n    s7  += carry6;\n    s6  -= carry6 * (1 \u003c\u003c 21);\n    carry7 = s7 \u003e\u003e 21;\n    s8  += carry7;\n    s7  -= carry7 * (1 \u003c\u003c 21);\n    carry8 = s8 \u003e\u003e 21;\n    s9  += carry8;\n    s8  -= carry8 * (1 \u003c\u003c 21);\n    carry9 = s9 \u003e\u003e 21;\n    s10 += carry9;\n    s9  -= carry9 * (1 \u003c\u003c 21);\n    carry10 = s10 \u003e\u003e 21;\n    s11 += carry10;\n    s10 -= carry10 * (1 \u003c\u003c 21);\n\n    s[ 0] = (uint8_t) (s0  \u003e\u003e  0);\n    s[ 1] = (uint8_t) (s0  \u003e\u003e  8);\n    s[ 2] = (uint8_t)((s0  \u003e\u003e 16) | (s1 \u003c\u003c 5));\n    s[ 3] = (uint8_t) (s1  \u003e\u003e  3);\n    s[ 4] = (uint8_t) (s1  \u003e\u003e 11);\n    s[ 5] = (uint8_t)((s1  \u003e\u003e 19) | (s2 \u003c\u003c 2));\n    s[ 6] = (uint8_t) (s2  \u003e\u003e  6);\n    s[ 7] = (uint8_t)((s2  \u003e\u003e 14) | (s3 \u003c\u003c 7));\n    s[ 8] = (uint8_t) (s3  \u003e\u003e  1);\n    s[ 9] = (uint8_t) (s3  \u003e\u003e  9);\n    s[10] = (uint8_t)((s3  \u003e\u003e 17) | (s4 \u003c\u003c 4));\n    s[11] = (uint8_t) (s4  \u003e\u003e  4);\n    s[12] = (uint8_t) (s4  \u003e\u003e 12);\n    s[13] = (uint8_t)((s4  \u003e\u003e 20) | (s5 \u003c\u003c 1));\n    s[14] = (uint8_t) (s5  \u003e\u003e  7);\n    s[15] = (uint8_t)((s5  \u003e\u003e 15) | (s6 \u003c\u003c 6));\n    s[16] = (uint8_t) (s6  \u003e\u003e  2);\n    s[17] = (uint8_t) (s6  \u003e\u003e 10);\n    s[18] = (uint8_t)((s6  \u003e\u003e 18) | (s7 \u003c\u003c 3));\n    s[19] = (uint8_t) (s7  \u003e\u003e  5);\n    s[20] = (uint8_t) (s7  \u003e\u003e 13);\n    s[21] = (uint8_t) (s8  \u003e\u003e  0);\n    s[22] = (uint8_t) (s8  \u003e\u003e  8);\n    s[23] = (uint8_t)((s8  \u003e\u003e 16) | (s9 \u003c\u003c 5));\n    s[24] = (uint8_t) (s9  \u003e\u003e  3);\n    s[25] = (uint8_t) (s9  \u003e\u003e 11);\n    s[26] = (uint8_t)((s9  \u003e\u003e 19) | (s10 \u003c\u003c 2));\n    s[27] = (uint8_t) (s10 \u003e\u003e  6);\n    s[28] = (uint8_t)((s10 \u003e\u003e 14) | (s11 \u003c\u003c 7));\n    s[29] = (uint8_t) (s11 \u003e\u003e  1);\n    s[30] = (uint8_t) (s11 \u003e\u003e  9);\n    s[31] = (uint8_t) (s11 \u003e\u003e 17);\n}","filepath":"libs-ext/openssl/crypto/ec/curve25519.c","line_number":4959,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"270110960":{"score":0.8547959,"function_name":"slide","code":"static void slide(signed char *r, const uint8_t *a)\n{\n    int i;\n    int b;\n    int k;\n\n    for (i = 0; i \u003c 256; ++i) {\n        r[i] = 1 \u0026 (a[i \u003e\u003e 3] \u003e\u003e (i \u0026 7));\n    }\n\n    for (i = 0; i \u003c 256; ++i) {\n        if (r[i]) {\n            for (b = 1; b \u003c= 6 \u0026\u0026 i + b \u003c 256; ++b) {\n                if (r[i + b]) {\n                    if (r[i] + (r[i + b] \u003c\u003c b) \u003c= 15) {\n                        r[i] += r[i + b] \u003c\u003c b;\n                        r[i + b] = 0;\n                    } else if (r[i] - (r[i + b] \u003c\u003c b) \u003e= -15) {\n                        r[i] -= r[i + b] \u003c\u003c b;\n                        for (k = i + b; k \u003c 256; ++k) {\n                            if (!r[k]) {\n                                r[k] = 1;\n                                break;\n                            }\n                            r[k] = 0;\n                        }\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}","filepath":"libs-ext/openssl/crypto/ec/curve25519.c","line_number":4424,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"270111216":{"score":0.8230641,"function_name":"table_select","code":"static void table_select(ge_precomp *t, int pos, signed char b)\n{\n    ge_precomp minust;\n    uint8_t bnegative = negative(b);\n    uint8_t babs = b - ((uint8_t)((-bnegative) \u0026 b) \u003c\u003c 1);\n\n    ge_precomp_0(t);\n    cmov(t, \u0026k25519Precomp[pos][0], equal(babs, 1));\n    cmov(t, \u0026k25519Precomp[pos][1], equal(babs, 2));\n    cmov(t, \u0026k25519Precomp[pos][2], equal(babs, 3));\n    cmov(t, \u0026k25519Precomp[pos][3], equal(babs, 4));\n    cmov(t, \u0026k25519Precomp[pos][4], equal(babs, 5));\n    cmov(t, \u0026k25519Precomp[pos][5], equal(babs, 6));\n    cmov(t, \u0026k25519Precomp[pos][6], equal(babs, 7));\n    cmov(t, \u0026k25519Precomp[pos][7], equal(babs, 8));\n    fe_copy(minust.yplusx, t-\u003eyminusx);\n    fe_copy(minust.yminusx, t-\u003eyplusx);\n    fe_neg(minust.xy2d, t-\u003exy2d);\n    cmov(t, \u0026minust, bnegative);\n}","filepath":"libs-ext/openssl/crypto/ec/curve25519.c","line_number":4198,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"270112080":{"score":0.91020525,"function_name":"x25519_sc_reduce","code":"static void x25519_sc_reduce(uint8_t *s)\n{\n    int64_t s0  = kBottom21Bits \u0026  load_3(s);\n    int64_t s1  = kBottom21Bits \u0026 (load_4(s +  2) \u003e\u003e 5);\n    int64_t s2  = kBottom21Bits \u0026 (load_3(s +  5) \u003e\u003e 2);\n    int64_t s3  = kBottom21Bits \u0026 (load_4(s +  7) \u003e\u003e 7);\n    int64_t s4  = kBottom21Bits \u0026 (load_4(s + 10) \u003e\u003e 4);\n    int64_t s5  = kBottom21Bits \u0026 (load_3(s + 13) \u003e\u003e 1);\n    int64_t s6  = kBottom21Bits \u0026 (load_4(s + 15) \u003e\u003e 6);\n    int64_t s7  = kBottom21Bits \u0026 (load_3(s + 18) \u003e\u003e 3);\n    int64_t s8  = kBottom21Bits \u0026  load_3(s + 21);\n    int64_t s9  = kBottom21Bits \u0026 (load_4(s + 23) \u003e\u003e 5);\n    int64_t s10 = kBottom21Bits \u0026 (load_3(s + 26) \u003e\u003e 2);\n    int64_t s11 = kBottom21Bits \u0026 (load_4(s + 28) \u003e\u003e 7);\n    int64_t s12 = kBottom21Bits \u0026 (load_4(s + 31) \u003e\u003e 4);\n    int64_t s13 = kBottom21Bits \u0026 (load_3(s + 34) \u003e\u003e 1);\n    int64_t s14 = kBottom21Bits \u0026 (load_4(s + 36) \u003e\u003e 6);\n    int64_t s15 = kBottom21Bits \u0026 (load_3(s + 39) \u003e\u003e 3);\n    int64_t s16 = kBottom21Bits \u0026  load_3(s + 42);\n    int64_t s17 = kBottom21Bits \u0026 (load_4(s + 44) \u003e\u003e 5);\n    int64_t s18 = kBottom21Bits \u0026 (load_3(s + 47) \u003e\u003e 2);\n    int64_t s19 = kBottom21Bits \u0026 (load_4(s + 49) \u003e\u003e 7);\n    int64_t s20 = kBottom21Bits \u0026 (load_4(s + 52) \u003e\u003e 4);\n    int64_t s21 = kBottom21Bits \u0026 (load_3(s + 55) \u003e\u003e 1);\n    int64_t s22 = kBottom21Bits \u0026 (load_4(s + 57) \u003e\u003e 6);\n    int64_t s23 =                 (load_4(s + 60) \u003e\u003e 3);\n    int64_t carry0;\n    int64_t carry1;\n    int64_t carry2;\n    int64_t carry3;\n    int64_t carry4;\n    int64_t carry5;\n    int64_t carry6;\n    int64_t carry7;\n    int64_t carry8;\n    int64_t carry9;\n    int64_t carry10;\n    int64_t carry11;\n    int64_t carry12;\n    int64_t carry13;\n    int64_t carry14;\n    int64_t carry15;\n    int64_t carry16;\n\n    s11 += s23 * 666643;\n    s12 += s23 * 470296;\n    s13 += s23 * 654183;\n    s14 -= s23 * 997805;\n    s15 += s23 * 136657;\n    s16 -= s23 * 683901;\n    s23  = 0;\n\n    s10 += s22 * 666643;\n    s11 += s22 * 470296;\n    s12 += s22 * 654183;\n    s13 -= s22 * 997805;\n    s14 += s22 * 136657;\n    s15 -= s22 * 683901;\n    s22  = 0;\n\n    s9  += s21 * 666643;\n    s10 += s21 * 470296;\n    s11 += s21 * 654183;\n    s12 -= s21 * 997805;\n    s13 += s21 * 136657;\n    s14 -= s21 * 683901;\n    s21  = 0;\n\n    s8  += s20 * 666643;\n    s9  += s20 * 470296;\n    s10 += s20 * 654183;\n    s11 -= s20 * 997805;\n    s12 += s20 * 136657;\n    s13 -= s20 * 683901;\n    s20  = 0;\n\n    s7  += s19 * 666643;\n    s8  += s19 * 470296;\n    s9  += s19 * 654183;\n    s10 -= s19 * 997805;\n    s11 += s19 * 136657;\n    s12 -= s19 * 683901;\n    s19  = 0;\n\n    s6  += s18 * 666643;\n    s7  += s18 * 470296;\n    s8  += s18 * 654183;\n    s9  -= s18 * 997805;\n    s10 += s18 * 136657;\n    s11 -= s18 * 683901;\n    s18  = 0;\n\n    carry6 = (s6 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s7  += carry6;\n    s6  -= carry6 * (1 \u003c\u003c 21);\n    carry8 = (s8 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s9  += carry8;\n    s8  -= carry8 * (1 \u003c\u003c 21);\n    carry10 = (s10 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s11 += carry10;\n    s10 -= carry10 * (1 \u003c\u003c 21);\n    carry12 = (s12 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s13 += carry12;\n    s12 -= carry12 * (1 \u003c\u003c 21);\n    carry14 = (s14 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s15 += carry14;\n    s14 -= carry14 * (1 \u003c\u003c 21);\n    carry16 = (s16 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s17 += carry16;\n    s16 -= carry16 * (1 \u003c\u003c 21);\n\n    carry7 = (s7 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s8  += carry7;\n    s7  -= carry7 * (1 \u003c\u003c 21);\n    carry9 = (s9 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s10 += carry9;\n    s9  -= carry9 * (1 \u003c\u003c 21);\n    carry11 = (s11 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s12 += carry11;\n    s11 -= carry11 * (1 \u003c\u003c 21);\n    carry13 = (s13 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s14 += carry13;\n    s13 -= carry13 * (1 \u003c\u003c 21);\n    carry15 = (s15 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s16 += carry15;\n    s15 -= carry15 * (1 \u003c\u003c 21);\n\n    s5  += s17 * 666643;\n    s6  += s17 * 470296;\n    s7  += s17 * 654183;\n    s8  -= s17 * 997805;\n    s9  += s17 * 136657;\n    s10 -= s17 * 683901;\n    s17  = 0;\n\n    s4  += s16 * 666643;\n    s5  += s16 * 470296;\n    s6  += s16 * 654183;\n    s7  -= s16 * 997805;\n    s8  += s16 * 136657;\n    s9  -= s16 * 683901;\n    s16  = 0;\n\n    s3  += s15 * 666643;\n    s4  += s15 * 470296;\n    s5  += s15 * 654183;\n    s6  -= s15 * 997805;\n    s7  += s15 * 136657;\n    s8  -= s15 * 683901;\n    s15  = 0;\n\n    s2  += s14 * 666643;\n    s3  += s14 * 470296;\n    s4  += s14 * 654183;\n    s5  -= s14 * 997805;\n    s6  += s14 * 136657;\n    s7  -= s14 * 683901;\n    s14  = 0;\n\n    s1  += s13 * 666643;\n    s2  += s13 * 470296;\n    s3  += s13 * 654183;\n    s4  -= s13 * 997805;\n    s5  += s13 * 136657;\n    s6  -= s13 * 683901;\n    s13  = 0;\n\n    s0  += s12 * 666643;\n    s1  += s12 * 470296;\n    s2  += s12 * 654183;\n    s3  -= s12 * 997805;\n    s4  += s12 * 136657;\n    s5  -= s12 * 683901;\n    s12  = 0;\n\n    carry0 = (s0 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s1  += carry0;\n    s0  -= carry0 * (1 \u003c\u003c 21);\n    carry2 = (s2 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s3  += carry2;\n    s2  -= carry2 * (1 \u003c\u003c 21);\n    carry4 = (s4 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s5  += carry4;\n    s4  -= carry4 * (1 \u003c\u003c 21);\n    carry6 = (s6 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s7 += carry6;\n    s6 -= carry6 * (1 \u003c\u003c 21);\n    carry8 = (s8 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s9  += carry8;\n    s8  -= carry8 * (1 \u003c\u003c 21);\n    carry10 = (s10 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s11 += carry10;\n    s10 -= carry10 * (1 \u003c\u003c 21);\n\n    carry1 = (s1 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s2  += carry1;\n    s1  -= carry1 * (1 \u003c\u003c 21);\n    carry3 = (s3 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s4  += carry3;\n    s3  -= carry3 * (1 \u003c\u003c 21);\n    carry5 = (s5 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s6  += carry5;\n    s5  -= carry5 * (1 \u003c\u003c 21);\n    carry7 = (s7 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s8  += carry7;\n    s7  -= carry7 * (1 \u003c\u003c 21);\n    carry9 = (s9 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s10 += carry9;\n    s9  -= carry9 * (1 \u003c\u003c 21);\n    carry11 = (s11 + (1 \u003c\u003c 20)) \u003e\u003e 21;\n    s12 += carry11;\n    s11 -= carry11 * (1 \u003c\u003c 21);\n\n    s0  += s12 * 666643;\n    s1  += s12 * 470296;\n    s2  += s12 * 654183;\n    s3  -= s12 * 997805;\n    s4  += s12 * 136657;\n    s5  -= s12 * 683901;\n    s12  = 0;\n\n    carry0 = s0 \u003e\u003e 21;\n    s1  += carry0;\n    s0  -= carry0 * (1 \u003c\u003c 21);\n    carry1 = s1 \u003e\u003e 21;\n    s2  += carry1;\n    s1  -= carry1 * (1 \u003c\u003c 21);\n    carry2 = s2 \u003e\u003e 21;\n    s3  += carry2;\n    s2  -= carry2 * (1 \u003c\u003c 21);\n    carry3 = s3 \u003e\u003e 21;\n    s4  += carry3;\n    s3  -= carry3 * (1 \u003c\u003c 21);\n    carry4 = s4 \u003e\u003e 21;\n    s5  += carry4;\n    s4  -= carry4 * (1 \u003c\u003c 21);\n    carry5 = s5 \u003e\u003e 21;\n    s6  += carry5;\n    s5  -= carry5 * (1 \u003c\u003c 21);\n    carry6 = s6 \u003e\u003e 21;\n    s7  += carry6;\n    s6  -= carry6 * (1 \u003c\u003c 21);\n    carry7 = s7 \u003e\u003e 21;\n    s8  += carry7;\n    s7  -= carry7 * (1 \u003c\u003c 21);\n    carry8 = s8 \u003e\u003e 21;\n    s9  += carry8;\n    s8  -= carry8 * (1 \u003c\u003c 21);\n    carry9 = s9 \u003e\u003e 21;\n    s10 += carry9;\n    s9  -= carry9 * (1 \u003c\u003c 21);\n    carry10 = s10 \u003e\u003e 21;\n    s11 += carry10;\n    s10 -= carry10 * (1 \u003c\u003c 21);\n    carry11 = s11 \u003e\u003e 21;\n    s12 += carry11;\n    s11 -= carry11 * (1 \u003c\u003c 21);\n\n    s0  += s12 * 666643;\n    s1  += s12 * 470296;\n    s2  += s12 * 654183;\n    s3  -= s12 * 997805;\n    s4  += s12 * 136657;\n    s5  -= s12 * 683901;\n    s12  = 0;\n\n    carry0 = s0 \u003e\u003e 21;\n    s1  += carry0;\n    s0  -= carry0 * (1 \u003c\u003c 21);\n    carry1 = s1 \u003e\u003e 21;\n    s2  += carry1;\n    s1  -= carry1 * (1 \u003c\u003c 21);\n    carry2 = s2 \u003e\u003e 21;\n    s3  += carry2;\n    s2  -= carry2 * (1 \u003c\u003c 21);\n    carry3 = s3 \u003e\u003e 21;\n    s4  += carry3;\n    s3  -= carry3 * (1 \u003c\u003c 21);\n    carry4 = s4 \u003e\u003e 21;\n    s5  += carry4;\n    s4  -= carry4 * (1 \u003c\u003c 21);\n    carry5 = s5 \u003e\u003e 21;\n    s6  += carry5;\n    s5  -= carry5 * (1 \u003c\u003c 21);\n    carry6 = s6 \u003e\u003e 21;\n    s7  += carry6;\n    s6  -= carry6 * (1 \u003c\u003c 21);\n    carry7 = s7 \u003e\u003e 21;\n    s8  += carry7;\n    s7  -= carry7 * (1 \u003c\u003c 21);\n    carry8 = s8 \u003e\u003e 21;\n    s9  += carry8;\n    s8  -= carry8 * (1 \u003c\u003c 21);\n    carry9 = s9 \u003e\u003e 21;\n    s10 += carry9;\n    s9  -= carry9 * (1 \u003c\u003c 21);\n    carry10 = s10 \u003e\u003e 21;\n    s11 += carry10;\n    s10 -= carry10 * (1 \u003c\u003c 21);\n\n    s[ 0] = (uint8_t) (s0  \u003e\u003e  0);\n    s[ 1] = (uint8_t) (s0  \u003e\u003e  8);\n    s[ 2] = (uint8_t)((s0  \u003e\u003e 16) | (s1  \u003c\u003c  5));\n    s[ 3] = (uint8_t) (s1  \u003e\u003e  3);\n    s[ 4] = (uint8_t) (s1  \u003e\u003e 11);\n    s[ 5] = (uint8_t)((s1  \u003e\u003e 19) | (s2  \u003c\u003c  2));\n    s[ 6] = (uint8_t) (s2  \u003e\u003e  6);\n    s[ 7] = (uint8_t)((s2  \u003e\u003e 14) | (s3  \u003c\u003c  7));\n    s[ 8] = (uint8_t) (s3  \u003e\u003e  1);\n    s[ 9] = (uint8_t) (s3  \u003e\u003e  9);\n    s[10] = (uint8_t)((s3  \u003e\u003e 17) | (s4  \u003c\u003c  4));\n    s[11] = (uint8_t) (s4  \u003e\u003e  4);\n    s[12] = (uint8_t) (s4  \u003e\u003e 12);\n    s[13] = (uint8_t)((s4  \u003e\u003e 20) | (s5  \u003c\u003c  1));\n    s[14] = (uint8_t) (s5  \u003e\u003e  7);\n    s[15] = (uint8_t)((s5  \u003e\u003e 15) | (s6  \u003c\u003c  6));\n    s[16] = (uint8_t) (s6  \u003e\u003e  2);\n    s[17] = (uint8_t) (s6  \u003e\u003e 10);\n    s[18] = (uint8_t)((s6  \u003e\u003e 18) | (s7  \u003c\u003c  3));\n    s[19] = (uint8_t) (s7  \u003e\u003e  5);\n    s[20] = (uint8_t) (s7  \u003e\u003e 13);\n    s[21] = (uint8_t) (s8  \u003e\u003e  0);\n    s[22] = (uint8_t) (s8  \u003e\u003e  8);\n    s[23] = (uint8_t)((s8  \u003e\u003e 16) | (s9  \u003c\u003c  5));\n    s[24] = (uint8_t) (s9  \u003e\u003e  3);\n    s[25] = (uint8_t) (s9  \u003e\u003e 11);\n    s[26] = (uint8_t)((s9  \u003e\u003e 19) | (s10 \u003c\u003c  2));\n    s[27] = (uint8_t) (s10 \u003e\u003e  6);\n    s[28] = (uint8_t)((s10 \u003e\u003e 14) | (s11 \u003c\u003c  7));\n    s[29] = (uint8_t) (s11 \u003e\u003e  1);\n    s[30] = (uint8_t) (s11 \u003e\u003e  9);\n    s[31] = (uint8_t) (s11 \u003e\u003e 17);\n}","filepath":"libs-ext/openssl/crypto/ec/curve25519.c","line_number":4615,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"270120384":{"score":0.82917607,"function_name":"x25519_scalar_mult_generic","code":"static void x25519_scalar_mult_generic(uint8_t out[32],\n                                       const uint8_t scalar[32],\n                                       const uint8_t point[32]) {\n    fe x1, x2, z2, x3, z3, tmp0, tmp1;\n    uint8_t e[32];\n    unsigned swap = 0;\n    int pos;\n\n    memcpy(e, scalar, 32);\n    e[0] \u0026= 248;\n    e[31] \u0026= 127;\n    e[31] |= 64;\n    fe_frombytes(x1, point);\n    fe_1(x2);\n    fe_0(z2);\n    fe_copy(x3, x1);\n    fe_1(z3);\n\n    for (pos = 254; pos \u003e= 0; --pos) {\n        unsigned b = 1 \u0026 (e[pos / 8] \u003e\u003e (pos \u0026 7));\n        swap ^= b;\n        fe_cswap(x2, x3, swap);\n        fe_cswap(z2, z3, swap);\n        swap = b;\n        fe_sub(tmp0, x3, z3);\n        fe_sub(tmp1, x2, z2);\n        fe_add(x2, x2, z2);\n        fe_add(z2, x3, z3);\n        fe_mul(z3, tmp0, x2);\n        fe_mul(z2, z2, tmp1);\n        fe_sq(tmp0, tmp1);\n        fe_sq(tmp1, x2);\n        fe_add(x3, z3, z2);\n        fe_sub(z2, z3, z2);\n        fe_mul(x2, tmp1, tmp0);\n        fe_sub(tmp1, tmp1, tmp0);\n        fe_sq(z2, z2);\n        fe_mul121666(z3, tmp1);\n        fe_sq(x3, x3);\n        fe_add(tmp0, tmp0, z3);\n        fe_mul(z3, x1, z2);\n        fe_mul(z2, tmp1, tmp0);\n    }\n\n    fe_invert(z2, z2);\n    fe_mul(x2, x2, z2);\n    fe_tobytes(out, x2);\n\n    OPENSSL_cleanse(e, sizeof(e));\n}","filepath":"libs-ext/openssl/crypto/ec/curve25519.c","line_number":4367,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"270122288":{"score":0.8047849,"function_name":"x448_derive_public_key","code":"void x448_derive_public_key(uint8_t out[X_PUBLIC_BYTES],\n                            const uint8_t scalar[X_PRIVATE_BYTES])\n{\n    /* Scalar conditioning */\n    uint8_t scalar2[X_PRIVATE_BYTES];\n    curve448_scalar_t the_scalar;\n    curve448_point_t p;\n    unsigned int i;\n\n    memcpy(scalar2, scalar, sizeof(scalar2));\n    scalar2[0] \u0026= -(uint8_t)COFACTOR;\n\n    scalar2[X_PRIVATE_BYTES - 1] \u0026= ~((0u - 1u) \u003c\u003c ((X_PRIVATE_BITS + 7) % 8));\n    scalar2[X_PRIVATE_BYTES - 1] |= 1 \u003c\u003c ((X_PRIVATE_BITS + 7) % 8);\n\n    curve448_scalar_decode_long(the_scalar, scalar2, sizeof(scalar2));\n\n    /* Compensate for the encoding ratio */\n    for (i = 1; i \u003c X448_ENCODE_RATIO; i \u003c\u003c= 1)\n        curve448_scalar_halve(the_scalar, the_scalar);\n\n    curve448_precomputed_scalarmul(p, curve448_precomputed_base, the_scalar);\n    curve448_point_mul_by_ratio_and_encode_like_x448(out, p);\n    curve448_point_destroy(p);\n}","filepath":"crypto/ec/curve448/curve448.c","line_number":472,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1c"},"270122768":{"score":0.8167561,"function_name":"add_niels_to_pt","code":"static void add_niels_to_pt(curve448_point_t d, const niels_t e,\n                            int before_double)\n{\n    gf a, b, c;\n\n    gf_sub_nr(b, d-\u003ey, d-\u003ex);   /* 3+e */\n    gf_mul(a, e-\u003ea, b);\n    gf_add_nr(b, d-\u003ex, d-\u003ey);   /* 2+e */\n    gf_mul(d-\u003ey, e-\u003eb, b);\n    gf_mul(d-\u003ex, e-\u003ec, d-\u003et);\n    gf_add_nr(c, a, d-\u003ey);      /* 2+e */\n    gf_sub_nr(b, d-\u003ey, a);      /* 3+e */\n    gf_sub_nr(d-\u003ey, d-\u003ez, d-\u003ex); /* 3+e */\n    gf_add_nr(a, d-\u003ex, d-\u003ez);   /* 2+e */\n    gf_mul(d-\u003ez, a, d-\u003ey);\n    gf_mul(d-\u003ex, d-\u003ey, b);\n    gf_mul(d-\u003ey, a, c);\n    if (!before_double)\n        gf_mul(d-\u003et, b, c);\n}","filepath":"crypto/ec/curve448/curve448.c","line_number":124,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1c"},"270123120":{"score":0.72490346,"function_name":"curve448_base_double_scalarmul_non_secret","code":"void curve448_base_double_scalarmul_non_secret(curve448_point_t combo,\n                                               const curve448_scalar_t scalar1,\n                                               const curve448_point_t base2,\n                                               const curve448_scalar_t scalar2)\n{\n    const int table_bits_var = C448_WNAF_VAR_TABLE_BITS;\n    const int table_bits_pre = C448_WNAF_FIXED_TABLE_BITS;\n    struct smvt_control control_var[C448_SCALAR_BITS /\n                                    (C448_WNAF_VAR_TABLE_BITS + 1) + 3];\n    struct smvt_control control_pre[C448_SCALAR_BITS /\n                                    (C448_WNAF_FIXED_TABLE_BITS + 1) + 3];\n    int ncb_pre = recode_wnaf(control_pre, scalar1, table_bits_pre);\n    int ncb_var = recode_wnaf(control_var, scalar2, table_bits_var);\n    pniels_t precmp_var[1 \u003c\u003c C448_WNAF_VAR_TABLE_BITS];\n    int contp = 0, contv = 0, i;\n\n    prepare_wnaf_table(precmp_var, base2, table_bits_var);\n    i = control_var[0].power;\n\n    if (i \u003c 0) {\n        curve448_point_copy(combo, curve448_point_identity);\n        return;\n    }\n    if (i \u003e control_pre[0].power) {\n        pniels_to_pt(combo, precmp_var[control_var[0].addend \u003e\u003e 1]);\n        contv++;\n    } else if (i == control_pre[0].power \u0026\u0026 i \u003e= 0) {\n        pniels_to_pt(combo, precmp_var[control_var[0].addend \u003e\u003e 1]);\n        add_niels_to_pt(combo, curve448_wnaf_base[control_pre[0].addend \u003e\u003e 1],\n                        i);\n        contv++;\n        contp++;\n    } else {\n        i = control_pre[0].power;\n        niels_to_pt(combo, curve448_wnaf_base[control_pre[0].addend \u003e\u003e 1]);\n        contp++;\n    }\n\n    for (i--; i \u003e= 0; i--) {\n        int cv = (i == control_var[contv].power);\n        int cp = (i == control_pre[contp].power);\n\n        point_double_internal(combo, combo, i \u0026\u0026 !(cv || cp));\n\n        if (cv) {\n            assert(control_var[contv].addend);\n\n            if (control_var[contv].addend \u003e 0)\n                add_pniels_to_pt(combo,\n                                 precmp_var[control_var[contv].addend \u003e\u003e 1],\n                                 i \u0026\u0026 !cp);\n            else\n                sub_pniels_from_pt(combo,\n                                   precmp_var[(-control_var[contv].addend)\n                                              \u003e\u003e 1], i \u0026\u0026 !cp);\n            contv++;\n        }\n\n        if (cp) {\n            assert(control_pre[contp].addend);\n\n            if (control_pre[contp].addend \u003e 0)\n                add_niels_to_pt(combo,\n                                curve448_wnaf_base[control_pre[contp].addend\n                                                   \u003e\u003e 1], i);\n            else\n                sub_niels_from_pt(combo,\n                                  curve448_wnaf_base[(-control_pre\n                                                      [contp].addend) \u003e\u003e 1], i);\n            contp++;\n        }\n    }\n\n    /* This function is non-secret, but whatever this is cheap. */\n    OPENSSL_cleanse(control_var, sizeof(control_var));\n    OPENSSL_cleanse(control_pre, sizeof(control_pre));\n    OPENSSL_cleanse(precmp_var, sizeof(precmp_var));\n\n    assert(contv == ncb_var);\n    (void)ncb_var;\n    assert(contp == ncb_pre);\n    (void)ncb_pre;\n}","filepath":"crypto/ec/curve448/curve448.c","line_number":627,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1c"},"270124368":{"score":0.6836653,"function_name":"curve448_point_decode_like_eddsa_and_mul_by_ratio","code":"c448_error_t curve448_point_decode_like_eddsa_and_mul_by_ratio(\n                                curve448_point_t p,\n                                const uint8_t enc[EDDSA_448_PUBLIC_BYTES])\n{\n    uint8_t enc2[EDDSA_448_PUBLIC_BYTES];\n    mask_t low;\n    mask_t succ;\n\n    memcpy(enc2, enc, sizeof(enc2));\n\n    low = ~word_is_zero(enc2[EDDSA_448_PRIVATE_BYTES - 1] \u0026 0x80);\n    enc2[EDDSA_448_PRIVATE_BYTES - 1] \u0026= ~0x80;\n\n    succ = gf_deserialize(p-\u003ey, enc2, 1, 0);\n    succ \u0026= word_is_zero(enc2[EDDSA_448_PRIVATE_BYTES - 1]);\n\n    gf_sqr(p-\u003ex, p-\u003ey);\n    gf_sub(p-\u003ez, ONE, p-\u003ex);    /* num = 1-y^2 */\n    gf_mulw(p-\u003et, p-\u003ex, EDWARDS_D); /* dy^2 */\n    gf_sub(p-\u003et, ONE, p-\u003et);    /* denom = 1-dy^2 or 1-d + dy^2 */\n\n    gf_mul(p-\u003ex, p-\u003ez, p-\u003et);\n    succ \u0026= gf_isr(p-\u003et, p-\u003ex); /* 1/sqrt(num * denom) */\n\n    gf_mul(p-\u003ex, p-\u003et, p-\u003ez);   /* sqrt(num / denom) */\n    gf_cond_neg(p-\u003ex, gf_lobit(p-\u003ex) ^ low);\n    gf_copy(p-\u003ez, ONE);\n\n    {\n        gf a, b, c, d;\n\n        /* 4-isogeny 2xy/(y^2-ax^2), (y^2+ax^2)/(2-y^2-ax^2) */\n        gf_sqr(c, p-\u003ex);\n        gf_sqr(a, p-\u003ey);\n        gf_add(d, c, a);\n        gf_add(p-\u003et, p-\u003ey, p-\u003ex);\n        gf_sqr(b, p-\u003et);\n        gf_sub(b, b, d);\n        gf_sub(p-\u003et, a, c);\n        gf_sqr(p-\u003ex, p-\u003ez);\n        gf_add(p-\u003ez, p-\u003ex, p-\u003ex);\n        gf_sub(a, p-\u003ez, d);\n        gf_mul(p-\u003ex, a, b);\n        gf_mul(p-\u003ez, p-\u003et, a);\n        gf_mul(p-\u003ey, p-\u003et, d);\n        gf_mul(p-\u003et, b, d);\n        OPENSSL_cleanse(a, sizeof(a));\n        OPENSSL_cleanse(b, sizeof(b));\n        OPENSSL_cleanse(c, sizeof(c));\n        OPENSSL_cleanse(d, sizeof(d));\n    }\n\n    OPENSSL_cleanse(enc2, sizeof(enc2));\n    assert(curve448_point_valid(p) || ~succ);\n\n    return c448_succeed_if(mask_to_bool(succ));\n}","filepath":"crypto/ec/curve448/curve448.c","line_number":321,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1c"},"270125056":{"score":0.7332912,"function_name":"curve448_point_eq","code":"c448_bool_t curve448_point_eq(const curve448_point_t p,\n                              const curve448_point_t q)\n{\n    mask_t succ;\n    gf a, b;\n\n    /* equality mod 2-torsion compares x/y */\n    gf_mul(a, p-\u003ey, q-\u003ex);\n    gf_mul(b, q-\u003ey, p-\u003ex);\n    succ = gf_eq(a, b);\n\n    return mask_to_bool(succ);\n}","filepath":"crypto/ec/curve448/curve448.c","line_number":186,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1c"},"270125168":{"score":0.8540771,"function_name":"curve448_point_mul_by_ratio_and_encode_like_eddsa","code":"void curve448_point_mul_by_ratio_and_encode_like_eddsa(\n                                    uint8_t enc[EDDSA_448_PUBLIC_BYTES],\n                                    const curve448_point_t p)\n{\n    gf x, y, z, t;\n    curve448_point_t q;\n\n    /* The point is now on the twisted curve.  Move it to untwisted. */\n    curve448_point_copy(q, p);\n\n    {\n        /* 4-isogeny: 2xy/(y^+x^2), (y^2-x^2)/(2z^2-y^2+x^2) */\n        gf u;\n\n        gf_sqr(x, q-\u003ex);\n        gf_sqr(t, q-\u003ey);\n        gf_add(u, x, t);\n        gf_add(z, q-\u003ey, q-\u003ex);\n        gf_sqr(y, z);\n        gf_sub(y, y, u);\n        gf_sub(z, t, x);\n        gf_sqr(x, q-\u003ez);\n        gf_add(t, x, x);\n        gf_sub(t, t, z);\n        gf_mul(x, t, y);\n        gf_mul(y, z, u);\n        gf_mul(z, u, t);\n        OPENSSL_cleanse(u, sizeof(u));\n    }\n\n    /* Affinize */\n    gf_invert(z, z, 1);\n    gf_mul(t, x, z);\n    gf_mul(x, y, z);\n\n    /* Encode */\n    enc[EDDSA_448_PRIVATE_BYTES - 1] = 0;\n    gf_serialize(enc, x, 1);\n    enc[EDDSA_448_PRIVATE_BYTES - 1] |= 0x80 \u0026 gf_lobit(t);\n\n    OPENSSL_cleanse(x, sizeof(x));\n    OPENSSL_cleanse(y, sizeof(y));\n    OPENSSL_cleanse(z, sizeof(z));\n    OPENSSL_cleanse(t, sizeof(t));\n    curve448_point_destroy(q);\n}","filepath":"crypto/ec/curve448/curve448.c","line_number":274,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1c"},"270125872":{"score":0.676039,"function_name":"curve448_precomputed_scalarmul","code":"void curve448_precomputed_scalarmul(curve448_point_t out,\n                                    const curve448_precomputed_s * table,\n                                    const curve448_scalar_t scalar)\n{\n    unsigned int i, j, k;\n    const unsigned int n = COMBS_N, t = COMBS_T, s = COMBS_S;\n    niels_t ni;\n    curve448_scalar_t scalar1x;\n\n    curve448_scalar_add(scalar1x, scalar, precomputed_scalarmul_adjustment);\n    curve448_scalar_halve(scalar1x, scalar1x);\n\n    for (i = s; i \u003e 0; i--) {\n        if (i != s)\n            point_double_internal(out, out, 0);\n\n        for (j = 0; j \u003c n; j++) {\n            int tab = 0;\n            mask_t invert;\n\n            for (k = 0; k \u003c t; k++) {\n                unsigned int bit = (i - 1) + s * (k + j * t);\n\n                if (bit \u003c C448_SCALAR_BITS)\n                    tab |=\n                        (scalar1x-\u003elimb[bit / WBITS] \u003e\u003e (bit % WBITS) \u0026 1) \u003c\u003c k;\n            }\n\n            invert = (tab \u003e\u003e (t - 1)) - 1;\n            tab ^= invert;\n            tab \u0026= (1 \u003c\u003c (t - 1)) - 1;\n\n            constant_time_lookup_niels(ni, \u0026table-\u003etable[j \u003c\u003c (t - 1)],\n                                       1 \u003c\u003c (t - 1), tab);\n\n            cond_neg_niels(ni, invert);\n            if ((i != s) || j != 0)\n                add_niels_to_pt(out, ni, j == n - 1 \u0026\u0026 i != 1);\n            else\n                niels_to_pt(out, ni);\n        }\n    }\n\n    OPENSSL_cleanse(ni, sizeof(ni));\n    OPENSSL_cleanse(scalar1x, sizeof(scalar1x));\n}","filepath":"crypto/ec/curve448/curve448.c","line_number":227,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1c"},"270126592":{"score":0.6944624,"function_name":"fe51_add","code":"static void fe51_add(fe51 h, const fe51 f, const fe51 g)\n{\n    h[0] = f[0] + g[0];\n    h[1] = f[1] + g[1];\n    h[2] = f[2] + g[2];\n    h[3] = f[3] + g[3];\n    h[4] = f[4] + g[4];\n}","filepath":"libs-ext/openssl/crypto/ec/curve25519.c","line_number":529,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"270127024":{"score":0.8289145,"function_name":"fe51_cswap","code":"static void fe51_cswap(fe51 f, fe51 g, unsigned int b)\n{\n    int i;\n    uint64_t mask = 0 - (uint64_t)b;\n\n    for (i = 0; i \u003c 5; i++) {\n        int64_t x = f[i] ^ g[i];\n        x \u0026= mask;\n        f[i] ^= x;\n        g[i] ^= x;\n    }\n}","filepath":"libs-ext/openssl/crypto/ec/curve25519.c","line_number":578,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"270127440":{"score":0.6888131,"function_name":"pniels_to_pt","code":"static void pniels_to_pt(curve448_point_t e, const pniels_t d)\n{\n    gf eu;\n\n    gf_add(eu, d-\u003en-\u003eb, d-\u003en-\u003ea);\n    gf_sub(e-\u003ey, d-\u003en-\u003eb, d-\u003en-\u003ea);\n    gf_mul(e-\u003et, e-\u003ey, eu);\n    gf_mul(e-\u003ex, d-\u003ez, e-\u003ey);\n    gf_mul(e-\u003ey, d-\u003ez, eu);\n    gf_sqr(e-\u003ez, d-\u003ez);\n}","filepath":"crypto/ec/curve448/curve448.c","line_number":104,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1c"},"270127584":{"score":0.84851664,"function_name":"point_double_internal","code":"static void point_double_internal(curve448_point_t p, const curve448_point_t q,\n                                  int before_double)\n{\n    gf a, b, c, d;\n\n    gf_sqr(c, q-\u003ex);\n    gf_sqr(a, q-\u003ey);\n    gf_add_nr(d, c, a);         /* 2+e */\n    gf_add_nr(p-\u003et, q-\u003ey, q-\u003ex); /* 2+e */\n    gf_sqr(b, p-\u003et);\n    gf_subx_nr(b, b, d, 3);     /* 4+e */\n    gf_sub_nr(p-\u003et, a, c);      /* 3+e */\n    gf_sqr(p-\u003ex, q-\u003ez);\n    gf_add_nr(p-\u003ez, p-\u003ex, p-\u003ex); /* 2+e */\n    gf_subx_nr(a, p-\u003ez, p-\u003et, 4); /* 6+e */\n    if (GF_HEADROOM == 5)\n        gf_weak_reduce(a);      /* or 1+e */\n    gf_mul(p-\u003ex, a, b);\n    gf_mul(p-\u003ez, p-\u003et, a);\n    gf_mul(p-\u003ey, p-\u003et, d);\n    if (!before_double)\n        gf_mul(p-\u003et, b, d);\n}","filepath":"crypto/ec/curve448/curve448.c","line_number":60,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1c"},"270128064":{"score":0.805066,"function_name":"recode_wnaf","code":"static int recode_wnaf(struct smvt_control *control,\n                       /* [nbits/(table_bits + 1) + 3] */\n                       const curve448_scalar_t scalar,\n                       unsigned int table_bits)\n{\n    unsigned int table_size = C448_SCALAR_BITS / (table_bits + 1) + 3;\n    int position = table_size - 1; /* at the end */\n    uint64_t current = scalar-\u003elimb[0] \u0026 0xFFFF;\n    uint32_t mask = (1 \u003c\u003c (table_bits + 1)) - 1;\n    unsigned int w;\n    const unsigned int B_OVER_16 = sizeof(scalar-\u003elimb[0]) / 2;\n    unsigned int n, i;\n\n    /* place the end marker */\n    control[position].power = -1;\n    control[position].addend = 0;\n    position--;\n\n    /*\n     * PERF: Could negate scalar if it's large.  But then would need more cases\n     * in the actual code that uses it, all for an expected reduction of like\n     * 1/5 op. Probably not worth it.\n     */\n\n    for (w = 1; w \u003c (C448_SCALAR_BITS - 1) / 16 + 3; w++) {\n        if (w \u003c (C448_SCALAR_BITS - 1) / 16 + 1) {\n            /* Refill the 16 high bits of current */\n            current += (uint32_t)((scalar-\u003elimb[w / B_OVER_16]\n                       \u003e\u003e (16 * (w % B_OVER_16))) \u003c\u003c 16);\n        }\n\n        while (current \u0026 0xFFFF) {\n            uint32_t pos = NUMTRAILINGZEROS((uint32_t)current);\n            uint32_t odd = (uint32_t)current \u003e\u003e pos;\n            int32_t delta = odd \u0026 mask;\n\n            assert(position \u003e= 0);\n            if (odd \u0026 (1 \u003c\u003c (table_bits + 1)))\n                delta -= (1 \u003c\u003c (table_bits + 1));\n            current -= delta * (1 \u003c\u003c pos);\n            control[position].power = pos + 16 * (w - 1);\n            control[position].addend = delta;\n            position--;\n        }\n        current \u003e\u003e= 16;\n    }\n    assert(current == 0);\n\n    position++;\n    n = table_size - position;\n    for (i = 0; i \u003c n; i++)\n        control[i] = control[i + position];\n\n    return n - 1;\n}","filepath":"crypto/ec/curve448/curve448.c","line_number":543,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1c"},"270128496":{"score":0.8342116,"function_name":"sub_niels_from_pt","code":"static void sub_niels_from_pt(curve448_point_t d, const niels_t e,\n                              int before_double)\n{\n    gf a, b, c;\n\n    gf_sub_nr(b, d-\u003ey, d-\u003ex);   /* 3+e */\n    gf_mul(a, e-\u003eb, b);\n    gf_add_nr(b, d-\u003ex, d-\u003ey);   /* 2+e */\n    gf_mul(d-\u003ey, e-\u003ea, b);\n    gf_mul(d-\u003ex, e-\u003ec, d-\u003et);\n    gf_add_nr(c, a, d-\u003ey);      /* 2+e */\n    gf_sub_nr(b, d-\u003ey, a);      /* 3+e */\n    gf_add_nr(d-\u003ey, d-\u003ez, d-\u003ex); /* 2+e */\n    gf_sub_nr(a, d-\u003ez, d-\u003ex);   /* 3+e */\n    gf_mul(d-\u003ez, a, d-\u003ey);\n    gf_mul(d-\u003ex, d-\u003ey, b);\n    gf_mul(d-\u003ey, a, c);\n    if (!before_double)\n        gf_mul(d-\u003et, b, c);\n}","filepath":"crypto/ec/curve448/curve448.c","line_number":145,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1c"},"270128864":{"score":0.69806963,"function_name":"x448_int","code":"c448_error_t x448_int(uint8_t out[X_PUBLIC_BYTES],\n                      const uint8_t base[X_PUBLIC_BYTES],\n                      const uint8_t scalar[X_PRIVATE_BYTES])\n{\n    gf x1, x2, z2, x3, z3, t1, t2;\n    int t;\n    mask_t swap = 0;\n    mask_t nz;\n\n    (void)gf_deserialize(x1, base, 1, 0);\n    gf_copy(x2, ONE);\n    gf_copy(z2, ZERO);\n    gf_copy(x3, x1);\n    gf_copy(z3, ONE);\n\n    for (t = X_PRIVATE_BITS - 1; t \u003e= 0; t--) {\n        uint8_t sb = scalar[t / 8];\n        mask_t k_t;\n\n        /* Scalar conditioning */\n        if (t / 8 == 0)\n            sb \u0026= -(uint8_t)COFACTOR;\n        else if (t == X_PRIVATE_BITS - 1)\n            sb = -1;\n\n        k_t = (sb \u003e\u003e (t % 8)) \u0026 1;\n        k_t = 0 - k_t;             /* set to all 0s or all 1s */\n\n        swap ^= k_t;\n        gf_cond_swap(x2, x3, swap);\n        gf_cond_swap(z2, z3, swap);\n        swap = k_t;\n\n        /*\n         * The \"_nr\" below skips coefficient reduction. In the following\n         * comments, \"2+e\" is saying that the coefficients are at most 2+epsilon\n         * times the reduction limit.\n         */\n        gf_add_nr(t1, x2, z2);  /* A = x2 + z2 */ /* 2+e */\n        gf_sub_nr(t2, x2, z2);  /* B = x2 - z2 */ /* 3+e */\n        gf_sub_nr(z2, x3, z3);  /* D = x3 - z3 */ /* 3+e */\n        gf_mul(x2, t1, z2);     /* DA */\n        gf_add_nr(z2, z3, x3);  /* C = x3 + z3 */ /* 2+e */\n        gf_mul(x3, t2, z2);     /* CB */\n        gf_sub_nr(z3, x2, x3);  /* DA-CB */ /* 3+e */\n        gf_sqr(z2, z3);         /* (DA-CB)^2 */\n        gf_mul(z3, x1, z2);     /* z3 = x1(DA-CB)^2 */\n        gf_add_nr(z2, x2, x3);  /* (DA+CB) */ /* 2+e */\n        gf_sqr(x3, z2);         /* x3 = (DA+CB)^2 */\n\n        gf_sqr(z2, t1);         /* AA = A^2 */\n        gf_sqr(t1, t2);         /* BB = B^2 */\n        gf_mul(x2, z2, t1);     /* x2 = AA*BB */\n        gf_sub_nr(t2, z2, t1);  /* E = AA-BB */ /* 3+e */\n\n        gf_mulw(t1, t2, -EDWARDS_D); /* E*-d = a24*E */\n        gf_add_nr(t1, t1, z2);  /* AA + a24*E */ /* 2+e */\n        gf_mul(z2, t2, t1);     /* z2 = E(AA+a24*E) */\n    }\n\n    /* Finish */\n    gf_cond_swap(x2, x3, swap);\n    gf_cond_swap(z2, z3, swap);\n    gf_invert(z2, z2, 0);\n    gf_mul(x1, x2, z2);\n    gf_serialize(out, x1, 1);\n    nz = ~gf_eq(x1, ZERO);\n\n    OPENSSL_cleanse(x1, sizeof(x1));\n    OPENSSL_cleanse(x2, sizeof(x2));\n    OPENSSL_cleanse(z2, sizeof(z2));\n    OPENSSL_cleanse(x3, sizeof(x3));\n    OPENSSL_cleanse(z3, sizeof(z3));\n    OPENSSL_cleanse(t1, sizeof(t1));\n    OPENSSL_cleanse(t2, sizeof(t2));\n\n    return c448_succeed_if(mask_to_bool(nz));\n}","filepath":"crypto/ec/curve448/curve448.c","line_number":379,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1c"},"270130592":{"score":0.68794423,"function_name":"c448_ed448_derive_public_key","code":"c448_error_t c448_ed448_derive_public_key(\n                        uint8_t pubkey[EDDSA_448_PUBLIC_BYTES],\n                        const uint8_t privkey[EDDSA_448_PRIVATE_BYTES])\n{\n    /* only this much used for keygen */\n    uint8_t secret_scalar_ser[EDDSA_448_PRIVATE_BYTES];\n    curve448_scalar_t secret_scalar;\n    unsigned int c;\n    curve448_point_t p;\n\n    if (!oneshot_hash(secret_scalar_ser, sizeof(secret_scalar_ser), privkey,\n                      EDDSA_448_PRIVATE_BYTES))\n        return C448_FAILURE;\n\n    clamp(secret_scalar_ser);\n\n    curve448_scalar_decode_long(secret_scalar, secret_scalar_ser,\n                                sizeof(secret_scalar_ser));\n\n    /*\n     * Since we are going to mul_by_cofactor during encoding, divide by it\n     * here. However, the EdDSA base point is not the same as the decaf base\n     * point if the sigma isogeny is in use: the EdDSA base point is on\n     * Etwist_d/(1-d) and the decaf base point is on Etwist_d, and when\n     * converted it effectively picks up a factor of 2 from the isogenies.  So\n     * we might start at 2 instead of 1.\n     */\n    for (c = 1; c \u003c C448_EDDSA_ENCODE_RATIO; c \u003c\u003c= 1)\n        curve448_scalar_halve(secret_scalar, secret_scalar);\n\n    curve448_precomputed_scalarmul(p, curve448_precomputed_base, secret_scalar);\n\n    curve448_point_mul_by_ratio_and_encode_like_eddsa(pubkey, p);\n\n    /* Cleanup */\n    curve448_scalar_destroy(secret_scalar);\n    curve448_point_destroy(p);\n    OPENSSL_cleanse(secret_scalar_ser, sizeof(secret_scalar_ser));\n\n    return C448_SUCCESS;\n}","filepath":"openssl/crypto/ec/curve448/eddsa.c","line_number":83,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.117"},"270130960":{"score":0.7819692,"function_name":"c448_ed448_sign","code":"c448_error_t c448_ed448_sign(\n                        uint8_t signature[EDDSA_448_SIGNATURE_BYTES],\n                        const uint8_t privkey[EDDSA_448_PRIVATE_BYTES],\n                        const uint8_t pubkey[EDDSA_448_PUBLIC_BYTES],\n                        const uint8_t *message, size_t message_len,\n                        uint8_t prehashed, const uint8_t *context,\n                        size_t context_len)\n{\n    curve448_scalar_t secret_scalar;\n    EVP_MD_CTX *hashctx = EVP_MD_CTX_new();\n    c448_error_t ret = C448_FAILURE;\n    curve448_scalar_t nonce_scalar;\n    uint8_t nonce_point[EDDSA_448_PUBLIC_BYTES] = { 0 };\n    unsigned int c;\n    curve448_scalar_t challenge_scalar;\n\n    if (hashctx == NULL)\n        return C448_FAILURE;\n\n    {\n        /*\n         * Schedule the secret key, First EDDSA_448_PRIVATE_BYTES is serialised\n         * secret scalar,next EDDSA_448_PRIVATE_BYTES bytes is the seed.\n         */\n        uint8_t expanded[EDDSA_448_PRIVATE_BYTES * 2];\n\n        if (!oneshot_hash(expanded, sizeof(expanded), privkey,\n                          EDDSA_448_PRIVATE_BYTES))\n            goto err;\n        clamp(expanded);\n        curve448_scalar_decode_long(secret_scalar, expanded,\n                                    EDDSA_448_PRIVATE_BYTES);\n\n        /* Hash to create the nonce */\n        if (!hash_init_with_dom(hashctx, prehashed, 0, context, context_len)\n                || !EVP_DigestUpdate(hashctx,\n                                     expanded + EDDSA_448_PRIVATE_BYTES,\n                                     EDDSA_448_PRIVATE_BYTES)\n                || !EVP_DigestUpdate(hashctx, message, message_len)) {\n            OPENSSL_cleanse(expanded, sizeof(expanded));\n            goto err;\n        }\n        OPENSSL_cleanse(expanded, sizeof(expanded));\n    }\n\n    /* Decode the nonce */\n    {\n        uint8_t nonce[2 * EDDSA_448_PRIVATE_BYTES];\n\n        if (!EVP_DigestFinalXOF(hashctx, nonce, sizeof(nonce)))\n            goto err;\n        curve448_scalar_decode_long(nonce_scalar, nonce, sizeof(nonce));\n        OPENSSL_cleanse(nonce, sizeof(nonce));\n    }\n\n    {\n        /* Scalarmul to create the nonce-point */\n        curve448_scalar_t nonce_scalar_2;\n        curve448_point_t p;\n\n        curve448_scalar_halve(nonce_scalar_2, nonce_scalar);\n        for (c = 2; c \u003c C448_EDDSA_ENCODE_RATIO; c \u003c\u003c= 1)\n            curve448_scalar_halve(nonce_scalar_2, nonce_scalar_2);\n\n        curve448_precomputed_scalarmul(p, curve448_precomputed_base,\n                                       nonce_scalar_2);\n        curve448_point_mul_by_ratio_and_encode_like_eddsa(nonce_point, p);\n        curve448_point_destroy(p);\n        curve448_scalar_destroy(nonce_scalar_2);\n    }\n\n    {\n        uint8_t challenge[2 * EDDSA_448_PRIVATE_BYTES];\n\n        /* Compute the challenge */\n        if (!hash_init_with_dom(hashctx, prehashed, 0, context, context_len)\n                || !EVP_DigestUpdate(hashctx, nonce_point, sizeof(nonce_point))\n                || !EVP_DigestUpdate(hashctx, pubkey, EDDSA_448_PUBLIC_BYTES)\n                || !EVP_DigestUpdate(hashctx, message, message_len)\n                || !EVP_DigestFinalXOF(hashctx, challenge, sizeof(challenge)))\n            goto err;\n\n        curve448_scalar_decode_long(challenge_scalar, challenge,\n                                    sizeof(challenge));\n        OPENSSL_cleanse(challenge, sizeof(challenge));\n    }\n\n    curve448_scalar_mul(challenge_scalar, challenge_scalar, secret_scalar);\n    curve448_scalar_add(challenge_scalar, challenge_scalar, nonce_scalar);\n\n    OPENSSL_cleanse(signature, EDDSA_448_SIGNATURE_BYTES);\n    memcpy(signature, nonce_point, sizeof(nonce_point));\n    curve448_scalar_encode(\u0026signature[EDDSA_448_PUBLIC_BYTES],\n                           challenge_scalar);\n\n    curve448_scalar_destroy(secret_scalar);\n    curve448_scalar_destroy(nonce_scalar);\n    curve448_scalar_destroy(challenge_scalar);\n\n    ret = C448_SUCCESS;\n err:\n    EVP_MD_CTX_free(hashctx);\n    return ret;\n}","filepath":"openssl/crypto/ec/curve448/eddsa.c","line_number":125,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.117"},"270131840":{"score":0.75579387,"function_name":"c448_ed448_verify","code":"c448_error_t c448_ed448_verify(\n                    const uint8_t signature[EDDSA_448_SIGNATURE_BYTES],\n                    const uint8_t pubkey[EDDSA_448_PUBLIC_BYTES],\n                    const uint8_t *message, size_t message_len,\n                    uint8_t prehashed, const uint8_t *context,\n                    uint8_t context_len)\n{\n    curve448_point_t pk_point, r_point;\n    c448_error_t error;\n    curve448_scalar_t challenge_scalar;\n    curve448_scalar_t response_scalar;\n    /* Order in little endian format */\n    static const uint8_t order[] = {\n        0xF3, 0x44, 0x58, 0xAB, 0x92, 0xC2, 0x78, 0x23, 0x55, 0x8F, 0xC5, 0x8D,\n        0x72, 0xC2, 0x6C, 0x21, 0x90, 0x36, 0xD6, 0xAE, 0x49, 0xDB, 0x4E, 0xC4,\n        0xE9, 0x23, 0xCA, 0x7C, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00\n    };\n    int i;\n\n    /*\n     * Check that s (second 57 bytes of the sig) is less than the order. Both\n     * s and the order are in little-endian format. This can be done in\n     * variable time, since if this is not the case the signature if publicly\n     * invalid.\n     */\n    for (i = EDDSA_448_PUBLIC_BYTES - 1; i \u003e= 0; i--) {\n        if (signature[i + EDDSA_448_PUBLIC_BYTES] \u003e order[i])\n            return C448_FAILURE;\n        if (signature[i + EDDSA_448_PUBLIC_BYTES] \u003c order[i])\n            break;\n    }\n    if (i \u003c 0)\n        return C448_FAILURE;\n\n    error =\n        curve448_point_decode_like_eddsa_and_mul_by_ratio(pk_point, pubkey);\n\n    if (C448_SUCCESS != error)\n        return error;\n\n    error =\n        curve448_point_decode_like_eddsa_and_mul_by_ratio(r_point, signature);\n    if (C448_SUCCESS != error)\n        return error;\n\n    {\n        /* Compute the challenge */\n        EVP_MD_CTX *hashctx = EVP_MD_CTX_new();\n        uint8_t challenge[2 * EDDSA_448_PRIVATE_BYTES];\n\n        if (hashctx == NULL\n                || !hash_init_with_dom(hashctx, prehashed, 0, context,\n                                       context_len)\n                || !EVP_DigestUpdate(hashctx, signature, EDDSA_448_PUBLIC_BYTES)\n                || !EVP_DigestUpdate(hashctx, pubkey, EDDSA_448_PUBLIC_BYTES)\n                || !EVP_DigestUpdate(hashctx, message, message_len)\n                || !EVP_DigestFinalXOF(hashctx, challenge, sizeof(challenge))) {\n            EVP_MD_CTX_free(hashctx);\n            return C448_FAILURE;\n        }\n\n        EVP_MD_CTX_free(hashctx);\n        curve448_scalar_decode_long(challenge_scalar, challenge,\n                                    sizeof(challenge));\n        OPENSSL_cleanse(challenge, sizeof(challenge));\n    }\n    curve448_scalar_sub(challenge_scalar, curve448_scalar_zero,\n                        challenge_scalar);\n\n    curve448_scalar_decode_long(response_scalar,\n                                \u0026signature[EDDSA_448_PUBLIC_BYTES],\n                                EDDSA_448_PRIVATE_BYTES);\n\n    /* pk_point = -c(x(P)) + (cx + k)G = kG */\n    curve448_base_double_scalarmul_non_secret(pk_point,\n                                              response_scalar,\n                                              pk_point, challenge_scalar);\n    return c448_succeed_if(curve448_point_eq(pk_point, r_point));\n}","filepath":"openssl/crypto/ec/curve448/eddsa.c","line_number":241,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.117"},"270132352":{"score":0.884416,"function_name":"hash_init_with_dom","code":"static c448_error_t hash_init_with_dom(EVP_MD_CTX *hashctx, uint8_t prehashed,\n                                       uint8_t for_prehash,\n                                       const uint8_t *context,\n                                       size_t context_len)\n{\n    const char *dom_s = \"SigEd448\";\n    uint8_t dom[2];\n\n    if (context_len \u003e UINT8_MAX)\n        return C448_FAILURE;\n\n    dom[0] = (uint8_t)(2 - (prehashed == 0 ? 1 : 0)\n                       - (for_prehash == 0 ? 1 : 0));\n    dom[1] = (uint8_t)context_len;\n\n    if (!EVP_DigestInit_ex(hashctx, EVP_shake256(), NULL)\n            || !EVP_DigestUpdate(hashctx, dom_s, strlen(dom_s))\n            || !EVP_DigestUpdate(hashctx, dom, sizeof(dom))\n            || !EVP_DigestUpdate(hashctx, context, context_len))\n        return C448_FAILURE;\n\n    return C448_SUCCESS;\n}","filepath":"openssl/crypto/ec/curve448/eddsa.c","line_number":48,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.117"},"270132496":{"score":0.87241954,"function_name":"oneshot_hash","code":"static c448_error_t oneshot_hash(uint8_t *out, size_t outlen,\n                                 const uint8_t *in, size_t inlen)\n{\n    EVP_MD_CTX *hashctx = EVP_MD_CTX_new();\n\n    if (hashctx == NULL)\n        return C448_FAILURE;\n\n    if (!EVP_DigestInit_ex(hashctx, EVP_shake256(), NULL)\n            || !EVP_DigestUpdate(hashctx, in, inlen)\n            || !EVP_DigestFinalXOF(hashctx, out, outlen)) {\n        EVP_MD_CTX_free(hashctx);\n        return C448_FAILURE;\n    }\n\n    EVP_MD_CTX_free(hashctx);\n    return C448_SUCCESS;\n}","filepath":"openssl/crypto/ec/curve448/eddsa.c","line_number":22,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.117"},"270132608":{"score":0.7850609,"function_name":"HMAC","code":"unsigned char *HMAC(const EVP_MD *evp_md, const void *key, int key_len,\n                    const unsigned char *d, size_t n, unsigned char *md,\n                    unsigned int *md_len)\n{\n    HMAC_CTX *c = NULL;\n    static unsigned char m[EVP_MAX_MD_SIZE];\n    static const unsigned char dummy_key[1] = {'\\0'};\n\n    if (md == NULL)\n        md = m;\n    if ((c = HMAC_CTX_new()) == NULL)\n        goto err;\n\n    /* For HMAC_Init_ex, NULL key signals reuse. */\n    if (key == NULL \u0026\u0026 key_len == 0) {\n        key = dummy_key;\n    }\n\n    if (!HMAC_Init_ex(c, key, key_len, evp_md, NULL))\n        goto err;\n    if (!HMAC_Update(c, d, n))\n        goto err;\n    if (!HMAC_Final(c, md, md_len))\n        goto err;\n    HMAC_CTX_free(c);\n    return md;\n err:\n    HMAC_CTX_free(c);\n    return NULL;\n}","filepath":"crypto/hmac/hmac.c","line_number":199,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre6"},"270132976":{"score":0.799282,"function_name":"HMAC_CTX_copy","code":"int HMAC_CTX_copy(HMAC_CTX *dctx, HMAC_CTX *sctx)\n{\n    if (!HMAC_CTX_reset(dctx))\n        goto err;\n    if (!EVP_MD_CTX_copy_ex(dctx-\u003ei_ctx, sctx-\u003ei_ctx))\n        goto err;\n    if (!EVP_MD_CTX_copy_ex(dctx-\u003eo_ctx, sctx-\u003eo_ctx))\n        goto err;\n    if (!EVP_MD_CTX_copy_ex(dctx-\u003emd_ctx, sctx-\u003emd_ctx))\n        goto err;\n    memcpy(dctx-\u003ekey, sctx-\u003ekey, HMAC_MAX_MD_CBLOCK);\n    dctx-\u003ekey_length = sctx-\u003ekey_length;\n    dctx-\u003emd = sctx-\u003emd;\n    return 1;\n err:\n    hmac_ctx_cleanup(dctx);\n    return 0;\n}","filepath":"crypto/hmac/hmac.c","line_number":180,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre6"},"270133312":{"score":0.92144585,"function_name":"HMAC_CTX_new","code":"HMAC_CTX *HMAC_CTX_new(void)\n{\n    HMAC_CTX *ctx = OPENSSL_zalloc(sizeof(HMAC_CTX));\n\n    if (ctx != NULL) {\n        if (!HMAC_CTX_reset(ctx)) {\n            HMAC_CTX_free(ctx);\n            return NULL;\n        }\n    }\n    return ctx;\n}","filepath":"crypto/hmac/hmac.c","line_number":124,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre6"},"270133376":{"score":0.7755502,"function_name":"HMAC_CTX_reset","code":"int HMAC_CTX_reset(HMAC_CTX *ctx)\n{\n    hmac_ctx_cleanup(ctx);\n    if (ctx-\u003ei_ctx == NULL)\n        ctx-\u003ei_ctx = EVP_MD_CTX_new();\n    if (ctx-\u003ei_ctx == NULL)\n        goto err;\n    if (ctx-\u003eo_ctx == NULL)\n        ctx-\u003eo_ctx = EVP_MD_CTX_new();\n    if (ctx-\u003eo_ctx == NULL)\n        goto err;\n    if (ctx-\u003emd_ctx == NULL)\n        ctx-\u003emd_ctx = EVP_MD_CTX_new();\n    if (ctx-\u003emd_ctx == NULL)\n        goto err;\n    ctx-\u003emd = NULL;\n    return 1;\n err:\n    hmac_ctx_cleanup(ctx);\n    return 0;\n}","filepath":"crypto/hmac/hmac.c","line_number":158,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre6"},"270133616":{"score":0.71620154,"function_name":"HMAC_Final","code":"int HMAC_Final(HMAC_CTX *ctx, unsigned char *md, unsigned int *len)\n{\n    unsigned int i;\n    unsigned char buf[EVP_MAX_MD_SIZE];\n\n    if (!ctx-\u003emd)\n        goto err;\n\n    if (!EVP_DigestFinal_ex(ctx-\u003emd_ctx, buf, \u0026i))\n        goto err;\n    if (!EVP_MD_CTX_copy_ex(ctx-\u003emd_ctx, ctx-\u003eo_ctx))\n        goto err;\n    if (!EVP_DigestUpdate(ctx-\u003emd_ctx, buf, i))\n        goto err;\n    if (!EVP_DigestFinal_ex(ctx-\u003emd_ctx, md, len))\n        goto err;\n    return 1;\n err:\n    return 0;\n}","filepath":"crypto/hmac/hmac.c","line_number":98,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre6"},"270133792":{"score":0.71760315,"function_name":"HMAC_Init_ex","code":"int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n                 const EVP_MD *md, ENGINE *impl)\n{\n    int i, j, reset = 0;\n    unsigned char pad[HMAC_MAX_MD_CBLOCK];\n\n    /* If we are changing MD then we must have a key */\n    if (md != NULL \u0026\u0026 md != ctx-\u003emd \u0026\u0026 (key == NULL || len \u003c 0))\n        return 0;\n\n    if (md != NULL) {\n        reset = 1;\n        ctx-\u003emd = md;\n    } else if (ctx-\u003emd) {\n        md = ctx-\u003emd;\n    } else {\n        return 0;\n    }\n\n    if (key != NULL) {\n        reset = 1;\n        j = EVP_MD_block_size(md);\n        OPENSSL_assert(j \u003c= (int)sizeof(ctx-\u003ekey));\n        if (j \u003c len) {\n            if (!EVP_DigestInit_ex(ctx-\u003emd_ctx, md, impl))\n                goto err;\n            if (!EVP_DigestUpdate(ctx-\u003emd_ctx, key, len))\n                goto err;\n            if (!EVP_DigestFinal_ex(ctx-\u003emd_ctx, ctx-\u003ekey,\n                                    \u0026ctx-\u003ekey_length))\n                goto err;\n        } else {\n            if (len \u003c 0 || len \u003e (int)sizeof(ctx-\u003ekey))\n                return 0;\n            memcpy(ctx-\u003ekey, key, len);\n            ctx-\u003ekey_length = len;\n        }\n        if (ctx-\u003ekey_length != HMAC_MAX_MD_CBLOCK)\n            memset(\u0026ctx-\u003ekey[ctx-\u003ekey_length], 0,\n                   HMAC_MAX_MD_CBLOCK - ctx-\u003ekey_length);\n    }\n\n    if (reset) {\n        for (i = 0; i \u003c HMAC_MAX_MD_CBLOCK; i++)\n            pad[i] = 0x36 ^ ctx-\u003ekey[i];\n        if (!EVP_DigestInit_ex(ctx-\u003ei_ctx, md, impl))\n            goto err;\n        if (!EVP_DigestUpdate(ctx-\u003ei_ctx, pad, EVP_MD_block_size(md)))\n            goto err;\n\n        for (i = 0; i \u003c HMAC_MAX_MD_CBLOCK; i++)\n            pad[i] = 0x5c ^ ctx-\u003ekey[i];\n        if (!EVP_DigestInit_ex(ctx-\u003eo_ctx, md, impl))\n            goto err;\n        if (!EVP_DigestUpdate(ctx-\u003eo_ctx, pad, EVP_MD_block_size(md)))\n            goto err;\n    }\n    if (!EVP_MD_CTX_copy_ex(ctx-\u003emd_ctx, ctx-\u003ei_ctx))\n        goto err;\n    return 1;\n err:\n    return 0;\n}","filepath":"crypto/hmac/hmac.c","line_number":18,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre6"},"270136592":{"score":0.91468304,"function_name":"RSA_sign","code":"int RSA_sign(int type, const unsigned char *m, unsigned int m_len,\n             unsigned char *sigret, unsigned int *siglen, RSA *rsa)\n{\n    int encrypt_len, encoded_len = 0, ret = 0;\n    unsigned char *tmps = NULL;\n    const unsigned char *encoded = NULL;\n\n    if (rsa-\u003emeth-\u003ersa_sign) {\n        return rsa-\u003emeth-\u003ersa_sign(type, m, m_len, sigret, siglen, rsa);\n    }\n\n    /* Compute the encoded digest. */\n    if (type == NID_md5_sha1) {\n        /*\n         * NID_md5_sha1 corresponds to the MD5/SHA1 combination in TLS 1.1 and\n         * earlier. It has no DigestInfo wrapper but otherwise is\n         * RSASSA-PKCS1-v1_5.\n         */\n        if (m_len != SSL_SIG_LENGTH) {\n            RSAerr(RSA_F_RSA_SIGN, RSA_R_INVALID_MESSAGE_LENGTH);\n            return 0;\n        }\n        encoded_len = SSL_SIG_LENGTH;\n        encoded = m;\n    } else {\n        if (!encode_pkcs1(\u0026tmps, \u0026encoded_len, type, m, m_len))\n            goto err;\n        encoded = tmps;\n    }\n\n    if (encoded_len \u003e RSA_size(rsa) - RSA_PKCS1_PADDING_SIZE) {\n        RSAerr(RSA_F_RSA_SIGN, RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY);\n        goto err;\n    }\n    encrypt_len = RSA_private_encrypt(encoded_len, encoded, sigret, rsa,\n                                      RSA_PKCS1_PADDING);\n    if (encrypt_len \u003c= 0)\n        goto err;\n\n    *siglen = encrypt_len;\n    ret = 1;\n\nerr:\n    OPENSSL_clear_free(tmps, (size_t)encoded_len);\n    return ret;\n}","filepath":"crypto/rsa/rsa_sign.c","line_number":69,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0c"},"270136896":{"score":0.9192989,"function_name":"RSA_verify","code":"int RSA_verify(int type, const unsigned char *m, unsigned int m_len,\n               const unsigned char *sigbuf, unsigned int siglen, RSA *rsa)\n{\n\n    if (rsa-\u003emeth-\u003ersa_verify) {\n        return rsa-\u003emeth-\u003ersa_verify(type, m, m_len, sigbuf, siglen, rsa);\n    }\n\n    return int_rsa_verify(type, m, m_len, NULL, NULL, sigbuf, siglen, rsa);\n}","filepath":"crypto/rsa/rsa_sign.c","line_number":239,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0c"},"270136960":{"score":0.85584897,"function_name":"encode_pkcs1","code":"static int encode_pkcs1(unsigned char **out, int *out_len, int type,\n                        const unsigned char *m, unsigned int m_len)\n{\n    X509_SIG sig;\n    X509_ALGOR algor;\n    ASN1_TYPE parameter;\n    ASN1_OCTET_STRING digest;\n    uint8_t *der = NULL;\n    int len;\n\n    sig.algor = \u0026algor;\n    sig.algor-\u003ealgorithm = OBJ_nid2obj(type);\n    if (sig.algor-\u003ealgorithm == NULL) {\n        RSAerr(RSA_F_ENCODE_PKCS1, RSA_R_UNKNOWN_ALGORITHM_TYPE);\n        return 0;\n    }\n    if (OBJ_length(sig.algor-\u003ealgorithm) == 0) {\n        RSAerr(RSA_F_ENCODE_PKCS1,\n               RSA_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD);\n        return 0;\n    }\n    parameter.type = V_ASN1_NULL;\n    parameter.value.ptr = NULL;\n    sig.algor-\u003eparameter = \u0026parameter;\n\n    sig.digest = \u0026digest;\n    sig.digest-\u003edata = (unsigned char *)m;\n    sig.digest-\u003elength = m_len;\n\n    len = i2d_X509_SIG(\u0026sig, \u0026der);\n    if (len \u003c 0)\n        return 0;\n\n    *out = der;\n    *out_len = len;\n    return 1;\n}","filepath":"crypto/rsa/rsa_sign.c","line_number":31,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0c"},"270137168":{"score":0.8931786,"function_name":"int_rsa_verify","code":"int int_rsa_verify(int type, const unsigned char *m, unsigned int m_len,\n                   unsigned char *rm, size_t *prm_len,\n                   const unsigned char *sigbuf, size_t siglen, RSA *rsa)\n{\n    int decrypt_len, ret = 0, encoded_len = 0;\n    unsigned char *decrypt_buf = NULL, *encoded = NULL;\n\n    if (siglen != (size_t)RSA_size(rsa)) {\n        RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_WRONG_SIGNATURE_LENGTH);\n        return 0;\n    }\n\n    /* Recover the encoded digest. */\n    decrypt_buf = OPENSSL_malloc(siglen);\n    if (decrypt_buf == NULL) {\n        RSAerr(RSA_F_INT_RSA_VERIFY, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    decrypt_len = RSA_public_decrypt((int)siglen, sigbuf, decrypt_buf, rsa,\n                                     RSA_PKCS1_PADDING);\n    if (decrypt_len \u003c= 0)\n        goto err;\n\n    if (type == NID_md5_sha1) {\n        /*\n         * NID_md5_sha1 corresponds to the MD5/SHA1 combination in TLS 1.1 and\n         * earlier. It has no DigestInfo wrapper but otherwise is\n         * RSASSA-PKCS1-v1_5.\n         */\n        if (decrypt_len != SSL_SIG_LENGTH) {\n            RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_BAD_SIGNATURE);\n            goto err;\n        }\n\n        if (rm != NULL) {\n            memcpy(rm, decrypt_buf, SSL_SIG_LENGTH);\n            *prm_len = SSL_SIG_LENGTH;\n        } else {\n            if (m_len != SSL_SIG_LENGTH) {\n                RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_INVALID_MESSAGE_LENGTH);\n                goto err;\n            }\n\n            if (memcmp(decrypt_buf, m, SSL_SIG_LENGTH) != 0) {\n                RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_BAD_SIGNATURE);\n                goto err;\n            }\n        }\n    } else if (type == NID_mdc2 \u0026\u0026 decrypt_len == 2 + 16\n               \u0026\u0026 decrypt_buf[0] == 0x04 \u0026\u0026 decrypt_buf[1] == 0x10) {\n        /*\n         * Oddball MDC2 case: signature can be OCTET STRING. check for correct\n         * tag and length octets.\n         */\n        if (rm != NULL) {\n            memcpy(rm, decrypt_buf + 2, 16);\n            *prm_len = 16;\n        } else {\n            if (m_len != 16) {\n                RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_INVALID_MESSAGE_LENGTH);\n                goto err;\n            }\n\n            if (memcmp(m, decrypt_buf + 2, 16) != 0) {\n                RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_BAD_SIGNATURE);\n                goto err;\n            }\n        }\n    } else {\n        /*\n         * If recovering the digest, extract a digest-sized output from the end\n         * of |decrypt_buf| for |encode_pkcs1|, then compare the decryption\n         * output as in a standard verification.\n         */\n        if (rm != NULL) {\n            const EVP_MD *md = EVP_get_digestbynid(type);\n            if (md == NULL) {\n                RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_UNKNOWN_ALGORITHM_TYPE);\n                goto err;\n            }\n\n            m_len = EVP_MD_size(md);\n            if (m_len \u003e (size_t)decrypt_len) {\n                RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_INVALID_DIGEST_LENGTH);\n                goto err;\n            }\n            m = decrypt_buf + decrypt_len - m_len;\n        }\n\n        /* Construct the encoded digest and ensure it matches. */\n        if (!encode_pkcs1(\u0026encoded, \u0026encoded_len, type, m, m_len))\n            goto err;\n\n        if (encoded_len != decrypt_len\n            || memcmp(encoded, decrypt_buf, encoded_len) != 0) {\n            RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_BAD_SIGNATURE);\n            goto err;\n        }\n\n        /* Output the recovered digest. */\n        if (rm != NULL) {\n            memcpy(rm, m, m_len);\n            *prm_len = m_len;\n        }\n    }\n\n    ret = 1;\n\nerr:\n    OPENSSL_clear_free(encoded, (size_t)encoded_len);\n    OPENSSL_clear_free(decrypt_buf, siglen);\n    return ret;\n}","filepath":"crypto/rsa/rsa_sign.c","line_number":124,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0c"},"270140160":{"score":0.88808215,"function_name":"rsa_pub_encode","code":"static int rsa_pub_encode(X509_PUBKEY *pk, const EVP_PKEY *pkey)\n{\n    unsigned char *penc = NULL;\n    int penclen;\n    ASN1_STRING *str;\n    int strtype;\n\n    if (!rsa_param_encode(pkey, \u0026str, \u0026strtype))\n        return 0;\n    penclen = i2d_RSAPublicKey(pkey-\u003epkey.rsa, \u0026penc);\n    if (penclen \u003c= 0)\n        return 0;\n    if (X509_PUBKEY_set0_param(pk, OBJ_nid2obj(pkey-\u003eameth-\u003epkey_id),\n                               strtype, str, penc, penclen))\n        return 1;\n\n    OPENSSL_free(penc);\n    return 0;\n}","filepath":"crypto/rsa/rsa_ameth.c","line_number":75,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270140320":{"score":0.89394385,"function_name":"rsa_pub_decode","code":"static int rsa_pub_decode(EVP_PKEY *pkey, X509_PUBKEY *pubkey)\n{\n    const unsigned char *p;\n    int pklen;\n    X509_ALGOR *alg;\n    RSA *rsa = NULL;\n\n    if (!X509_PUBKEY_get0_param(NULL, \u0026p, \u0026pklen, \u0026alg, pubkey))\n        return 0;\n    if ((rsa = d2i_RSAPublicKey(NULL, \u0026p, pklen)) == NULL) {\n        RSAerr(RSA_F_RSA_PUB_DECODE, ERR_R_RSA_LIB);\n        return 0;\n    }\n    if (!rsa_param_decode(rsa, alg)) {\n        RSA_free(rsa);\n        return 0;\n    }\n    if (!EVP_PKEY_assign(pkey, pkey-\u003eameth-\u003epkey_id, rsa)) {\n        RSA_free(rsa);\n        return 0;\n    }\n    return 1;\n}","filepath":"crypto/rsa/rsa_ameth.c","line_number":95,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270140688":{"score":0.8910588,"function_name":"rsa_priv_encode","code":"static int rsa_priv_encode(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pkey)\n{\n    unsigned char *rk = NULL;\n    int rklen;\n    ASN1_STRING *str;\n    int strtype;\n\n    if (!rsa_param_encode(pkey, \u0026str, \u0026strtype))\n        return 0;\n    rklen = i2d_RSAPrivateKey(pkey-\u003epkey.rsa, \u0026rk);\n\n    if (rklen \u003c= 0) {\n        RSAerr(RSA_F_RSA_PRIV_ENCODE, ERR_R_MALLOC_FAILURE);\n        ASN1_STRING_free(str);\n        return 0;\n    }\n\n    if (!PKCS8_pkey_set0(p8, OBJ_nid2obj(pkey-\u003eameth-\u003epkey_id), 0,\n                         strtype, str, rk, rklen)) {\n        RSAerr(RSA_F_RSA_PRIV_ENCODE, ERR_R_MALLOC_FAILURE);\n        ASN1_STRING_free(str);\n        return 0;\n    }\n\n    return 1;\n}","filepath":"crypto/rsa/rsa_ameth.c","line_number":145,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270140864":{"score":0.90605396,"function_name":"rsa_priv_decode","code":"static int rsa_priv_decode(EVP_PKEY *pkey, const PKCS8_PRIV_KEY_INFO *p8)\n{\n    const unsigned char *p;\n    RSA *rsa;\n    int pklen;\n    const X509_ALGOR *alg;\n\n    if (!PKCS8_pkey_get0(NULL, \u0026p, \u0026pklen, \u0026alg, p8))\n        return 0;\n    rsa = d2i_RSAPrivateKey(NULL, \u0026p, pklen);\n    if (rsa == NULL) {\n        RSAerr(RSA_F_RSA_PRIV_DECODE, ERR_R_RSA_LIB);\n        return 0;\n    }\n    if (!rsa_param_decode(rsa, alg)) {\n        RSA_free(rsa);\n        return 0;\n    }\n    EVP_PKEY_assign(pkey, pkey-\u003eameth-\u003epkey_id, rsa);\n    return 1;\n}","filepath":"crypto/rsa/rsa_ameth.c","line_number":172,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270141296":{"score":0.8524909,"function_name":"rsa_pkey_ctrl","code":"static int rsa_pkey_ctrl(EVP_PKEY *pkey, int op, long arg1, void *arg2)\n{\n    X509_ALGOR *alg = NULL;\n    const EVP_MD *md;\n    const EVP_MD *mgf1md;\n    int min_saltlen;\n\n    switch (op) {\n\n    case ASN1_PKEY_CTRL_PKCS7_SIGN:\n        if (arg1 == 0)\n            PKCS7_SIGNER_INFO_get0_algs(arg2, NULL, NULL, \u0026alg);\n        break;\n\n    case ASN1_PKEY_CTRL_PKCS7_ENCRYPT:\n        if (pkey_is_pss(pkey))\n            return -2;\n        if (arg1 == 0)\n            PKCS7_RECIP_INFO_get0_alg(arg2, \u0026alg);\n        break;\n#ifndef OPENSSL_NO_CMS\n    case ASN1_PKEY_CTRL_CMS_SIGN:\n        if (arg1 == 0)\n            return rsa_cms_sign(arg2);\n        else if (arg1 == 1)\n            return rsa_cms_verify(arg2);\n        break;\n\n    case ASN1_PKEY_CTRL_CMS_ENVELOPE:\n        if (pkey_is_pss(pkey))\n            return -2;\n        if (arg1 == 0)\n            return rsa_cms_encrypt(arg2);\n        else if (arg1 == 1)\n            return rsa_cms_decrypt(arg2);\n        break;\n\n    case ASN1_PKEY_CTRL_CMS_RI_TYPE:\n        if (pkey_is_pss(pkey))\n            return -2;\n        *(int *)arg2 = CMS_RECIPINFO_TRANS;\n        return 1;\n#endif\n\n    case ASN1_PKEY_CTRL_DEFAULT_MD_NID:\n        if (pkey-\u003epkey.rsa-\u003epss != NULL) {\n            if (!rsa_pss_get_param(pkey-\u003epkey.rsa-\u003epss, \u0026md, \u0026mgf1md,\n                                   \u0026min_saltlen)) {\n                RSAerr(0, ERR_R_INTERNAL_ERROR);\n                return 0;\n            }\n            *(int *)arg2 = EVP_MD_type(md);\n            /* Return of 2 indicates this MD is mandatory */\n            return 2;\n        }\n        *(int *)arg2 = NID_sha256;\n        return 1;\n\n    default:\n        return -2;\n\n    }\n\n    if (alg)\n        X509_ALGOR_set0(alg, OBJ_nid2obj(NID_rsaEncryption), V_ASN1_NULL, 0);\n\n    return 1;\n\n}","filepath":"crypto/rsa/rsa_ameth.c","line_number":458,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270142272":{"score":0.79548866,"function_name":"rsa_item_sign","code":"static int rsa_item_sign(EVP_MD_CTX *ctx, const ASN1_ITEM *it, void *asn,\n                         X509_ALGOR *alg1, X509_ALGOR *alg2,\n                         ASN1_BIT_STRING *sig)\n{\n    int pad_mode;\n    EVP_PKEY_CTX *pkctx = EVP_MD_CTX_pkey_ctx(ctx);\n\n    if (EVP_PKEY_CTX_get_rsa_padding(pkctx, \u0026pad_mode) \u003c= 0)\n        return 0;\n    if (pad_mode == RSA_PKCS1_PADDING)\n        return 2;\n    if (pad_mode == RSA_PKCS1_PSS_PADDING) {\n        ASN1_STRING *os1 = NULL;\n        os1 = rsa_ctx_to_pss_string(pkctx);\n        if (!os1)\n            return 0;\n        /* Duplicate parameters if we have to */\n        if (alg2) {\n            ASN1_STRING *os2 = ASN1_STRING_dup(os1);\n            if (!os2) {\n                ASN1_STRING_free(os1);\n                return 0;\n            }\n            X509_ALGOR_set0(alg2, OBJ_nid2obj(EVP_PKEY_RSA_PSS),\n                            V_ASN1_SEQUENCE, os2);\n        }\n        X509_ALGOR_set0(alg1, OBJ_nid2obj(EVP_PKEY_RSA_PSS),\n                        V_ASN1_SEQUENCE, os1);\n        return 3;\n    }\n    return 2;\n}","filepath":"crypto/rsa/rsa_ameth.c","line_number":817,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270142464":{"score":0.7130043,"function_name":"rsa_sig_info_set","code":"static int rsa_sig_info_set(X509_SIG_INFO *siginf, const X509_ALGOR *sigalg,\n                            const ASN1_STRING *sig)\n{\n    int rv = 0;\n    int mdnid, saltlen;\n    uint32_t flags;\n    const EVP_MD *mgf1md = NULL, *md = NULL;\n    RSA_PSS_PARAMS *pss;\n\n    /* Sanity check: make sure it is PSS */\n    if (OBJ_obj2nid(sigalg-\u003ealgorithm) != EVP_PKEY_RSA_PSS)\n        return 0;\n    /* Decode PSS parameters */\n    pss = rsa_pss_decode(sigalg);\n    if (!rsa_pss_get_param(pss, \u0026md, \u0026mgf1md, \u0026saltlen))\n        goto err;\n    mdnid = EVP_MD_type(md);\n    /*\n     * For TLS need SHA256, SHA384 or SHA512, digest and MGF1 digest must\n     * match and salt length must equal digest size\n     */\n    if ((mdnid == NID_sha256 || mdnid == NID_sha384 || mdnid == NID_sha512)\n            \u0026\u0026 mdnid == EVP_MD_type(mgf1md) \u0026\u0026 saltlen == EVP_MD_size(md))\n        flags = X509_SIG_INFO_TLS;\n    else\n        flags = 0;\n    /* Note: security bits half number of digest bits */\n    X509_SIG_INFO_set(siginf, mdnid, EVP_PKEY_RSA_PSS, EVP_MD_size(md) * 4,\n                      flags);\n    rv = 1;\n    err:\n    RSA_PSS_PARAMS_free(pss);\n    return rv;\n}","filepath":"crypto/rsa/rsa_ameth.c","line_number":850,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270142720":{"score":0.93098193,"function_name":"pkey_rsa_print","code":"static int pkey_rsa_print(BIO *bp, const EVP_PKEY *pkey, int off, int priv)\n{\n    const RSA *x = pkey-\u003epkey.rsa;\n    char *str;\n    const char *s;\n    int ret = 0, mod_len = 0, ex_primes;\n\n    if (x-\u003en != NULL)\n        mod_len = BN_num_bits(x-\u003en);\n    ex_primes = sk_RSA_PRIME_INFO_num(x-\u003eprime_infos);\n\n    if (!BIO_indent(bp, off, 128))\n        goto err;\n\n    if (BIO_printf(bp, \"%s \", pkey_is_pss(pkey) ?  \"RSA-PSS\" : \"RSA\") \u003c= 0)\n        goto err;\n\n    if (priv \u0026\u0026 x-\u003ed) {\n        if (BIO_printf(bp, \"Private-Key: (%d bit, %d primes)\\n\",\n                       mod_len, ex_primes \u003c= 0 ? 2 : ex_primes + 2) \u003c= 0)\n            goto err;\n        str = \"modulus:\";\n        s = \"publicExponent:\";\n    } else {\n        if (BIO_printf(bp, \"Public-Key: (%d bit)\\n\", mod_len) \u003c= 0)\n            goto err;\n        str = \"Modulus:\";\n        s = \"Exponent:\";\n    }\n    if (!ASN1_bn_print(bp, str, x-\u003en, NULL, off))\n        goto err;\n    if (!ASN1_bn_print(bp, s, x-\u003ee, NULL, off))\n        goto err;\n    if (priv) {\n        int i;\n\n        if (!ASN1_bn_print(bp, \"privateExponent:\", x-\u003ed, NULL, off))\n            goto err;\n        if (!ASN1_bn_print(bp, \"prime1:\", x-\u003ep, NULL, off))\n            goto err;\n        if (!ASN1_bn_print(bp, \"prime2:\", x-\u003eq, NULL, off))\n            goto err;\n        if (!ASN1_bn_print(bp, \"exponent1:\", x-\u003edmp1, NULL, off))\n            goto err;\n        if (!ASN1_bn_print(bp, \"exponent2:\", x-\u003edmq1, NULL, off))\n            goto err;\n        if (!ASN1_bn_print(bp, \"coefficient:\", x-\u003eiqmp, NULL, off))\n            goto err;\n        for (i = 0; i \u003c sk_RSA_PRIME_INFO_num(x-\u003eprime_infos); i++) {\n            /* print multi-prime info */\n            BIGNUM *bn = NULL;\n            RSA_PRIME_INFO *pinfo;\n            int j;\n\n            pinfo = sk_RSA_PRIME_INFO_value(x-\u003eprime_infos, i);\n            for (j = 0; j \u003c 3; j++) {\n                if (!BIO_indent(bp, off, 128))\n                    goto err;\n                switch (j) {\n                case 0:\n                    if (BIO_printf(bp, \"prime%d:\", i + 3) \u003c= 0)\n                        goto err;\n                    bn = pinfo-\u003er;\n                    break;\n                case 1:\n                    if (BIO_printf(bp, \"exponent%d:\", i + 3) \u003c= 0)\n                        goto err;\n                    bn = pinfo-\u003ed;\n                    break;\n                case 2:\n                    if (BIO_printf(bp, \"coefficient%d:\", i + 3) \u003c= 0)\n                        goto err;\n                    bn = pinfo-\u003et;\n                    break;\n                default:\n                    break;\n                }\n                if (!ASN1_bn_print(bp, \"\", bn, NULL, off))\n                    goto err;\n            }\n        }\n    }\n    if (pkey_is_pss(pkey) \u0026\u0026 !rsa_pss_param_print(bp, 1, x-\u003epss, off))\n        goto err;\n    ret = 1;\n err:\n    return ret;\n}","filepath":"crypto/rsa/rsa_ameth.c","line_number":317,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270143520":{"score":0.85897,"function_name":"rsa_algor_to_md","code":"static const EVP_MD *rsa_algor_to_md(X509_ALGOR *alg)\n{\n    const EVP_MD *md;\n\n    if (!alg)\n        return EVP_sha1();\n    md = EVP_get_digestbyobj(alg-\u003ealgorithm);\n    if (md == NULL)\n        RSAerr(RSA_F_RSA_ALGOR_TO_MD, RSA_R_UNKNOWN_DIGEST);\n    return md;\n}","filepath":"crypto/rsa/rsa_ameth.c","line_number":568,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270143600":{"score":0.89286,"function_name":"rsa_cms_decrypt","code":"static int rsa_cms_decrypt(CMS_RecipientInfo *ri)\n{\n    EVP_PKEY_CTX *pkctx;\n    X509_ALGOR *cmsalg;\n    int nid;\n    int rv = -1;\n    unsigned char *label = NULL;\n    int labellen = 0;\n    const EVP_MD *mgf1md = NULL, *md = NULL;\n    RSA_OAEP_PARAMS *oaep;\n\n    pkctx = CMS_RecipientInfo_get0_pkey_ctx(ri);\n    if (pkctx == NULL)\n        return 0;\n    if (!CMS_RecipientInfo_ktri_get0_algs(ri, NULL, NULL, \u0026cmsalg))\n        return -1;\n    nid = OBJ_obj2nid(cmsalg-\u003ealgorithm);\n    if (nid == NID_rsaEncryption)\n        return 1;\n    if (nid != NID_rsaesOaep) {\n        RSAerr(RSA_F_RSA_CMS_DECRYPT, RSA_R_UNSUPPORTED_ENCRYPTION_TYPE);\n        return -1;\n    }\n    /* Decode OAEP parameters */\n    oaep = rsa_oaep_decode(cmsalg);\n\n    if (oaep == NULL) {\n        RSAerr(RSA_F_RSA_CMS_DECRYPT, RSA_R_INVALID_OAEP_PARAMETERS);\n        goto err;\n    }\n\n    mgf1md = rsa_algor_to_md(oaep-\u003emaskHash);\n    if (mgf1md == NULL)\n        goto err;\n    md = rsa_algor_to_md(oaep-\u003ehashFunc);\n    if (md == NULL)\n        goto err;\n\n    if (oaep-\u003epSourceFunc != NULL) {\n        X509_ALGOR *plab = oaep-\u003epSourceFunc;\n\n        if (OBJ_obj2nid(plab-\u003ealgorithm) != NID_pSpecified) {\n            RSAerr(RSA_F_RSA_CMS_DECRYPT, RSA_R_UNSUPPORTED_LABEL_SOURCE);\n            goto err;\n        }\n        if (plab-\u003eparameter-\u003etype != V_ASN1_OCTET_STRING) {\n            RSAerr(RSA_F_RSA_CMS_DECRYPT, RSA_R_INVALID_LABEL);\n            goto err;\n        }\n\n        label = plab-\u003eparameter-\u003evalue.octet_string-\u003edata;\n        /* Stop label being freed when OAEP parameters are freed */\n        plab-\u003eparameter-\u003evalue.octet_string-\u003edata = NULL;\n        labellen = plab-\u003eparameter-\u003evalue.octet_string-\u003elength;\n    }\n\n    if (EVP_PKEY_CTX_set_rsa_padding(pkctx, RSA_PKCS1_OAEP_PADDING) \u003c= 0)\n        goto err;\n    if (EVP_PKEY_CTX_set_rsa_oaep_md(pkctx, md) \u003c= 0)\n        goto err;\n    if (EVP_PKEY_CTX_set_rsa_mgf1_md(pkctx, mgf1md) \u003c= 0)\n        goto err;\n    if (EVP_PKEY_CTX_set0_rsa_oaep_label(pkctx, label, labellen) \u003c= 0)\n        goto err;\n    /* Carry on */\n    rv = 1;\n\n err:\n    RSA_OAEP_PARAMS_free(oaep);\n    return rv;\n}","filepath":"crypto/rsa/rsa_ameth.c","line_number":906,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270144256":{"score":0.8258468,"function_name":"rsa_cms_encrypt","code":"static int rsa_cms_encrypt(CMS_RecipientInfo *ri)\n{\n    const EVP_MD *md, *mgf1md;\n    RSA_OAEP_PARAMS *oaep = NULL;\n    ASN1_STRING *os = NULL;\n    X509_ALGOR *alg;\n    EVP_PKEY_CTX *pkctx = CMS_RecipientInfo_get0_pkey_ctx(ri);\n    int pad_mode = RSA_PKCS1_PADDING, rv = 0, labellen;\n    unsigned char *label;\n\n    if (CMS_RecipientInfo_ktri_get0_algs(ri, NULL, NULL, \u0026alg) \u003c= 0)\n        return 0;\n    if (pkctx) {\n        if (EVP_PKEY_CTX_get_rsa_padding(pkctx, \u0026pad_mode) \u003c= 0)\n            return 0;\n    }\n    if (pad_mode == RSA_PKCS1_PADDING) {\n        X509_ALGOR_set0(alg, OBJ_nid2obj(NID_rsaEncryption), V_ASN1_NULL, 0);\n        return 1;\n    }\n    /* Not supported */\n    if (pad_mode != RSA_PKCS1_OAEP_PADDING)\n        return 0;\n    if (EVP_PKEY_CTX_get_rsa_oaep_md(pkctx, \u0026md) \u003c= 0)\n        goto err;\n    if (EVP_PKEY_CTX_get_rsa_mgf1_md(pkctx, \u0026mgf1md) \u003c= 0)\n        goto err;\n    labellen = EVP_PKEY_CTX_get0_rsa_oaep_label(pkctx, \u0026label);\n    if (labellen \u003c 0)\n        goto err;\n    oaep = RSA_OAEP_PARAMS_new();\n    if (oaep == NULL)\n        goto err;\n    if (!rsa_md_to_algor(\u0026oaep-\u003ehashFunc, md))\n        goto err;\n    if (!rsa_md_to_mgf1(\u0026oaep-\u003emaskGenFunc, mgf1md))\n        goto err;\n    if (labellen \u003e 0) {\n        ASN1_OCTET_STRING *los;\n        oaep-\u003epSourceFunc = X509_ALGOR_new();\n        if (oaep-\u003epSourceFunc == NULL)\n            goto err;\n        los = ASN1_OCTET_STRING_new();\n        if (los == NULL)\n            goto err;\n        if (!ASN1_OCTET_STRING_set(los, label, labellen)) {\n            ASN1_OCTET_STRING_free(los);\n            goto err;\n        }\n        X509_ALGOR_set0(oaep-\u003epSourceFunc, OBJ_nid2obj(NID_pSpecified),\n                        V_ASN1_OCTET_STRING, los);\n    }\n    /* create string with pss parameter encoding. */\n    if (!ASN1_item_pack(oaep, ASN1_ITEM_rptr(RSA_OAEP_PARAMS), \u0026os))\n         goto err;\n    X509_ALGOR_set0(alg, OBJ_nid2obj(NID_rsaesOaep), V_ASN1_SEQUENCE, os);\n    os = NULL;\n    rv = 1;\n err:\n    RSA_OAEP_PARAMS_free(oaep);\n    ASN1_STRING_free(os);\n    return rv;\n}","filepath":"crypto/rsa/rsa_ameth.c","line_number":978,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270144784":{"score":0.65392077,"function_name":"rsa_ctx_to_pss","code":"static RSA_PSS_PARAMS *rsa_ctx_to_pss(EVP_PKEY_CTX *pkctx)\n{\n    const EVP_MD *sigmd, *mgf1md;\n    EVP_PKEY *pk = EVP_PKEY_CTX_get0_pkey(pkctx);\n    int saltlen;\n\n    if (EVP_PKEY_CTX_get_signature_md(pkctx, \u0026sigmd) \u003c= 0)\n        return NULL;\n    if (EVP_PKEY_CTX_get_rsa_mgf1_md(pkctx, \u0026mgf1md) \u003c= 0)\n        return NULL;\n    if (!EVP_PKEY_CTX_get_rsa_pss_saltlen(pkctx, \u0026saltlen))\n        return NULL;\n    if (saltlen == -1) {\n        saltlen = EVP_MD_size(sigmd);\n    } else if (saltlen == -2 || saltlen == -3) {\n        saltlen = EVP_PKEY_size(pk) - EVP_MD_size(sigmd) - 2;\n        if ((EVP_PKEY_bits(pk) \u0026 0x7) == 1)\n            saltlen--;\n        if (saltlen \u003c 0)\n            return NULL;\n    }\n\n    return rsa_pss_params_create(sigmd, mgf1md, saltlen);\n}","filepath":"crypto/rsa/rsa_ameth.c","line_number":585,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270145232":{"score":0.8588009,"function_name":"rsa_md_to_algor","code":"static int rsa_md_to_algor(X509_ALGOR **palg, const EVP_MD *md)\n{\n    if (md == NULL || EVP_MD_type(md) == NID_sha1)\n        return 1;\n    *palg = X509_ALGOR_new();\n    if (*palg == NULL)\n        return 0;\n    X509_ALGOR_set_md(*palg, md);\n    return 1;\n}","filepath":"crypto/rsa/rsa_ameth.c","line_number":529,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270145296":{"score":0.7991965,"function_name":"rsa_md_to_mgf1","code":"static int rsa_md_to_mgf1(X509_ALGOR **palg, const EVP_MD *mgf1md)\n{\n    X509_ALGOR *algtmp = NULL;\n    ASN1_STRING *stmp = NULL;\n\n    *palg = NULL;\n    if (mgf1md == NULL || EVP_MD_type(mgf1md) == NID_sha1)\n        return 1;\n    /* need to embed algorithm ID inside another */\n    if (!rsa_md_to_algor(\u0026algtmp, mgf1md))\n        goto err;\n    if (ASN1_item_pack(algtmp, ASN1_ITEM_rptr(X509_ALGOR), \u0026stmp) == NULL)\n         goto err;\n    *palg = X509_ALGOR_new();\n    if (*palg == NULL)\n        goto err;\n    X509_ALGOR_set0(*palg, OBJ_nid2obj(NID_mgf1), V_ASN1_SEQUENCE, stmp);\n    stmp = NULL;\n err:\n    ASN1_STRING_free(stmp);\n    X509_ALGOR_free(algtmp);\n    if (*palg)\n        return 1;\n    return 0;\n}","filepath":"crypto/rsa/rsa_ameth.c","line_number":541,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270145552":{"score":0.8523128,"function_name":"rsa_param_decode","code":"static int rsa_param_decode(RSA *rsa, const X509_ALGOR *alg)\n{\n    const ASN1_OBJECT *algoid;\n    const void *algp;\n    int algptype;\n\n    X509_ALGOR_get0(\u0026algoid, \u0026algptype, \u0026algp, alg);\n    if (OBJ_obj2nid(algoid) != EVP_PKEY_RSA_PSS)\n        return 1;\n    if (algptype == V_ASN1_UNDEF)\n        return 1;\n    if (algptype != V_ASN1_SEQUENCE) {\n        RSAerr(RSA_F_RSA_PARAM_DECODE, RSA_R_INVALID_PSS_PARAMETERS);\n        return 0;\n    }\n    rsa-\u003epss = rsa_pss_decode(alg);\n    if (rsa-\u003epss == NULL)\n        return 0;\n    return 1;\n}","filepath":"crypto/rsa/rsa_ameth.c","line_number":54,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270145696":{"score":0.89628386,"function_name":"rsa_param_encode","code":"static int rsa_param_encode(const EVP_PKEY *pkey,\n                            ASN1_STRING **pstr, int *pstrtype)\n{\n    const RSA *rsa = pkey-\u003epkey.rsa;\n\n    *pstr = NULL;\n    /* If RSA it's just NULL type */\n    if (pkey-\u003eameth-\u003epkey_id != EVP_PKEY_RSA_PSS) {\n        *pstrtype = V_ASN1_NULL;\n        return 1;\n    }\n    /* If no PSS parameters we omit parameters entirely */\n    if (rsa-\u003epss == NULL) {\n        *pstrtype = V_ASN1_UNDEF;\n        return 1;\n    }\n    /* Encode PSS parameters */\n    if (ASN1_item_pack(rsa-\u003epss, ASN1_ITEM_rptr(RSA_PSS_PARAMS), pstr) == NULL)\n        return 0;\n\n    *pstrtype = V_ASN1_SEQUENCE;\n    return 1;\n}","filepath":"crypto/rsa/rsa_ameth.c","line_number":30,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270145808":{"score":0.74829525,"function_name":"rsa_pss_decode","code":"static RSA_PSS_PARAMS *rsa_pss_decode(const X509_ALGOR *alg)\n{\n    RSA_PSS_PARAMS *pss;\n\n    pss = ASN1_TYPE_unpack_sequence(ASN1_ITEM_rptr(RSA_PSS_PARAMS),\n                                    alg-\u003eparameter);\n\n    if (pss == NULL)\n        return NULL;\n\n    if (pss-\u003emaskGenAlgorithm != NULL) {\n        pss-\u003emaskHash = rsa_mgf1_decode(pss-\u003emaskGenAlgorithm);\n        if (pss-\u003emaskHash == NULL) {\n            RSA_PSS_PARAMS_free(pss);\n            return NULL;\n        }\n    }\n\n    return pss;\n}","filepath":"crypto/rsa/rsa_ameth.c","line_number":418,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270145920":{"score":0.93699616,"function_name":"rsa_pss_get_param","code":"int rsa_pss_get_param(const RSA_PSS_PARAMS *pss, const EVP_MD **pmd,\n                      const EVP_MD **pmgf1md, int *psaltlen)\n{\n    if (pss == NULL)\n        return 0;\n    *pmd = rsa_algor_to_md(pss-\u003ehashAlgorithm);\n    if (*pmd == NULL)\n        return 0;\n    *pmgf1md = rsa_algor_to_md(pss-\u003emaskHash);\n    if (*pmgf1md == NULL)\n        return 0;\n    if (pss-\u003esaltLength) {\n        *psaltlen = ASN1_INTEGER_get(pss-\u003esaltLength);\n        if (*psaltlen \u003c 0) {\n            RSAerr(RSA_F_RSA_PSS_GET_PARAM, RSA_R_INVALID_SALT_LENGTH);\n            return 0;\n        }\n    } else {\n        *psaltlen = 20;\n    }\n\n    /*\n     * low-level routines support only trailer field 0xbc (value 1) and\n     * PKCS#1 says we should reject any other value anyway.\n     */\n    if (pss-\u003etrailerField \u0026\u0026 ASN1_INTEGER_get(pss-\u003etrailerField) != 1) {\n        RSAerr(RSA_F_RSA_PSS_GET_PARAM, RSA_R_INVALID_TRAILER);\n        return 0;\n    }\n\n    return 1;\n}","filepath":"crypto/rsa/rsa_ameth.c","line_number":708,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270146112":{"score":0.9430067,"function_name":"rsa_pss_param_print","code":"static int rsa_pss_param_print(BIO *bp, int pss_key, RSA_PSS_PARAMS *pss,\n                               int indent)\n{\n    int rv = 0;\n    X509_ALGOR *maskHash = NULL;\n\n    if (!BIO_indent(bp, indent, 128))\n        goto err;\n    if (pss_key) {\n        if (pss == NULL) {\n            if (BIO_puts(bp, \"No PSS parameter restrictions\\n\") \u003c= 0)\n                return 0;\n            return 1;\n        } else {\n            if (BIO_puts(bp, \"PSS parameter restrictions:\") \u003c= 0)\n                return 0;\n        }\n    } else if (pss == NULL) {\n        if (BIO_puts(bp,\"(INVALID PSS PARAMETERS)\\n\") \u003c= 0)\n            return 0;\n        return 1;\n    }\n    if (BIO_puts(bp, \"\\n\") \u003c= 0)\n        goto err;\n    if (pss_key)\n        indent += 2;\n    if (!BIO_indent(bp, indent, 128))\n        goto err;\n    if (BIO_puts(bp, \"Hash Algorithm: \") \u003c= 0)\n        goto err;\n\n    if (pss-\u003ehashAlgorithm) {\n        if (i2a_ASN1_OBJECT(bp, pss-\u003ehashAlgorithm-\u003ealgorithm) \u003c= 0)\n            goto err;\n    } else if (BIO_puts(bp, \"sha1 (default)\") \u003c= 0) {\n        goto err;\n    }\n\n    if (BIO_puts(bp, \"\\n\") \u003c= 0)\n        goto err;\n\n    if (!BIO_indent(bp, indent, 128))\n        goto err;\n\n    if (BIO_puts(bp, \"Mask Algorithm: \") \u003c= 0)\n        goto err;\n    if (pss-\u003emaskGenAlgorithm) {\n        if (i2a_ASN1_OBJECT(bp, pss-\u003emaskGenAlgorithm-\u003ealgorithm) \u003c= 0)\n            goto err;\n        if (BIO_puts(bp, \" with \") \u003c= 0)\n            goto err;\n        maskHash = rsa_mgf1_decode(pss-\u003emaskGenAlgorithm);\n        if (maskHash != NULL) {\n            if (i2a_ASN1_OBJECT(bp, maskHash-\u003ealgorithm) \u003c= 0)\n                goto err;\n        } else if (BIO_puts(bp, \"INVALID\") \u003c= 0) {\n            goto err;\n        }\n    } else if (BIO_puts(bp, \"mgf1 with sha1 (default)\") \u003c= 0) {\n        goto err;\n    }\n    BIO_puts(bp, \"\\n\");\n\n    if (!BIO_indent(bp, indent, 128))\n        goto err;\n    if (BIO_printf(bp, \"%s Salt Length: 0x\", pss_key ? \"Minimum\" : \"\") \u003c= 0)\n        goto err;\n    if (pss-\u003esaltLength) {\n        if (i2a_ASN1_INTEGER(bp, pss-\u003esaltLength) \u003c= 0)\n            goto err;\n    } else if (BIO_puts(bp, \"14 (default)\") \u003c= 0) {\n        goto err;\n    }\n    BIO_puts(bp, \"\\n\");\n\n    if (!BIO_indent(bp, indent, 128))\n        goto err;\n    if (BIO_puts(bp, \"Trailer Field: 0x\") \u003c= 0)\n        goto err;\n    if (pss-\u003etrailerField) {\n        if (i2a_ASN1_INTEGER(bp, pss-\u003etrailerField) \u003c= 0)\n            goto err;\n    } else if (BIO_puts(bp, \"BC (default)\") \u003c= 0) {\n        goto err;\n    }\n    BIO_puts(bp, \"\\n\");\n\n    rv = 1;\n\n err:\n    X509_ALGOR_free(maskHash);\n    return rv;\n\n}","filepath":"crypto/rsa/rsa_ameth.c","line_number":222,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270146784":{"score":0.83104223,"function_name":"rsa_pss_params_create","code":"RSA_PSS_PARAMS *rsa_pss_params_create(const EVP_MD *sigmd,\n                                      const EVP_MD *mgf1md, int saltlen)\n{\n    RSA_PSS_PARAMS *pss = RSA_PSS_PARAMS_new();\n\n    if (pss == NULL)\n        goto err;\n    if (saltlen != 20) {\n        pss-\u003esaltLength = ASN1_INTEGER_new();\n        if (pss-\u003esaltLength == NULL)\n            goto err;\n        if (!ASN1_INTEGER_set(pss-\u003esaltLength, saltlen))\n            goto err;\n    }\n    if (!rsa_md_to_algor(\u0026pss-\u003ehashAlgorithm, sigmd))\n        goto err;\n    if (mgf1md == NULL)\n        mgf1md = sigmd;\n    if (!rsa_md_to_mgf1(\u0026pss-\u003emaskGenAlgorithm, mgf1md))\n        goto err;\n    if (!rsa_md_to_algor(\u0026pss-\u003emaskHash, mgf1md))\n        goto err;\n    return pss;\n err:\n    RSA_PSS_PARAMS_free(pss);\n    return NULL;\n}","filepath":"crypto/rsa/rsa_ameth.c","line_number":610,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270146944":{"score":0.7891597,"function_name":"rsa_pss_to_ctx","code":"static int rsa_pss_to_ctx(EVP_MD_CTX *ctx, EVP_PKEY_CTX *pkctx,\n                          X509_ALGOR *sigalg, EVP_PKEY *pkey)\n{\n    int rv = -1;\n    int saltlen;\n    const EVP_MD *mgf1md = NULL, *md = NULL;\n    RSA_PSS_PARAMS *pss;\n\n    /* Sanity check: make sure it is PSS */\n    if (OBJ_obj2nid(sigalg-\u003ealgorithm) != EVP_PKEY_RSA_PSS) {\n        RSAerr(RSA_F_RSA_PSS_TO_CTX, RSA_R_UNSUPPORTED_SIGNATURE_TYPE);\n        return -1;\n    }\n    /* Decode PSS parameters */\n    pss = rsa_pss_decode(sigalg);\n\n    if (!rsa_pss_get_param(pss, \u0026md, \u0026mgf1md, \u0026saltlen)) {\n        RSAerr(RSA_F_RSA_PSS_TO_CTX, RSA_R_INVALID_PSS_PARAMETERS);\n        goto err;\n    }\n\n    /* We have all parameters now set up context */\n    if (pkey) {\n        if (!EVP_DigestVerifyInit(ctx, \u0026pkctx, md, NULL, pkey))\n            goto err;\n    } else {\n        const EVP_MD *checkmd;\n        if (EVP_PKEY_CTX_get_signature_md(pkctx, \u0026checkmd) \u003c= 0)\n            goto err;\n        if (EVP_MD_type(md) != EVP_MD_type(checkmd)) {\n            RSAerr(RSA_F_RSA_PSS_TO_CTX, RSA_R_DIGEST_DOES_NOT_MATCH);\n            goto err;\n        }\n    }\n\n    if (EVP_PKEY_CTX_set_rsa_padding(pkctx, RSA_PKCS1_PSS_PADDING) \u003c= 0)\n        goto err;\n\n    if (EVP_PKEY_CTX_set_rsa_pss_saltlen(pkctx, saltlen) \u003c= 0)\n        goto err;\n\n    if (EVP_PKEY_CTX_set_rsa_mgf1_md(pkctx, mgf1md) \u003c= 0)\n        goto err;\n    /* Carry on */\n    rv = 1;\n\n err:\n    RSA_PSS_PARAMS_free(pss);\n    return rv;\n}","filepath":"crypto/rsa/rsa_ameth.c","line_number":657,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270150160":{"score":0.7958386,"function_name":"Poly1305_Final","code":"void Poly1305_Final(POLY1305 *ctx, unsigned char mac[16])\n{\n#ifdef POLY1305_ASM\n    poly1305_blocks_f poly1305_blocks_p = ctx-\u003efunc.blocks;\n    poly1305_emit_f poly1305_emit_p = ctx-\u003efunc.emit;\n#endif\n    size_t num;\n\n    if ((num = ctx-\u003enum)) {\n        ctx-\u003edata[num++] = 1;   /* pad bit */\n        while (num \u003c POLY1305_BLOCK_SIZE)\n            ctx-\u003edata[num++] = 0;\n        poly1305_blocks(ctx-\u003eopaque, ctx-\u003edata, POLY1305_BLOCK_SIZE, 0);\n    }\n\n    poly1305_emit(ctx-\u003eopaque, mac, ctx-\u003enonce);\n\n    /* zero out the state */\n    OPENSSL_cleanse(ctx, sizeof(*ctx));\n}","filepath":"crypto/poly1305/poly1305.c","line_number":512,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre7"},"270150288":{"score":0.7906475,"function_name":"Poly1305_Init","code":"void Poly1305_Init(POLY1305 *ctx, const unsigned char key[32])\n{\n    ctx-\u003enonce[0] = U8TOU32(\u0026key[16]);\n    ctx-\u003enonce[1] = U8TOU32(\u0026key[20]);\n    ctx-\u003enonce[2] = U8TOU32(\u0026key[24]);\n    ctx-\u003enonce[3] = U8TOU32(\u0026key[28]);\n\n#ifndef POLY1305_ASM\n    poly1305_init(ctx-\u003eopaque, key);\n#else\n    /*\n     * Unlike reference poly1305_init assembly counterpart is expected\n     * to return a value: non-zero if it initializes ctx-\u003efunc, and zero\n     * otherwise. Latter is to simplify assembly in cases when there no\n     * multiple code paths to switch between.\n     */\n    if (!poly1305_init(ctx-\u003eopaque, key, \u0026ctx-\u003efunc)) {\n        ctx-\u003efunc.blocks = poly1305_blocks;\n        ctx-\u003efunc.emit = poly1305_emit;\n    }","filepath":"crypto/poly1305/poly1305.c","line_number":435,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre7"},"270150496":{"score":0.76090515,"function_name":"Poly1305_Update","code":"void Poly1305_Update(POLY1305 *ctx, const unsigned char *inp, size_t len)\n{\n#ifdef POLY1305_ASM\n    /*\n     * As documented, poly1305_blocks is never called with input\n     * longer than single block and padbit argument set to 0. This\n     * property is fluently used in assembly modules to optimize\n     * padbit handling on loop boundary.\n     */\n    poly1305_blocks_f poly1305_blocks_p = ctx-\u003efunc.blocks;\n#endif\n    size_t rem, num;\n\n    if ((num = ctx-\u003enum)) {\n        rem = POLY1305_BLOCK_SIZE - num;\n        if (len \u003e= rem) {\n            memcpy(ctx-\u003edata + num, inp, rem);\n            poly1305_blocks(ctx-\u003eopaque, ctx-\u003edata, POLY1305_BLOCK_SIZE, 1);\n            inp += rem;\n            len -= rem;\n        } else {\n            /* Still not enough data to process a block. */\n            memcpy(ctx-\u003edata + num, inp, len);\n            ctx-\u003enum = num + len;\n            return;\n        }\n    }\n\n    rem = len % POLY1305_BLOCK_SIZE;\n    len -= rem;\n\n    if (len \u003e= POLY1305_BLOCK_SIZE) {\n        poly1305_blocks(ctx-\u003eopaque, inp, len, 1);\n        inp += len;\n    }\n\n    if (rem)\n        memcpy(ctx-\u003edata, inp, rem);\n\n    ctx-\u003enum = rem;\n}","filepath":"crypto/poly1305/poly1305.c","line_number":470,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre7"},"270150704":{"score":0.8754639,"function_name":"SipHash_Final","code":"int SipHash_Final(SIPHASH *ctx, unsigned char *out, size_t outlen)\n{\n    /* finalize hash */\n    int i;\n    uint64_t b = ctx-\u003etotal_inlen \u003c\u003c 56;\n    uint64_t v0 = ctx-\u003ev0;\n    uint64_t v1 = ctx-\u003ev1;\n    uint64_t v2 = ctx-\u003ev2;\n    uint64_t v3 = ctx-\u003ev3;\n\n    if (outlen != (size_t)ctx-\u003ehash_size)\n        return 0;\n\n    switch (ctx-\u003elen) {\n    case 7:\n        b |= ((uint64_t)ctx-\u003eleavings[6]) \u003c\u003c 48;\n        /* fall thru */\n    case 6:\n        b |= ((uint64_t)ctx-\u003eleavings[5]) \u003c\u003c 40;\n        /* fall thru */\n    case 5:\n        b |= ((uint64_t)ctx-\u003eleavings[4]) \u003c\u003c 32;\n        /* fall thru */\n    case 4:\n        b |= ((uint64_t)ctx-\u003eleavings[3]) \u003c\u003c 24;\n        /* fall thru */\n    case 3:\n        b |= ((uint64_t)ctx-\u003eleavings[2]) \u003c\u003c 16;\n        /* fall thru */\n    case 2:\n        b |= ((uint64_t)ctx-\u003eleavings[1]) \u003c\u003c  8;\n        /* fall thru */\n    case 1:\n        b |= ((uint64_t)ctx-\u003eleavings[0]);\n    case 0:\n        break;\n    }\n\n    v3 ^= b;\n    for (i = 0; i \u003c ctx-\u003ecrounds; ++i)\n        SIPROUND;\n    v0 ^= b;\n    if (ctx-\u003ehash_size == SIPHASH_MAX_DIGEST_SIZE)\n        v2 ^= 0xee;\n    else\n        v2 ^= 0xff;\n    for (i = 0; i \u003c ctx-\u003edrounds; ++i)\n        SIPROUND;\n    b = v0 ^ v1 ^ v2  ^ v3;\n    U64TO8_LE(out, b);\n    if (ctx-\u003ehash_size == SIPHASH_MIN_DIGEST_SIZE)\n        return 1;\n    v1 ^= 0xdd;\n    for (i = 0; i \u003c ctx-\u003edrounds; ++i)\n        SIPROUND;\n    b = v0 ^ v1 ^ v2  ^ v3;\n    U64TO8_LE(out + 8, b);\n    return 1;\n}","filepath":"crypto/siphash/siphash.c","line_number":202,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"270151872":{"score":0.8610704,"function_name":"SipHash_Init","code":"int SipHash_Init(SIPHASH *ctx, const unsigned char *k, int crounds, int drounds)\n{\n    uint64_t k0 = U8TO64_LE(k);\n    uint64_t k1 = U8TO64_LE(k + 8);\n\n    /* If the hash size wasn't set, i.e. is zero */\n    ctx-\u003ehash_size = siphash_adjust_hash_size(ctx-\u003ehash_size);\n\n    if (drounds == 0)\n        drounds = SIPHASH_D_ROUNDS;\n    if (crounds == 0)\n        crounds = SIPHASH_C_ROUNDS;\n\n    ctx-\u003ecrounds = crounds;\n    ctx-\u003edrounds = drounds;\n\n    ctx-\u003elen = 0;\n    ctx-\u003etotal_inlen = 0;\n\n    ctx-\u003ev0 = 0x736f6d6570736575ULL ^ k0;\n    ctx-\u003ev1 = 0x646f72616e646f6dULL ^ k1;\n    ctx-\u003ev2 = 0x6c7967656e657261ULL ^ k0;\n    ctx-\u003ev3 = 0x7465646279746573ULL ^ k1;\n\n    if (ctx-\u003ehash_size == SIPHASH_MAX_DIGEST_SIZE)\n        ctx-\u003ev1 ^= 0xee;\n\n    return 1;\n}","filepath":"crypto/siphash/siphash.c","line_number":114,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"270152336":{"score":0.77590024,"function_name":"SipHash_Update","code":"void SipHash_Update(SIPHASH *ctx, const unsigned char *in, size_t inlen)\n{\n    uint64_t m;\n    const uint8_t *end;\n    int left;\n    int i;\n    uint64_t v0 = ctx-\u003ev0;\n    uint64_t v1 = ctx-\u003ev1;\n    uint64_t v2 = ctx-\u003ev2;\n    uint64_t v3 = ctx-\u003ev3;\n\n    ctx-\u003etotal_inlen += inlen;\n\n    if (ctx-\u003elen) {\n        /* deal with leavings */\n        size_t available = SIPHASH_BLOCK_SIZE - ctx-\u003elen;\n\n        /* not enough to fill leavings */\n        if (inlen \u003c available) {\n            memcpy(\u0026ctx-\u003eleavings[ctx-\u003elen], in, inlen);\n            ctx-\u003elen += inlen;\n            return;\n        }\n\n        /* copy data into leavings and reduce input */\n        memcpy(\u0026ctx-\u003eleavings[ctx-\u003elen], in, available);\n        inlen -= available;\n        in += available;\n\n        /* process leavings */\n        m = U8TO64_LE(ctx-\u003eleavings);\n        v3 ^= m;\n        for (i = 0; i \u003c ctx-\u003ecrounds; ++i)\n            SIPROUND;\n        v0 ^= m;\n    }\n    left = inlen \u0026 (SIPHASH_BLOCK_SIZE-1); /* gets put into leavings */\n    end = in + inlen - left;\n\n    for (; in != end; in += 8) {\n        m = U8TO64_LE(in);\n        v3 ^= m;\n        for (i = 0; i \u003c ctx-\u003ecrounds; ++i)\n            SIPROUND;\n        v0 ^= m;\n    }\n\n    /* save leavings and other ctx */\n    if (left)\n        memcpy(ctx-\u003eleavings, end, left);\n    ctx-\u003elen = left;\n\n    ctx-\u003ev0 = v0;\n    ctx-\u003ev1 = v1;\n    ctx-\u003ev2 = v2;\n    ctx-\u003ev3 = v3;\n}","filepath":"crypto/siphash/siphash.c","line_number":144,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"270153648":{"score":0.79499525,"function_name":"SipHash_set_hash_size","code":"int SipHash_set_hash_size(SIPHASH *ctx, size_t hash_size)\n{\n    hash_size = siphash_adjust_hash_size(hash_size);\n    if (hash_size != SIPHASH_MIN_DIGEST_SIZE\n        \u0026\u0026 hash_size != SIPHASH_MAX_DIGEST_SIZE)\n        return 0;\n\n    /*\n     * It's possible that the key was set first.  If the hash size changes,\n     * we need to adjust v1 (see SipHash_Init().\n     */\n\n    /* Start by adjusting the stored size, to make things easier */\n    ctx-\u003ehash_size = siphash_adjust_hash_size(ctx-\u003ehash_size);\n\n    /* Now, adjust ctx-\u003ev1 if the old and the new size differ */\n    if ((size_t)ctx-\u003ehash_size != hash_size) {\n        ctx-\u003ev1 ^= 0xee;\n        ctx-\u003ehash_size = hash_size;\n    }\n    return 1;\n}","filepath":"crypto/siphash/siphash.c","line_number":90,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"270153728":{"score":0.85315585,"function_name":"OBJ_NAME_add","code":"int OBJ_NAME_add(const char *name, int type, const char *data)\n\t{\n\tOBJ_NAME *onp,*ret;\n\tint alias;\n\n\tif ((names_lh == NULL) \u0026\u0026 !OBJ_NAME_init()) return(0);\n\n\talias=type\u0026OBJ_NAME_ALIAS;\n\ttype\u0026= ~OBJ_NAME_ALIAS;\n\n\tonp=(OBJ_NAME *)OPENSSL_malloc(sizeof(OBJ_NAME));\n\tif (onp == NULL)\n\t\t{\n\t\t/* ERROR */\n\t\treturn(0);\n\t\t}\n\n\tonp-\u003ename=name;\n\tonp-\u003ealias=alias;\n\tonp-\u003etype=type;\n\tonp-\u003edata=data;\n\n\tret=(OBJ_NAME *)lh_insert(names_lh,onp);\n\tif (ret != NULL)\n\t\t{\n\t\t/* free things */\n\t\tif ((name_funcs_stack != NULL) \u0026\u0026 (sk_NAME_FUNCS_num(name_funcs_stack) \u003e ret-\u003etype))\n\t\t\t{\n\t\t\t/* XXX: I'm not sure I understand why the free\n\t\t\t * function should get three arguments...\n\t\t\t * -- Richard Levitte\n\t\t\t */\n\t\t\tsk_NAME_FUNCS_value(name_funcs_stack,ret-\u003etype)\n\t\t\t\t-\u003efree_func(ret-\u003ename,ret-\u003etype,ret-\u003edata);\n\t\t\t}\n\t\tOPENSSL_free(ret);\n\t\t}\n\telse\n\t\t{\n\t\tif (lh_error(names_lh))\n\t\t\t{\n\t\t\t/* ERROR */\n\t\t\treturn(0);\n\t\t\t}\n\t\t}\n\treturn(1);\n\t}","filepath":"crypto/objects/o_names.c","line_number":150,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL-engine-0_9_6-beta1"},"270154032":{"score":0.899392,"function_name":"OBJ_NAME_cleanup","code":"void OBJ_NAME_cleanup(int type)\n\t{\n\tunsigned long down_load;\n\n\tif (names_lh == NULL) return;\n\n\tfree_type=type;\n\tdown_load=names_lh-\u003edown_load;\n\tnames_lh-\u003edown_load=0;\n\n\tlh_doall(names_lh,names_lh_free);\n\tif (type \u003c 0)\n\t\t{\n\t\tlh_free(names_lh);\n\t\tsk_NAME_FUNCS_pop_free(name_funcs_stack,name_funcs_free);\n\t\tnames_lh=NULL;\n\t\tname_funcs_stack = NULL;\n\t\t}\n\telse\n\t\tnames_lh-\u003edown_load=down_load;\n\t}","filepath":"crypto/objects/o_names.c","line_number":245,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL-engine-0_9_6-beta1"},"270154208":{"score":0.77872235,"function_name":"OBJ_NAME_get","code":"const char *OBJ_NAME_get(const char *name, int type)\n\t{\n\tOBJ_NAME on,*ret;\n\tint num=0,alias;\n\n\tif (name == NULL) return(NULL);\n\tif ((names_lh == NULL) \u0026\u0026 !OBJ_NAME_init()) return(NULL);\n\n\talias=type\u0026OBJ_NAME_ALIAS;\n\ttype\u0026= ~OBJ_NAME_ALIAS;\n\n\ton.name=name;\n\ton.type=type;\n\n\tfor (;;)\n\t\t{\n\t\tret=(OBJ_NAME *)lh_retrieve(names_lh,\u0026on);\n\t\tif (ret == NULL) return(NULL);\n\t\tif ((ret-\u003ealias) \u0026\u0026 !alias)\n\t\t\t{\n\t\t\tif (++num \u003e 10) return(NULL);\n\t\t\ton.name=ret-\u003edata;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\treturn(ret-\u003edata);\n\t\t\t}\n\t\t}\n\t}","filepath":"crypto/objects/o_names.c","line_number":120,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL-engine-0_9_6-beta1"},"270154464":{"score":0.57437384,"function_name":"names_lh_free","code":"static void names_lh_free(OBJ_NAME *onp, int type)\n{\n\tif(onp == NULL)\n\t    return;\n\n\tif ((free_type \u003c 0) || (free_type == onp-\u003etype))\n\t\t{\n\t\tOBJ_NAME_remove(onp-\u003ename,onp-\u003etype);\n\t\t}\n\t}","filepath":"crypto/objects/o_names.c","line_number":229,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL-engine-0_9_6-beta1"},"270156272":{"score":0.9257242,"function_name":"ENGINE_ctrl","code":"int ENGINE_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void))\n{\n    int ctrl_exists, ref_exists;\n    if (e == NULL) {\n        ERR_raise(ERR_LIB_ENGINE, ERR_R_PASSED_NULL_PARAMETER);\n        return 0;\n    }\n    CRYPTO_THREAD_write_lock(global_engine_lock);\n    ref_exists = ((e-\u003estruct_ref \u003e 0) ? 1 : 0);\n    CRYPTO_THREAD_unlock(global_engine_lock);\n    ctrl_exists = ((e-\u003ectrl == NULL) ? 0 : 1);\n    if (!ref_exists) {\n        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_NO_REFERENCE);\n        return 0;\n    }\n    /*\n     * Intercept any \"root-level\" commands before trying to hand them on to\n     * ctrl() handlers.\n     */\n    switch (cmd) {\n    case ENGINE_CTRL_HAS_CTRL_FUNCTION:\n        return ctrl_exists;\n    case ENGINE_CTRL_GET_FIRST_CMD_TYPE:\n    case ENGINE_CTRL_GET_NEXT_CMD_TYPE:\n    case ENGINE_CTRL_GET_CMD_FROM_NAME:\n    case ENGINE_CTRL_GET_NAME_LEN_FROM_CMD:\n    case ENGINE_CTRL_GET_NAME_FROM_CMD:\n    case ENGINE_CTRL_GET_DESC_LEN_FROM_CMD:\n    case ENGINE_CTRL_GET_DESC_FROM_CMD:\n    case ENGINE_CTRL_GET_CMD_FLAGS:\n        if (ctrl_exists \u0026\u0026 !(e-\u003eflags \u0026 ENGINE_FLAGS_MANUAL_CMD_CTRL))\n            return int_ctrl_helper(e, cmd, i, p, f);\n        if (!ctrl_exists) {\n            ERR_raise(ERR_LIB_ENGINE, ENGINE_R_NO_CONTROL_FUNCTION);\n            /*\n             * For these cmd-related functions, failure is indicated by a -1\n             * return value (because 0 is used as a valid return in some\n             * places).\n             */\n            return -1;\n        }\n    default:\n        break;\n    }\n    /* Anything else requires a ctrl() handler to exist. */\n    if (!ctrl_exists) {\n        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_NO_CONTROL_FUNCTION);\n        return 0;\n    }\n    return e-\u003ectrl(e, cmd, i, p, f);\n}","filepath":"crypto/engine/eng_ctrl.c","line_number":128,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"270156544":{"score":0.888998,"function_name":"ENGINE_ctrl_cmd_string","code":"int ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg,\n                           int cmd_optional)\n{\n    int num, flags;\n    long l;\n    char *ptr;\n\n    if (e == NULL || cmd_name == NULL) {\n        ERR_raise(ERR_LIB_ENGINE, ERR_R_PASSED_NULL_PARAMETER);\n        return 0;\n    }\n    if (e-\u003ectrl == NULL\n        || (num = ENGINE_ctrl(e, ENGINE_CTRL_GET_CMD_FROM_NAME,\n                              0, (void *)cmd_name, NULL)) \u003c= 0) {\n        /*\n         * If the command didn't *have* to be supported, we fake success.\n         * This allows certain settings to be specified for multiple ENGINEs\n         * and only require a change of ENGINE id (without having to\n         * selectively apply settings). Eg. changing from a hardware device\n         * back to the regular software ENGINE without editing the config\n         * file, etc.\n         */\n        if (cmd_optional) {\n            ERR_clear_error();\n            return 1;\n        }\n        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INVALID_CMD_NAME);\n        return 0;\n    }\n    if (!ENGINE_cmd_is_executable(e, num)) {\n        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_CMD_NOT_EXECUTABLE);\n        return 0;\n    }\n\n    flags = ENGINE_ctrl(e, ENGINE_CTRL_GET_CMD_FLAGS, num, NULL, NULL);\n    if (flags \u003c 0) {\n        /*\n         * Shouldn't happen, given that ENGINE_cmd_is_executable() returned\n         * success.\n         */\n        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INTERNAL_LIST_ERROR);\n        return 0;\n    }\n    /*\n     * If the command takes no input, there must be no input. And vice versa.\n     */\n    if (flags \u0026 ENGINE_CMD_FLAG_NO_INPUT) {\n        if (arg != NULL) {\n            ERR_raise(ERR_LIB_ENGINE, ENGINE_R_COMMAND_TAKES_NO_INPUT);\n            return 0;\n        }\n        /*\n         * We deliberately force the result of ENGINE_ctrl() to 0 or 1 rather\n         * than returning it as \"return data\". This is to ensure usage of\n         * these commands is consistent across applications and that certain\n         * applications don't understand it one way, and others another.\n         */\n        if (ENGINE_ctrl(e, num, 0, (void *)arg, NULL) \u003e 0)\n            return 1;\n        return 0;\n    }\n    /* So, we require input */\n    if (arg == NULL) {\n        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_COMMAND_TAKES_INPUT);\n        return 0;\n    }\n    /* If it takes string input, that's easy */\n    if (flags \u0026 ENGINE_CMD_FLAG_STRING) {\n        /* Same explanation as above */\n        if (ENGINE_ctrl(e, num, 0, (void *)arg, NULL) \u003e 0)\n            return 1;\n        return 0;\n    }\n    /*\n     * If it doesn't take numeric either, then it is unsupported for use in a\n     * config-setting situation, which is what this function is for. This\n     * should never happen though, because ENGINE_cmd_is_executable() was\n     * used.\n     */\n    if (!(flags \u0026 ENGINE_CMD_FLAG_NUMERIC)) {\n        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INTERNAL_LIST_ERROR);\n        return 0;\n    }\n    l = strtol(arg, \u0026ptr, 10);\n    if ((arg == ptr) || (*ptr != '\\0')) {\n        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_ARGUMENT_IS_NOT_A_NUMBER);\n        return 0;\n    }\n    /*\n     * Force the result of the control command to 0 or 1, for the reasons\n     * mentioned before.\n     */\n    if (ENGINE_ctrl(e, num, l, NULL, NULL) \u003e 0)\n        return 1;\n    return 0;\n}","filepath":"crypto/engine/eng_ctrl.c","line_number":231,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"270157072":{"score":0.8510207,"function_name":"int_ctrl_helper","code":"static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p,\n                           void (*f) (void))\n{\n    int idx;\n    char *s = (char *)p;\n    const ENGINE_CMD_DEFN *cdp;\n\n    /* Take care of the easy one first (eg. it requires no searches) */\n    if (cmd == ENGINE_CTRL_GET_FIRST_CMD_TYPE) {\n        if ((e-\u003ecmd_defns == NULL) || int_ctrl_cmd_is_null(e-\u003ecmd_defns))\n            return 0;\n        return e-\u003ecmd_defns-\u003ecmd_num;\n    }\n    /* One or two commands require that \"p\" be a valid string buffer */\n    if ((cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) ||\n        (cmd == ENGINE_CTRL_GET_NAME_FROM_CMD) ||\n        (cmd == ENGINE_CTRL_GET_DESC_FROM_CMD)) {\n        if (s == NULL) {\n            ERR_raise(ERR_LIB_ENGINE, ERR_R_PASSED_NULL_PARAMETER);\n            return -1;\n        }\n    }\n    /* Now handle cmd_name -\u003e cmd_num conversion */\n    if (cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) {\n        if ((e-\u003ecmd_defns == NULL)\n            || ((idx = int_ctrl_cmd_by_name(e-\u003ecmd_defns, s)) \u003c 0)) {\n            ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INVALID_CMD_NAME);\n            return -1;\n        }\n        return e-\u003ecmd_defns[idx].cmd_num;\n    }\n    /*\n     * For the rest of the commands, the 'long' argument must specify a valid\n     * command number - so we need to conduct a search.\n     */\n    if ((e-\u003ecmd_defns == NULL)\n        || ((idx = int_ctrl_cmd_by_num(e-\u003ecmd_defns, (unsigned int)i)) \u003c 0)) {\n        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INVALID_CMD_NUMBER);\n        return -1;\n    }\n    /* Now the logic splits depending on command type */\n    cdp = \u0026e-\u003ecmd_defns[idx];\n    switch (cmd) {\n    case ENGINE_CTRL_GET_NEXT_CMD_TYPE:\n        cdp++;\n        return int_ctrl_cmd_is_null(cdp) ? 0 : cdp-\u003ecmd_num;\n    case ENGINE_CTRL_GET_NAME_LEN_FROM_CMD:\n        return strlen(cdp-\u003ecmd_name);\n    case ENGINE_CTRL_GET_NAME_FROM_CMD:\n        return strlen(strcpy(s, cdp-\u003ecmd_name));\n    case ENGINE_CTRL_GET_DESC_LEN_FROM_CMD:\n        return strlen(cdp-\u003ecmd_desc == NULL ? int_no_description\n                                            : cdp-\u003ecmd_desc);\n    case ENGINE_CTRL_GET_DESC_FROM_CMD:\n        return strlen(strcpy(s, cdp-\u003ecmd_desc == NULL ? int_no_description\n                                                      : cdp-\u003ecmd_desc));\n    case ENGINE_CTRL_GET_CMD_FLAGS:\n        return cdp-\u003ecmd_flags;\n    }\n    /* Shouldn't really be here ... */\n    ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INTERNAL_LIST_ERROR);\n    return -1;\n}","filepath":"crypto/engine/eng_ctrl.c","line_number":64,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"270157616":{"score":0.75413984,"function_name":"ENGINE_get_pkey_asn1_meth","code":"const EVP_PKEY_ASN1_METHOD *ENGINE_get_pkey_asn1_meth(ENGINE *e, int nid)\n{\n    EVP_PKEY_ASN1_METHOD *ret;\n    ENGINE_PKEY_ASN1_METHS_PTR fn = ENGINE_get_pkey_asn1_meths(e);\n    if (!fn || !fn(e, \u0026ret, NULL, nid)) {\n        ENGINEerr(ENGINE_F_ENGINE_GET_PKEY_ASN1_METH,\n                  ENGINE_R_UNIMPLEMENTED_PUBLIC_KEY_METHOD);\n        return NULL;\n    }\n    return ret;\n}","filepath":"crypto/engine/tb_asnmth.c","line_number":83,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre8"},"270157712":{"score":0.81361985,"function_name":"ENGINE_pkey_asn1_find_str","code":"const EVP_PKEY_ASN1_METHOD *ENGINE_pkey_asn1_find_str(ENGINE **pe,\n                                                      const char *str,\n                                                      int len)\n{\n    ENGINE_FIND_STR fstr;\n    fstr.e = NULL;\n    fstr.ameth = NULL;\n    fstr.str = str;\n    fstr.len = len;\n\n    if (!RUN_ONCE(\u0026engine_lock_init, do_engine_lock_init)) {\n        ENGINEerr(ENGINE_F_ENGINE_PKEY_ASN1_FIND_STR, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    CRYPTO_THREAD_write_lock(global_engine_lock);\n    engine_table_doall(pkey_asn1_meth_table, look_str_cb, \u0026fstr);\n    /* If found obtain a structural reference to engine */\n    if (fstr.e) {\n        fstr.e-\u003estruct_ref++;\n        engine_ref_debug(fstr.e, 0, 1);\n    }\n    *pe = fstr.e;\n    CRYPTO_THREAD_unlock(global_engine_lock);\n    return fstr.ameth;\n}","filepath":"crypto/engine/tb_asnmth.c","line_number":184,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre8"},"270158064":{"score":0.8953333,"function_name":"engine_pkey_asn1_meths_free","code":"void engine_pkey_asn1_meths_free(ENGINE *e)\n{\n    int i;\n    EVP_PKEY_ASN1_METHOD *pkm;\n    if (e-\u003epkey_asn1_meths) {\n        const int *pknids;\n        int npknids;\n        npknids = e-\u003epkey_asn1_meths(e, NULL, \u0026pknids, 0);\n        for (i = 0; i \u003c npknids; i++) {\n            if (e-\u003epkey_asn1_meths(e, \u0026pkm, NULL, pknids[i])) {\n                EVP_PKEY_asn1_free(pkm);\n            }\n        }\n    }\n}","filepath":"crypto/engine/tb_asnmth.c","line_number":113,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre8"},"270158192":{"score":0.91103387,"function_name":"look_str_cb","code":"static void look_str_cb(int nid, STACK_OF(ENGINE) *sk, ENGINE *def, void *arg)\n{\n    ENGINE_FIND_STR *lk = arg;\n    int i;\n    if (lk-\u003eameth)\n        return;\n    for (i = 0; i \u003c sk_ENGINE_num(sk); i++) {\n        ENGINE *e = sk_ENGINE_value(sk, i);\n        EVP_PKEY_ASN1_METHOD *ameth;\n        e-\u003epkey_asn1_meths(e, \u0026ameth, NULL, nid);\n        if (ameth != NULL\n                \u0026\u0026 ((int)strlen(ameth-\u003epem_str) == lk-\u003elen)\n                \u0026\u0026 strncasecmp(ameth-\u003epem_str, lk-\u003estr, lk-\u003elen) == 0) {\n            lk-\u003ee = e;\n            lk-\u003eameth = ameth;\n            return;\n        }\n    }\n}","filepath":"crypto/engine/tb_asnmth.c","line_number":164,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre8"},"270158736":{"score":0.89828885,"function_name":"dh_pub_encode","code":"static int dh_pub_encode(X509_PUBKEY *pk, const EVP_PKEY *pkey)\n{\n    DH *dh;\n    int ptype;\n    unsigned char *penc = NULL;\n    int penclen;\n    ASN1_STRING *str;\n    ASN1_INTEGER *pub_key = NULL;\n\n    dh = pkey-\u003epkey.dh;\n\n    str = ASN1_STRING_new();\n    if (str == NULL) {\n        DHerr(DH_F_DH_PUB_ENCODE, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    str-\u003elength = i2d_dhp(pkey, dh, \u0026str-\u003edata);\n    if (str-\u003elength \u003c= 0) {\n        DHerr(DH_F_DH_PUB_ENCODE, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    ptype = V_ASN1_SEQUENCE;\n\n    pub_key = BN_to_ASN1_INTEGER(dh-\u003epub_key, NULL);\n    if (!pub_key)\n        goto err;\n\n    penclen = i2d_ASN1_INTEGER(pub_key, \u0026penc);\n\n    ASN1_INTEGER_free(pub_key);\n\n    if (penclen \u003c= 0) {\n        DHerr(DH_F_DH_PUB_ENCODE, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (X509_PUBKEY_set0_param(pk, OBJ_nid2obj(pkey-\u003eameth-\u003epkey_id),\n                               ptype, str, penc, penclen))\n        return 1;\n\n err:\n    OPENSSL_free(penc);\n    ASN1_STRING_free(str);\n\n    return 0;\n}","filepath":"crypto/dh/dh_ameth.c","line_number":148,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre4"},"270158992":{"score":0.9048519,"function_name":"dh_priv_decode","code":"static int dh_priv_decode(EVP_PKEY *pkey, PKCS8_PRIV_KEY_INFO *p8)\n{\n    const unsigned char *p, *pm;\n    int pklen, pmlen;\n    int ptype;\n    void *pval;\n    ASN1_STRING *pstr;\n    X509_ALGOR *palg;\n    ASN1_INTEGER *privkey = NULL;\n\n    DH *dh = NULL;\n\n    if (!PKCS8_pkey_get0(NULL, \u0026p, \u0026pklen, \u0026palg, p8))\n        return 0;\n\n    X509_ALGOR_get0(NULL, \u0026ptype, \u0026pval, palg);\n\n    if (ptype != V_ASN1_SEQUENCE)\n        goto decerr;\n    if ((privkey = d2i_ASN1_INTEGER(NULL, \u0026p, pklen)) == NULL)\n        goto decerr;\n\n    pstr = pval;\n    pm = pstr-\u003edata;\n    pmlen = pstr-\u003elength;\n    if ((dh = d2i_dhp(pkey, \u0026pm, pmlen)) == NULL)\n        goto decerr;\n\n    /* We have parameters now set private key */\n    if ((dh-\u003epriv_key = BN_secure_new()) == NULL\n        || !ASN1_INTEGER_to_BN(privkey, dh-\u003epriv_key)) {\n        DHerr(DH_F_DH_PRIV_DECODE, DH_R_BN_ERROR);\n        goto dherr;\n    }\n    /* Calculate public key */\n    if (!DH_generate_key(dh))\n        goto dherr;\n\n    EVP_PKEY_assign(pkey, pkey-\u003eameth-\u003epkey_id, dh);\n\n    ASN1_STRING_clear_free(privkey);\n\n    return 1;\n\n decerr:\n    DHerr(DH_F_DH_PRIV_DECODE, EVP_R_DECODE_ERROR);\n dherr:\n    DH_free(dh);\n    ASN1_STRING_clear_free(privkey);\n    return 0;\n}","filepath":"crypto/dh/dh_ameth.c","line_number":201,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre4"},"270159312":{"score":0.9229985,"function_name":"dh_priv_encode","code":"static int dh_priv_encode(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pkey)\n{\n    ASN1_STRING *params = NULL;\n    ASN1_INTEGER *prkey = NULL;\n    unsigned char *dp = NULL;\n    int dplen;\n\n    params = ASN1_STRING_new();\n\n    if (params == NULL) {\n        DHerr(DH_F_DH_PRIV_ENCODE, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    params-\u003elength = i2d_dhp(pkey, pkey-\u003epkey.dh, \u0026params-\u003edata);\n    if (params-\u003elength \u003c= 0) {\n        DHerr(DH_F_DH_PRIV_ENCODE, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    params-\u003etype = V_ASN1_SEQUENCE;\n\n    /* Get private key into integer */\n    prkey = BN_to_ASN1_INTEGER(pkey-\u003epkey.dh-\u003epriv_key, NULL);\n\n    if (!prkey) {\n        DHerr(DH_F_DH_PRIV_ENCODE, DH_R_BN_ERROR);\n        goto err;\n    }\n\n    dplen = i2d_ASN1_INTEGER(prkey, \u0026dp);\n\n    ASN1_STRING_clear_free(prkey);\n    prkey = NULL;\n\n    if (!PKCS8_pkey_set0(p8, OBJ_nid2obj(pkey-\u003eameth-\u003epkey_id), 0,\n                         V_ASN1_SEQUENCE, params, dp, dplen))\n        goto err;\n\n    return 1;\n\n err:\n    OPENSSL_free(dp);\n    ASN1_STRING_free(params);\n    ASN1_STRING_clear_free(prkey);\n    return 0;\n}","filepath":"crypto/dh/dh_ameth.c","line_number":253,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre4"},"270160032":{"score":0.81392753,"function_name":"dsa_cmp_parameters","code":"static int dsa_cmp_parameters(const EVP_PKEY *a, const EVP_PKEY *b)\n{\n    if (BN_cmp(a-\u003epkey.dsa-\u003ep, b-\u003epkey.dsa-\u003ep) ||\n        BN_cmp(a-\u003epkey.dsa-\u003eq, b-\u003epkey.dsa-\u003eq) ||\n        BN_cmp(a-\u003epkey.dsa-\u003eg, b-\u003epkey.dsa-\u003eg))\n        return 0;\n    else\n        return 1;\n}","filepath":"crypto/dsa/dsa_ameth.c","line_number":306,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270160608":{"score":0.8876346,"function_name":"dh_cms_encrypt","code":"static int dh_cms_encrypt(CMS_RecipientInfo *ri)\n{\n    EVP_PKEY_CTX *pctx;\n    EVP_PKEY *pkey;\n    EVP_CIPHER_CTX *ctx;\n    int keylen;\n    X509_ALGOR *talg, *wrap_alg = NULL;\n    ASN1_OBJECT *aoid;\n    ASN1_BIT_STRING *pubkey;\n    ASN1_STRING *wrap_str;\n    ASN1_OCTET_STRING *ukm;\n    unsigned char *penc = NULL, *dukm = NULL;\n    int penclen;\n    size_t dukmlen = 0;\n    int rv = 0;\n    int kdf_type, wrap_nid;\n    const EVP_MD *kdf_md;\n    pctx = CMS_RecipientInfo_get0_pkey_ctx(ri);\n    if (!pctx)\n        return 0;\n    /* Get ephemeral key */\n    pkey = EVP_PKEY_CTX_get0_pkey(pctx);\n    if (!CMS_RecipientInfo_kari_get0_orig_id(ri, \u0026talg, \u0026pubkey,\n                                             NULL, NULL, NULL))\n        goto err;\n    X509_ALGOR_get0(\u0026aoid, NULL, NULL, talg);\n    /* Is everything uninitialised? */\n    if (aoid == OBJ_nid2obj(NID_undef)) {\n        ASN1_INTEGER *pubk = BN_to_ASN1_INTEGER(pkey-\u003epkey.dh-\u003epub_key, NULL);\n        if (!pubk)\n            goto err;\n        /* Set the key */\n\n        penclen = i2d_ASN1_INTEGER(pubk, \u0026penc);\n        ASN1_INTEGER_free(pubk);\n        if (penclen \u003c= 0)\n            goto err;\n        ASN1_STRING_set0(pubkey, penc, penclen);\n        pubkey-\u003eflags \u0026= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);\n        pubkey-\u003eflags |= ASN1_STRING_FLAG_BITS_LEFT;\n\n        penc = NULL;\n        X509_ALGOR_set0(talg, OBJ_nid2obj(NID_dhpublicnumber),\n                        V_ASN1_UNDEF, NULL);\n    }\n\n    /* See if custom parameters set */\n    kdf_type = EVP_PKEY_CTX_get_dh_kdf_type(pctx);\n    if (kdf_type \u003c= 0)\n        goto err;\n    if (!EVP_PKEY_CTX_get_dh_kdf_md(pctx, \u0026kdf_md))\n        goto err;\n\n    if (kdf_type == EVP_PKEY_DH_KDF_NONE) {\n        kdf_type = EVP_PKEY_DH_KDF_X9_42;\n        if (EVP_PKEY_CTX_set_dh_kdf_type(pctx, kdf_type) \u003c= 0)\n            goto err;\n    } else if (kdf_type != EVP_PKEY_DH_KDF_X9_42)\n        /* Unknown KDF */\n        goto err;\n    if (kdf_md == NULL) {\n        /* Only SHA1 supported */\n        kdf_md = EVP_sha1();\n        if (EVP_PKEY_CTX_set_dh_kdf_md(pctx, kdf_md) \u003c= 0)\n            goto err;\n    } else if (EVP_MD_type(kdf_md) != NID_sha1)\n        /* Unsupported digest */\n        goto err;\n\n    if (!CMS_RecipientInfo_kari_get0_alg(ri, \u0026talg, \u0026ukm))\n        goto err;\n\n    /* Get wrap NID */\n    ctx = CMS_RecipientInfo_kari_get0_ctx(ri);\n    wrap_nid = EVP_CIPHER_CTX_type(ctx);\n    if (EVP_PKEY_CTX_set0_dh_kdf_oid(pctx, OBJ_nid2obj(wrap_nid)) \u003c= 0)\n        goto err;\n    keylen = EVP_CIPHER_CTX_key_length(ctx);\n\n    /* Package wrap algorithm in an AlgorithmIdentifier */\n\n    wrap_alg = X509_ALGOR_new();\n    if (wrap_alg == NULL)\n        goto err;\n    wrap_alg-\u003ealgorithm = OBJ_nid2obj(wrap_nid);\n    wrap_alg-\u003eparameter = ASN1_TYPE_new();\n    if (wrap_alg-\u003eparameter == NULL)\n        goto err;\n    if (EVP_CIPHER_param_to_asn1(ctx, wrap_alg-\u003eparameter) \u003c= 0)\n        goto err;\n    if (ASN1_TYPE_get(wrap_alg-\u003eparameter) == NID_undef) {\n        ASN1_TYPE_free(wrap_alg-\u003eparameter);\n        wrap_alg-\u003eparameter = NULL;\n    }\n\n    if (EVP_PKEY_CTX_set_dh_kdf_outlen(pctx, keylen) \u003c= 0)\n        goto err;\n\n    if (ukm) {\n        dukmlen = ASN1_STRING_length(ukm);\n        dukm = OPENSSL_memdup(ASN1_STRING_data(ukm), dukmlen);\n        if (!dukm)\n            goto err;\n    }\n\n    if (EVP_PKEY_CTX_set0_dh_kdf_ukm(pctx, dukm, dukmlen) \u003c= 0)\n        goto err;\n    dukm = NULL;\n\n    /*\n     * Now need to wrap encoding of wrap AlgorithmIdentifier into parameter\n     * of another AlgorithmIdentifier.\n     */\n    penc = NULL;\n    penclen = i2d_X509_ALGOR(wrap_alg, \u0026penc);\n    if (!penc || !penclen)\n        goto err;\n    wrap_str = ASN1_STRING_new();\n    if (wrap_str == NULL)\n        goto err;\n    ASN1_STRING_set0(wrap_str, penc, penclen);\n    penc = NULL;\n    X509_ALGOR_set0(talg, OBJ_nid2obj(NID_id_smime_alg_ESDH),\n                    V_ASN1_SEQUENCE, wrap_str);\n\n    rv = 1;\n\n err:\n    OPENSSL_free(penc);\n    X509_ALGOR_free(wrap_alg);\n    return rv;\n}","filepath":"crypto/dh/dh_ameth.c","line_number":787,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre4"},"270161552":{"score":0.87858516,"function_name":"dh_cms_set_peerkey","code":"static int dh_cms_set_peerkey(EVP_PKEY_CTX *pctx,\n                              X509_ALGOR *alg, ASN1_BIT_STRING *pubkey)\n{\n    ASN1_OBJECT *aoid;\n    int atype;\n    void *aval;\n    ASN1_INTEGER *public_key = NULL;\n    int rv = 0;\n    EVP_PKEY *pkpeer = NULL, *pk = NULL;\n    DH *dhpeer = NULL;\n    const unsigned char *p;\n    int plen;\n\n    X509_ALGOR_get0(\u0026aoid, \u0026atype, \u0026aval, alg);\n    if (OBJ_obj2nid(aoid) != NID_dhpublicnumber)\n        goto err;\n    /* Only absent parameters allowed in RFC XXXX */\n    if (atype != V_ASN1_UNDEF \u0026\u0026 atype == V_ASN1_NULL)\n        goto err;\n\n    pk = EVP_PKEY_CTX_get0_pkey(pctx);\n    if (!pk)\n        goto err;\n    if (pk-\u003etype != EVP_PKEY_DHX)\n        goto err;\n    /* Get parameters from parent key */\n    dhpeer = DHparams_dup(pk-\u003epkey.dh);\n    /* We have parameters now set public key */\n    plen = ASN1_STRING_length(pubkey);\n    p = ASN1_STRING_data(pubkey);\n    if (!p || !plen)\n        goto err;\n\n    if ((public_key = d2i_ASN1_INTEGER(NULL, \u0026p, plen)) == NULL) {\n        DHerr(DH_F_DH_CMS_SET_PEERKEY, DH_R_DECODE_ERROR);\n        goto err;\n    }\n\n    /* We have parameters now set public key */\n    if ((dhpeer-\u003epub_key = ASN1_INTEGER_to_BN(public_key, NULL)) == NULL) {\n        DHerr(DH_F_DH_CMS_SET_PEERKEY, DH_R_BN_DECODE_ERROR);\n        goto err;\n    }\n\n    pkpeer = EVP_PKEY_new();\n    if (pkpeer == NULL)\n        goto err;\n    EVP_PKEY_assign(pkpeer, pk-\u003eameth-\u003epkey_id, dhpeer);\n    dhpeer = NULL;\n    if (EVP_PKEY_derive_set_peer(pctx, pkpeer) \u003e 0)\n        rv = 1;\n err:\n    ASN1_INTEGER_free(public_key);\n    EVP_PKEY_free(pkpeer);\n    DH_free(dhpeer);\n    return rv;\n}","filepath":"crypto/dh/dh_ameth.c","line_number":624,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre4"},"270161968":{"score":0.8675989,"function_name":"dh_cms_set_shared_info","code":"static int dh_cms_set_shared_info(EVP_PKEY_CTX *pctx, CMS_RecipientInfo *ri)\n{\n    int rv = 0;\n\n    X509_ALGOR *alg, *kekalg = NULL;\n    ASN1_OCTET_STRING *ukm;\n    const unsigned char *p;\n    unsigned char *dukm = NULL;\n    size_t dukmlen = 0;\n    int keylen, plen;\n    const EVP_CIPHER *kekcipher;\n    EVP_CIPHER_CTX *kekctx;\n\n    if (!CMS_RecipientInfo_kari_get0_alg(ri, \u0026alg, \u0026ukm))\n        goto err;\n\n    /*\n     * For DH we only have one OID permissible. If ever any more get defined\n     * we will need something cleverer.\n     */\n    if (OBJ_obj2nid(alg-\u003ealgorithm) != NID_id_smime_alg_ESDH) {\n        DHerr(DH_F_DH_CMS_SET_SHARED_INFO, DH_R_KDF_PARAMETER_ERROR);\n        goto err;\n    }\n\n    if (EVP_PKEY_CTX_set_dh_kdf_type(pctx, EVP_PKEY_DH_KDF_X9_42) \u003c= 0)\n        goto err;\n\n    if (EVP_PKEY_CTX_set_dh_kdf_md(pctx, EVP_sha1()) \u003c= 0)\n        goto err;\n\n    if (alg-\u003eparameter-\u003etype != V_ASN1_SEQUENCE)\n        goto err;\n\n    p = alg-\u003eparameter-\u003evalue.sequence-\u003edata;\n    plen = alg-\u003eparameter-\u003evalue.sequence-\u003elength;\n    kekalg = d2i_X509_ALGOR(NULL, \u0026p, plen);\n    if (!kekalg)\n        goto err;\n    kekctx = CMS_RecipientInfo_kari_get0_ctx(ri);\n    if (!kekctx)\n        goto err;\n    kekcipher = EVP_get_cipherbyobj(kekalg-\u003ealgorithm);\n    if (!kekcipher || EVP_CIPHER_mode(kekcipher) != EVP_CIPH_WRAP_MODE)\n        goto err;\n    if (!EVP_EncryptInit_ex(kekctx, kekcipher, NULL, NULL, NULL))\n        goto err;\n    if (EVP_CIPHER_asn1_to_param(kekctx, kekalg-\u003eparameter) \u003c= 0)\n        goto err;\n\n    keylen = EVP_CIPHER_CTX_key_length(kekctx);\n    if (EVP_PKEY_CTX_set_dh_kdf_outlen(pctx, keylen) \u003c= 0)\n        goto err;\n    /* Use OBJ_nid2obj to ensure we use built in OID that isn't freed */\n    if (EVP_PKEY_CTX_set0_dh_kdf_oid(pctx,\n                                     OBJ_nid2obj(EVP_CIPHER_type(kekcipher)))\n        \u003c= 0)\n        goto err;\n\n    if (ukm) {\n        dukmlen = ASN1_STRING_length(ukm);\n        dukm = OPENSSL_memdup(ASN1_STRING_data(ukm), dukmlen);\n        if (!dukm)\n            goto err;\n    }\n\n    if (EVP_PKEY_CTX_set0_dh_kdf_ukm(pctx, dukm, dukmlen) \u003c= 0)\n        goto err;\n    dukm = NULL;\n\n    rv = 1;\n err:\n    X509_ALGOR_free(kekalg);\n    OPENSSL_free(dukm);\n    return rv;\n}","filepath":"crypto/dh/dh_ameth.c","line_number":682,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre4"},"270162576":{"score":0.9354032,"function_name":"do_dh_print","code":"static int do_dh_print(BIO *bp, const DH *x, int indent, int ptype)\n{\n    int reason = ERR_R_BUF_LIB;\n    const char *ktype = NULL;\n    BIGNUM *priv_key, *pub_key;\n\n    if (ptype == 2)\n        priv_key = x-\u003epriv_key;\n    else\n        priv_key = NULL;\n\n    if (ptype \u003e 0)\n        pub_key = x-\u003epub_key;\n    else\n        pub_key = NULL;\n\n    if (priv_key == NULL \u0026\u0026 pub_key == NULL) {\n        reason = ERR_R_PASSED_NULL_PARAMETER;\n        goto err;\n    }\n\n    if (ptype == 2)\n        ktype = \"DH Private-Key\";\n    else if (ptype == 1)\n        ktype = \"DH Public-Key\";\n    else\n        ktype = \"DH Parameters\";\n\n    BIO_indent(bp, indent, 128);\n    if (BIO_printf(bp, \"%s: (%d bit)\\n\", ktype, BN_num_bits(x-\u003ep)) \u003c= 0)\n        goto err;\n    indent += 4;\n\n    if (!ASN1_bn_print(bp, \"private-key:\", priv_key, NULL, indent))\n        goto err;\n    if (!ASN1_bn_print(bp, \"public-key:\", pub_key, NULL, indent))\n        goto err;\n\n    if (!ASN1_bn_print(bp, \"prime:\", x-\u003ep, NULL, indent))\n        goto err;\n    if (!ASN1_bn_print(bp, \"generator:\", x-\u003eg, NULL, indent))\n        goto err;\n    if (x-\u003eq \u0026\u0026 !ASN1_bn_print(bp, \"subgroup order:\", x-\u003eq, NULL, indent))\n        goto err;\n    if (x-\u003ej \u0026\u0026 !ASN1_bn_print(bp, \"subgroup factor:\", x-\u003ej, NULL, indent))\n        goto err;\n    if (x-\u003eseed) {\n        int i;\n        BIO_indent(bp, indent, 128);\n        BIO_puts(bp, \"seed:\");\n        for (i = 0; i \u003c x-\u003eseedlen; i++) {\n            if ((i % 15) == 0) {\n                if (BIO_puts(bp, \"\\n\") \u003c= 0\n                    || !BIO_indent(bp, indent + 4, 128))\n                    goto err;\n            }\n            if (BIO_printf(bp, \"%02x%s\", x-\u003eseed[i],\n                           ((i + 1) == x-\u003eseedlen) ? \"\" : \":\") \u003c= 0)\n                goto err;\n        }\n        if (BIO_write(bp, \"\\n\", 1) \u003c= 0)\n            return (0);\n    }\n    if (x-\u003ecounter \u0026\u0026 !ASN1_bn_print(bp, \"counter:\", x-\u003ecounter, NULL, indent))\n        goto err;\n    if (x-\u003elength != 0) {\n        BIO_indent(bp, indent, 128);\n        if (BIO_printf(bp, \"recommended-private-length: %d bits\\n\",\n                       (int)x-\u003elength) \u003c= 0)\n            goto err;\n    }\n\n    return 1;\n\n err:\n    DHerr(DH_F_DO_DH_PRINT, reason);\n    return 0;\n}","filepath":"crypto/dh/dh_ameth.c","line_number":318,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre4"},"270163264":{"score":0.75287455,"function_name":"int_dh_bn_cpy","code":"static int int_dh_bn_cpy(BIGNUM **dst, const BIGNUM *src)\n{\n    BIGNUM *a;\n    if (src) {\n        a = BN_dup(src);\n        if (!a)\n            return 0;\n    } else\n        a = NULL;\n    BN_free(*dst);\n    *dst = a;\n    return 1;\n}","filepath":"crypto/dh/dh_ameth.c","line_number":424,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre4"},"270163360":{"score":0.8664979,"function_name":"int_dh_param_copy","code":"static int int_dh_param_copy(DH *to, const DH *from, int is_x942)\n{\n    if (is_x942 == -1)\n        is_x942 = ! !from-\u003eq;\n    if (!int_dh_bn_cpy(\u0026to-\u003ep, from-\u003ep))\n        return 0;\n    if (!int_dh_bn_cpy(\u0026to-\u003eg, from-\u003eg))\n        return 0;\n    if (is_x942) {\n        if (!int_dh_bn_cpy(\u0026to-\u003eq, from-\u003eq))\n            return 0;\n        if (!int_dh_bn_cpy(\u0026to-\u003ej, from-\u003ej))\n            return 0;\n        OPENSSL_free(to-\u003eseed);\n        to-\u003eseed = NULL;\n        to-\u003eseedlen = 0;\n        if (from-\u003eseed) {\n            to-\u003eseed = OPENSSL_memdup(from-\u003eseed, from-\u003eseedlen);\n            if (!to-\u003eseed)\n                return 0;\n            to-\u003eseedlen = from-\u003eseedlen;\n        }\n    } else\n        to-\u003elength = from-\u003elength;\n    return 1;\n}","filepath":"crypto/dh/dh_ameth.c","line_number":438,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre4"},"270163936":{"score":0.9074887,"function_name":"dsa_pub_encode","code":"static int dsa_pub_encode(X509_PUBKEY *pk, const EVP_PKEY *pkey)\n{\n    DSA *dsa;\n    int ptype;\n    unsigned char *penc = NULL;\n    int penclen;\n    ASN1_STRING *str = NULL;\n    ASN1_INTEGER *pubint = NULL;\n    ASN1_OBJECT *aobj;\n\n    dsa = pkey-\u003epkey.dsa;\n    if (pkey-\u003esave_parameters \u0026\u0026 dsa-\u003ep \u0026\u0026 dsa-\u003eq \u0026\u0026 dsa-\u003eg) {\n        str = ASN1_STRING_new();\n        if (str == NULL) {\n            DSAerr(DSA_F_DSA_PUB_ENCODE, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        str-\u003elength = i2d_DSAparams(dsa, \u0026str-\u003edata);\n        if (str-\u003elength \u003c= 0) {\n            DSAerr(DSA_F_DSA_PUB_ENCODE, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        ptype = V_ASN1_SEQUENCE;\n    } else\n        ptype = V_ASN1_UNDEF;\n\n    pubint = BN_to_ASN1_INTEGER(dsa-\u003epub_key, NULL);\n\n    if (pubint == NULL) {\n        DSAerr(DSA_F_DSA_PUB_ENCODE, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    penclen = i2d_ASN1_INTEGER(pubint, \u0026penc);\n    ASN1_INTEGER_free(pubint);\n\n    if (penclen \u003c= 0) {\n        DSAerr(DSA_F_DSA_PUB_ENCODE, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    aobj = OBJ_nid2obj(EVP_PKEY_DSA);\n    if (aobj == NULL)\n        goto err;\n\n    if (X509_PUBKEY_set0_param(pk, aobj, ptype, str, penc, penclen))\n        return 1;\n\n err:\n    OPENSSL_free(penc);\n    ASN1_STRING_free(str);\n\n    return 0;\n}","filepath":"crypto/dsa/dsa_ameth.c","line_number":77,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270164208":{"score":0.90648687,"function_name":"dsa_priv_decode","code":"static int dsa_priv_decode(EVP_PKEY *pkey, const PKCS8_PRIV_KEY_INFO *p8)\n{\n    const unsigned char *p, *pm;\n    int pklen, pmlen;\n    int ptype;\n    const void *pval;\n    const ASN1_STRING *pstr;\n    const X509_ALGOR *palg;\n    ASN1_INTEGER *privkey = NULL;\n    BN_CTX *ctx = NULL;\n\n    DSA *dsa = NULL;\n\n    int ret = 0;\n\n    if (!PKCS8_pkey_get0(NULL, \u0026p, \u0026pklen, \u0026palg, p8))\n        return 0;\n    X509_ALGOR_get0(NULL, \u0026ptype, \u0026pval, palg);\n\n    if ((privkey = d2i_ASN1_INTEGER(NULL, \u0026p, pklen)) == NULL)\n        goto decerr;\n    if (privkey-\u003etype == V_ASN1_NEG_INTEGER || ptype != V_ASN1_SEQUENCE)\n        goto decerr;\n\n    pstr = pval;\n    pm = pstr-\u003edata;\n    pmlen = pstr-\u003elength;\n    if ((dsa = d2i_DSAparams(NULL, \u0026pm, pmlen)) == NULL)\n        goto decerr;\n    /* We have parameters now set private key */\n    if ((dsa-\u003epriv_key = BN_secure_new()) == NULL\n        || !ASN1_INTEGER_to_BN(privkey, dsa-\u003epriv_key)) {\n        DSAerr(DSA_F_DSA_PRIV_DECODE, DSA_R_BN_ERROR);\n        goto dsaerr;\n    }\n    /* Calculate public key */\n    if ((dsa-\u003epub_key = BN_new()) == NULL) {\n        DSAerr(DSA_F_DSA_PRIV_DECODE, ERR_R_MALLOC_FAILURE);\n        goto dsaerr;\n    }\n    if ((ctx = BN_CTX_new()) == NULL) {\n        DSAerr(DSA_F_DSA_PRIV_DECODE, ERR_R_MALLOC_FAILURE);\n        goto dsaerr;\n    }\n\n    BN_set_flags(dsa-\u003epriv_key, BN_FLG_CONSTTIME);\n    if (!BN_mod_exp(dsa-\u003epub_key, dsa-\u003eg, dsa-\u003epriv_key, dsa-\u003ep, ctx)) {\n        DSAerr(DSA_F_DSA_PRIV_DECODE, DSA_R_BN_ERROR);\n        goto dsaerr;\n    }\n\n    EVP_PKEY_assign_DSA(pkey, dsa);\n\n    ret = 1;\n    goto done;\n\n decerr:\n    DSAerr(DSA_F_DSA_PRIV_DECODE, DSA_R_DECODE_ERROR);\n dsaerr:\n    DSA_free(dsa);\n done:\n    BN_CTX_free(ctx);\n    ASN1_STRING_clear_free(privkey);\n    return ret;\n}","filepath":"crypto/dsa/dsa_ameth.c","line_number":137,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270164592":{"score":0.920312,"function_name":"dsa_priv_encode","code":"static int dsa_priv_encode(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pkey)\n{\n    ASN1_STRING *params = NULL;\n    ASN1_INTEGER *prkey = NULL;\n    unsigned char *dp = NULL;\n    int dplen;\n\n    if (!pkey-\u003epkey.dsa || !pkey-\u003epkey.dsa-\u003epriv_key) {\n        DSAerr(DSA_F_DSA_PRIV_ENCODE, DSA_R_MISSING_PARAMETERS);\n        goto err;\n    }\n\n    params = ASN1_STRING_new();\n\n    if (params == NULL) {\n        DSAerr(DSA_F_DSA_PRIV_ENCODE, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    params-\u003elength = i2d_DSAparams(pkey-\u003epkey.dsa, \u0026params-\u003edata);\n    if (params-\u003elength \u003c= 0) {\n        DSAerr(DSA_F_DSA_PRIV_ENCODE, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    params-\u003etype = V_ASN1_SEQUENCE;\n\n    /* Get private key into integer */\n    prkey = BN_to_ASN1_INTEGER(pkey-\u003epkey.dsa-\u003epriv_key, NULL);\n\n    if (!prkey) {\n        DSAerr(DSA_F_DSA_PRIV_ENCODE, DSA_R_BN_ERROR);\n        goto err;\n    }\n\n    dplen = i2d_ASN1_INTEGER(prkey, \u0026dp);\n\n    ASN1_STRING_clear_free(prkey);\n    prkey = NULL;\n\n    if (!PKCS8_pkey_set0(p8, OBJ_nid2obj(NID_dsa), 0,\n                         V_ASN1_SEQUENCE, params, dp, dplen))\n        goto err;\n\n    return 1;\n\n err:\n    OPENSSL_free(dp);\n    ASN1_STRING_free(params);\n    ASN1_STRING_clear_free(prkey);\n    return 0;\n}","filepath":"crypto/dsa/dsa_ameth.c","line_number":203,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270165616":{"score":0.79486203,"function_name":"dsa_sig_print","code":"static int dsa_sig_print(BIO *bp, const X509_ALGOR *sigalg,\n                         const ASN1_STRING *sig, int indent, ASN1_PCTX *pctx)\n{\n    DSA_SIG *dsa_sig;\n    const unsigned char *p;\n\n    if (!sig) {\n        if (BIO_puts(bp, \"\\n\") \u003c= 0)\n            return 0;\n        else\n            return 1;\n    }\n    p = sig-\u003edata;\n    dsa_sig = d2i_DSA_SIG(NULL, \u0026p, sig-\u003elength);\n    if (dsa_sig) {\n        int rv = 0;\n        const BIGNUM *r, *s;\n\n        DSA_SIG_get0(dsa_sig, \u0026r, \u0026s);\n\n        if (BIO_write(bp, \"\\n\", 1) != 1)\n            goto err;\n\n        if (!ASN1_bn_print(bp, \"r:   \", r, NULL, indent))\n            goto err;\n        if (!ASN1_bn_print(bp, \"s:   \", s, NULL, indent))\n            goto err;\n        rv = 1;\n err:\n        DSA_SIG_free(dsa_sig);\n        return rv;\n    }\n    return X509_signature_dump(bp, sig, indent);\n}","filepath":"crypto/dsa/dsa_ameth.c","line_number":429,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270165856":{"score":0.80393326,"function_name":"dsa_pkey_ctrl","code":"static int dsa_pkey_ctrl(EVP_PKEY *pkey, int op, long arg1, void *arg2)\n{\n    switch (op) {\n    case ASN1_PKEY_CTRL_PKCS7_SIGN:\n        if (arg1 == 0) {\n            int snid, hnid;\n            X509_ALGOR *alg1, *alg2;\n            PKCS7_SIGNER_INFO_get0_algs(arg2, NULL, \u0026alg1, \u0026alg2);\n            if (alg1 == NULL || alg1-\u003ealgorithm == NULL)\n                return -1;\n            hnid = OBJ_obj2nid(alg1-\u003ealgorithm);\n            if (hnid == NID_undef)\n                return -1;\n            if (!OBJ_find_sigid_by_algs(\u0026snid, hnid, EVP_PKEY_id(pkey)))\n                return -1;\n            X509_ALGOR_set0(alg2, OBJ_nid2obj(snid), V_ASN1_UNDEF, 0);\n        }\n        return 1;\n#ifndef OPENSSL_NO_CMS\n    case ASN1_PKEY_CTRL_CMS_SIGN:\n        if (arg1 == 0) {\n            int snid, hnid;\n            X509_ALGOR *alg1, *alg2;\n            CMS_SignerInfo_get0_algs(arg2, NULL, NULL, \u0026alg1, \u0026alg2);\n            if (alg1 == NULL || alg1-\u003ealgorithm == NULL)\n                return -1;\n            hnid = OBJ_obj2nid(alg1-\u003ealgorithm);\n            if (hnid == NID_undef)\n                return -1;\n            if (!OBJ_find_sigid_by_algs(\u0026snid, hnid, EVP_PKEY_id(pkey)))\n                return -1;\n            X509_ALGOR_set0(alg2, OBJ_nid2obj(snid), V_ASN1_UNDEF, 0);\n        }\n        return 1;\n\n    case ASN1_PKEY_CTRL_CMS_RI_TYPE:\n        *(int *)arg2 = CMS_RECIPINFO_NONE;\n        return 1;\n#endif\n\n    case ASN1_PKEY_CTRL_DEFAULT_MD_NID:\n        *(int *)arg2 = NID_sha256;\n        return 1;\n\n    default:\n        return -2;\n\n    }\n\n}","filepath":"crypto/dsa/dsa_ameth.c","line_number":464,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270166256":{"score":0.92191976,"function_name":"do_dsa_print","code":"static int do_dsa_print(BIO *bp, const DSA *x, int off, int ptype)\n{\n    int ret = 0;\n    const char *ktype = NULL;\n    const BIGNUM *priv_key, *pub_key;\n\n    if (ptype == 2)\n        priv_key = x-\u003epriv_key;\n    else\n        priv_key = NULL;\n\n    if (ptype \u003e 0)\n        pub_key = x-\u003epub_key;\n    else\n        pub_key = NULL;\n\n    if (ptype == 2)\n        ktype = \"Private-Key\";\n    else if (ptype == 1)\n        ktype = \"Public-Key\";\n    else\n        ktype = \"DSA-Parameters\";\n\n    if (priv_key) {\n        if (!BIO_indent(bp, off, 128))\n            goto err;\n        if (BIO_printf(bp, \"%s: (%d bit)\\n\", ktype, BN_num_bits(x-\u003ep))\n            \u003c= 0)\n            goto err;\n    }\n\n    if (!ASN1_bn_print(bp, \"priv:\", priv_key, NULL, off))\n        goto err;\n    if (!ASN1_bn_print(bp, \"pub: \", pub_key, NULL, off))\n        goto err;\n    if (!ASN1_bn_print(bp, \"P:   \", x-\u003ep, NULL, off))\n        goto err;\n    if (!ASN1_bn_print(bp, \"Q:   \", x-\u003eq, NULL, off))\n        goto err;\n    if (!ASN1_bn_print(bp, \"G:   \", x-\u003eg, NULL, off))\n        goto err;\n    ret = 1;\n err:\n    return ret;\n}","filepath":"crypto/dsa/dsa_ameth.c","line_number":329,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270166576":{"score":0.90150154,"function_name":"eckey_pub_encode","code":"static int eckey_pub_encode(X509_PUBKEY *pk, const EVP_PKEY *pkey)\n{\n    EC_KEY *ec_key = pkey-\u003epkey.ec;\n    void *pval = NULL;\n    int ptype;\n    unsigned char *penc = NULL, *p;\n    int penclen;\n\n    if (!eckey_param2type(\u0026ptype, \u0026pval, ec_key)) {\n        ECerr(EC_F_ECKEY_PUB_ENCODE, ERR_R_EC_LIB);\n        return 0;\n    }\n    penclen = i2o_ECPublicKey(ec_key, NULL);\n    if (penclen \u003c= 0)\n        goto err;\n    penc = OPENSSL_malloc(penclen);\n    if (penc == NULL)\n        goto err;\n    p = penc;\n    penclen = i2o_ECPublicKey(ec_key, \u0026p);\n    if (penclen \u003c= 0)\n        goto err;\n    if (X509_PUBKEY_set0_param(pk, OBJ_nid2obj(EVP_PKEY_EC),\n                               ptype, pval, penc, penclen))\n        return 1;\n err:\n    if (ptype == V_ASN1_OBJECT)\n        ASN1_OBJECT_free(pval);\n    else\n        ASN1_STRING_free(pval);\n    OPENSSL_free(penc);\n    return 0;\n}","filepath":"openssl/crypto/ec/ec_ameth.c","line_number":58,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.0"},"270166832":{"score":0.93254006,"function_name":"eckey_priv_decode","code":"static int eckey_priv_decode(EVP_PKEY *pkey, const PKCS8_PRIV_KEY_INFO *p8)\n{\n    const unsigned char *p = NULL;\n    const void *pval;\n    int ptype, pklen;\n    EC_KEY *eckey = NULL;\n    const X509_ALGOR *palg;\n\n    if (!PKCS8_pkey_get0(NULL, \u0026p, \u0026pklen, \u0026palg, p8))\n        return 0;\n    X509_ALGOR_get0(NULL, \u0026ptype, \u0026pval, palg);\n\n    eckey = eckey_type2param(ptype, pval);\n\n    if (!eckey)\n        goto ecliberr;\n\n    /* We have parameters now set private key */\n    if (!d2i_ECPrivateKey(\u0026eckey, \u0026p, pklen)) {\n        ECerr(EC_F_ECKEY_PRIV_DECODE, EC_R_DECODE_ERROR);\n        goto ecerr;\n    }\n\n    EVP_PKEY_assign_EC_KEY(pkey, eckey);\n    return 1;\n\n ecliberr:\n    ECerr(EC_F_ECKEY_PRIV_DECODE, ERR_R_EC_LIB);\n ecerr:\n    EC_KEY_free(eckey);\n    return 0;\n}","filepath":"openssl/crypto/ec/ec_ameth.c","line_number":185,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.0"},"270167408":{"score":0.91259545,"function_name":"eckey_priv_encode","code":"static int eckey_priv_encode(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pkey)\n{\n    EC_KEY ec_key = *(pkey-\u003epkey.ec);\n    unsigned char *ep, *p;\n    int eplen, ptype;\n    void *pval;\n    unsigned int old_flags;\n\n    if (!eckey_param2type(\u0026ptype, \u0026pval, \u0026ec_key)) {\n        ECerr(EC_F_ECKEY_PRIV_ENCODE, EC_R_DECODE_ERROR);\n        return 0;\n    }\n\n    /* set the private key */\n\n    /*\n     * do not include the parameters in the SEC1 private key see PKCS#11\n     * 12.11\n     */\n    old_flags = EC_KEY_get_enc_flags(\u0026ec_key);\n    EC_KEY_set_enc_flags(\u0026ec_key, old_flags | EC_PKEY_NO_PARAMETERS);\n\n    eplen = i2d_ECPrivateKey(\u0026ec_key, NULL);\n    if (!eplen) {\n        ECerr(EC_F_ECKEY_PRIV_ENCODE, ERR_R_EC_LIB);\n        return 0;\n    }\n    ep = OPENSSL_malloc(eplen);\n    if (ep == NULL) {\n        ECerr(EC_F_ECKEY_PRIV_ENCODE, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n    p = ep;\n    if (!i2d_ECPrivateKey(\u0026ec_key, \u0026p)) {\n        OPENSSL_free(ep);\n        ECerr(EC_F_ECKEY_PRIV_ENCODE, ERR_R_EC_LIB);\n        return 0;\n    }\n\n    if (!PKCS8_pkey_set0(p8, OBJ_nid2obj(NID_X9_62_id_ecPublicKey), 0,\n                         ptype, pval, ep, eplen)) {\n        OPENSSL_free(ep);\n        return 0;\n    }\n\n    return 1;\n}","filepath":"openssl/crypto/ec/ec_ameth.c","line_number":218,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.0"},"270168528":{"score":0.8636177,"function_name":"ec_pkey_ctrl","code":"static int ec_pkey_ctrl(EVP_PKEY *pkey, int op, long arg1, void *arg2)\n{\n    switch (op) {\n    case ASN1_PKEY_CTRL_PKCS7_SIGN:\n        if (arg1 == 0) {\n            int snid, hnid;\n            X509_ALGOR *alg1, *alg2;\n            PKCS7_SIGNER_INFO_get0_algs(arg2, NULL, \u0026alg1, \u0026alg2);\n            if (alg1 == NULL || alg1-\u003ealgorithm == NULL)\n                return -1;\n            hnid = OBJ_obj2nid(alg1-\u003ealgorithm);\n            if (hnid == NID_undef)\n                return -1;\n            if (!OBJ_find_sigid_by_algs(\u0026snid, hnid, EVP_PKEY_id(pkey)))\n                return -1;\n            X509_ALGOR_set0(alg2, OBJ_nid2obj(snid), V_ASN1_UNDEF, 0);\n        }\n        return 1;\n#ifndef OPENSSL_NO_CMS\n    case ASN1_PKEY_CTRL_CMS_SIGN:\n        if (arg1 == 0) {\n            int snid, hnid;\n            X509_ALGOR *alg1, *alg2;\n            CMS_SignerInfo_get0_algs(arg2, NULL, NULL, \u0026alg1, \u0026alg2);\n            if (alg1 == NULL || alg1-\u003ealgorithm == NULL)\n                return -1;\n            hnid = OBJ_obj2nid(alg1-\u003ealgorithm);\n            if (hnid == NID_undef)\n                return -1;\n            if (!OBJ_find_sigid_by_algs(\u0026snid, hnid, EVP_PKEY_id(pkey)))\n                return -1;\n            X509_ALGOR_set0(alg2, OBJ_nid2obj(snid), V_ASN1_UNDEF, 0);\n        }\n        return 1;\n\n    case ASN1_PKEY_CTRL_CMS_ENVELOPE:\n        if (arg1 == 1)\n            return ecdh_cms_decrypt(arg2);\n        else if (arg1 == 0)\n            return ecdh_cms_encrypt(arg2);\n        return -2;\n\n    case ASN1_PKEY_CTRL_CMS_RI_TYPE:\n        *(int *)arg2 = CMS_RECIPINFO_AGREE;\n        return 1;\n#endif\n\n    case ASN1_PKEY_CTRL_DEFAULT_MD_NID:\n        if (EVP_PKEY_id(pkey) == EVP_PKEY_SM2) {\n            /* For SM2, the only valid digest-alg is SM3 */\n            *(int *)arg2 = NID_sm3;\n        } else {\n            *(int *)arg2 = NID_sha256;\n        }\n        return 1;\n\n    case ASN1_PKEY_CTRL_SET1_TLS_ENCPT:\n        return EC_KEY_oct2key(EVP_PKEY_get0_EC_KEY(pkey), arg2, arg1, NULL);\n\n    case ASN1_PKEY_CTRL_GET1_TLS_ENCPT:\n        return EC_KEY_key2buf(EVP_PKEY_get0_EC_KEY(pkey),\n                              POINT_CONVERSION_UNCOMPRESSED, arg2, NULL);\n\n    default:\n        return -2;\n\n    }\n\n}","filepath":"openssl/crypto/ec/ec_ameth.c","line_number":459,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.0"},"270169232":{"score":0.92286384,"function_name":"do_EC_KEY_print","code":"static int do_EC_KEY_print(BIO *bp, const EC_KEY *x, int off, ec_print_t ktype)\n{\n    const char *ecstr;\n    unsigned char *priv = NULL, *pub = NULL;\n    size_t privlen = 0, publen = 0;\n    int ret = 0;\n    const EC_GROUP *group;\n\n    if (x == NULL || (group = EC_KEY_get0_group(x)) == NULL) {\n        ECerr(EC_F_DO_EC_KEY_PRINT, ERR_R_PASSED_NULL_PARAMETER);\n        return 0;\n    }\n\n    if (ktype != EC_KEY_PRINT_PARAM \u0026\u0026 EC_KEY_get0_public_key(x) != NULL) {\n        publen = EC_KEY_key2buf(x, EC_KEY_get_conv_form(x), \u0026pub, NULL);\n        if (publen == 0)\n            goto err;\n    }\n\n    if (ktype == EC_KEY_PRINT_PRIVATE \u0026\u0026 EC_KEY_get0_private_key(x) != NULL) {\n        privlen = EC_KEY_priv2buf(x, \u0026priv);\n        if (privlen == 0)\n            goto err;\n    }\n\n    if (ktype == EC_KEY_PRINT_PRIVATE)\n        ecstr = \"Private-Key\";\n    else if (ktype == EC_KEY_PRINT_PUBLIC)\n        ecstr = \"Public-Key\";\n    else\n        ecstr = \"ECDSA-Parameters\";\n\n    if (!BIO_indent(bp, off, 128))\n        goto err;\n    if (BIO_printf(bp, \"%s: (%d bit)\\n\", ecstr,\n                   EC_GROUP_order_bits(group)) \u003c= 0)\n        goto err;\n\n    if (privlen != 0) {\n        if (BIO_printf(bp, \"%*spriv:\\n\", off, \"\") \u003c= 0)\n            goto err;\n        if (ASN1_buf_print(bp, priv, privlen, off + 4) == 0)\n            goto err;\n    }\n\n    if (publen != 0) {\n        if (BIO_printf(bp, \"%*spub:\\n\", off, \"\") \u003c= 0)\n            goto err;\n        if (ASN1_buf_print(bp, pub, publen, off + 4) == 0)\n            goto err;\n    }\n\n    if (!ECPKParameters_print(bp, group, off))\n        goto err;\n    ret = 1;\n err:\n    if (!ret)\n        ECerr(EC_F_DO_EC_KEY_PRINT, ERR_R_EC_LIB);\n    OPENSSL_clear_free(priv, privlen);\n    OPENSSL_free(pub);\n    return ret;\n}","filepath":"openssl/crypto/ec/ec_ameth.c","line_number":342,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.0"},"270169760":{"score":0.83452994,"function_name":"ecdh_cms_decrypt","code":"static int ecdh_cms_decrypt(CMS_RecipientInfo *ri)\n{\n    EVP_PKEY_CTX *pctx;\n    pctx = CMS_RecipientInfo_get0_pkey_ctx(ri);\n    if (!pctx)\n        return 0;\n    /* See if we need to set peer key */\n    if (!EVP_PKEY_CTX_get0_peerkey(pctx)) {\n        X509_ALGOR *alg;\n        ASN1_BIT_STRING *pubkey;\n        if (!CMS_RecipientInfo_kari_get0_orig_id(ri, \u0026alg, \u0026pubkey,\n                                                 NULL, NULL, NULL))\n            return 0;\n        if (!alg || !pubkey)\n            return 0;\n        if (!ecdh_cms_set_peerkey(pctx, alg, pubkey)) {\n            ECerr(EC_F_ECDH_CMS_DECRYPT, EC_R_PEER_KEY_ERROR);\n            return 0;\n        }\n    }\n    /* Set ECDH derivation parameters and initialise unwrap context */\n    if (!ecdh_cms_set_shared_info(pctx, ri)) {\n        ECerr(EC_F_ECDH_CMS_DECRYPT, EC_R_SHARED_INFO_ERROR);\n        return 0;\n    }\n    return 1;\n}","filepath":"openssl/crypto/ec/ec_ameth.c","line_number":778,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.0"},"270170272":{"score":0.9083713,"function_name":"ecdh_cms_encrypt","code":"static int ecdh_cms_encrypt(CMS_RecipientInfo *ri)\n{\n    EVP_PKEY_CTX *pctx;\n    EVP_PKEY *pkey;\n    EVP_CIPHER_CTX *ctx;\n    int keylen;\n    X509_ALGOR *talg, *wrap_alg = NULL;\n    const ASN1_OBJECT *aoid;\n    ASN1_BIT_STRING *pubkey;\n    ASN1_STRING *wrap_str;\n    ASN1_OCTET_STRING *ukm;\n    unsigned char *penc = NULL;\n    int penclen;\n    int rv = 0;\n    int ecdh_nid, kdf_type, kdf_nid, wrap_nid;\n    const EVP_MD *kdf_md;\n    pctx = CMS_RecipientInfo_get0_pkey_ctx(ri);\n    if (!pctx)\n        return 0;\n    /* Get ephemeral key */\n    pkey = EVP_PKEY_CTX_get0_pkey(pctx);\n    if (!CMS_RecipientInfo_kari_get0_orig_id(ri, \u0026talg, \u0026pubkey,\n                                             NULL, NULL, NULL))\n        goto err;\n    X509_ALGOR_get0(\u0026aoid, NULL, NULL, talg);\n    /* Is everything uninitialised? */\n    if (aoid == OBJ_nid2obj(NID_undef)) {\n\n        EC_KEY *eckey = pkey-\u003epkey.ec;\n        /* Set the key */\n        unsigned char *p;\n\n        penclen = i2o_ECPublicKey(eckey, NULL);\n        if (penclen \u003c= 0)\n            goto err;\n        penc = OPENSSL_malloc(penclen);\n        if (penc == NULL)\n            goto err;\n        p = penc;\n        penclen = i2o_ECPublicKey(eckey, \u0026p);\n        if (penclen \u003c= 0)\n            goto err;\n        ASN1_STRING_set0(pubkey, penc, penclen);\n        pubkey-\u003eflags \u0026= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);\n        pubkey-\u003eflags |= ASN1_STRING_FLAG_BITS_LEFT;\n\n        penc = NULL;\n        X509_ALGOR_set0(talg, OBJ_nid2obj(NID_X9_62_id_ecPublicKey),\n                        V_ASN1_UNDEF, NULL);\n    }\n\n    /* See if custom parameters set */\n    kdf_type = EVP_PKEY_CTX_get_ecdh_kdf_type(pctx);\n    if (kdf_type \u003c= 0)\n        goto err;\n    if (!EVP_PKEY_CTX_get_ecdh_kdf_md(pctx, \u0026kdf_md))\n        goto err;\n    ecdh_nid = EVP_PKEY_CTX_get_ecdh_cofactor_mode(pctx);\n    if (ecdh_nid \u003c 0)\n        goto err;\n    else if (ecdh_nid == 0)\n        ecdh_nid = NID_dh_std_kdf;\n    else if (ecdh_nid == 1)\n        ecdh_nid = NID_dh_cofactor_kdf;\n\n    if (kdf_type == EVP_PKEY_ECDH_KDF_NONE) {\n        kdf_type = EVP_PKEY_ECDH_KDF_X9_63;\n        if (EVP_PKEY_CTX_set_ecdh_kdf_type(pctx, kdf_type) \u003c= 0)\n            goto err;\n    } else\n        /* Unknown KDF */\n        goto err;\n    if (kdf_md == NULL) {\n        /* Fixme later for better MD */\n        kdf_md = EVP_sha1();\n        if (EVP_PKEY_CTX_set_ecdh_kdf_md(pctx, kdf_md) \u003c= 0)\n            goto err;\n    }\n\n    if (!CMS_RecipientInfo_kari_get0_alg(ri, \u0026talg, \u0026ukm))\n        goto err;\n\n    /* Lookup NID for KDF+cofactor+digest */\n\n    if (!OBJ_find_sigid_by_algs(\u0026kdf_nid, EVP_MD_type(kdf_md), ecdh_nid))\n        goto err;\n    /* Get wrap NID */\n    ctx = CMS_RecipientInfo_kari_get0_ctx(ri);\n    wrap_nid = EVP_CIPHER_CTX_type(ctx);\n    keylen = EVP_CIPHER_CTX_key_length(ctx);\n\n    /* Package wrap algorithm in an AlgorithmIdentifier */\n\n    wrap_alg = X509_ALGOR_new();\n    if (wrap_alg == NULL)\n        goto err;\n    wrap_alg-\u003ealgorithm = OBJ_nid2obj(wrap_nid);\n    wrap_alg-\u003eparameter = ASN1_TYPE_new();\n    if (wrap_alg-\u003eparameter == NULL)\n        goto err;\n    if (EVP_CIPHER_param_to_asn1(ctx, wrap_alg-\u003eparameter) \u003c= 0)\n        goto err;\n    if (ASN1_TYPE_get(wrap_alg-\u003eparameter) == NID_undef) {\n        ASN1_TYPE_free(wrap_alg-\u003eparameter);\n        wrap_alg-\u003eparameter = NULL;\n    }\n\n    if (EVP_PKEY_CTX_set_ecdh_kdf_outlen(pctx, keylen) \u003c= 0)\n        goto err;\n\n    penclen = CMS_SharedInfo_encode(\u0026penc, wrap_alg, ukm, keylen);\n\n    if (!penclen)\n        goto err;\n\n    if (EVP_PKEY_CTX_set0_ecdh_kdf_ukm(pctx, penc, penclen) \u003c= 0)\n        goto err;\n    penc = NULL;\n\n    /*\n     * Now need to wrap encoding of wrap AlgorithmIdentifier into parameter\n     * of another AlgorithmIdentifier.\n     */\n    penclen = i2d_X509_ALGOR(wrap_alg, \u0026penc);\n    if (!penc || !penclen)\n        goto err;\n    wrap_str = ASN1_STRING_new();\n    if (wrap_str == NULL)\n        goto err;\n    ASN1_STRING_set0(wrap_str, penc, penclen);\n    penc = NULL;\n    X509_ALGOR_set0(talg, OBJ_nid2obj(kdf_nid), V_ASN1_SEQUENCE, wrap_str);\n\n    rv = 1;\n\n err:\n    OPENSSL_free(penc);\n    X509_ALGOR_free(wrap_alg);\n    return rv;\n}","filepath":"openssl/crypto/ec/ec_ameth.c","line_number":806,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.0"},"270171216":{"score":0.81035805,"function_name":"ecdh_cms_set_shared_info","code":"static int ecdh_cms_set_shared_info(EVP_PKEY_CTX *pctx, CMS_RecipientInfo *ri)\n{\n    int rv = 0;\n\n    X509_ALGOR *alg, *kekalg = NULL;\n    ASN1_OCTET_STRING *ukm;\n    const unsigned char *p;\n    unsigned char *der = NULL;\n    int plen, keylen;\n    const EVP_CIPHER *kekcipher;\n    EVP_CIPHER_CTX *kekctx;\n\n    if (!CMS_RecipientInfo_kari_get0_alg(ri, \u0026alg, \u0026ukm))\n        return 0;\n\n    if (!ecdh_cms_set_kdf_param(pctx, OBJ_obj2nid(alg-\u003ealgorithm))) {\n        ECerr(EC_F_ECDH_CMS_SET_SHARED_INFO, EC_R_KDF_PARAMETER_ERROR);\n        return 0;\n    }\n\n    if (alg-\u003eparameter-\u003etype != V_ASN1_SEQUENCE)\n        return 0;\n\n    p = alg-\u003eparameter-\u003evalue.sequence-\u003edata;\n    plen = alg-\u003eparameter-\u003evalue.sequence-\u003elength;\n    kekalg = d2i_X509_ALGOR(NULL, \u0026p, plen);\n    if (!kekalg)\n        goto err;\n    kekctx = CMS_RecipientInfo_kari_get0_ctx(ri);\n    if (!kekctx)\n        goto err;\n    kekcipher = EVP_get_cipherbyobj(kekalg-\u003ealgorithm);\n    if (!kekcipher || EVP_CIPHER_mode(kekcipher) != EVP_CIPH_WRAP_MODE)\n        goto err;\n    if (!EVP_EncryptInit_ex(kekctx, kekcipher, NULL, NULL, NULL))\n        goto err;\n    if (EVP_CIPHER_asn1_to_param(kekctx, kekalg-\u003eparameter) \u003c= 0)\n        goto err;\n\n    keylen = EVP_CIPHER_CTX_key_length(kekctx);\n    if (EVP_PKEY_CTX_set_ecdh_kdf_outlen(pctx, keylen) \u003c= 0)\n        goto err;\n\n    plen = CMS_SharedInfo_encode(\u0026der, kekalg, ukm, keylen);\n\n    if (!plen)\n        goto err;\n\n    if (EVP_PKEY_CTX_set0_ecdh_kdf_ukm(pctx, der, plen) \u003c= 0)\n        goto err;\n    der = NULL;\n\n    rv = 1;\n err:\n    X509_ALGOR_free(kekalg);\n    OPENSSL_free(der);\n    return rv;\n}","filepath":"openssl/crypto/ec/ec_ameth.c","line_number":719,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.0"},"270171856":{"score":0.86361384,"function_name":"eckey_param2type","code":"static int eckey_param2type(int *pptype, void **ppval, EC_KEY *ec_key)\n{\n    const EC_GROUP *group;\n    int nid;\n    if (ec_key == NULL || (group = EC_KEY_get0_group(ec_key)) == NULL) {\n        ECerr(EC_F_ECKEY_PARAM2TYPE, EC_R_MISSING_PARAMETERS);\n        return 0;\n    }\n    if (EC_GROUP_get_asn1_flag(group)\n        \u0026\u0026 (nid = EC_GROUP_get_curve_name(group)))\n        /* we have a 'named curve' =\u003e just set the OID */\n    {\n        *ppval = OBJ_nid2obj(nid);\n        *pptype = V_ASN1_OBJECT;\n    } else {                    /* explicit parameters */\n\n        ASN1_STRING *pstr = NULL;\n        pstr = ASN1_STRING_new();\n        if (pstr == NULL)\n            return 0;\n        pstr-\u003elength = i2d_ECParameters(ec_key, \u0026pstr-\u003edata);\n        if (pstr-\u003elength \u003c= 0) {\n            ASN1_STRING_free(pstr);\n            ECerr(EC_F_ECKEY_PARAM2TYPE, ERR_R_EC_LIB);\n            return 0;\n        }\n        *ppval = pstr;\n        *pptype = V_ASN1_SEQUENCE;\n    }\n    return 1;\n}","filepath":"openssl/crypto/ec/ec_ameth.c","line_number":26,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.0"},"270172080":{"score":0.9218305,"function_name":"eckey_type2param","code":"static EC_KEY *eckey_type2param(int ptype, const void *pval)\n{\n    EC_KEY *eckey = NULL;\n    EC_GROUP *group = NULL;\n\n    if (ptype == V_ASN1_SEQUENCE) {\n        const ASN1_STRING *pstr = pval;\n        const unsigned char *pm = pstr-\u003edata;\n        int pmlen = pstr-\u003elength;\n\n        if ((eckey = d2i_ECParameters(NULL, \u0026pm, pmlen)) == NULL) {\n            ECerr(EC_F_ECKEY_TYPE2PARAM, EC_R_DECODE_ERROR);\n            goto ecerr;\n        }\n    } else if (ptype == V_ASN1_OBJECT) {\n        const ASN1_OBJECT *poid = pval;\n\n        /*\n         * type == V_ASN1_OBJECT =\u003e the parameters are given by an asn1 OID\n         */\n        if ((eckey = EC_KEY_new()) == NULL) {\n            ECerr(EC_F_ECKEY_TYPE2PARAM, ERR_R_MALLOC_FAILURE);\n            goto ecerr;\n        }\n        group = EC_GROUP_new_by_curve_name(OBJ_obj2nid(poid));\n        if (group == NULL)\n            goto ecerr;\n        EC_GROUP_set_asn1_flag(group, OPENSSL_EC_NAMED_CURVE);\n        if (EC_KEY_set_group(eckey, group) == 0)\n            goto ecerr;\n        EC_GROUP_free(group);\n    } else {\n        ECerr(EC_F_ECKEY_TYPE2PARAM, EC_R_DECODE_ERROR);\n        goto ecerr;\n    }\n\n    return eckey;\n\n ecerr:\n    EC_KEY_free(eckey);\n    EC_GROUP_free(group);\n    return NULL;\n}","filepath":"openssl/crypto/ec/ec_ameth.c","line_number":92,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.0"},"270173968":{"score":0.7355567,"function_name":"ecp_nistz256_mult_precompute","code":"__owur static int ecp_nistz256_mult_precompute(EC_GROUP *group, BN_CTX *ctx)\n{\n    /*\n     * We precompute a table for a Booth encoded exponent (wNAF) based\n     * computation. Each table holds 64 values for safe access, with an\n     * implicit value of infinity at index zero. We use window of size 7, and\n     * therefore require ceil(256/7) = 37 tables.\n     */\n    const BIGNUM *order;\n    EC_POINT *P = NULL, *T = NULL;\n    const EC_POINT *generator;\n    NISTZ256_PRE_COMP *pre_comp;\n    BN_CTX *new_ctx = NULL;\n    int i, j, k, ret = 0;\n    size_t w;\n\n    PRECOMP256_ROW *preComputedTable = NULL;\n    unsigned char *precomp_storage = NULL;\n\n    /* if there is an old NISTZ256_PRE_COMP object, throw it away */\n    EC_pre_comp_free(group);\n    generator = EC_GROUP_get0_generator(group);\n    if (generator == NULL) {\n        ECerr(EC_F_ECP_NISTZ256_MULT_PRECOMPUTE, EC_R_UNDEFINED_GENERATOR);\n        return 0;\n    }\n\n    if (ecp_nistz256_is_affine_G(generator)) {\n        /*\n         * No need to calculate tables for the standard generator because we\n         * have them statically.\n         */\n        return 1;\n    }\n\n    if ((pre_comp = ecp_nistz256_pre_comp_new(group)) == NULL)\n        return 0;\n\n    if (ctx == NULL) {\n        ctx = new_ctx = BN_CTX_new();\n        if (ctx == NULL)\n            goto err;\n    }\n\n    BN_CTX_start(ctx);\n\n    order = EC_GROUP_get0_order(group);\n    if (order == NULL)\n        goto err;\n\n    if (BN_is_zero(order)) {\n        ECerr(EC_F_ECP_NISTZ256_MULT_PRECOMPUTE, EC_R_UNKNOWN_ORDER);\n        goto err;\n    }\n\n    w = 7;\n\n    if ((precomp_storage =\n         OPENSSL_malloc(37 * 64 * sizeof(P256_POINT_AFFINE) + 64)) == NULL) {\n        ECerr(EC_F_ECP_NISTZ256_MULT_PRECOMPUTE, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    preComputedTable = (void *)ALIGNPTR(precomp_storage, 64);\n\n    P = EC_POINT_new(group);\n    T = EC_POINT_new(group);\n    if (P == NULL || T == NULL)\n        goto err;\n\n    /*\n     * The zero entry is implicitly infinity, and we skip it, storing other\n     * values with -1 offset.\n     */\n    if (!EC_POINT_copy(T, generator))\n        goto err;\n\n    for (k = 0; k \u003c 64; k++) {\n        if (!EC_POINT_copy(P, T))\n            goto err;\n        for (j = 0; j \u003c 37; j++) {\n            P256_POINT_AFFINE temp;\n            /*\n             * It would be faster to use EC_POINTs_make_affine and\n             * make multiple points affine at the same time.\n             */\n            if (!EC_POINT_make_affine(group, P, ctx))\n                goto err;\n            if (!ecp_nistz256_bignum_to_field_elem(temp.X, P-\u003eX) ||\n                !ecp_nistz256_bignum_to_field_elem(temp.Y, P-\u003eY)) {\n                ECerr(EC_F_ECP_NISTZ256_MULT_PRECOMPUTE,\n                      EC_R_COORDINATES_OUT_OF_RANGE);\n                goto err;\n            }\n            ecp_nistz256_scatter_w7(preComputedTable[j], \u0026temp, k);\n            for (i = 0; i \u003c 7; i++) {\n                if (!EC_POINT_dbl(group, P, P, ctx))\n                    goto err;\n            }\n        }\n        if (!EC_POINT_add(group, T, T, generator, ctx))\n            goto err;\n    }\n\n    pre_comp-\u003egroup = group;\n    pre_comp-\u003ew = w;\n    pre_comp-\u003eprecomp = preComputedTable;\n    pre_comp-\u003eprecomp_storage = precomp_storage;\n    precomp_storage = NULL;\n    SETPRECOMP(group, nistz256, pre_comp);\n    pre_comp = NULL;\n    ret = 1;\n\n err:\n    BN_CTX_end(ctx);\n    BN_CTX_free(new_ctx);\n\n    EC_nistz256_pre_comp_free(pre_comp);\n    OPENSSL_free(precomp_storage);\n    EC_POINT_free(P);\n    EC_POINT_free(T);\n    return ret;\n}","filepath":"openssl/crypto/ec/ecp_nistz256.c","line_number":777,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.117"},"270174992":{"score":0.7727855,"function_name":"ecp_nistz256_points_mul","code":"__owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n                                          EC_POINT *r,\n                                          const BIGNUM *scalar,\n                                          size_t num,\n                                          const EC_POINT *points[],\n                                          const BIGNUM *scalars[], BN_CTX *ctx)\n{\n    int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n    unsigned char p_str[33] = { 0 };\n    const PRECOMP256_ROW *preComputedTable = NULL;\n    const NISTZ256_PRE_COMP *pre_comp = NULL;\n    const EC_POINT *generator = NULL;\n    const BIGNUM **new_scalars = NULL;\n    const EC_POINT **new_points = NULL;\n    unsigned int idx = 0;\n    const unsigned int window_size = 7;\n    const unsigned int mask = (1 \u003c\u003c (window_size + 1)) - 1;\n    unsigned int wvalue;\n    ALIGN32 union {\n        P256_POINT p;\n        P256_POINT_AFFINE a;\n    } t, p;\n    BIGNUM *tmp_scalar;\n\n    if ((num + 1) == 0 || (num + 1) \u003e OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n        ECerr(EC_F_ECP_NISTZ256_POINTS_MUL, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n\n    BN_CTX_start(ctx);\n\n    if (scalar) {\n        generator = EC_GROUP_get0_generator(group);\n        if (generator == NULL) {\n            ECerr(EC_F_ECP_NISTZ256_POINTS_MUL, EC_R_UNDEFINED_GENERATOR);\n            goto err;\n        }\n\n        /* look if we can use precomputed multiples of generator */\n        pre_comp = group-\u003epre_comp.nistz256;\n\n        if (pre_comp) {\n            /*\n             * If there is a precomputed table for the generator, check that\n             * it was generated with the same generator.\n             */\n            EC_POINT *pre_comp_generator = EC_POINT_new(group);\n            if (pre_comp_generator == NULL)\n                goto err;\n\n            ecp_nistz256_gather_w7(\u0026p.a, pre_comp-\u003eprecomp[0], 1);\n            if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n                                              group, \u0026p.a, ctx)) {\n                EC_POINT_free(pre_comp_generator);\n                goto err;\n            }\n\n            if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n                preComputedTable = (const PRECOMP256_ROW *)pre_comp-\u003eprecomp;\n\n            EC_POINT_free(pre_comp_generator);\n        }\n\n        if (preComputedTable == NULL \u0026\u0026 ecp_nistz256_is_affine_G(generator)) {\n            /*\n             * If there is no precomputed data, but the generator is the\n             * default, a hardcoded table of precomputed data is used. This\n             * is because applications, such as Apache, do not use\n             * EC_KEY_precompute_mult.\n             */\n            preComputedTable = ecp_nistz256_precomputed;\n        }\n\n        if (preComputedTable) {\n            if ((BN_num_bits(scalar) \u003e 256)\n                || BN_is_negative(scalar)) {\n                if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n                    goto err;\n\n                if (!BN_nnmod(tmp_scalar, scalar, group-\u003eorder, ctx)) {\n                    ECerr(EC_F_ECP_NISTZ256_POINTS_MUL, ERR_R_BN_LIB);\n                    goto err;\n                }\n                scalar = tmp_scalar;\n            }\n\n            for (i = 0; i \u003c bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n                BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n\n                p_str[i + 0] = (unsigned char)d;\n                p_str[i + 1] = (unsigned char)(d \u003e\u003e 8);\n                p_str[i + 2] = (unsigned char)(d \u003e\u003e 16);\n                p_str[i + 3] = (unsigned char)(d \u003e\u003e= 24);\n                if (BN_BYTES == 8) {\n                    d \u003e\u003e= 8;\n                    p_str[i + 4] = (unsigned char)d;\n                    p_str[i + 5] = (unsigned char)(d \u003e\u003e 8);\n                    p_str[i + 6] = (unsigned char)(d \u003e\u003e 16);\n                    p_str[i + 7] = (unsigned char)(d \u003e\u003e 24);\n                }\n            }\n\n            for (; i \u003c 33; i++)\n                p_str[i] = 0;\n\n#if defined(ECP_NISTZ256_AVX2)\n            if (ecp_nistz_avx2_eligible()) {\n                ecp_nistz256_avx2_mul_g(\u0026p.p, p_str, preComputedTable);\n            } else\n#endif\n            {\n                BN_ULONG infty;\n\n                /* First window */\n                wvalue = (p_str[0] \u003c\u003c 1) \u0026 mask;\n                idx += window_size;\n\n                wvalue = _booth_recode_w7(wvalue);\n\n                ecp_nistz256_gather_w7(\u0026p.a, preComputedTable[0],\n                                       wvalue \u003e\u003e 1);\n\n                ecp_nistz256_neg(p.p.Z, p.p.Y);\n                copy_conditional(p.p.Y, p.p.Z, wvalue \u0026 1);\n\n                /*\n                 * Since affine infinity is encoded as (0,0) and\n                 * Jacobian ias (,,0), we need to harmonize them\n                 * by assigning \"one\" or zero to Z.\n                 */\n                infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n                         p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n                if (P256_LIMBS == 8)\n                    infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n                              p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n\n                infty = 0 - is_zero(infty);\n                infty = ~infty;\n\n                p.p.Z[0] = ONE[0] \u0026 infty;\n                p.p.Z[1] = ONE[1] \u0026 infty;\n                p.p.Z[2] = ONE[2] \u0026 infty;\n                p.p.Z[3] = ONE[3] \u0026 infty;\n                if (P256_LIMBS == 8) {\n                    p.p.Z[4] = ONE[4] \u0026 infty;\n                    p.p.Z[5] = ONE[5] \u0026 infty;\n                    p.p.Z[6] = ONE[6] \u0026 infty;\n                    p.p.Z[7] = ONE[7] \u0026 infty;\n                }\n\n                for (i = 1; i \u003c 37; i++) {\n                    unsigned int off = (idx - 1) / 8;\n                    wvalue = p_str[off] | p_str[off + 1] \u003c\u003c 8;\n                    wvalue = (wvalue \u003e\u003e ((idx - 1) % 8)) \u0026 mask;\n                    idx += window_size;\n\n                    wvalue = _booth_recode_w7(wvalue);\n\n                    ecp_nistz256_gather_w7(\u0026t.a,\n                                           preComputedTable[i], wvalue \u003e\u003e 1);\n\n                    ecp_nistz256_neg(t.p.Z, t.a.Y);\n                    copy_conditional(t.a.Y, t.p.Z, wvalue \u0026 1);\n\n                    ecp_nistz256_point_add_affine(\u0026p.p, \u0026p.p, \u0026t.a);\n                }\n            }\n        } else {\n            p_is_infinity = 1;\n            no_precomp_for_generator = 1;\n        }\n    } else\n        p_is_infinity = 1;\n\n    if (no_precomp_for_generator) {\n        /*\n         * Without a precomputed table for the generator, it has to be\n         * handled like a normal point.\n         */\n        new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n        if (new_scalars == NULL) {\n            ECerr(EC_F_ECP_NISTZ256_POINTS_MUL, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n        if (new_points == NULL) {\n            ECerr(EC_F_ECP_NISTZ256_POINTS_MUL, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n        new_scalars[num] = scalar;\n        memcpy(new_points, points, num * sizeof(EC_POINT *));\n        new_points[num] = generator;\n\n        scalars = new_scalars;\n        points = new_points;\n        num++;\n    }\n\n    if (num) {\n        P256_POINT *out = \u0026t.p;\n        if (p_is_infinity)\n            out = \u0026p.p;\n\n        if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n            goto err;\n\n        if (!p_is_infinity)\n            ecp_nistz256_point_add(\u0026p.p, \u0026p.p, out);\n    }\n\n    /* Not constant-time, but we're only operating on the public output. */\n    if (!bn_set_words(r-\u003eX, p.p.X, P256_LIMBS) ||\n        !bn_set_words(r-\u003eY, p.p.Y, P256_LIMBS) ||\n        !bn_set_words(r-\u003eZ, p.p.Z, P256_LIMBS)) {\n        goto err;\n    }\n    r-\u003eZ_is_one = is_one(r-\u003eZ) \u0026 1;\n\n    ret = 1;\n\nerr:\n    BN_CTX_end(ctx);\n    OPENSSL_free(new_points);\n    OPENSSL_free(new_scalars);\n    return ret;\n}","filepath":"openssl/crypto/ec/ecp_nistz256.c","line_number":1117,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.117"},"270176704":{"score":0.78916585,"function_name":"ecp_nistz256_get_affine","code":"__owur static int ecp_nistz256_get_affine(const EC_GROUP *group,\n                                          const EC_POINT *point,\n                                          BIGNUM *x, BIGNUM *y, BN_CTX *ctx)\n{\n    BN_ULONG z_inv2[P256_LIMBS];\n    BN_ULONG z_inv3[P256_LIMBS];\n    BN_ULONG x_aff[P256_LIMBS];\n    BN_ULONG y_aff[P256_LIMBS];\n    BN_ULONG point_x[P256_LIMBS], point_y[P256_LIMBS], point_z[P256_LIMBS];\n    BN_ULONG x_ret[P256_LIMBS], y_ret[P256_LIMBS];\n\n    if (EC_POINT_is_at_infinity(group, point)) {\n        ECerr(EC_F_ECP_NISTZ256_GET_AFFINE, EC_R_POINT_AT_INFINITY);\n        return 0;\n    }\n\n    if (!ecp_nistz256_bignum_to_field_elem(point_x, point-\u003eX) ||\n        !ecp_nistz256_bignum_to_field_elem(point_y, point-\u003eY) ||\n        !ecp_nistz256_bignum_to_field_elem(point_z, point-\u003eZ)) {\n        ECerr(EC_F_ECP_NISTZ256_GET_AFFINE, EC_R_COORDINATES_OUT_OF_RANGE);\n        return 0;\n    }\n\n    ecp_nistz256_mod_inverse(z_inv3, point_z);\n    ecp_nistz256_sqr_mont(z_inv2, z_inv3);\n    ecp_nistz256_mul_mont(x_aff, z_inv2, point_x);\n\n    if (x != NULL) {\n        ecp_nistz256_from_mont(x_ret, x_aff);\n        if (!bn_set_words(x, x_ret, P256_LIMBS))\n            return 0;\n    }\n\n    if (y != NULL) {\n        ecp_nistz256_mul_mont(z_inv3, z_inv3, z_inv2);\n        ecp_nistz256_mul_mont(y_aff, z_inv3, point_y);\n        ecp_nistz256_from_mont(y_ret, y_aff);\n        if (!bn_set_words(y, y_ret, P256_LIMBS))\n            return 0;\n    }\n\n    return 1;\n}","filepath":"openssl/crypto/ec/ecp_nistz256.c","line_number":1347,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.117"},"270177280":{"score":0.74608594,"function_name":"EC_nistz256_pre_comp_free","code":"void EC_nistz256_pre_comp_free(NISTZ256_PRE_COMP *pre)\n{\n    int i;\n\n    if (pre == NULL)\n        return;\n\n    CRYPTO_DOWN_REF(\u0026pre-\u003ereferences, \u0026i, pre-\u003elock);\n    REF_PRINT_COUNT(\"EC_nistz256\", x);\n    if (i \u003e 0)\n        return;\n    REF_ASSERT_ISNT(i \u003c 0);\n\n    OPENSSL_free(pre-\u003eprecomp_storage);\n    CRYPTO_THREAD_lock_free(pre-\u003elock);\n    OPENSSL_free(pre);\n}","filepath":"openssl/crypto/ec/ecp_nistz256.c","line_number":1426,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.117"},"270177360":{"score":0.839478,"function_name":"copy_conditional","code":"static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n                             const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n{\n    BN_ULONG mask1 = 0-move;\n    BN_ULONG mask2 = ~mask1;\n\n    dst[0] = (src[0] \u0026 mask1) ^ (dst[0] \u0026 mask2);\n    dst[1] = (src[1] \u0026 mask1) ^ (dst[1] \u0026 mask2);\n    dst[2] = (src[2] \u0026 mask1) ^ (dst[2] \u0026 mask2);\n    dst[3] = (src[3] \u0026 mask1) ^ (dst[3] \u0026 mask2);\n    if (P256_LIMBS == 8) {\n        dst[4] = (src[4] \u0026 mask1) ^ (dst[4] \u0026 mask2);\n        dst[5] = (src[5] \u0026 mask1) ^ (dst[5] \u0026 mask2);\n        dst[6] = (src[6] \u0026 mask1) ^ (dst[6] \u0026 mask2);\n        dst[7] = (src[7] \u0026 mask1) ^ (dst[7] \u0026 mask2);\n    }\n}","filepath":"openssl/crypto/ec/ecp_nistz256.c","line_number":171,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.117"},"270177504":{"score":0.641074,"function_name":"ecp_nistz256_is_affine_G","code":"static int ecp_nistz256_is_affine_G(const EC_POINT *generator)\n{\n    return (bn_get_top(generator-\u003eX) == P256_LIMBS) \u0026\u0026\n        (bn_get_top(generator-\u003eY) == P256_LIMBS) \u0026\u0026\n        is_equal(bn_get_words(generator-\u003eX), def_xG) \u0026\u0026\n        is_equal(bn_get_words(generator-\u003eY), def_yG) \u0026\u0026\n        is_one(generator-\u003eZ);\n}","filepath":"openssl/crypto/ec/ecp_nistz256.c","line_number":768,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.117"},"270177712":{"score":0.70734763,"function_name":"ecp_nistz256_mod_inverse","code":"static void ecp_nistz256_mod_inverse(BN_ULONG r[P256_LIMBS],\n                                     const BN_ULONG in[P256_LIMBS])\n{\n    /*\n     * The poly is ffffffff 00000001 00000000 00000000 00000000 ffffffff\n     * ffffffff ffffffff We use FLT and used poly-2 as exponent\n     */\n    BN_ULONG p2[P256_LIMBS];\n    BN_ULONG p4[P256_LIMBS];\n    BN_ULONG p8[P256_LIMBS];\n    BN_ULONG p16[P256_LIMBS];\n    BN_ULONG p32[P256_LIMBS];\n    BN_ULONG res[P256_LIMBS];\n    int i;\n\n    ecp_nistz256_sqr_mont(res, in);\n    ecp_nistz256_mul_mont(p2, res, in);         /* 3*p */\n\n    ecp_nistz256_sqr_mont(res, p2);\n    ecp_nistz256_sqr_mont(res, res);\n    ecp_nistz256_mul_mont(p4, res, p2);         /* f*p */\n\n    ecp_nistz256_sqr_mont(res, p4);\n    ecp_nistz256_sqr_mont(res, res);\n    ecp_nistz256_sqr_mont(res, res);\n    ecp_nistz256_sqr_mont(res, res);\n    ecp_nistz256_mul_mont(p8, res, p4);         /* ff*p */\n\n    ecp_nistz256_sqr_mont(res, p8);\n    for (i = 0; i \u003c 7; i++)\n        ecp_nistz256_sqr_mont(res, res);\n    ecp_nistz256_mul_mont(p16, res, p8);        /* ffff*p */\n\n    ecp_nistz256_sqr_mont(res, p16);\n    for (i = 0; i \u003c 15; i++)\n        ecp_nistz256_sqr_mont(res, res);\n    ecp_nistz256_mul_mont(p32, res, p16);       /* ffffffff*p */\n\n    ecp_nistz256_sqr_mont(res, p32);\n    for (i = 0; i \u003c 31; i++)\n        ecp_nistz256_sqr_mont(res, res);\n    ecp_nistz256_mul_mont(res, res, in);\n\n    for (i = 0; i \u003c 32 * 4; i++)\n        ecp_nistz256_sqr_mont(res, res);\n    ecp_nistz256_mul_mont(res, res, p32);\n\n    for (i = 0; i \u003c 32; i++)\n        ecp_nistz256_sqr_mont(res, res);\n    ecp_nistz256_mul_mont(res, res, p32);\n\n    for (i = 0; i \u003c 16; i++)\n        ecp_nistz256_sqr_mont(res, res);\n    ecp_nistz256_mul_mont(res, res, p16);\n\n    for (i = 0; i \u003c 8; i++)\n        ecp_nistz256_sqr_mont(res, res);\n    ecp_nistz256_mul_mont(res, res, p8);\n\n    ecp_nistz256_sqr_mont(res, res);\n    ecp_nistz256_sqr_mont(res, res);\n    ecp_nistz256_sqr_mont(res, res);\n    ecp_nistz256_sqr_mont(res, res);\n    ecp_nistz256_mul_mont(res, res, p4);\n\n    ecp_nistz256_sqr_mont(res, res);\n    ecp_nistz256_sqr_mont(res, res);\n    ecp_nistz256_mul_mont(res, res, p2);\n\n    ecp_nistz256_sqr_mont(res, res);\n    ecp_nistz256_sqr_mont(res, res);\n    ecp_nistz256_mul_mont(res, res, in);\n\n    memcpy(r, res, sizeof(res));\n}","filepath":"openssl/crypto/ec/ecp_nistz256.c","line_number":492,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.117"},"270178480":{"score":0.8336207,"function_name":"ecp_nistz256_windowed_mul","code":"__owur static int ecp_nistz256_windowed_mul(const EC_GROUP *group,\n                                            P256_POINT *r,\n                                            const BIGNUM **scalar,\n                                            const EC_POINT **point,\n                                            size_t num, BN_CTX *ctx)\n{\n    size_t i;\n    int j, ret = 0;\n    unsigned int idx;\n    unsigned char (*p_str)[33] = NULL;\n    const unsigned int window_size = 5;\n    const unsigned int mask = (1 \u003c\u003c (window_size + 1)) - 1;\n    unsigned int wvalue;\n    P256_POINT *temp;           /* place for 5 temporary points */\n    const BIGNUM **scalars = NULL;\n    P256_POINT (*table)[16] = NULL;\n    void *table_storage = NULL;\n\n    if ((num * 16 + 6) \u003e OPENSSL_MALLOC_MAX_NELEMS(P256_POINT)\n        || (table_storage =\n            OPENSSL_malloc((num * 16 + 5) * sizeof(P256_POINT) + 64)) == NULL\n        || (p_str =\n            OPENSSL_malloc(num * 33 * sizeof(unsigned char))) == NULL\n        || (scalars = OPENSSL_malloc(num * sizeof(BIGNUM *))) == NULL) {\n        ECerr(EC_F_ECP_NISTZ256_WINDOWED_MUL, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    table = (void *)ALIGNPTR(table_storage, 64);\n    temp = (P256_POINT *)(table + num);\n\n    for (i = 0; i \u003c num; i++) {\n        P256_POINT *row = table[i];\n\n        /* This is an unusual input, we don't guarantee constant-timeness. */\n        if ((BN_num_bits(scalar[i]) \u003e 256) || BN_is_negative(scalar[i])) {\n            BIGNUM *mod;\n\n            if ((mod = BN_CTX_get(ctx)) == NULL)\n                goto err;\n            if (!BN_nnmod(mod, scalar[i], group-\u003eorder, ctx)) {\n                ECerr(EC_F_ECP_NISTZ256_WINDOWED_MUL, ERR_R_BN_LIB);\n                goto err;\n            }\n            scalars[i] = mod;\n        } else\n            scalars[i] = scalar[i];\n\n        for (j = 0; j \u003c bn_get_top(scalars[i]) * BN_BYTES; j += BN_BYTES) {\n            BN_ULONG d = bn_get_words(scalars[i])[j / BN_BYTES];\n\n            p_str[i][j + 0] = (unsigned char)d;\n            p_str[i][j + 1] = (unsigned char)(d \u003e\u003e 8);\n            p_str[i][j + 2] = (unsigned char)(d \u003e\u003e 16);\n            p_str[i][j + 3] = (unsigned char)(d \u003e\u003e= 24);\n            if (BN_BYTES == 8) {\n                d \u003e\u003e= 8;\n                p_str[i][j + 4] = (unsigned char)d;\n                p_str[i][j + 5] = (unsigned char)(d \u003e\u003e 8);\n                p_str[i][j + 6] = (unsigned char)(d \u003e\u003e 16);\n                p_str[i][j + 7] = (unsigned char)(d \u003e\u003e 24);\n            }\n        }\n        for (; j \u003c 33; j++)\n            p_str[i][j] = 0;\n\n        if (!ecp_nistz256_bignum_to_field_elem(temp[0].X, point[i]-\u003eX)\n            || !ecp_nistz256_bignum_to_field_elem(temp[0].Y, point[i]-\u003eY)\n            || !ecp_nistz256_bignum_to_field_elem(temp[0].Z, point[i]-\u003eZ)) {\n            ECerr(EC_F_ECP_NISTZ256_WINDOWED_MUL,\n                  EC_R_COORDINATES_OUT_OF_RANGE);\n            goto err;\n        }\n\n        /*\n         * row[0] is implicitly (0,0,0) (the point at infinity), therefore it\n         * is not stored. All other values are actually stored with an offset\n         * of -1 in table.\n         */\n\n        ecp_nistz256_scatter_w5  (row, \u0026temp[0], 1);\n        ecp_nistz256_point_double(\u0026temp[1], \u0026temp[0]);              /*1+1=2  */\n        ecp_nistz256_scatter_w5  (row, \u0026temp[1], 2);\n        ecp_nistz256_point_add   (\u0026temp[2], \u0026temp[1], \u0026temp[0]);    /*2+1=3  */\n        ecp_nistz256_scatter_w5  (row, \u0026temp[2], 3);\n        ecp_nistz256_point_double(\u0026temp[1], \u0026temp[1]);              /*2*2=4  */\n        ecp_nistz256_scatter_w5  (row, \u0026temp[1], 4);\n        ecp_nistz256_point_double(\u0026temp[2], \u0026temp[2]);              /*2*3=6  */\n        ecp_nistz256_scatter_w5  (row, \u0026temp[2], 6);\n        ecp_nistz256_point_add   (\u0026temp[3], \u0026temp[1], \u0026temp[0]);    /*4+1=5  */\n        ecp_nistz256_scatter_w5  (row, \u0026temp[3], 5);\n        ecp_nistz256_point_add   (\u0026temp[4], \u0026temp[2], \u0026temp[0]);    /*6+1=7  */\n        ecp_nistz256_scatter_w5  (row, \u0026temp[4], 7);\n        ecp_nistz256_point_double(\u0026temp[1], \u0026temp[1]);              /*2*4=8  */\n        ecp_nistz256_scatter_w5  (row, \u0026temp[1], 8);\n        ecp_nistz256_point_double(\u0026temp[2], \u0026temp[2]);              /*2*6=12 */\n        ecp_nistz256_scatter_w5  (row, \u0026temp[2], 12);\n        ecp_nistz256_point_double(\u0026temp[3], \u0026temp[3]);              /*2*5=10 */\n        ecp_nistz256_scatter_w5  (row, \u0026temp[3], 10);\n        ecp_nistz256_point_double(\u0026temp[4], \u0026temp[4]);              /*2*7=14 */\n        ecp_nistz256_scatter_w5  (row, \u0026temp[4], 14);\n        ecp_nistz256_point_add   (\u0026temp[2], \u0026temp[2], \u0026temp[0]);    /*12+1=13*/\n        ecp_nistz256_scatter_w5  (row, \u0026temp[2], 13);\n        ecp_nistz256_point_add   (\u0026temp[3], \u0026temp[3], \u0026temp[0]);    /*10+1=11*/\n        ecp_nistz256_scatter_w5  (row, \u0026temp[3], 11);\n        ecp_nistz256_point_add   (\u0026temp[4], \u0026temp[4], \u0026temp[0]);    /*14+1=15*/\n        ecp_nistz256_scatter_w5  (row, \u0026temp[4], 15);\n        ecp_nistz256_point_add   (\u0026temp[2], \u0026temp[1], \u0026temp[0]);    /*8+1=9  */\n        ecp_nistz256_scatter_w5  (row, \u0026temp[2], 9);\n        ecp_nistz256_point_double(\u0026temp[1], \u0026temp[1]);              /*2*8=16 */\n        ecp_nistz256_scatter_w5  (row, \u0026temp[1], 16);\n    }\n\n    idx = 255;\n\n    wvalue = p_str[0][(idx - 1) / 8];\n    wvalue = (wvalue \u003e\u003e ((idx - 1) % 8)) \u0026 mask;\n\n    /*\n     * We gather to temp[0], because we know it's position relative\n     * to table\n     */\n    ecp_nistz256_gather_w5(\u0026temp[0], table[0], _booth_recode_w5(wvalue) \u003e\u003e 1);\n    memcpy(r, \u0026temp[0], sizeof(temp[0]));\n\n    while (idx \u003e= 5) {\n        for (i = (idx == 255 ? 1 : 0); i \u003c num; i++) {\n            unsigned int off = (idx - 1) / 8;\n\n            wvalue = p_str[i][off] | p_str[i][off + 1] \u003c\u003c 8;\n            wvalue = (wvalue \u003e\u003e ((idx - 1) % 8)) \u0026 mask;\n\n            wvalue = _booth_recode_w5(wvalue);\n\n            ecp_nistz256_gather_w5(\u0026temp[0], table[i], wvalue \u003e\u003e 1);\n\n            ecp_nistz256_neg(temp[1].Y, temp[0].Y);\n            copy_conditional(temp[0].Y, temp[1].Y, (wvalue \u0026 1));\n\n            ecp_nistz256_point_add(r, r, \u0026temp[0]);\n        }\n\n        idx -= window_size;\n\n        ecp_nistz256_point_double(r, r);\n        ecp_nistz256_point_double(r, r);\n        ecp_nistz256_point_double(r, r);\n        ecp_nistz256_point_double(r, r);\n        ecp_nistz256_point_double(r, r);\n    }\n\n    /* Final window */\n    for (i = 0; i \u003c num; i++) {\n        wvalue = p_str[i][0];\n        wvalue = (wvalue \u003c\u003c 1) \u0026 mask;\n\n        wvalue = _booth_recode_w5(wvalue);\n\n        ecp_nistz256_gather_w5(\u0026temp[0], table[i], wvalue \u003e\u003e 1);\n\n        ecp_nistz256_neg(temp[1].Y, temp[0].Y);\n        copy_conditional(temp[0].Y, temp[1].Y, wvalue \u0026 1);\n\n        ecp_nistz256_point_add(r, r, \u0026temp[0]);\n    }\n\n    ret = 1;\n err:\n    OPENSSL_free(table_storage);\n    OPENSSL_free(p_str);\n    OPENSSL_free(scalars);\n    return ret;\n}","filepath":"openssl/crypto/ec/ecp_nistz256.c","line_number":579,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.117"},"270180448":{"score":0.7654073,"function_name":"is_equal","code":"static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n                         const BN_ULONG b[P256_LIMBS])\n{\n    BN_ULONG res;\n\n    res = a[0] ^ b[0];\n    res |= a[1] ^ b[1];\n    res |= a[2] ^ b[2];\n    res |= a[3] ^ b[3];\n    if (P256_LIMBS == 8) {\n        res |= a[4] ^ b[4];\n        res |= a[5] ^ b[5];\n        res |= a[6] ^ b[6];\n        res |= a[7] ^ b[7];\n    }\n\n    return is_zero(res);\n}","filepath":"openssl/crypto/ec/ecp_nistz256.c","line_number":197,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.117"},"270180672":{"score":0.78217804,"function_name":"EC_ec_pre_comp_free","code":"void EC_ec_pre_comp_free(EC_PRE_COMP *pre)\n{\n    int i;\n\n    if (pre == NULL)\n        return;\n\n    CRYPTO_DOWN_REF(\u0026pre-\u003ereferences, \u0026i, pre-\u003elock);\n    REF_PRINT_COUNT(\"EC_ec\", pre);\n    if (i \u003e 0)\n        return;\n    REF_ASSERT_ISNT(i \u003c 0);\n\n    if (pre-\u003epoints != NULL) {\n        EC_POINT **pts;\n\n        for (pts = pre-\u003epoints; *pts != NULL; pts++)\n            EC_POINT_free(*pts);\n        OPENSSL_free(pre-\u003epoints);\n    }\n    CRYPTO_THREAD_lock_free(pre-\u003elock);\n    OPENSSL_free(pre);\n}","filepath":"openssl/crypto/ec/ec_mult.c","line_number":80,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.210"},"270180784":{"score":0.8572375,"function_name":"ec_scalar_mul_ladder","code":"int ec_scalar_mul_ladder(const EC_GROUP *group, EC_POINT *r,\n                         const BIGNUM *scalar, const EC_POINT *point,\n                         BN_CTX *ctx)\n{\n    int i, cardinality_bits, group_top, kbit, pbit, Z_is_one;\n    EC_POINT *p = NULL;\n    EC_POINT *s = NULL;\n    BIGNUM *k = NULL;\n    BIGNUM *lambda = NULL;\n    BIGNUM *cardinality = NULL;\n    int ret = 0;\n\n    /* early exit if the input point is the point at infinity */\n    if (point != NULL \u0026\u0026 EC_POINT_is_at_infinity(group, point))\n        return EC_POINT_set_to_infinity(group, r);\n\n    if (BN_is_zero(group-\u003eorder)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_UNKNOWN_ORDER);\n        return 0;\n    }\n    if (BN_is_zero(group-\u003ecofactor)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_UNKNOWN_COFACTOR);\n        return 0;\n    }\n\n    BN_CTX_start(ctx);\n\n    if (((p = EC_POINT_new(group)) == NULL)\n        || ((s = EC_POINT_new(group)) == NULL)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (point == NULL) {\n        if (!EC_POINT_copy(p, group-\u003egenerator)) {\n            ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_EC_LIB);\n            goto err;\n        }\n    } else {\n        if (!EC_POINT_copy(p, point)) {\n            ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_EC_LIB);\n            goto err;\n        }\n    }\n\n    EC_POINT_BN_set_flags(p, BN_FLG_CONSTTIME);\n    EC_POINT_BN_set_flags(r, BN_FLG_CONSTTIME);\n    EC_POINT_BN_set_flags(s, BN_FLG_CONSTTIME);\n\n    cardinality = BN_CTX_get(ctx);\n    lambda = BN_CTX_get(ctx);\n    k = BN_CTX_get(ctx);\n    if (k == NULL) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (!BN_mul(cardinality, group-\u003eorder, group-\u003ecofactor, ctx)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\n        goto err;\n    }\n\n    /*\n     * Group cardinalities are often on a word boundary.\n     * So when we pad the scalar, some timing diff might\n     * pop if it needs to be expanded due to carries.\n     * So expand ahead of time.\n     */\n    cardinality_bits = BN_num_bits(cardinality);\n    group_top = bn_get_top(cardinality);\n    if ((bn_wexpand(k, group_top + 2) == NULL)\n        || (bn_wexpand(lambda, group_top + 2) == NULL)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\n        goto err;\n    }\n\n    if (!BN_copy(k, scalar)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\n        goto err;\n    }\n\n    BN_set_flags(k, BN_FLG_CONSTTIME);\n\n    if ((BN_num_bits(k) \u003e cardinality_bits) || (BN_is_negative(k))) {\n        /*-\n         * this is an unusual input, and we don't guarantee\n         * constant-timeness\n         */\n        if (!BN_nnmod(k, k, cardinality, ctx)) {\n            ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\n            goto err;\n        }\n    }\n\n    if (!BN_add(lambda, k, cardinality)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\n        goto err;\n    }\n    BN_set_flags(lambda, BN_FLG_CONSTTIME);\n    if (!BN_add(k, lambda, cardinality)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\n        goto err;\n    }\n    /*\n     * lambda := scalar + cardinality\n     * k := scalar + 2*cardinality\n     */\n    kbit = BN_is_bit_set(lambda, cardinality_bits);\n    BN_consttime_swap(kbit, k, lambda, group_top + 2);\n\n    group_top = bn_get_top(group-\u003efield);\n    if ((bn_wexpand(s-\u003eX, group_top) == NULL)\n        || (bn_wexpand(s-\u003eY, group_top) == NULL)\n        || (bn_wexpand(s-\u003eZ, group_top) == NULL)\n        || (bn_wexpand(r-\u003eX, group_top) == NULL)\n        || (bn_wexpand(r-\u003eY, group_top) == NULL)\n        || (bn_wexpand(r-\u003eZ, group_top) == NULL)\n        || (bn_wexpand(p-\u003eX, group_top) == NULL)\n        || (bn_wexpand(p-\u003eY, group_top) == NULL)\n        || (bn_wexpand(p-\u003eZ, group_top) == NULL)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\n        goto err;\n    }\n\n    /* ensure input point is in affine coords for ladder step efficiency */\n    if (!p-\u003eZ_is_one \u0026\u0026 !EC_POINT_make_affine(group, p, ctx)) {\n            ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_EC_LIB);\n            goto err;\n    }\n\n    /* Initialize the Montgomery ladder */\n    if (!ec_point_ladder_pre(group, r, s, p, ctx)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_LADDER_PRE_FAILURE);\n        goto err;\n    }\n\n    /* top bit is a 1, in a fixed pos */\n    pbit = 1;\n\n#define EC_POINT_CSWAP(c, a, b, w, t) do {         \\\n        BN_consttime_swap(c, (a)-\u003eX, (b)-\u003eX, w);   \\\n        BN_consttime_swap(c, (a)-\u003eY, (b)-\u003eY, w);   \\\n        BN_consttime_swap(c, (a)-\u003eZ, (b)-\u003eZ, w);   \\\n        t = ((a)-\u003eZ_is_one ^ (b)-\u003eZ_is_one) \u0026 (c); \\\n        (a)-\u003eZ_is_one ^= (t);                      \\\n        (b)-\u003eZ_is_one ^= (t);                      \\\n} while(0)\n\n    /*-\n     * The ladder step, with branches, is\n     *\n     * k[i] == 0: S = add(R, S), R = dbl(R)\n     * k[i] == 1: R = add(S, R), S = dbl(S)\n     *\n     * Swapping R, S conditionally on k[i] leaves you with state\n     *\n     * k[i] == 0: T, U = R, S\n     * k[i] == 1: T, U = S, R\n     *\n     * Then perform the ECC ops.\n     *\n     * U = add(T, U)\n     * T = dbl(T)\n     *\n     * Which leaves you with state\n     *\n     * k[i] == 0: U = add(R, S), T = dbl(R)\n     * k[i] == 1: U = add(S, R), T = dbl(S)\n     *\n     * Swapping T, U conditionally on k[i] leaves you with state\n     *\n     * k[i] == 0: R, S = T, U\n     * k[i] == 1: R, S = U, T\n     *\n     * Which leaves you with state\n     *\n     * k[i] == 0: S = add(R, S), R = dbl(R)\n     * k[i] == 1: R = add(S, R), S = dbl(S)\n     *\n     * So we get the same logic, but instead of a branch it's a\n     * conditional swap, followed by ECC ops, then another conditional swap.\n     *\n     * Optimization: The end of iteration i and start of i-1 looks like\n     *\n     * ...\n     * CSWAP(k[i], R, S)\n     * ECC\n     * CSWAP(k[i], R, S)\n     * (next iteration)\n     * CSWAP(k[i-1], R, S)\n     * ECC\n     * CSWAP(k[i-1], R, S)\n     * ...\n     *\n     * So instead of two contiguous swaps, you can merge the condition\n     * bits and do a single swap.\n     *\n     * k[i]   k[i-1]    Outcome\n     * 0      0         No Swap\n     * 0      1         Swap\n     * 1      0         Swap\n     * 1      1         No Swap\n     *\n     * This is XOR. pbit tracks the previous bit of k.\n     */\n\n    for (i = cardinality_bits - 1; i \u003e= 0; i--) {\n        kbit = BN_is_bit_set(k, i) ^ pbit;\n        EC_POINT_CSWAP(kbit, r, s, group_top, Z_is_one);\n\n        /* Perform a single step of the Montgomery ladder */\n        if (!ec_point_ladder_step(group, r, s, p, ctx)) {\n            ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_LADDER_STEP_FAILURE);\n            goto err;\n        }\n        /*\n         * pbit logic merges this cswap with that of the\n         * next iteration\n         */\n        pbit ^= kbit;\n    }\n    /* one final cswap to move the right value into r */\n    EC_POINT_CSWAP(pbit, r, s, group_top, Z_is_one);\n#undef EC_POINT_CSWAP\n\n    /* Finalize ladder (and recover full point coordinates) */\n    if (!ec_point_ladder_post(group, r, s, p, ctx)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_LADDER_POST_FAILURE);\n        goto err;\n    }\n\n    ret = 1;\n\n err:\n    EC_POINT_free(p);\n    EC_POINT_clear_free(s);\n    BN_CTX_end(ctx);\n\n    return ret;\n}","filepath":"openssl/crypto/ec/ec_mult.c","line_number":139,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.210"},"270182384":{"score":0.8251271,"function_name":"ec_wNAF_mul","code":"int ec_wNAF_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,\n                size_t num, const EC_POINT *points[], const BIGNUM *scalars[],\n                BN_CTX *ctx)\n{\n    const EC_POINT *generator = NULL;\n    EC_POINT *tmp = NULL;\n    size_t totalnum;\n    size_t blocksize = 0, numblocks = 0; /* for wNAF splitting */\n    size_t pre_points_per_block = 0;\n    size_t i, j;\n    int k;\n    int r_is_inverted = 0;\n    int r_is_at_infinity = 1;\n    size_t *wsize = NULL;       /* individual window sizes */\n    signed char **wNAF = NULL;  /* individual wNAFs */\n    size_t *wNAF_len = NULL;\n    size_t max_len = 0;\n    size_t num_val;\n    EC_POINT **val = NULL;      /* precomputation */\n    EC_POINT **v;\n    EC_POINT ***val_sub = NULL; /* pointers to sub-arrays of 'val' or\n                                 * 'pre_comp-\u003epoints' */\n    const EC_PRE_COMP *pre_comp = NULL;\n    int num_scalar = 0;         /* flag: will be set to 1 if 'scalar' must be\n                                 * treated like other scalars, i.e.\n                                 * precomputation is not available */\n    int ret = 0;\n\n    if (!BN_is_zero(group-\u003eorder) \u0026\u0026 !BN_is_zero(group-\u003ecofactor)) {\n        /*-\n         * Handle the common cases where the scalar is secret, enforcing a\n         * scalar multiplication implementation based on a Montgomery ladder,\n         * with various timing attack defenses.\n         */\n        if ((scalar != group-\u003eorder) \u0026\u0026 (scalar != NULL) \u0026\u0026 (num == 0)) {\n            /*-\n             * In this case we want to compute scalar * GeneratorPoint: this\n             * codepath is reached most prominently by (ephemeral) key\n             * generation of EC cryptosystems (i.e. ECDSA keygen and sign setup,\n             * ECDH keygen/first half), where the scalar is always secret. This\n             * is why we ignore if BN_FLG_CONSTTIME is actually set and we\n             * always call the ladder version.\n             */\n            return ec_scalar_mul_ladder(group, r, scalar, NULL, ctx);\n        }\n        if ((scalar == NULL) \u0026\u0026 (num == 1) \u0026\u0026 (scalars[0] != group-\u003eorder)) {\n            /*-\n             * In this case we want to compute scalar * VariablePoint: this\n             * codepath is reached most prominently by the second half of ECDH,\n             * where the secret scalar is multiplied by the peer's public point.\n             * To protect the secret scalar, we ignore if BN_FLG_CONSTTIME is\n             * actually set and we always call the ladder version.\n             */\n            return ec_scalar_mul_ladder(group, r, scalars[0], points[0], ctx);\n        }\n    }\n\n    if (scalar != NULL) {\n        generator = EC_GROUP_get0_generator(group);\n        if (generator == NULL) {\n            ECerr(EC_F_EC_WNAF_MUL, EC_R_UNDEFINED_GENERATOR);\n            goto err;\n        }\n\n        /* look if we can use precomputed multiples of generator */\n\n        pre_comp = group-\u003epre_comp.ec;\n        if (pre_comp \u0026\u0026 pre_comp-\u003enumblocks\n            \u0026\u0026 (EC_POINT_cmp(group, generator, pre_comp-\u003epoints[0], ctx) ==\n                0)) {\n            blocksize = pre_comp-\u003eblocksize;\n\n            /*\n             * determine maximum number of blocks that wNAF splitting may\n             * yield (NB: maximum wNAF length is bit length plus one)\n             */\n            numblocks = (BN_num_bits(scalar) / blocksize) + 1;\n\n            /*\n             * we cannot use more blocks than we have precomputation for\n             */\n            if (numblocks \u003e pre_comp-\u003enumblocks)\n                numblocks = pre_comp-\u003enumblocks;\n\n            pre_points_per_block = (size_t)1 \u003c\u003c (pre_comp-\u003ew - 1);\n\n            /* check that pre_comp looks sane */\n            if (pre_comp-\u003enum != (pre_comp-\u003enumblocks * pre_points_per_block)) {\n                ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n        } else {\n            /* can't use precomputation */\n            pre_comp = NULL;\n            numblocks = 1;\n            num_scalar = 1;     /* treat 'scalar' like 'num'-th element of\n                                 * 'scalars' */\n        }\n    }\n\n    totalnum = num + numblocks;\n\n    wsize = OPENSSL_malloc(totalnum * sizeof(wsize[0]));\n    wNAF_len = OPENSSL_malloc(totalnum * sizeof(wNAF_len[0]));\n    /* include space for pivot */\n    wNAF = OPENSSL_malloc((totalnum + 1) * sizeof(wNAF[0]));\n    val_sub = OPENSSL_malloc(totalnum * sizeof(val_sub[0]));\n\n    /* Ensure wNAF is initialised in case we end up going to err */\n    if (wNAF != NULL)\n        wNAF[0] = NULL;         /* preliminary pivot */\n\n    if (wsize == NULL || wNAF_len == NULL || wNAF == NULL || val_sub == NULL) {\n        ECerr(EC_F_EC_WNAF_MUL, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    /*\n     * num_val will be the total number of temporarily precomputed points\n     */\n    num_val = 0;\n\n    for (i = 0; i \u003c num + num_scalar; i++) {\n        size_t bits;\n\n        bits = i \u003c num ? BN_num_bits(scalars[i]) : BN_num_bits(scalar);\n        wsize[i] = EC_window_bits_for_scalar_size(bits);\n        num_val += (size_t)1 \u003c\u003c (wsize[i] - 1);\n        wNAF[i + 1] = NULL;     /* make sure we always have a pivot */\n        wNAF[i] =\n            bn_compute_wNAF((i \u003c num ? scalars[i] : scalar), wsize[i],\n                            \u0026wNAF_len[i]);\n        if (wNAF[i] == NULL)\n            goto err;\n        if (wNAF_len[i] \u003e max_len)\n            max_len = wNAF_len[i];\n    }\n\n    if (numblocks) {\n        /* we go here iff scalar != NULL */\n\n        if (pre_comp == NULL) {\n            if (num_scalar != 1) {\n                ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n            /* we have already generated a wNAF for 'scalar' */\n        } else {\n            signed char *tmp_wNAF = NULL;\n            size_t tmp_len = 0;\n\n            if (num_scalar != 0) {\n                ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n\n            /*\n             * use the window size for which we have precomputation\n             */\n            wsize[num] = pre_comp-\u003ew;\n            tmp_wNAF = bn_compute_wNAF(scalar, wsize[num], \u0026tmp_len);\n            if (!tmp_wNAF)\n                goto err;\n\n            if (tmp_len \u003c= max_len) {\n                /*\n                 * One of the other wNAFs is at least as long as the wNAF\n                 * belonging to the generator, so wNAF splitting will not buy\n                 * us anything.\n                 */\n\n                numblocks = 1;\n                totalnum = num + 1; /* don't use wNAF splitting */\n                wNAF[num] = tmp_wNAF;\n                wNAF[num + 1] = NULL;\n                wNAF_len[num] = tmp_len;\n                /*\n                 * pre_comp-\u003epoints starts with the points that we need here:\n                 */\n                val_sub[num] = pre_comp-\u003epoints;\n            } else {\n                /*\n                 * don't include tmp_wNAF directly into wNAF array - use wNAF\n                 * splitting and include the blocks\n                 */\n\n                signed char *pp;\n                EC_POINT **tmp_points;\n\n                if (tmp_len \u003c numblocks * blocksize) {\n                    /*\n                     * possibly we can do with fewer blocks than estimated\n                     */\n                    numblocks = (tmp_len + blocksize - 1) / blocksize;\n                    if (numblocks \u003e pre_comp-\u003enumblocks) {\n                        ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\n                        OPENSSL_free(tmp_wNAF);\n                        goto err;\n                    }\n                    totalnum = num + numblocks;\n                }\n\n                /* split wNAF in 'numblocks' parts */\n                pp = tmp_wNAF;\n                tmp_points = pre_comp-\u003epoints;\n\n                for (i = num; i \u003c totalnum; i++) {\n                    if (i \u003c totalnum - 1) {\n                        wNAF_len[i] = blocksize;\n                        if (tmp_len \u003c blocksize) {\n                            ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\n                            OPENSSL_free(tmp_wNAF);\n                            goto err;\n                        }\n                        tmp_len -= blocksize;\n                    } else\n                        /*\n                         * last block gets whatever is left (this could be\n                         * more or less than 'blocksize'!)\n                         */\n                        wNAF_len[i] = tmp_len;\n\n                    wNAF[i + 1] = NULL;\n                    wNAF[i] = OPENSSL_malloc(wNAF_len[i]);\n                    if (wNAF[i] == NULL) {\n                        ECerr(EC_F_EC_WNAF_MUL, ERR_R_MALLOC_FAILURE);\n                        OPENSSL_free(tmp_wNAF);\n                        goto err;\n                    }\n                    memcpy(wNAF[i], pp, wNAF_len[i]);\n                    if (wNAF_len[i] \u003e max_len)\n                        max_len = wNAF_len[i];\n\n                    if (*tmp_points == NULL) {\n                        ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\n                        OPENSSL_free(tmp_wNAF);\n                        goto err;\n                    }\n                    val_sub[i] = tmp_points;\n                    tmp_points += pre_points_per_block;\n                    pp += blocksize;\n                }\n                OPENSSL_free(tmp_wNAF);\n            }\n        }\n    }\n\n    /*\n     * All points we precompute now go into a single array 'val'.\n     * 'val_sub[i]' is a pointer to the subarray for the i-th point, or to a\n     * subarray of 'pre_comp-\u003epoints' if we already have precomputation.\n     */\n    val = OPENSSL_malloc((num_val + 1) * sizeof(val[0]));\n    if (val == NULL) {\n        ECerr(EC_F_EC_WNAF_MUL, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    val[num_val] = NULL;        /* pivot element */\n\n    /* allocate points for precomputation */\n    v = val;\n    for (i = 0; i \u003c num + num_scalar; i++) {\n        val_sub[i] = v;\n        for (j = 0; j \u003c ((size_t)1 \u003c\u003c (wsize[i] - 1)); j++) {\n            *v = EC_POINT_new(group);\n            if (*v == NULL)\n                goto err;\n            v++;\n        }\n    }\n    if (!(v == val + num_val)) {\n        ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    if ((tmp = EC_POINT_new(group)) == NULL)\n        goto err;\n\n    /*-\n     * prepare precomputed values:\n     *    val_sub[i][0] :=     points[i]\n     *    val_sub[i][1] := 3 * points[i]\n     *    val_sub[i][2] := 5 * points[i]\n     *    ...\n     */\n    for (i = 0; i \u003c num + num_scalar; i++) {\n        if (i \u003c num) {\n            if (!EC_POINT_copy(val_sub[i][0], points[i]))\n                goto err;\n        } else {\n            if (!EC_POINT_copy(val_sub[i][0], generator))\n                goto err;\n        }\n\n        if (wsize[i] \u003e 1) {\n            if (!EC_POINT_dbl(group, tmp, val_sub[i][0], ctx))\n                goto err;\n            for (j = 1; j \u003c ((size_t)1 \u003c\u003c (wsize[i] - 1)); j++) {\n                if (!EC_POINT_add\n                    (group, val_sub[i][j], val_sub[i][j - 1], tmp, ctx))\n                    goto err;\n            }\n        }\n    }\n\n    if (!EC_POINTs_make_affine(group, num_val, val, ctx))\n        goto err;\n\n    r_is_at_infinity = 1;\n\n    for (k = max_len - 1; k \u003e= 0; k--) {\n        if (!r_is_at_infinity) {\n            if (!EC_POINT_dbl(group, r, r, ctx))\n                goto err;\n        }\n\n        for (i = 0; i \u003c totalnum; i++) {\n            if (wNAF_len[i] \u003e (size_t)k) {\n                int digit = wNAF[i][k];\n                int is_neg;\n\n                if (digit) {\n                    is_neg = digit \u003c 0;\n\n                    if (is_neg)\n                        digit = -digit;\n\n                    if (is_neg != r_is_inverted) {\n                        if (!r_is_at_infinity) {\n                            if (!EC_POINT_invert(group, r, ctx))\n                                goto err;\n                        }\n                        r_is_inverted = !r_is_inverted;\n                    }\n\n                    /* digit \u003e 0 */\n\n                    if (r_is_at_infinity) {\n                        if (!EC_POINT_copy(r, val_sub[i][digit \u003e\u003e 1]))\n                            goto err;\n\n                        /*-\n                         * Apply coordinate blinding for EC_POINT.\n                         *\n                         * The underlying EC_METHOD can optionally implement this function:\n                         * ec_point_blind_coordinates() returns 0 in case of errors or 1 on\n                         * success or if coordinate blinding is not implemented for this\n                         * group.\n                         */\n                        if (!ec_point_blind_coordinates(group, r, ctx)) {\n                            ECerr(EC_F_EC_WNAF_MUL, EC_R_POINT_COORDINATES_BLIND_FAILURE);\n                            goto err;\n                        }\n\n                        r_is_at_infinity = 0;\n                    } else {\n                        if (!EC_POINT_add\n                            (group, r, r, val_sub[i][digit \u003e\u003e 1], ctx))\n                            goto err;\n                    }\n                }\n            }\n        }\n    }\n\n    if (r_is_at_infinity) {\n        if (!EC_POINT_set_to_infinity(group, r))\n            goto err;\n    } else {\n        if (r_is_inverted)\n            if (!EC_POINT_invert(group, r, ctx))\n                goto err;\n    }\n\n    ret = 1;\n\n err:\n    EC_POINT_free(tmp);\n    OPENSSL_free(wsize);\n    OPENSSL_free(wNAF_len);\n    if (wNAF != NULL) {\n        signed char **w;\n\n        for (w = wNAF; *w != NULL; w++)\n            OPENSSL_free(*w);\n\n        OPENSSL_free(wNAF);\n    }\n    if (val != NULL) {\n        for (v = val; *v != NULL; v++)\n            EC_POINT_clear_free(*v);\n\n        OPENSSL_free(val);\n    }\n    OPENSSL_free(val_sub);\n    return ret;\n}"},"270194144":{"score":0.80297744,"function_name":"ec_GF2m_simple_oct2point","code":"int ec_GF2m_simple_oct2point(const EC_GROUP *group, EC_POINT *point,\n                             const unsigned char *buf, size_t len,\n                             BN_CTX *ctx)\n{\n    point_conversion_form_t form;\n    int y_bit, m;\n    BN_CTX *new_ctx = NULL;\n    BIGNUM *x, *y, *yxi;\n    size_t field_len, enc_len;\n    int ret = 0;\n\n    if (len == 0) {\n        ECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_BUFFER_TOO_SMALL);\n        return 0;\n    }\n    form = buf[0];\n    y_bit = form \u0026 1;\n    form = form \u0026 ~1U;\n    if ((form != 0) \u0026\u0026 (form != POINT_CONVERSION_COMPRESSED)\n        \u0026\u0026 (form != POINT_CONVERSION_UNCOMPRESSED)\n        \u0026\u0026 (form != POINT_CONVERSION_HYBRID)) {\n        ECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\n        return 0;\n    }\n    if ((form == 0 || form == POINT_CONVERSION_UNCOMPRESSED) \u0026\u0026 y_bit) {\n        ECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\n        return 0;\n    }\n\n    if (form == 0) {\n        if (len != 1) {\n            ECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\n            return 0;\n        }\n\n        return EC_POINT_set_to_infinity(group, point);\n    }\n\n    m = EC_GROUP_get_degree(group);\n    field_len = (m + 7) / 8;\n    enc_len =\n        (form ==\n         POINT_CONVERSION_COMPRESSED) ? 1 + field_len : 1 + 2 * field_len;\n\n    if (len != enc_len) {\n        ECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\n        return 0;\n    }\n\n    if (ctx == NULL) {\n        ctx = new_ctx = BN_CTX_new();\n        if (ctx == NULL)\n            return 0;\n    }\n\n    BN_CTX_start(ctx);\n    x = BN_CTX_get(ctx);\n    y = BN_CTX_get(ctx);\n    yxi = BN_CTX_get(ctx);\n    if (yxi == NULL)\n        goto err;\n\n    if (!BN_bin2bn(buf + 1, field_len, x))\n        goto err;\n    if (BN_num_bits(x) \u003e m) {\n        ECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\n        goto err;\n    }\n\n    if (form == POINT_CONVERSION_COMPRESSED) {\n        if (!EC_POINT_set_compressed_coordinates(group, point, x, y_bit, ctx))\n            goto err;\n    } else {\n        if (!BN_bin2bn(buf + 1 + field_len, field_len, y))\n            goto err;\n        if (BN_num_bits(y) \u003e m) {\n            ECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\n            goto err;\n        }\n        if (form == POINT_CONVERSION_HYBRID) {\n            if (!group-\u003emeth-\u003efield_div(group, yxi, y, x, ctx))\n                goto err;\n            if (y_bit != BN_is_odd(yxi)) {\n                ECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\n                goto err;\n            }\n        }\n\n        /*\n         * EC_POINT_set_affine_coordinates is responsible for checking that\n         * the point is on the curve.\n         */\n        if (!EC_POINT_set_affine_coordinates(group, point, x, y, ctx))\n            goto err;\n    }\n\n    ret = 1;\n\n err:\n    BN_CTX_end(ctx);\n    BN_CTX_free(new_ctx);\n    return ret;\n}","filepath":"crypto/ec/ec2_oct.c","line_number":235,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1c"},"270194752":{"score":0.90652555,"function_name":"ec_GF2m_simple_point2oct","code":"size_t ec_GF2m_simple_point2oct(const EC_GROUP *group, const EC_POINT *point,\n                                point_conversion_form_t form,\n                                unsigned char *buf, size_t len, BN_CTX *ctx)\n{\n    size_t ret;\n    BN_CTX *new_ctx = NULL;\n    int used_ctx = 0;\n    BIGNUM *x, *y, *yxi;\n    size_t field_len, i, skip;\n\n    if ((form != POINT_CONVERSION_COMPRESSED)\n        \u0026\u0026 (form != POINT_CONVERSION_UNCOMPRESSED)\n        \u0026\u0026 (form != POINT_CONVERSION_HYBRID)) {\n        ECerr(EC_F_EC_GF2M_SIMPLE_POINT2OCT, EC_R_INVALID_FORM);\n        goto err;\n    }\n\n    if (EC_POINT_is_at_infinity(group, point)) {\n        /* encodes to a single 0 octet */\n        if (buf != NULL) {\n            if (len \u003c 1) {\n                ECerr(EC_F_EC_GF2M_SIMPLE_POINT2OCT, EC_R_BUFFER_TOO_SMALL);\n                return 0;\n            }\n            buf[0] = 0;\n        }\n        return 1;\n    }\n\n    /* ret := required output buffer length */\n    field_len = (EC_GROUP_get_degree(group) + 7) / 8;\n    ret =\n        (form ==\n         POINT_CONVERSION_COMPRESSED) ? 1 + field_len : 1 + 2 * field_len;\n\n    /* if 'buf' is NULL, just return required length */\n    if (buf != NULL) {\n        if (len \u003c ret) {\n            ECerr(EC_F_EC_GF2M_SIMPLE_POINT2OCT, EC_R_BUFFER_TOO_SMALL);\n            goto err;\n        }\n\n        if (ctx == NULL) {\n            ctx = new_ctx = BN_CTX_new();\n            if (ctx == NULL)\n                return 0;\n        }\n\n        BN_CTX_start(ctx);\n        used_ctx = 1;\n        x = BN_CTX_get(ctx);\n        y = BN_CTX_get(ctx);\n        yxi = BN_CTX_get(ctx);\n        if (yxi == NULL)\n            goto err;\n\n        if (!EC_POINT_get_affine_coordinates(group, point, x, y, ctx))\n            goto err;\n\n        buf[0] = form;\n        if ((form != POINT_CONVERSION_UNCOMPRESSED) \u0026\u0026 !BN_is_zero(x)) {\n            if (!group-\u003emeth-\u003efield_div(group, yxi, y, x, ctx))\n                goto err;\n            if (BN_is_odd(yxi))\n                buf[0]++;\n        }\n\n        i = 1;\n\n        skip = field_len - BN_num_bytes(x);\n        if (skip \u003e field_len) {\n            ECerr(EC_F_EC_GF2M_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        while (skip \u003e 0) {\n            buf[i++] = 0;\n            skip--;\n        }\n        skip = BN_bn2bin(x, buf + i);\n        i += skip;\n        if (i != 1 + field_len) {\n            ECerr(EC_F_EC_GF2M_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n\n        if (form == POINT_CONVERSION_UNCOMPRESSED\n            || form == POINT_CONVERSION_HYBRID) {\n            skip = field_len - BN_num_bytes(y);\n            if (skip \u003e field_len) {\n                ECerr(EC_F_EC_GF2M_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n            while (skip \u003e 0) {\n                buf[i++] = 0;\n                skip--;\n            }\n            skip = BN_bn2bin(y, buf + i);\n            i += skip;\n        }\n\n        if (i != ret) {\n            ECerr(EC_F_EC_GF2M_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n    }\n\n    if (used_ctx)\n        BN_CTX_end(ctx);\n    BN_CTX_free(new_ctx);\n    return ret;\n\n err:\n    if (used_ctx)\n        BN_CTX_end(ctx);\n    BN_CTX_free(new_ctx);\n    return 0;\n}","filepath":"crypto/ec/ec2_oct.c","line_number":113,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1c"},"270195552":{"score":0.89834607,"function_name":"ec_GF2m_simple_set_compressed_coordinates","code":"int ec_GF2m_simple_set_compressed_coordinates(const EC_GROUP *group,\n                                              EC_POINT *point,\n                                              const BIGNUM *x_, int y_bit,\n                                              BN_CTX *ctx)\n{\n    BN_CTX *new_ctx = NULL;\n    BIGNUM *tmp, *x, *y, *z;\n    int ret = 0, z0;\n\n    /* clear error queue */\n    ERR_clear_error();\n\n    if (ctx == NULL) {\n        ctx = new_ctx = BN_CTX_new();\n        if (ctx == NULL)\n            return 0;\n    }\n\n    y_bit = (y_bit != 0) ? 1 : 0;\n\n    BN_CTX_start(ctx);\n    tmp = BN_CTX_get(ctx);\n    x = BN_CTX_get(ctx);\n    y = BN_CTX_get(ctx);\n    z = BN_CTX_get(ctx);\n    if (z == NULL)\n        goto err;\n\n    if (!BN_GF2m_mod_arr(x, x_, group-\u003epoly))\n        goto err;\n    if (BN_is_zero(x)) {\n        if (!BN_GF2m_mod_sqrt_arr(y, group-\u003eb, group-\u003epoly, ctx))\n            goto err;\n    } else {\n        if (!group-\u003emeth-\u003efield_sqr(group, tmp, x, ctx))\n            goto err;\n        if (!group-\u003emeth-\u003efield_div(group, tmp, group-\u003eb, tmp, ctx))\n            goto err;\n        if (!BN_GF2m_add(tmp, group-\u003ea, tmp))\n            goto err;\n        if (!BN_GF2m_add(tmp, x, tmp))\n            goto err;\n        if (!BN_GF2m_mod_solve_quad_arr(z, tmp, group-\u003epoly, ctx)) {\n            unsigned long err = ERR_peek_last_error();\n\n            if (ERR_GET_LIB(err) == ERR_LIB_BN\n                \u0026\u0026 ERR_GET_REASON(err) == BN_R_NO_SOLUTION) {\n                ERR_clear_error();\n                ECerr(EC_F_EC_GF2M_SIMPLE_SET_COMPRESSED_COORDINATES,\n                      EC_R_INVALID_COMPRESSED_POINT);\n            } else\n                ECerr(EC_F_EC_GF2M_SIMPLE_SET_COMPRESSED_COORDINATES,\n                      ERR_R_BN_LIB);\n            goto err;\n        }\n        z0 = (BN_is_odd(z)) ? 1 : 0;\n        if (!group-\u003emeth-\u003efield_mul(group, y, x, z, ctx))\n            goto err;\n        if (z0 != y_bit) {\n            if (!BN_GF2m_add(y, y, x))\n                goto err;\n        }\n    }\n\n    if (!EC_POINT_set_affine_coordinates(group, point, x, y, ctx))\n        goto err;\n\n    ret = 1;\n\n err:\n    BN_CTX_end(ctx);\n    BN_CTX_free(new_ctx);\n    return ret;\n}","filepath":"crypto/ec/ec2_oct.c","line_number":33,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1c"},"270196752":{"score":0.87355995,"function_name":"ecdsa_sign_setup","code":"static int ecdsa_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in,\n                            BIGNUM **kinvp, BIGNUM **rp,\n                            const unsigned char *dgst, int dlen)\n{\n    BN_CTX *ctx = NULL;\n    BIGNUM *k = NULL, *r = NULL, *X = NULL;\n    const BIGNUM *order;\n    EC_POINT *tmp_point = NULL;\n    const EC_GROUP *group;\n    int ret = 0;\n    int order_bits;\n    const BIGNUM *priv_key;\n\n    if (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL) {\n        ECerr(EC_F_ECDSA_SIGN_SETUP, ERR_R_PASSED_NULL_PARAMETER);\n        return 0;\n    }\n    if ((priv_key = EC_KEY_get0_private_key(eckey)) == NULL) {\n        ECerr(EC_F_ECDSA_SIGN_SETUP, EC_R_MISSING_PRIVATE_KEY);\n        return 0;\n    }\n\n    if (!EC_KEY_can_sign(eckey)) {\n        ECerr(EC_F_ECDSA_SIGN_SETUP, EC_R_CURVE_DOES_NOT_SUPPORT_SIGNING);\n        return 0;\n    }\n\n    if ((ctx = ctx_in) == NULL) {\n        if ((ctx = BN_CTX_new()) == NULL) {\n            ECerr(EC_F_ECDSA_SIGN_SETUP, ERR_R_MALLOC_FAILURE);\n            return 0;\n        }\n    }\n\n    k = BN_new();               /* this value is later returned in *kinvp */\n    r = BN_new();               /* this value is later returned in *rp */\n    X = BN_new();\n    if (k == NULL || r == NULL || X == NULL) {\n        ECerr(EC_F_ECDSA_SIGN_SETUP, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    if ((tmp_point = EC_POINT_new(group)) == NULL) {\n        ECerr(EC_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n        goto err;\n    }\n    order = EC_GROUP_get0_order(group);\n\n    /* Preallocate space */\n    order_bits = BN_num_bits(order);\n    if (!BN_set_bit(k, order_bits)\n        || !BN_set_bit(r, order_bits)\n        || !BN_set_bit(X, order_bits))\n        goto err;\n\n    do {\n        /* get random k */\n        do {\n            if (dgst != NULL) {\n                if (!BN_generate_dsa_nonce(k, order, priv_key,\n                                           dgst, dlen, ctx)) {\n                    ECerr(EC_F_ECDSA_SIGN_SETUP,\n                          EC_R_RANDOM_NUMBER_GENERATION_FAILED);\n                    goto err;\n                }\n            } else {\n                if (!BN_priv_rand_range(k, order)) {\n                    ECerr(EC_F_ECDSA_SIGN_SETUP,\n                          EC_R_RANDOM_NUMBER_GENERATION_FAILED);\n                    goto err;\n                }\n            }\n        } while (BN_is_zero(k));\n\n        /* compute r the x-coordinate of generator * k */\n        if (!EC_POINT_mul(group, tmp_point, k, NULL, NULL, ctx)) {\n            ECerr(EC_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n            goto err;\n        }\n\n        if (!EC_POINT_get_affine_coordinates(group, tmp_point, X, NULL, ctx)) {\n            ECerr(EC_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n            goto err;\n        }\n\n        if (!BN_nnmod(r, X, order, ctx)) {\n            ECerr(EC_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n            goto err;\n        }\n    } while (BN_is_zero(r));\n\n    /* compute the inverse of k */\n    if (!ec_group_do_inverse_ord(group, k, k, ctx)) {\n        ECerr(EC_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n        goto err;\n    }\n\n    /* clear old values if necessary */\n    BN_clear_free(*rp);\n    BN_clear_free(*kinvp);\n    /* save the pre-computed values  */\n    *rp = r;\n    *kinvp = k;\n    ret = 1;\n err:\n    if (!ret) {\n        BN_clear_free(k);\n        BN_clear_free(r);\n    }\n    if (ctx != ctx_in)\n        BN_CTX_free(ctx);\n    EC_POINT_free(tmp_point);\n    BN_clear_free(X);\n    return ret;\n}","filepath":"openssl/crypto/ec/ecdsa_ossl.c","line_number":33,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.72"},"270197616":{"score":0.90740407,"function_name":"ossl_ecdsa_sign_sig","code":"ECDSA_SIG *ossl_ecdsa_sign_sig(const unsigned char *dgst, int dgst_len,\n                               const BIGNUM *in_kinv, const BIGNUM *in_r,\n                               EC_KEY *eckey)\n{\n    int ok = 0, i;\n    BIGNUM *kinv = NULL, *s, *m = NULL;\n    const BIGNUM *order, *ckinv;\n    BN_CTX *ctx = NULL;\n    const EC_GROUP *group;\n    ECDSA_SIG *ret;\n    const BIGNUM *priv_key;\n\n    group = EC_KEY_get0_group(eckey);\n    priv_key = EC_KEY_get0_private_key(eckey);\n\n    if (group == NULL) {\n        ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_PASSED_NULL_PARAMETER);\n        return NULL;\n    }\n    if (priv_key == NULL) {\n        ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, EC_R_MISSING_PRIVATE_KEY);\n        return NULL;\n    }\n\n    if (!EC_KEY_can_sign(eckey)) {\n        ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, EC_R_CURVE_DOES_NOT_SUPPORT_SIGNING);\n        return NULL;\n    }\n\n    ret = ECDSA_SIG_new();\n    if (ret == NULL) {\n        ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    ret-\u003er = BN_new();\n    ret-\u003es = BN_new();\n    if (ret-\u003er == NULL || ret-\u003es == NULL) {\n        ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    s = ret-\u003es;\n\n    if ((ctx = BN_CTX_new()) == NULL\n        || (m = BN_new()) == NULL) {\n        ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    order = EC_GROUP_get0_order(group);\n    i = BN_num_bits(order);\n    /*\n     * Need to truncate digest if it is too long: first truncate whole bytes.\n     */\n    if (8 * dgst_len \u003e i)\n        dgst_len = (i + 7) / 8;\n    if (!BN_bin2bn(dgst, dgst_len, m)) {\n        ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_BN_LIB);\n        goto err;\n    }\n    /* If still too long, truncate remaining bits with a shift */\n    if ((8 * dgst_len \u003e i) \u0026\u0026 !BN_rshift(m, m, 8 - (i \u0026 0x7))) {\n        ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_BN_LIB);\n        goto err;\n    }\n    do {\n        if (in_kinv == NULL || in_r == NULL) {\n            if (!ecdsa_sign_setup(eckey, ctx, \u0026kinv, \u0026ret-\u003er, dgst, dgst_len)) {\n                ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_ECDSA_LIB);\n                goto err;\n            }\n            ckinv = kinv;\n        } else {\n            ckinv = in_kinv;\n            if (BN_copy(ret-\u003er, in_r) == NULL) {\n                ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n        }\n\n        /*\n         * With only one multiplicant being in Montgomery domain\n         * multiplication yields real result without post-conversion.\n         * Also note that all operations but last are performed with\n         * zero-padded vectors. Last operation, BN_mod_mul_montgomery\n         * below, returns user-visible value with removed zero padding.\n         */\n        if (!bn_to_mont_fixed_top(s, ret-\u003er, group-\u003emont_data, ctx)\n            || !bn_mul_mont_fixed_top(s, s, priv_key, group-\u003emont_data, ctx)) {\n            ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_BN_LIB);\n            goto err;\n        }\n        if (!bn_mod_add_fixed_top(s, s, m, order)) {\n            ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_BN_LIB);\n            goto err;\n        }\n        /*\n         * |s| can still be larger than modulus, because |m| can be. In\n         * such case we count on Montgomery reduction to tie it up.\n         */\n        if (!bn_to_mont_fixed_top(s, s, group-\u003emont_data, ctx)\n            || !BN_mod_mul_montgomery(s, s, ckinv, group-\u003emont_data, ctx)) {\n            ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_BN_LIB);\n            goto err;\n        }\n\n        if (BN_is_zero(s)) {\n            /*\n             * if kinv and r have been supplied by the caller, don't\n             * generate new kinv and r values\n             */\n            if (in_kinv != NULL \u0026\u0026 in_r != NULL) {\n                ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, EC_R_NEED_NEW_SETUP_VALUES);\n                goto err;\n            }\n        } else {\n            /* s != 0 =\u003e we have a valid signature */\n            break;\n        }\n    } while (1);\n\n    ok = 1;\n err:\n    if (!ok) {\n        ECDSA_SIG_free(ret);\n        ret = NULL;\n    }\n    BN_CTX_free(ctx);\n    BN_clear_free(m);\n    BN_clear_free(kinv);\n    return ret;\n}","filepath":"openssl/crypto/ec/ecdsa_ossl.c","line_number":154,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.72"},"270198432":{"score":0.871392,"function_name":"ossl_ecdsa_verify","code":"int ossl_ecdsa_verify(int type, const unsigned char *dgst, int dgst_len,\n                      const unsigned char *sigbuf, int sig_len, EC_KEY *eckey)\n{\n    ECDSA_SIG *s;\n    const unsigned char *p = sigbuf;\n    unsigned char *der = NULL;\n    int derlen = -1;\n    int ret = -1;\n\n    s = ECDSA_SIG_new();\n    if (s == NULL)\n        return ret;\n    if (d2i_ECDSA_SIG(\u0026s, \u0026p, sig_len) == NULL)\n        goto err;\n    /* Ensure signature uses DER and doesn't have trailing garbage */\n    derlen = i2d_ECDSA_SIG(s, \u0026der);\n    if (derlen != sig_len || memcmp(sigbuf, der, derlen) != 0)\n        goto err;\n    ret = ECDSA_do_verify(dgst, dgst_len, s, eckey);\n err:\n    OPENSSL_clear_free(der, derlen);\n    ECDSA_SIG_free(s);\n    return ret;\n}","filepath":"openssl/crypto/ec/ecdsa_ossl.c","line_number":292,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.72"},"270198704":{"score":0.9276334,"function_name":"ossl_ecdsa_verify_sig","code":"int ossl_ecdsa_verify_sig(const unsigned char *dgst, int dgst_len,\n                          const ECDSA_SIG *sig, EC_KEY *eckey)\n{\n    int ret = -1, i;\n    BN_CTX *ctx;\n    const BIGNUM *order;\n    BIGNUM *u1, *u2, *m, *X;\n    EC_POINT *point = NULL;\n    const EC_GROUP *group;\n    const EC_POINT *pub_key;\n\n    /* check input values */\n    if (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL ||\n        (pub_key = EC_KEY_get0_public_key(eckey)) == NULL || sig == NULL) {\n        ECerr(EC_F_OSSL_ECDSA_VERIFY_SIG, EC_R_MISSING_PARAMETERS);\n        return -1;\n    }\n\n    if (!EC_KEY_can_sign(eckey)) {\n        ECerr(EC_F_OSSL_ECDSA_VERIFY_SIG, EC_R_CURVE_DOES_NOT_SUPPORT_SIGNING);\n        return -1;\n    }\n\n    ctx = BN_CTX_new();\n    if (ctx == NULL) {\n        ECerr(EC_F_OSSL_ECDSA_VERIFY_SIG, ERR_R_MALLOC_FAILURE);\n        return -1;\n    }\n    BN_CTX_start(ctx);\n    u1 = BN_CTX_get(ctx);\n    u2 = BN_CTX_get(ctx);\n    m = BN_CTX_get(ctx);\n    X = BN_CTX_get(ctx);\n    if (X == NULL) {\n        ECerr(EC_F_OSSL_ECDSA_VERIFY_SIG, ERR_R_BN_LIB);\n        goto err;\n    }\n\n    order = EC_GROUP_get0_order(group);\n    if (order == NULL) {\n        ECerr(EC_F_OSSL_ECDSA_VERIFY_SIG, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    if (BN_is_zero(sig-\u003er) || BN_is_negative(sig-\u003er) ||\n        BN_ucmp(sig-\u003er, order) \u003e= 0 || BN_is_zero(sig-\u003es) ||\n        BN_is_negative(sig-\u003es) || BN_ucmp(sig-\u003es, order) \u003e= 0) {\n        ECerr(EC_F_OSSL_ECDSA_VERIFY_SIG, EC_R_BAD_SIGNATURE);\n        ret = 0;                /* signature is invalid */\n        goto err;\n    }\n    /* calculate tmp1 = inv(S) mod order */\n    if (!ec_group_do_inverse_ord(group, u2, sig-\u003es, ctx)) {\n        ECerr(EC_F_OSSL_ECDSA_VERIFY_SIG, ERR_R_BN_LIB);\n        goto err;\n    }\n    /* digest -\u003e m */\n    i = BN_num_bits(order);\n    /*\n     * Need to truncate digest if it is too long: first truncate whole bytes.\n     */\n    if (8 * dgst_len \u003e i)\n        dgst_len = (i + 7) / 8;\n    if (!BN_bin2bn(dgst, dgst_len, m)) {\n        ECerr(EC_F_OSSL_ECDSA_VERIFY_SIG, ERR_R_BN_LIB);\n        goto err;\n    }\n    /* If still too long truncate remaining bits with a shift */\n    if ((8 * dgst_len \u003e i) \u0026\u0026 !BN_rshift(m, m, 8 - (i \u0026 0x7))) {\n        ECerr(EC_F_OSSL_ECDSA_VERIFY_SIG, ERR_R_BN_LIB);\n        goto err;\n    }\n    /* u1 = m * tmp mod order */\n    if (!BN_mod_mul(u1, m, u2, order, ctx)) {\n        ECerr(EC_F_OSSL_ECDSA_VERIFY_SIG, ERR_R_BN_LIB);\n        goto err;\n    }\n    /* u2 = r * w mod q */\n    if (!BN_mod_mul(u2, sig-\u003er, u2, order, ctx)) {\n        ECerr(EC_F_OSSL_ECDSA_VERIFY_SIG, ERR_R_BN_LIB);\n        goto err;\n    }\n\n    if ((point = EC_POINT_new(group)) == NULL) {\n        ECerr(EC_F_OSSL_ECDSA_VERIFY_SIG, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    if (!EC_POINT_mul(group, point, u1, pub_key, u2, ctx)) {\n        ECerr(EC_F_OSSL_ECDSA_VERIFY_SIG, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    if (!EC_POINT_get_affine_coordinates(group, point, X, NULL, ctx)) {\n        ECerr(EC_F_OSSL_ECDSA_VERIFY_SIG, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    if (!BN_nnmod(u1, X, order, ctx)) {\n        ECerr(EC_F_OSSL_ECDSA_VERIFY_SIG, ERR_R_BN_LIB);\n        goto err;\n    }\n    /*  if the signature is correct u1 is equal to sig-\u003er */\n    ret = (BN_ucmp(u1, sig-\u003er) == 0);\n err:\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    EC_POINT_free(point);\n    return ret;\n}","filepath":"openssl/crypto/ec/ecdsa_ossl.c","line_number":317,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.72"},"270201456":{"score":0.9288577,"function_name":"ASN1_STRING_to_UTF8","code":"int ASN1_STRING_to_UTF8(unsigned char **out, ASN1_STRING *in)\n{\n    ASN1_STRING stmp, *str = \u0026stmp;\n    int mbflag, type, ret;\n    if (!in)\n        return -1;\n    type = in-\u003etype;\n    if ((type \u003c 0) || (type \u003e 30))\n        return -1;\n    mbflag = tag2nbyte[type];\n    if (mbflag == -1)\n        return -1;\n    mbflag |= MBSTRING_FLAG;\n    stmp.data = NULL;\n    stmp.length = 0;\n    stmp.flags = 0;\n    ret =\n        ASN1_mbstring_copy(\u0026str, in-\u003edata, in-\u003elength, mbflag,\n                           B_ASN1_UTF8STRING);\n    if (ret \u003c 0)\n        return ret;\n    *out = stmp.data;\n    return stmp.length;\n}","filepath":"crypto/asn1/a_strex.c","line_number":647,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_0_2p"},"270201648":{"score":0.7854908,"function_name":"do_buf","code":"static int do_buf(unsigned char *buf, int buflen,\n                  int type, unsigned char flags, char *quotes, char_io *io_ch,\n                  void *arg)\n{\n    int i, outlen, len, charwidth;\n    unsigned char orflags, *p, *q;\n    unsigned long c;\n    p = buf;\n    q = buf + buflen;\n    outlen = 0;\n    charwidth = type \u0026 BUF_TYPE_WIDTH_MASK;\n\n    switch (charwidth) {\n    case 4:\n        if (buflen \u0026 3) {\n            ASN1err(ASN1_F_DO_BUF, ASN1_R_INVALID_UNIVERSALSTRING_LENGTH);\n            return -1;\n        }\n        break;\n    case 2:\n        if (buflen \u0026 1) {\n            ASN1err(ASN1_F_DO_BUF, ASN1_R_INVALID_BMPSTRING_LENGTH);\n            return -1;\n        }\n        break;\n    default:\n        break;\n    }\n\n    while (p != q) {\n        if (p == buf \u0026\u0026 flags \u0026 ASN1_STRFLGS_ESC_2253)\n            orflags = CHARTYPE_FIRST_ESC_2253;\n        else\n            orflags = 0;\n\n        switch (charwidth) {\n        case 4:\n            c = ((unsigned long)*p++) \u003c\u003c 24;\n            c |= ((unsigned long)*p++) \u003c\u003c 16;\n            c |= ((unsigned long)*p++) \u003c\u003c 8;\n            c |= *p++;\n            break;\n\n        case 2:\n            c = ((unsigned long)*p++) \u003c\u003c 8;\n            c |= *p++;\n            break;\n\n        case 1:\n            c = *p++;\n            break;\n\n        case 0:\n            i = UTF8_getc(p, buflen, \u0026c);\n            if (i \u003c 0)\n                return -1;      /* Invalid UTF8String */\n            buflen -= i;\n            p += i;\n            break;\n        default:\n            return -1;          /* invalid width */\n        }\n        if (p == q \u0026\u0026 flags \u0026 ASN1_STRFLGS_ESC_2253)\n            orflags = CHARTYPE_LAST_ESC_2253;\n        if (type \u0026 BUF_TYPE_CONVUTF8) {\n            unsigned char utfbuf[6];\n            int utflen;\n            utflen = UTF8_putc(utfbuf, sizeof(utfbuf), c);\n            for (i = 0; i \u003c utflen; i++) {\n                /*\n                 * We don't need to worry about setting orflags correctly\n                 * because if utflen==1 its value will be correct anyway\n                 * otherwise each character will be \u003e 0x7f and so the\n                 * character will never be escaped on first and last.\n                 */\n                len =\n                    do_esc_char(utfbuf[i], (unsigned char)(flags | orflags),\n                                quotes, io_ch, arg);\n                if (len \u003c 0)\n                    return -1;\n                outlen += len;\n            }\n        } else {\n            len =\n                do_esc_char(c, (unsigned char)(flags | orflags), quotes,\n                            io_ch, arg);\n            if (len \u003c 0)\n                return -1;\n            outlen += len;\n        }\n    }\n    return outlen;\n}","filepath":"crypto/asn1/a_strex.c","line_number":193,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_0_2p"},"270202240":{"score":0.79260343,"function_name":"do_esc_char","code":"static int do_esc_char(unsigned long c, unsigned char flags, char *do_quotes,\n                       char_io *io_ch, void *arg)\n{\n    unsigned char chflgs, chtmp;\n    char tmphex[HEX_SIZE(long) + 3];\n\n    if (c \u003e 0xffffffffL)\n        return -1;\n    if (c \u003e 0xffff) {\n        BIO_snprintf(tmphex, sizeof(tmphex), \"\\\\W%08lX\", c);\n        if (!io_ch(arg, tmphex, 10))\n            return -1;\n        return 10;\n    }\n    if (c \u003e 0xff) {\n        BIO_snprintf(tmphex, sizeof(tmphex), \"\\\\U%04lX\", c);\n        if (!io_ch(arg, tmphex, 6))\n            return -1;\n        return 6;\n    }\n    chtmp = (unsigned char)c;\n    if (chtmp \u003e 0x7f)\n        chflgs = flags \u0026 ASN1_STRFLGS_ESC_MSB;\n    else\n        chflgs = char_type[chtmp] \u0026 flags;\n    if (chflgs \u0026 CHARTYPE_BS_ESC) {\n        /* If we don't escape with quotes, signal we need quotes */\n        if (chflgs \u0026 ASN1_STRFLGS_ESC_QUOTE) {\n            if (do_quotes)\n                *do_quotes = 1;\n            if (!io_ch(arg, \u0026chtmp, 1))\n                return -1;\n            return 1;\n        }\n        if (!io_ch(arg, \"\\\\\", 1))\n            return -1;\n        if (!io_ch(arg, \u0026chtmp, 1))\n            return -1;\n        return 2;\n    }\n    if (chflgs \u0026 (ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB)) {\n        BIO_snprintf(tmphex, 11, \"\\\\%02X\", chtmp);\n        if (!io_ch(arg, tmphex, 3))\n            return -1;\n        return 3;\n    }\n    /*\n     * If we get this far and do any escaping at all must escape the escape\n     * character itself: backslash.\n     */\n    if (chtmp == '\\\\' \u0026\u0026 flags \u0026 ESC_FLAGS) {\n        if (!io_ch(arg, \"\\\\\\\\\", 2))\n            return -1;\n        return 2;\n    }\n    if (!io_ch(arg, \u0026chtmp, 1))\n        return -1;\n    return 1;\n}","filepath":"crypto/asn1/a_strex.c","line_number":124,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_0_2p"},"270202720":{"score":0.8991585,"function_name":"do_hex_dump","code":"static int do_hex_dump(char_io *io_ch, void *arg, unsigned char *buf,\n                       int buflen)\n{\n    static const char hexdig[] = \"0123456789ABCDEF\";\n    unsigned char *p, *q;\n    char hextmp[2];\n    if (arg) {\n        p = buf;\n        q = buf + buflen;\n        while (p != q) {\n            hextmp[0] = hexdig[*p \u003e\u003e 4];\n            hextmp[1] = hexdig[*p \u0026 0xf];\n            if (!io_ch(arg, hextmp, 2))\n                return -1;\n            p++;\n        }\n    }\n    return buflen \u003c\u003c 1;\n}","filepath":"crypto/asn1/a_strex.c","line_number":289,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_0_2p"},"270202832":{"score":0.9598024,"function_name":"do_indent","code":"static int do_indent(char_io *io_ch, void *arg, int indent)\n{\n    int i;\n    for (i = 0; i \u003c indent; i++)\n        if (!io_ch(arg, \" \", 1))\n            return 0;\n    return 1;\n}","filepath":"crypto/asn1/a_strex.c","line_number":454,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_0_2p"},"270202896":{"score":0.7069512,"function_name":"do_name_ex","code":"static int do_name_ex(char_io *io_ch, void *arg, X509_NAME *n,\n                      int indent, unsigned long flags)\n{\n    int i, prev = -1, orflags, cnt;\n    int fn_opt, fn_nid;\n    ASN1_OBJECT *fn;\n    ASN1_STRING *val;\n    X509_NAME_ENTRY *ent;\n    char objtmp[80];\n    const char *objbuf;\n    int outlen, len;\n    char *sep_dn, *sep_mv, *sep_eq;\n    int sep_dn_len, sep_mv_len, sep_eq_len;\n    if (indent \u003c 0)\n        indent = 0;\n    outlen = indent;\n    if (!do_indent(io_ch, arg, indent))\n        return -1;\n    switch (flags \u0026 XN_FLAG_SEP_MASK) {\n    case XN_FLAG_SEP_MULTILINE:\n        sep_dn = \"\\n\";\n        sep_dn_len = 1;\n        sep_mv = \" + \";\n        sep_mv_len = 3;\n        break;\n\n    case XN_FLAG_SEP_COMMA_PLUS:\n        sep_dn = \",\";\n        sep_dn_len = 1;\n        sep_mv = \"+\";\n        sep_mv_len = 1;\n        indent = 0;\n        break;\n\n    case XN_FLAG_SEP_CPLUS_SPC:\n        sep_dn = \", \";\n        sep_dn_len = 2;\n        sep_mv = \" + \";\n        sep_mv_len = 3;\n        indent = 0;\n        break;\n\n    case XN_FLAG_SEP_SPLUS_SPC:\n        sep_dn = \"; \";\n        sep_dn_len = 2;\n        sep_mv = \" + \";\n        sep_mv_len = 3;\n        indent = 0;\n        break;\n\n    default:\n        return -1;\n    }\n\n    if (flags \u0026 XN_FLAG_SPC_EQ) {\n        sep_eq = \" = \";\n        sep_eq_len = 3;\n    } else {\n        sep_eq = \"=\";\n        sep_eq_len = 1;\n    }\n\n    fn_opt = flags \u0026 XN_FLAG_FN_MASK;\n\n    cnt = X509_NAME_entry_count(n);\n    for (i = 0; i \u003c cnt; i++) {\n        if (flags \u0026 XN_FLAG_DN_REV)\n            ent = X509_NAME_get_entry(n, cnt - i - 1);\n        else\n            ent = X509_NAME_get_entry(n, i);\n        if (prev != -1) {\n            if (prev == ent-\u003eset) {\n                if (!io_ch(arg, sep_mv, sep_mv_len))\n                    return -1;\n                outlen += sep_mv_len;\n            } else {\n                if (!io_ch(arg, sep_dn, sep_dn_len))\n                    return -1;\n                outlen += sep_dn_len;\n                if (!do_indent(io_ch, arg, indent))\n                    return -1;\n                outlen += indent;\n            }\n        }\n        prev = ent-\u003eset;\n        fn = X509_NAME_ENTRY_get_object(ent);\n        val = X509_NAME_ENTRY_get_data(ent);\n        fn_nid = OBJ_obj2nid(fn);\n        if (fn_opt != XN_FLAG_FN_NONE) {\n            int objlen, fld_len;\n            if ((fn_opt == XN_FLAG_FN_OID) || (fn_nid == NID_undef)) {\n                OBJ_obj2txt(objtmp, sizeof(objtmp), fn, 1);\n                fld_len = 0;    /* XXX: what should this be? */\n                objbuf = objtmp;\n            } else {\n                if (fn_opt == XN_FLAG_FN_SN) {\n                    fld_len = FN_WIDTH_SN;\n                    objbuf = OBJ_nid2sn(fn_nid);\n                } else if (fn_opt == XN_FLAG_FN_LN) {\n                    fld_len = FN_WIDTH_LN;\n                    objbuf = OBJ_nid2ln(fn_nid);\n                } else {\n                    fld_len = 0; /* XXX: what should this be? */\n                    objbuf = \"\";\n                }\n            }\n            objlen = strlen(objbuf);\n            if (!io_ch(arg, objbuf, objlen))\n                return -1;\n            if ((objlen \u003c fld_len) \u0026\u0026 (flags \u0026 XN_FLAG_FN_ALIGN)) {\n                if (!do_indent(io_ch, arg, fld_len - objlen))\n                    return -1;\n                outlen += fld_len - objlen;\n            }\n            if (!io_ch(arg, sep_eq, sep_eq_len))\n                return -1;\n            outlen += objlen + sep_eq_len;\n        }\n        /*\n         * If the field name is unknown then fix up the DER dump flag. We\n         * might want to limit this further so it will DER dump on anything\n         * other than a few 'standard' fields.\n         */\n        if ((fn_nid == NID_undef) \u0026\u0026 (flags \u0026 XN_FLAG_DUMP_UNKNOWN_FIELDS))\n            orflags = ASN1_STRFLGS_DUMP_ALL;\n        else\n            orflags = 0;\n\n        len = do_print_ex(io_ch, arg, flags | orflags, val);\n        if (len \u003c 0)\n            return -1;\n        outlen += len;\n    }\n    return outlen;\n}","filepath":"crypto/asn1/a_strex.c","line_number":466,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_0_2p"},"270203792":{"score":0.92860603,"function_name":"do_print_ex","code":"static int do_print_ex(char_io *io_ch, void *arg, unsigned long lflags,\n                       ASN1_STRING *str)\n{\n    int outlen, len;\n    int type;\n    char quotes;\n    unsigned char flags;\n    quotes = 0;\n    /* Keep a copy of escape flags */\n    flags = (unsigned char)(lflags \u0026 ESC_FLAGS);\n\n    type = str-\u003etype;\n\n    outlen = 0;\n\n    if (lflags \u0026 ASN1_STRFLGS_SHOW_TYPE) {\n        const char *tagname;\n        tagname = ASN1_tag2str(type);\n        outlen += strlen(tagname);\n        if (!io_ch(arg, tagname, outlen) || !io_ch(arg, \":\", 1))\n            return -1;\n        outlen++;\n    }\n\n    /* Decide what to do with type, either dump content or display it */\n\n    /* Dump everything */\n    if (lflags \u0026 ASN1_STRFLGS_DUMP_ALL)\n        type = -1;\n    /* Ignore the string type */\n    else if (lflags \u0026 ASN1_STRFLGS_IGNORE_TYPE)\n        type = 1;\n    else {\n        /* Else determine width based on type */\n        if ((type \u003e 0) \u0026\u0026 (type \u003c 31))\n            type = tag2nbyte[type];\n        else\n            type = -1;\n        if ((type == -1) \u0026\u0026 !(lflags \u0026 ASN1_STRFLGS_DUMP_UNKNOWN))\n            type = 1;\n    }\n\n    if (type == -1) {\n        len = do_dump(lflags, io_ch, arg, str);\n        if (len \u003c 0)\n            return -1;\n        outlen += len;\n        return outlen;\n    }\n\n    if (lflags \u0026 ASN1_STRFLGS_UTF8_CONVERT) {\n        /*\n         * Note: if string is UTF8 and we want to convert to UTF8 then we\n         * just interpret it as 1 byte per character to avoid converting\n         * twice.\n         */\n        if (!type)\n            type = 1;\n        else\n            type |= BUF_TYPE_CONVUTF8;\n    }\n\n    len = do_buf(str-\u003edata, str-\u003elength, type, flags, \u0026quotes, io_ch, NULL);\n    if (len \u003c 0)\n        return -1;\n    outlen += len;\n    if (quotes)\n        outlen += 2;\n    if (!arg)\n        return outlen;\n    if (quotes \u0026\u0026 !io_ch(arg, \"\\\"\", 1))\n        return -1;\n    if (do_buf(str-\u003edata, str-\u003elength, type, flags, NULL, io_ch, arg) \u003c 0)\n        return -1;\n    if (quotes \u0026\u0026 !io_ch(arg, \"\\\"\", 1))\n        return -1;\n    return outlen;\n}","filepath":"crypto/asn1/a_strex.c","line_number":373,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_0_2p"},"270208128":{"score":0.92157525,"function_name":"ASIdentifierChoice_canonize","code":"static int ASIdentifierChoice_canonize(ASIdentifierChoice *choice)\n{\n    ASN1_INTEGER *a_max_plus_one = NULL;\n    ASN1_INTEGER *orig;\n    BIGNUM *bn = NULL;\n    int i, ret = 0;\n\n    /*\n     * Nothing to do for empty element or inheritance.\n     */\n    if (choice == NULL || choice-\u003etype == ASIdentifierChoice_inherit)\n        return 1;\n\n    /*\n     * If not a list, or if empty list, it's broken.\n     */\n    if (choice-\u003etype != ASIdentifierChoice_asIdsOrRanges ||\n        sk_ASIdOrRange_num(choice-\u003eu.asIdsOrRanges) == 0) {\n        X509V3err(X509V3_F_ASIDENTIFIERCHOICE_CANONIZE,\n                  X509V3_R_EXTENSION_VALUE_ERROR);\n        return 0;\n    }\n\n    /*\n     * We have a non-empty list.  Sort it.\n     */\n    sk_ASIdOrRange_sort(choice-\u003eu.asIdsOrRanges);\n\n    /*\n     * Now check for errors and suboptimal encoding, rejecting the\n     * former and fixing the latter.\n     */\n    for (i = 0; i \u003c sk_ASIdOrRange_num(choice-\u003eu.asIdsOrRanges) - 1; i++) {\n        ASIdOrRange *a = sk_ASIdOrRange_value(choice-\u003eu.asIdsOrRanges, i);\n        ASIdOrRange *b = sk_ASIdOrRange_value(choice-\u003eu.asIdsOrRanges, i + 1);\n        ASN1_INTEGER *a_min = NULL, *a_max = NULL, *b_min = NULL, *b_max =\n            NULL;\n\n        if (!extract_min_max(a, \u0026a_min, \u0026a_max)\n                || !extract_min_max(b, \u0026b_min, \u0026b_max))\n            goto done;\n\n        /*\n         * Make sure we're properly sorted (paranoia).\n         */\n        if (!ossl_assert(ASN1_INTEGER_cmp(a_min, b_min) \u003c= 0))\n            goto done;\n\n        /*\n         * Punt inverted ranges.\n         */\n        if (ASN1_INTEGER_cmp(a_min, a_max) \u003e 0 ||\n            ASN1_INTEGER_cmp(b_min, b_max) \u003e 0)\n            goto done;\n\n        /*\n         * Check for overlaps.\n         */\n        if (ASN1_INTEGER_cmp(a_max, b_min) \u003e= 0) {\n            X509V3err(X509V3_F_ASIDENTIFIERCHOICE_CANONIZE,\n                      X509V3_R_EXTENSION_VALUE_ERROR);\n            goto done;\n        }\n\n        /*\n         * Calculate a_max + 1 to check for adjacency.\n         */\n        if ((bn == NULL \u0026\u0026 (bn = BN_new()) == NULL) ||\n            ASN1_INTEGER_to_BN(a_max, bn) == NULL ||\n            !BN_add_word(bn, 1)) {\n            X509V3err(X509V3_F_ASIDENTIFIERCHOICE_CANONIZE,\n                      ERR_R_MALLOC_FAILURE);\n            goto done;\n        }\n\n        if ((a_max_plus_one =\n                 BN_to_ASN1_INTEGER(bn, orig = a_max_plus_one)) == NULL) {\n            a_max_plus_one = orig;\n            X509V3err(X509V3_F_ASIDENTIFIERCHOICE_CANONIZE,\n                      ERR_R_MALLOC_FAILURE);\n            goto done;\n        }\n\n        /*\n         * If a and b are adjacent, merge them.\n         */\n        if (ASN1_INTEGER_cmp(a_max_plus_one, b_min) == 0) {\n            ASRange *r;\n            switch (a-\u003etype) {\n            case ASIdOrRange_id:\n                if ((r = OPENSSL_malloc(sizeof(*r))) == NULL) {\n                    X509V3err(X509V3_F_ASIDENTIFIERCHOICE_CANONIZE,\n                              ERR_R_MALLOC_FAILURE);\n                    goto done;\n                }\n                r-\u003emin = a_min;\n                r-\u003emax = b_max;\n                a-\u003etype = ASIdOrRange_range;\n                a-\u003eu.range = r;\n                break;\n            case ASIdOrRange_range:\n                ASN1_INTEGER_free(a-\u003eu.range-\u003emax);\n                a-\u003eu.range-\u003emax = b_max;\n                break;\n            }\n            switch (b-\u003etype) {\n            case ASIdOrRange_id:\n                b-\u003eu.id = NULL;\n                break;\n            case ASIdOrRange_range:\n                b-\u003eu.range-\u003emax = NULL;\n                break;\n            }\n            ASIdOrRange_free(b);\n            (void)sk_ASIdOrRange_delete(choice-\u003eu.asIdsOrRanges, i + 1);\n            i--;\n            continue;\n        }\n    }\n\n    /*\n     * Check for final inverted range.\n     */\n    i = sk_ASIdOrRange_num(choice-\u003eu.asIdsOrRanges) - 1;\n    {\n        ASIdOrRange *a = sk_ASIdOrRange_value(choice-\u003eu.asIdsOrRanges, i);\n        ASN1_INTEGER *a_min, *a_max;\n        if (a != NULL \u0026\u0026 a-\u003etype == ASIdOrRange_range) {\n            if (!extract_min_max(a, \u0026a_min, \u0026a_max)\n                    || ASN1_INTEGER_cmp(a_min, a_max) \u003e 0)\n                goto done;\n        }\n    }\n\n    /* Paranoia */\n    if (!ossl_assert(ASIdentifierChoice_is_canonical(choice)))\n        goto done;\n\n    ret = 1;\n\n done:\n    ASN1_INTEGER_free(a_max_plus_one);\n    BN_free(bn);\n    return ret;\n}","filepath":"crypto/x509v3/v3_asid.c","line_number":358,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1p"},"270208992":{"score":0.9266343,"function_name":"ASIdentifierChoice_is_canonical","code":"static int ASIdentifierChoice_is_canonical(ASIdentifierChoice *choice)\n{\n    ASN1_INTEGER *a_max_plus_one = NULL;\n    ASN1_INTEGER *orig;\n    BIGNUM *bn = NULL;\n    int i, ret = 0;\n\n    /*\n     * Empty element or inheritance is canonical.\n     */\n    if (choice == NULL || choice-\u003etype == ASIdentifierChoice_inherit)\n        return 1;\n\n    /*\n     * If not a list, or if empty list, it's broken.\n     */\n    if (choice-\u003etype != ASIdentifierChoice_asIdsOrRanges ||\n        sk_ASIdOrRange_num(choice-\u003eu.asIdsOrRanges) == 0)\n        return 0;\n\n    /*\n     * It's a list, check it.\n     */\n    for (i = 0; i \u003c sk_ASIdOrRange_num(choice-\u003eu.asIdsOrRanges) - 1; i++) {\n        ASIdOrRange *a = sk_ASIdOrRange_value(choice-\u003eu.asIdsOrRanges, i);\n        ASIdOrRange *b = sk_ASIdOrRange_value(choice-\u003eu.asIdsOrRanges, i + 1);\n        ASN1_INTEGER *a_min = NULL, *a_max = NULL, *b_min = NULL, *b_max =\n            NULL;\n\n        if (!extract_min_max(a, \u0026a_min, \u0026a_max)\n                || !extract_min_max(b, \u0026b_min, \u0026b_max))\n            goto done;\n\n        /*\n         * Punt misordered list, overlapping start, or inverted range.\n         */\n        if (ASN1_INTEGER_cmp(a_min, b_min) \u003e= 0 ||\n            ASN1_INTEGER_cmp(a_min, a_max) \u003e 0 ||\n            ASN1_INTEGER_cmp(b_min, b_max) \u003e 0)\n            goto done;\n\n        /*\n         * Calculate a_max + 1 to check for adjacency.\n         */\n        if ((bn == NULL \u0026\u0026 (bn = BN_new()) == NULL) ||\n            ASN1_INTEGER_to_BN(a_max, bn) == NULL ||\n            !BN_add_word(bn, 1)) {\n            X509V3err(X509V3_F_ASIDENTIFIERCHOICE_IS_CANONICAL,\n                      ERR_R_MALLOC_FAILURE);\n            goto done;\n        }\n\n        if ((a_max_plus_one =\n                BN_to_ASN1_INTEGER(bn, orig = a_max_plus_one)) == NULL) {\n            a_max_plus_one = orig;\n            X509V3err(X509V3_F_ASIDENTIFIERCHOICE_IS_CANONICAL,\n                      ERR_R_MALLOC_FAILURE);\n            goto done;\n        }\n\n        /*\n         * Punt if adjacent or overlapping.\n         */\n        if (ASN1_INTEGER_cmp(a_max_plus_one, b_min) \u003e= 0)\n            goto done;\n    }\n\n    /*\n     * Check for inverted range.\n     */\n    i = sk_ASIdOrRange_num(choice-\u003eu.asIdsOrRanges) - 1;\n    {\n        ASIdOrRange *a = sk_ASIdOrRange_value(choice-\u003eu.asIdsOrRanges, i);\n        ASN1_INTEGER *a_min, *a_max;\n        if (a != NULL \u0026\u0026 a-\u003etype == ASIdOrRange_range) {\n            if (!extract_min_max(a, \u0026a_min, \u0026a_max)\n                    || ASN1_INTEGER_cmp(a_min, a_max) \u003e 0)\n                goto done;\n        }\n    }\n\n    ret = 1;\n\n done:\n    ASN1_INTEGER_free(a_max_plus_one);\n    BN_free(bn);\n    return ret;\n}","filepath":"crypto/x509v3/v3_asid.c","line_number":256,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1p"},"270209600":{"score":0.95396644,"function_name":"extract_min_max","code":"static int extract_min_max(ASIdOrRange *aor,\n                           ASN1_INTEGER **min, ASN1_INTEGER **max)\n{\n    if (!ossl_assert(aor != NULL))\n        return 0;\n    switch (aor-\u003etype) {\n    case ASIdOrRange_id:\n        *min = aor-\u003eu.id;\n        *max = aor-\u003eu.id;\n        return 1;\n    case ASIdOrRange_range:\n        *min = aor-\u003eu.range-\u003emin;\n        *max = aor-\u003eu.range-\u003emax;\n        return 1;\n    }\n\n    return 0;\n}","filepath":"crypto/x509v3/v3_asid.c","line_number":234,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1p"},"270211024":{"score":0.71349406,"function_name":"v2i_ASIdentifiers","code":"static void *v2i_ASIdentifiers(const struct v3_ext_method *method,\n                               struct v3_ext_ctx *ctx,\n                               STACK_OF(CONF_VALUE) *values)\n{\n    ASN1_INTEGER *min = NULL, *max = NULL;\n    ASIdentifiers *asid = NULL;\n    int i;\n\n    if ((asid = ASIdentifiers_new()) == NULL) {\n        X509V3err(X509V3_F_V2I_ASIDENTIFIERS, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    for (i = 0; i \u003c sk_CONF_VALUE_num(values); i++) {\n        CONF_VALUE *val = sk_CONF_VALUE_value(values, i);\n        int i1 = 0, i2 = 0, i3 = 0, is_range = 0, which = 0;\n\n        /*\n         * Figure out whether this is an AS or an RDI.\n         */\n        if (!name_cmp(val-\u003ename, \"AS\")) {\n            which = V3_ASID_ASNUM;\n        } else if (!name_cmp(val-\u003ename, \"RDI\")) {\n            which = V3_ASID_RDI;\n        } else {\n            X509V3err(X509V3_F_V2I_ASIDENTIFIERS,\n                      X509V3_R_EXTENSION_NAME_ERROR);\n            X509V3_conf_err(val);\n            goto err;\n        }\n\n        /*\n         * Handle inheritance.\n         */\n        if (strcmp(val-\u003evalue, \"inherit\") == 0) {\n            if (X509v3_asid_add_inherit(asid, which))\n                continue;\n            X509V3err(X509V3_F_V2I_ASIDENTIFIERS,\n                      X509V3_R_INVALID_INHERITANCE);\n            X509V3_conf_err(val);\n            goto err;\n        }\n\n        /*\n         * Number, range, or mistake, pick it apart and figure out which.\n         */\n        i1 = strspn(val-\u003evalue, \"0123456789\");\n        if (val-\u003evalue[i1] == '\\0') {\n            is_range = 0;\n        } else {\n            is_range = 1;\n            i2 = i1 + strspn(val-\u003evalue + i1, \" \\t\");\n            if (val-\u003evalue[i2] != '-') {\n                X509V3err(X509V3_F_V2I_ASIDENTIFIERS,\n                          X509V3_R_INVALID_ASNUMBER);\n                X509V3_conf_err(val);\n                goto err;\n            }\n            i2++;\n            i2 = i2 + strspn(val-\u003evalue + i2, \" \\t\");\n            i3 = i2 + strspn(val-\u003evalue + i2, \"0123456789\");\n            if (val-\u003evalue[i3] != '\\0') {\n                X509V3err(X509V3_F_V2I_ASIDENTIFIERS,\n                          X509V3_R_INVALID_ASRANGE);\n                X509V3_conf_err(val);\n                goto err;\n            }\n        }\n\n        /*\n         * Syntax is ok, read and add it.\n         */\n        if (!is_range) {\n            if (!X509V3_get_value_int(val, \u0026min)) {\n                X509V3err(X509V3_F_V2I_ASIDENTIFIERS, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n        } else {\n            char *s = OPENSSL_strdup(val-\u003evalue);\n            if (s == NULL) {\n                X509V3err(X509V3_F_V2I_ASIDENTIFIERS, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n            s[i1] = '\\0';\n            min = s2i_ASN1_INTEGER(NULL, s);\n            max = s2i_ASN1_INTEGER(NULL, s + i2);\n            OPENSSL_free(s);\n            if (min == NULL || max == NULL) {\n                X509V3err(X509V3_F_V2I_ASIDENTIFIERS, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n            if (ASN1_INTEGER_cmp(min, max) \u003e 0) {\n                X509V3err(X509V3_F_V2I_ASIDENTIFIERS,\n                          X509V3_R_EXTENSION_VALUE_ERROR);\n                goto err;\n            }\n        }\n        if (!X509v3_asid_add_id_or_range(asid, which, min, max)) {\n            X509V3err(X509V3_F_V2I_ASIDENTIFIERS, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        min = max = NULL;\n    }\n\n    /*\n     * Canonize the result, then we're done.\n     */\n    if (!X509v3_asid_canonize(asid))\n        goto err;\n    return asid;\n\n err:\n    ASIdentifiers_free(asid);\n    ASN1_INTEGER_free(min);\n    ASN1_INTEGER_free(max);\n    return NULL;\n}","filepath":"crypto/x509v3/v3_asid.c","line_number":517,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1p"},"270219248":{"score":0.6381746,"function_name":"X509V3_NAME_from_section","code":"int X509V3_NAME_from_section(X509_NAME *nm, STACK_OF(CONF_VALUE) *dn_sk,\n                             unsigned long chtype)\n{\n    CONF_VALUE *v;\n    int i, mval, spec_char, plus_char;\n    char *p, *type;\n    if (!nm)\n        return 0;\n\n    for (i = 0; i \u003c sk_CONF_VALUE_num(dn_sk); i++) {\n        v = sk_CONF_VALUE_value(dn_sk, i);\n        type = v-\u003ename;\n        /*\n         * Skip past any leading X. X: X, etc to allow for multiple instances\n         */\n        for (p = type; *p; p++) {\n#ifndef CHARSET_EBCDIC\n            spec_char = ((*p == ':') || (*p == ',') || (*p == '.'));\n#else\n            spec_char = ((*p == os_toascii[':']) || (*p == os_toascii[','])\n                    || (*p == os_toascii['.']));\n#endif\n            if (spec_char) {\n                p++;\n                if (*p)\n                    type = p;\n                break;\n            }\n        }\n#ifndef CHARSET_EBCDIC\n        plus_char = (*type == '+');\n#else\n        plus_char = (*type == os_toascii['+']);\n#endif\n        if (plus_char) {\n            mval = -1;\n            type++;\n        }","filepath":"crypto/x509v3/v3_utl.c","line_number":1193,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270219424":{"score":0.91764295,"function_name":"X509V3_add_value","code":"int X509V3_add_value(const char *name, const char *value,\n                     STACK_OF(CONF_VALUE) **extlist)\n{\n    CONF_VALUE *vtmp = NULL;\n    char *tname = NULL, *tvalue = NULL;\n    int sk_allocated = (*extlist == NULL);\n\n    if (name \u0026\u0026 (tname = OPENSSL_strdup(name)) == NULL)\n        goto err;\n    if (value \u0026\u0026 (tvalue = OPENSSL_strdup(value)) == NULL)\n        goto err;\n    if ((vtmp = OPENSSL_malloc(sizeof(*vtmp))) == NULL)\n        goto err;\n    if (sk_allocated \u0026\u0026 (*extlist = sk_CONF_VALUE_new_null()) == NULL)\n        goto err;\n    vtmp-\u003esection = NULL;\n    vtmp-\u003ename = tname;\n    vtmp-\u003evalue = tvalue;\n    if (!sk_CONF_VALUE_push(*extlist, vtmp))\n        goto err;\n    return 1;\n err:\n    X509V3err(X509V3_F_X509V3_ADD_VALUE, ERR_R_MALLOC_FAILURE);\n    if (sk_allocated) {\n        sk_CONF_VALUE_free(*extlist);\n        *extlist = NULL;\n    }\n    OPENSSL_free(vtmp);\n    OPENSSL_free(tname);\n    OPENSSL_free(tvalue);\n    return 0;\n}","filepath":"crypto/x509v3/v3_utl.c","line_number":37,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270219968":{"score":0.63160086,"function_name":"X509V3_get_value_bool","code":"int X509V3_get_value_bool(const CONF_VALUE *value, int *asn1_bool)\n{\n    const char *btmp;\n\n    if ((btmp = value-\u003evalue) == NULL)\n        goto err;\n    if (strcmp(btmp, \"TRUE\") == 0\n        || strcmp(btmp, \"true\") == 0\n        || strcmp(btmp, \"Y\") == 0\n        || strcmp(btmp, \"y\") == 0\n        || strcmp(btmp, \"YES\") == 0\n        || strcmp(btmp, \"yes\") == 0) {\n        *asn1_bool = 0xff;\n        return 1;\n    }\n    if (strcmp(btmp, \"FALSE\") == 0\n        || strcmp(btmp, \"false\") == 0\n        || strcmp(btmp, \"N\") == 0\n        || strcmp(btmp, \"n\") == 0\n        || strcmp(btmp, \"NO\") == 0\n        || strcmp(btmp, \"no\") == 0) {\n        *asn1_bool = 0;\n        return 1;\n    }\n err:\n    X509V3err(X509V3_F_X509V3_GET_VALUE_BOOL,\n              X509V3_R_INVALID_BOOLEAN_STRING);\n    X509V3_conf_err(value);\n    return 0;\n}","filepath":"crypto/x509v3/v3_utl.c","line_number":237,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270220704":{"score":0.5957831,"function_name":"X509V3_get_value_int","code":"int X509V3_get_value_int(const CONF_VALUE *value, ASN1_INTEGER **aint)\n{\n    ASN1_INTEGER *itmp;\n\n    if ((itmp = s2i_ASN1_INTEGER(NULL, value-\u003evalue)) == NULL) {\n        X509V3_conf_err(value);\n        return 0;\n    }\n    *aint = itmp;\n    return 1;\n}","filepath":"crypto/x509v3/v3_utl.c","line_number":268,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270221024":{"score":0.87357694,"function_name":"X509V3_parse_list","code":"STACK_OF(CONF_VALUE) *X509V3_parse_list(const char *line)\n{\n    char *p, *q, c;\n    char *ntmp, *vtmp;\n    STACK_OF(CONF_VALUE) *values = NULL;\n    char *linebuf;\n    int state;\n    /* We are going to modify the line so copy it first */\n    linebuf = OPENSSL_strdup(line);\n    if (linebuf == NULL) {\n        X509V3err(X509V3_F_X509V3_PARSE_LIST, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    state = HDR_NAME;\n    ntmp = NULL;\n    /* Go through all characters */\n    for (p = linebuf, q = linebuf; (c = *p) \u0026\u0026 (c != '\\r') \u0026\u0026 (c != '\\n');\n         p++) {\n\n        switch (state) {\n        case HDR_NAME:\n            if (c == ':') {\n                state = HDR_VALUE;\n                *p = 0;\n                ntmp = strip_spaces(q);\n                if (!ntmp) {\n                    X509V3err(X509V3_F_X509V3_PARSE_LIST,\n                              X509V3_R_INVALID_NULL_NAME);\n                    goto err;\n                }\n                q = p + 1;\n            } else if (c == ',') {\n                *p = 0;\n                ntmp = strip_spaces(q);\n                q = p + 1;\n                if (!ntmp) {\n                    X509V3err(X509V3_F_X509V3_PARSE_LIST,\n                              X509V3_R_INVALID_NULL_NAME);\n                    goto err;\n                }\n                X509V3_add_value(ntmp, NULL, \u0026values);\n            }\n            break;\n\n        case HDR_VALUE:\n            if (c == ',') {\n                state = HDR_NAME;\n                *p = 0;\n                vtmp = strip_spaces(q);\n                if (!vtmp) {\n                    X509V3err(X509V3_F_X509V3_PARSE_LIST,\n                              X509V3_R_INVALID_NULL_VALUE);\n                    goto err;\n                }\n                X509V3_add_value(ntmp, vtmp, \u0026values);\n                ntmp = NULL;\n                q = p + 1;\n            }\n\n        }\n    }\n\n    if (state == HDR_VALUE) {\n        vtmp = strip_spaces(q);\n        if (!vtmp) {\n            X509V3err(X509V3_F_X509V3_PARSE_LIST,\n                      X509V3_R_INVALID_NULL_VALUE);\n            goto err;\n        }\n        X509V3_add_value(ntmp, vtmp, \u0026values);\n    } else {\n        ntmp = strip_spaces(q);\n        if (!ntmp) {\n            X509V3err(X509V3_F_X509V3_PARSE_LIST, X509V3_R_INVALID_NULL_NAME);\n            goto err;\n        }\n        X509V3_add_value(ntmp, NULL, \u0026values);\n    }\n    OPENSSL_free(linebuf);\n    return values;\n\n err:\n    OPENSSL_free(linebuf);\n    sk_CONF_VALUE_pop_free(values, X509V3_conf_free);\n    return NULL;\n\n}","filepath":"crypto/x509v3/v3_utl.c","line_number":287,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270221456":{"score":0.6122407,"function_name":"a2i_IPADDRESS","code":"ASN1_OCTET_STRING *a2i_IPADDRESS(const char *ipasc)\n{\n    unsigned char ipout[16];\n    ASN1_OCTET_STRING *ret;\n    int iplen;\n\n    /* If string contains a ':' assume IPv6 */\n\n    iplen = a2i_ipadd(ipout, ipasc);\n\n    if (!iplen)\n        return NULL;\n\n    ret = ASN1_OCTET_STRING_new();\n    if (ret == NULL)\n        return NULL;\n    if (!ASN1_OCTET_STRING_set(ret, ipout, iplen)) {\n        ASN1_OCTET_STRING_free(ret);\n        return NULL;\n    }\n    return ret;\n}","filepath":"crypto/x509v3/v3_utl.c","line_number":963,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270221584":{"score":0.8303713,"function_name":"a2i_IPADDRESS_NC","code":"ASN1_OCTET_STRING *a2i_IPADDRESS_NC(const char *ipasc)\n{\n    ASN1_OCTET_STRING *ret = NULL;\n    unsigned char ipout[32];\n    char *iptmp = NULL, *p;\n    int iplen1, iplen2;\n    p = strchr(ipasc, '/');\n    if (!p)\n        return NULL;\n    iptmp = OPENSSL_strdup(ipasc);\n    if (!iptmp)\n        return NULL;\n    p = iptmp + (p - ipasc);\n    *p++ = 0;\n\n    iplen1 = a2i_ipadd(ipout, iptmp);\n\n    if (!iplen1)\n        goto err;\n\n    iplen2 = a2i_ipadd(ipout + iplen1, p);\n\n    OPENSSL_free(iptmp);\n    iptmp = NULL;\n\n    if (!iplen2 || (iplen1 != iplen2))\n        goto err;\n\n    ret = ASN1_OCTET_STRING_new();\n    if (ret == NULL)\n        goto err;\n    if (!ASN1_OCTET_STRING_set(ret, ipout, iplen1 + iplen2))\n        goto err;\n\n    return ret;\n\n err:\n    OPENSSL_free(iptmp);\n    ASN1_OCTET_STRING_free(ret);\n    return NULL;\n}","filepath":"crypto/x509v3/v3_utl.c","line_number":986,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270221840":{"score":0.6587615,"function_name":"ipv6_from_asc","code":"static int ipv6_from_asc(unsigned char *v6, const char *in)\n{\n    IPV6_STAT v6stat;\n    v6stat.total = 0;\n    v6stat.zero_pos = -1;\n    v6stat.zero_cnt = 0;\n    /*\n     * Treat the IPv6 representation as a list of values separated by ':'.\n     * The presence of a '::' will parse as one, two or three zero length\n     * elements.\n     */\n    if (!CONF_parse_list(in, ':', 0, ipv6_cb, \u0026v6stat))\n        return 0;\n\n    /* Now for some sanity checks */\n\n    if (v6stat.zero_pos == -1) {\n        /* If no '::' must have exactly 16 bytes */\n        if (v6stat.total != 16)\n            return 0;\n    } else {\n        /* If '::' must have less than 16 bytes */\n        if (v6stat.total == 16)\n            return 0;\n        /* More than three zeroes is an error */\n        if (v6stat.zero_cnt \u003e 3)\n            return 0;\n        /* Can only have three zeroes if nothing else present */\n        else if (v6stat.zero_cnt == 3) {\n            if (v6stat.total \u003e 0)\n                return 0;\n        }\n        /* Can only have two zeroes if at start or end */\n        else if (v6stat.zero_cnt == 2) {\n            if ((v6stat.zero_pos != 0)\n                \u0026\u0026 (v6stat.zero_pos != v6stat.total))\n                return 0;\n        } else\n            /* Can only have one zero if *not* start or end */\n        {\n            if ((v6stat.zero_pos == 0)\n                || (v6stat.zero_pos == v6stat.total))\n                return 0;\n        }\n    }\n\n    /* Format result */\n\n    if (v6stat.zero_pos \u003e= 0) {\n        /* Copy initial part */\n        memcpy(v6, v6stat.tmp, v6stat.zero_pos);\n        /* Zero middle */\n        memset(v6 + v6stat.zero_pos, 0, 16 - v6stat.total);\n        /* Copy final part */\n        if (v6stat.total != v6stat.zero_pos)\n            memcpy(v6 + v6stat.zero_pos + 16 - v6stat.total,\n                   v6stat.tmp + v6stat.zero_pos,\n                   v6stat.total - v6stat.zero_pos);\n    } else\n        memcpy(v6, v6stat.tmp, 16);\n\n    return 1;\n}","filepath":"crypto/x509v3/v3_utl.c","line_number":1069,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270222240":{"score":0.85275847,"function_name":"bignum_to_string","code":"static char *bignum_to_string(const BIGNUM *bn)\n{\n    char *tmp, *ret;\n    size_t len;\n\n    /*\n     * Display large numbers in hex and small numbers in decimal. Converting to\n     * decimal takes quadratic time and is no more useful than hex for large\n     * numbers.\n     */\n    if (BN_num_bits(bn) \u003c 128)\n        return BN_bn2dec(bn);\n\n    tmp = BN_bn2hex(bn);\n    if (tmp == NULL)\n        return NULL;\n\n    len = strlen(tmp) + 3;\n    ret = OPENSSL_malloc(len);\n    if (ret == NULL) {\n        X509V3err(X509V3_F_BIGNUM_TO_STRING, ERR_R_MALLOC_FAILURE);\n        OPENSSL_free(tmp);\n        return NULL;\n    }\n\n    /* Prepend \"0x\", but place it after the \"-\" if negative. */\n    if (tmp[0] == '-') {\n        OPENSSL_strlcpy(ret, \"-0x\", len);\n        OPENSSL_strlcat(ret, tmp + 1, len);\n    } else {\n        OPENSSL_strlcpy(ret, \"0x\", len);\n        OPENSSL_strlcat(ret, tmp, len);\n    }\n    OPENSSL_free(tmp);\n    return ret;\n}","filepath":"crypto/x509v3/v3_utl.c","line_number":104,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270222544":{"score":0.9176418,"function_name":"i2s_ASN1_INTEGER","code":"char *i2s_ASN1_INTEGER(X509V3_EXT_METHOD *method, const ASN1_INTEGER *a)\n{\n    BIGNUM *bntmp = NULL;\n    char *strtmp = NULL;\n\n    if (!a)\n        return NULL;\n    if ((bntmp = ASN1_INTEGER_to_BN(a, NULL)) == NULL\n        || (strtmp = bignum_to_string(bntmp)) == NULL)\n        X509V3err(X509V3_F_I2S_ASN1_INTEGER, ERR_R_MALLOC_FAILURE);\n    BN_free(bntmp);\n    return strtmp;\n}","filepath":"crypto/x509v3/v3_utl.c","line_number":155,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270222640":{"score":0.9623235,"function_name":"ipv4_from_asc","code":"static int ipv4_from_asc(unsigned char *v4, const char *in)\n{\n    int a0, a1, a2, a3;\n    if (sscanf(in, \"%d.%d.%d.%d\", \u0026a0, \u0026a1, \u0026a2, \u0026a3) != 4)\n        return 0;\n    if ((a0 \u003c 0) || (a0 \u003e 255) || (a1 \u003c 0) || (a1 \u003e 255)\n        || (a2 \u003c 0) || (a2 \u003e 255) || (a3 \u003c 0) || (a3 \u003e 255))\n        return 0;\n    v4[0] = a0;\n    v4[1] = a1;\n    v4[2] = a2;\n    v4[3] = a3;\n    return 1;\n}","filepath":"crypto/x509v3/v3_utl.c","line_number":1043,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270222784":{"score":0.8661113,"function_name":"ipv6_cb","code":"static int ipv6_cb(const char *elem, int len, void *usr)\n{\n    IPV6_STAT *s = usr;\n    /* Error if 16 bytes written */\n    if (s-\u003etotal == 16)\n        return 0;\n    if (len == 0) {\n        /* Zero length element, corresponds to '::' */\n        if (s-\u003ezero_pos == -1)\n            s-\u003ezero_pos = s-\u003etotal;\n        /* If we've already got a :: its an error */\n        else if (s-\u003ezero_pos != s-\u003etotal)\n            return 0;\n        s-\u003ezero_cnt++;\n    } else {\n        /* If more than 4 characters could be final a.b.c.d form */\n        if (len \u003e 4) {\n            /* Need at least 4 bytes left */\n            if (s-\u003etotal \u003e 12)\n                return 0;\n            /* Must be end of string */\n            if (elem[len])\n                return 0;\n            if (!ipv4_from_asc(s-\u003etmp + s-\u003etotal, elem))\n                return 0;\n            s-\u003etotal += 4;\n        } else {\n            if (!ipv6_hex(s-\u003etmp + s-\u003etotal, elem, len))\n                return 0;\n            s-\u003etotal += 2;\n        }\n    }\n    return 1;\n}","filepath":"crypto/x509v3/v3_utl.c","line_number":1133,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270223008":{"score":0.87785876,"function_name":"name_cmp","code":"int name_cmp(const char *name, const char *cmp)\n{\n    int len, ret;\n    char c;\n    len = strlen(cmp);\n    if ((ret = strncmp(name, cmp, len)))\n        return ret;\n    c = name[len];\n    if (!c || (c == '.'))\n        return 0;\n    return 1;\n}","filepath":"crypto/x509v3/v3_utl.c","line_number":400,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270223088":{"score":0.92617303,"function_name":"s2i_ASN1_INTEGER","code":"ASN1_INTEGER *s2i_ASN1_INTEGER(X509V3_EXT_METHOD *method, const char *value)\n{\n    BIGNUM *bn = NULL;\n    ASN1_INTEGER *aint;\n    int isneg, ishex;\n    int ret;\n    if (value == NULL) {\n        X509V3err(X509V3_F_S2I_ASN1_INTEGER, X509V3_R_INVALID_NULL_VALUE);\n        return NULL;\n    }\n    bn = BN_new();\n    if (bn == NULL) {\n        X509V3err(X509V3_F_S2I_ASN1_INTEGER, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    if (value[0] == '-') {\n        value++;\n        isneg = 1;\n    } else\n        isneg = 0;\n\n    if (value[0] == '0' \u0026\u0026 ((value[1] == 'x') || (value[1] == 'X'))) {\n        value += 2;\n        ishex = 1;\n    } else\n        ishex = 0;\n\n    if (ishex)\n        ret = BN_hex2bn(\u0026bn, value);\n    else\n        ret = BN_dec2bn(\u0026bn, value);\n\n    if (!ret || value[ret]) {\n        BN_free(bn);\n        X509V3err(X509V3_F_S2I_ASN1_INTEGER, X509V3_R_BN_DEC2BN_ERROR);\n        return NULL;\n    }\n\n    if (isneg \u0026\u0026 BN_is_zero(bn))\n        isneg = 0;\n\n    aint = BN_to_ASN1_INTEGER(bn, NULL);\n    BN_free(bn);\n    if (!aint) {\n        X509V3err(X509V3_F_S2I_ASN1_INTEGER,\n                  X509V3_R_BN_TO_ASN1_INTEGER_ERROR);\n        return NULL;\n    }\n    if (isneg)\n        aint-\u003etype |= V_ASN1_NEG;\n    return aint;\n}","filepath":"crypto/x509v3/v3_utl.c","line_number":169,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270223408":{"score":0.88907856,"function_name":"strip_spaces","code":"static char *strip_spaces(char *name)\n{\n    char *p, *q;\n    /* Skip over leading spaces */\n    p = name;\n    while (*p \u0026\u0026 ossl_isspace(*p))\n        p++;\n    if (!*p)\n        return NULL;\n    q = p + strlen(p) - 1;\n    while ((q != p) \u0026\u0026 ossl_isspace(*q))\n        q--;\n    if (p != q)\n        q[1] = 0;\n    if (!*p)\n        return NULL;\n    return p;\n}","filepath":"crypto/x509v3/v3_utl.c","line_number":376,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270225120":{"score":0.89274985,"function_name":"enc_write","code":"static int enc_write(BIO *b, const char *in, int inl)\n{\n    int ret = 0, n, i;\n    BIO_ENC_CTX *ctx;\n    BIO *next;\n\n    ctx = BIO_get_data(b);\n    next = BIO_next(b);\n    if ((ctx == NULL) || (next == NULL))\n        return 0;\n\n    ret = inl;\n\n    BIO_clear_retry_flags(b);\n    n = ctx-\u003ebuf_len - ctx-\u003ebuf_off;\n    while (n \u003e 0) {\n        i = BIO_write(next, \u0026(ctx-\u003ebuf[ctx-\u003ebuf_off]), n);\n        if (i \u003c= 0) {\n            BIO_copy_next_retry(b);\n            return i;\n        }\n        ctx-\u003ebuf_off += i;\n        n -= i;\n    }\n    /* at this point all pending data has been written */\n\n    if ((in == NULL) || (inl \u003c= 0))\n        return 0;\n\n    ctx-\u003ebuf_off = 0;\n    while (inl \u003e 0) {\n        n = (inl \u003e ENC_BLOCK_SIZE) ? ENC_BLOCK_SIZE : inl;\n        if (!EVP_CipherUpdate(ctx-\u003ecipher,\n                              ctx-\u003ebuf, \u0026ctx-\u003ebuf_len,\n                              (const unsigned char *)in, n)) {\n            BIO_clear_retry_flags(b);\n            ctx-\u003eok = 0;\n            return 0;\n        }\n        inl -= n;\n        in += n;\n\n        ctx-\u003ebuf_off = 0;\n        n = ctx-\u003ebuf_len;\n        while (n \u003e 0) {\n            i = BIO_write(next, \u0026(ctx-\u003ebuf[ctx-\u003ebuf_off]), n);\n            if (i \u003c= 0) {\n                BIO_copy_next_retry(b);\n                return (ret == inl) ? i : ret - inl;\n            }\n            n -= i;\n            ctx-\u003ebuf_off += i;\n        }\n        ctx-\u003ebuf_len = 0;\n        ctx-\u003ebuf_off = 0;\n    }\n    BIO_copy_next_retry(b);\n    return ret;\n}","filepath":"crypto/evp/bio_enc.c","line_number":234,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"270225536":{"score":0.84926236,"function_name":"enc_read","code":"static int enc_read(BIO *b, char *out, int outl)\n{\n    int ret = 0, i, blocksize;\n    BIO_ENC_CTX *ctx;\n    BIO *next;\n\n    if (out == NULL)\n        return 0;\n    ctx = BIO_get_data(b);\n\n    next = BIO_next(b);\n    if ((ctx == NULL) || (next == NULL))\n        return 0;\n\n    /* First check if there are bytes decoded/encoded */\n    if (ctx-\u003ebuf_len \u003e 0) {\n        i = ctx-\u003ebuf_len - ctx-\u003ebuf_off;\n        if (i \u003e outl)\n            i = outl;\n        memcpy(out, \u0026(ctx-\u003ebuf[ctx-\u003ebuf_off]), i);\n        ret = i;\n        out += i;\n        outl -= i;\n        ctx-\u003ebuf_off += i;\n        if (ctx-\u003ebuf_len == ctx-\u003ebuf_off) {\n            ctx-\u003ebuf_len = 0;\n            ctx-\u003ebuf_off = 0;\n        }\n    }\n\n    blocksize = EVP_CIPHER_CTX_block_size(ctx-\u003ecipher);\n    if (blocksize == 1)\n        blocksize = 0;\n\n    /*\n     * At this point, we have room of outl bytes and an empty buffer, so we\n     * should read in some more.\n     */\n\n    while (outl \u003e 0) {\n        if (ctx-\u003econt \u003c= 0)\n            break;\n\n        if (ctx-\u003eread_start == ctx-\u003eread_end) { /* time to read more data */\n            ctx-\u003eread_end = ctx-\u003eread_start = \u0026(ctx-\u003ebuf[BUF_OFFSET]);\n            i = BIO_read(next, ctx-\u003eread_start, ENC_BLOCK_SIZE);\n            if (i \u003e 0)\n                ctx-\u003eread_end += i;\n        } else {\n            i = ctx-\u003eread_end - ctx-\u003eread_start;\n        }\n\n        if (i \u003c= 0) {\n            /* Should be continue next time we are called? */\n            if (!BIO_should_retry(next)) {\n                ctx-\u003econt = i;\n                i = EVP_CipherFinal_ex(ctx-\u003ecipher,\n                                       ctx-\u003ebuf, \u0026(ctx-\u003ebuf_len));\n                ctx-\u003eok = i;\n                ctx-\u003ebuf_off = 0;\n            } else {\n                ret = (ret == 0) ? i : ret;\n                break;\n            }\n        } else {\n            if (outl \u003e ENC_MIN_CHUNK) {\n                /*\n                 * Depending on flags block cipher decrypt can write\n                 * one extra block and then back off, i.e. output buffer\n                 * has to accommodate extra block...\n                 */\n                int j = outl - blocksize, buf_len;\n\n                if (!EVP_CipherUpdate(ctx-\u003ecipher,\n                                      (unsigned char *)out, \u0026buf_len,\n                                      ctx-\u003eread_start, i \u003e j ? j : i)) {\n                    BIO_clear_retry_flags(b);\n                    return 0;\n                }\n                ret += buf_len;\n                out += buf_len;\n                outl -= buf_len;\n\n                if ((i -= j) \u003c= 0) {\n                    ctx-\u003eread_start = ctx-\u003eread_end;\n                    continue;\n                }\n                ctx-\u003eread_start += j;\n            }\n            if (i \u003e ENC_MIN_CHUNK)\n                i = ENC_MIN_CHUNK;\n            if (!EVP_CipherUpdate(ctx-\u003ecipher,\n                                  ctx-\u003ebuf, \u0026ctx-\u003ebuf_len,\n                                  ctx-\u003eread_start, i)) {\n                BIO_clear_retry_flags(b);\n                ctx-\u003eok = 0;\n                return 0;\n            }\n            ctx-\u003eread_start += i;\n            ctx-\u003econt = 1;\n            /*\n             * Note: it is possible for EVP_CipherUpdate to decrypt zero\n             * bytes because this is or looks like the final block: if this\n             * happens we should retry and either read more data or decrypt\n             * the final block\n             */\n            if (ctx-\u003ebuf_len == 0)\n                continue;\n        }\n\n        if (ctx-\u003ebuf_len \u003c= outl)\n            i = ctx-\u003ebuf_len;\n        else\n            i = outl;\n        if (i \u003c= 0)\n            break;\n        memcpy(out, ctx-\u003ebuf, i);\n        ret += i;\n        ctx-\u003ebuf_off = i;\n        outl -= i;\n        out += i;\n    }\n\n    BIO_clear_retry_flags(b);\n    BIO_copy_next_retry(b);\n    return ((ret == 0) ? ctx-\u003econt : ret);\n}","filepath":"crypto/evp/bio_enc.c","line_number":106,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"270226144":{"score":0.9135521,"function_name":"enc_ctrl","code":"static long enc_ctrl(BIO *b, int cmd, long num, void *ptr)\n{\n    BIO *dbio;\n    BIO_ENC_CTX *ctx, *dctx;\n    long ret = 1;\n    int i;\n    EVP_CIPHER_CTX **c_ctx;\n    BIO *next;\n\n    ctx = BIO_get_data(b);\n    next = BIO_next(b);\n    if (ctx == NULL)\n        return 0;\n\n    switch (cmd) {\n    case BIO_CTRL_RESET:\n        ctx-\u003eok = 1;\n        ctx-\u003efinished = 0;\n        if (!EVP_CipherInit_ex(ctx-\u003ecipher, NULL, NULL, NULL, NULL,\n                               EVP_CIPHER_CTX_encrypting(ctx-\u003ecipher)))\n            return 0;\n        ret = BIO_ctrl(next, cmd, num, ptr);\n        break;\n    case BIO_CTRL_EOF:         /* More to read */\n        if (ctx-\u003econt \u003c= 0)\n            ret = 1;\n        else\n            ret = BIO_ctrl(next, cmd, num, ptr);\n        break;\n    case BIO_CTRL_WPENDING:\n        ret = ctx-\u003ebuf_len - ctx-\u003ebuf_off;\n        if (ret \u003c= 0)\n            ret = BIO_ctrl(next, cmd, num, ptr);\n        break;\n    case BIO_CTRL_PENDING:     /* More to read in buffer */\n        ret = ctx-\u003ebuf_len - ctx-\u003ebuf_off;\n        if (ret \u003c= 0)\n            ret = BIO_ctrl(next, cmd, num, ptr);\n        break;\n    case BIO_CTRL_FLUSH:\n        /* do a final write */\n again:\n        while (ctx-\u003ebuf_len != ctx-\u003ebuf_off) {\n            i = enc_write(b, NULL, 0);\n            if (i \u003c 0)\n                return i;\n        }\n\n        if (!ctx-\u003efinished) {\n            ctx-\u003efinished = 1;\n            ctx-\u003ebuf_off = 0;\n            ret = EVP_CipherFinal_ex(ctx-\u003ecipher,\n                                     (unsigned char *)ctx-\u003ebuf,\n                                     \u0026(ctx-\u003ebuf_len));\n            ctx-\u003eok = (int)ret;\n            if (ret \u003c= 0)\n                break;\n\n            /* push out the bytes */\n            goto again;\n        }\n\n        /* Finally flush the underlying BIO */\n        ret = BIO_ctrl(next, cmd, num, ptr);\n        break;\n    case BIO_C_GET_CIPHER_STATUS:\n        ret = (long)ctx-\u003eok;\n        break;\n    case BIO_C_DO_STATE_MACHINE:\n        BIO_clear_retry_flags(b);\n        ret = BIO_ctrl(next, cmd, num, ptr);\n        BIO_copy_next_retry(b);\n        break;\n    case BIO_C_GET_CIPHER_CTX:\n        c_ctx = (EVP_CIPHER_CTX **)ptr;\n        *c_ctx = ctx-\u003ecipher;\n        BIO_set_init(b, 1);\n        break;\n    case BIO_CTRL_DUP:\n        dbio = (BIO *)ptr;\n        dctx = BIO_get_data(dbio);\n        dctx-\u003ecipher = EVP_CIPHER_CTX_new();\n        if (dctx-\u003ecipher == NULL)\n            return 0;\n        ret = EVP_CIPHER_CTX_copy(dctx-\u003ecipher, ctx-\u003ecipher);\n        if (ret)\n            BIO_set_init(dbio, 1);\n        break;\n    default:\n        ret = BIO_ctrl(next, cmd, num, ptr);\n        break;\n    }\n    return ret;\n}","filepath":"crypto/evp/bio_enc.c","line_number":294,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha9"},"270227024":{"score":0.6688185,"function_name":"EVP_PKEY_derive","code":"int EVP_PKEY_derive(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *pkeylen)\n{\n    if (!ctx || !ctx-\u003epmeth || !ctx-\u003epmeth-\u003ederive) {\n        EVPerr(EVP_F_EVP_PKEY_DERIVE,\n               EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\n        return -2;\n    }\n    if (ctx-\u003eoperation != EVP_PKEY_OP_DERIVE) {\n        EVPerr(EVP_F_EVP_PKEY_DERIVE, EVP_R_OPERATON_NOT_INITIALIZED);\n        return -1;\n    }\n    M_check_autoarg(ctx, key, pkeylen, EVP_F_EVP_PKEY_DERIVE)\n        return ctx-\u003epmeth-\u003ederive(ctx, key, pkeylen);\n}","filepath":"crypto/evp/pmeth_fn.c","line_number":284,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre1"},"270227264":{"score":0.91825527,"function_name":"EVP_PKEY_derive_set_peer","code":"int EVP_PKEY_derive_set_peer(EVP_PKEY_CTX *ctx, EVP_PKEY *peer)\n{\n    int ret;\n    if (!ctx || !ctx-\u003epmeth\n        || !(ctx-\u003epmeth-\u003ederive || ctx-\u003epmeth-\u003eencrypt || ctx-\u003epmeth-\u003edecrypt)\n        || !ctx-\u003epmeth-\u003ectrl) {\n        EVPerr(EVP_F_EVP_PKEY_DERIVE_SET_PEER,\n               EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\n        return -2;\n    }\n    if (ctx-\u003eoperation != EVP_PKEY_OP_DERIVE\n        \u0026\u0026 ctx-\u003eoperation != EVP_PKEY_OP_ENCRYPT\n        \u0026\u0026 ctx-\u003eoperation != EVP_PKEY_OP_DECRYPT) {\n        EVPerr(EVP_F_EVP_PKEY_DERIVE_SET_PEER,\n               EVP_R_OPERATON_NOT_INITIALIZED);\n        return -1;\n    }\n\n    ret = ctx-\u003epmeth-\u003ectrl(ctx, EVP_PKEY_CTRL_PEER_KEY, 0, peer);\n\n    if (ret \u003c= 0)\n        return ret;\n\n    if (ret == 2)\n        return 1;\n\n    if (!ctx-\u003epkey) {\n        EVPerr(EVP_F_EVP_PKEY_DERIVE_SET_PEER, EVP_R_NO_KEY_SET);\n        return -1;\n    }\n\n    if (ctx-\u003epkey-\u003etype != peer-\u003etype) {\n        EVPerr(EVP_F_EVP_PKEY_DERIVE_SET_PEER, EVP_R_DIFFERENT_KEY_TYPES);\n        return -1;\n    }\n\n    /*\n     * For clarity.  The error is if parameters in peer are\n     * present (!missing) but don't match.  EVP_PKEY_cmp_parameters may return\n     * 1 (match), 0 (don't match) and -2 (comparison is not defined).  -1\n     * (different key types) is impossible here because it is checked earlier.\n     * -2 is OK for us here, as well as 1, so we can check for 0 only.\n     */\n    if (!EVP_PKEY_missing_parameters(peer) \u0026\u0026\n        !EVP_PKEY_cmp_parameters(ctx-\u003epkey, peer)) {\n        EVPerr(EVP_F_EVP_PKEY_DERIVE_SET_PEER, EVP_R_DIFFERENT_PARAMETERS);\n        return -1;\n    }\n\n    EVP_PKEY_free(ctx-\u003epeerkey);\n    ctx-\u003epeerkey = peer;\n\n    ret = ctx-\u003epmeth-\u003ectrl(ctx, EVP_PKEY_CTRL_PEER_KEY, 1, peer);\n\n    if (ret \u003c= 0) {\n        ctx-\u003epeerkey = NULL;\n        return ret;\n    }\n\n    EVP_PKEY_up_ref(peer);\n    return 1;\n}","filepath":"crypto/evp/pmeth_fn.c","line_number":221,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre1"},"270227872":{"score":0.91122055,"function_name":"EVP_PKEY_encrypt_init","code":"int EVP_PKEY_encrypt_init(EVP_PKEY_CTX *ctx)\n{\n    int ret;\n    if (!ctx || !ctx-\u003epmeth || !ctx-\u003epmeth-\u003eencrypt) {\n        EVPerr(EVP_F_EVP_PKEY_ENCRYPT_INIT,\n               EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\n        return -2;\n    }\n    ctx-\u003eoperation = EVP_PKEY_OP_ENCRYPT;\n    if (!ctx-\u003epmeth-\u003eencrypt_init)\n        return 1;\n    ret = ctx-\u003epmeth-\u003eencrypt_init(ctx);\n    if (ret \u003c= 0)\n        ctx-\u003eoperation = EVP_PKEY_OP_UNDEFINED;\n    return ret;\n}","filepath":"crypto/evp/pmeth_fn.c","line_number":136,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre1"},"270227984":{"score":0.7367418,"function_name":"EVP_PKEY_encrypt","code":"int EVP_PKEY_encrypt(EVP_PKEY_CTX *ctx,\n                     unsigned char *out, size_t *outlen,\n                     const unsigned char *in, size_t inlen)\n{\n    if (!ctx || !ctx-\u003epmeth || !ctx-\u003epmeth-\u003eencrypt) {\n        EVPerr(EVP_F_EVP_PKEY_ENCRYPT,\n               EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\n        return -2;\n    }\n    if (ctx-\u003eoperation != EVP_PKEY_OP_ENCRYPT) {\n        EVPerr(EVP_F_EVP_PKEY_ENCRYPT, EVP_R_OPERATON_NOT_INITIALIZED);\n        return -1;\n    }\n    M_check_autoarg(ctx, out, outlen, EVP_F_EVP_PKEY_ENCRYPT)\n        return ctx-\u003epmeth-\u003eencrypt(ctx, out, outlen, in, inlen);\n}","filepath":"crypto/evp/pmeth_fn.c","line_number":153,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre1"},"270228320":{"score":0.8830581,"function_name":"EVP_PKEY_verify","code":"int EVP_PKEY_verify(EVP_PKEY_CTX *ctx,\n                    const unsigned char *sig, size_t siglen,\n                    const unsigned char *tbs, size_t tbslen)\n{\n    if (!ctx || !ctx-\u003epmeth || !ctx-\u003epmeth-\u003everify) {\n        EVPerr(EVP_F_EVP_PKEY_VERIFY,\n               EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\n        return -2;\n    }\n    if (ctx-\u003eoperation != EVP_PKEY_OP_VERIFY) {\n        EVPerr(EVP_F_EVP_PKEY_VERIFY, EVP_R_OPERATON_NOT_INITIALIZED);\n        return -1;\n    }\n    return ctx-\u003epmeth-\u003everify(ctx, sig, siglen, tbs, tbslen);\n}","filepath":"crypto/evp/pmeth_fn.c","line_number":86,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre1"},"270229760":{"score":0.7012871,"function_name":"OPENSSL_gmtime","code":"struct tm *OPENSSL_gmtime(const time_t *timer, struct tm *result)\n{\n    struct tm *ts = NULL;\n\n#if defined(OPENSSL_THREADS) \u0026\u0026 defined(OPENSSL_SYS_VMS)\n    {\n        /*\n         * On VMS, gmtime_r() takes a 32-bit pointer as second argument.\n         * Since we can't know that |result| is in a space that can easily\n         * translate to a 32-bit pointer, we must store temporarly on stack\n         * and copy the result.  The stack is always reachable with 32-bit\n         * pointers.\n         */\n#if defined(OPENSSL_SYS_VMS) \u0026\u0026 __INITIAL_POINTER_SIZE\n# pragma pointer_size save\n# pragma pointer_size 32\n#endif\n        struct tm data, *ts2 = \u0026data;\n#if defined OPENSSL_SYS_VMS \u0026\u0026 __INITIAL_POINTER_SIZE\n# pragma pointer_size restore\n#endif\n        if (gmtime_r(timer, ts2) == NULL)\n            return NULL;\n        memcpy(result, ts2, sizeof(struct tm));\n        ts = result;\n    }\n#elif defined(OPENSSL_THREADS) \u0026\u0026 !defined(OPENSSL_SYS_WIN32) \u0026\u0026 !defined(OPENSSL_SYS_MACOSX)\n    if (gmtime_r(timer, result) == NULL)\n        return NULL;\n    ts = result;\n#else\n    ts = gmtime(timer);\n    if (ts == NULL)\n        return NULL;\n\n    memcpy(result, ts, sizeof(struct tm));\n    ts = result;\n#endif\n    return ts;\n}","filepath":"crypto/o_time.c","line_number":14,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0f"},"270229792":{"score":0.84532875,"function_name":"OPENSSL_gmtime_adj","code":"int OPENSSL_gmtime_adj(struct tm *tm, int off_day, long offset_sec)\n{\n    int time_sec, time_year, time_month, time_day;\n    long time_jd;\n\n    /* Convert time and offset into Julian day and seconds */\n    if (!julian_adj(tm, off_day, offset_sec, \u0026time_jd, \u0026time_sec))\n        return 0;\n\n    /* Convert Julian day back to date */\n\n    julian_to_date(time_jd, \u0026time_year, \u0026time_month, \u0026time_day);\n\n    if (time_year \u003c 1900 || time_year \u003e 9999)\n        return 0;\n\n    /* Update tm structure */\n\n    tm-\u003etm_year = time_year - 1900;\n    tm-\u003etm_mon = time_month - 1;\n    tm-\u003etm_mday = time_day;\n\n    tm-\u003etm_hour = time_sec / 3600;\n    tm-\u003etm_min = (time_sec / 60) % 60;\n    tm-\u003etm_sec = time_sec % 60;\n\n    return 1;\n\n}","filepath":"crypto/o_time.c","line_number":68,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0f"},"270230176":{"score":0.93699706,"function_name":"julian_adj","code":"static int julian_adj(const struct tm *tm, int off_day, long offset_sec,\n                      long *pday, int *psec)\n{\n    int offset_hms, offset_day;\n    long time_jd;\n    int time_year, time_month, time_day;\n    /* split offset into days and day seconds */\n    offset_day = offset_sec / SECS_PER_DAY;\n    /* Avoid sign issues with % operator */\n    offset_hms = offset_sec - (offset_day * SECS_PER_DAY);\n    offset_day += off_day;\n    /* Add current time seconds to offset */\n    offset_hms += tm-\u003etm_hour * 3600 + tm-\u003etm_min * 60 + tm-\u003etm_sec;\n    /* Adjust day seconds if overflow */\n    if (offset_hms \u003e= SECS_PER_DAY) {\n        offset_day++;\n        offset_hms -= SECS_PER_DAY;\n    } else if (offset_hms \u003c 0) {\n        offset_day--;\n        offset_hms += SECS_PER_DAY;\n    }\n\n    /*\n     * Convert date of time structure into a Julian day number.\n     */\n\n    time_year = tm-\u003etm_year + 1900;\n    time_month = tm-\u003etm_mon + 1;\n    time_day = tm-\u003etm_mday;\n\n    time_jd = date_to_julian(time_year, time_month, time_day);\n\n    /* Work out Julian day of new date */\n    time_jd += offset_day;\n\n    if (time_jd \u003c 0)\n        return 0;\n\n    *pday = time_jd;\n    *psec = offset_hms;\n    return 1;\n}","filepath":"crypto/o_time.c","line_number":129,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0f"},"270235856":{"score":0.7579919,"function_name":"X509V3_EXT_d2i","code":"void *X509V3_EXT_d2i(X509_EXTENSION *ext)\n{\n    const X509V3_EXT_METHOD *method;\n    const unsigned char *p;\n    ASN1_STRING *extvalue;\n    int extlen;\n\n    if ((method = X509V3_EXT_get(ext)) == NULL)\n        return NULL;\n    extvalue = X509_EXTENSION_get_data(ext);\n    p = ASN1_STRING_get0_data(extvalue);\n    extlen = ASN1_STRING_length(extvalue);\n    if (method-\u003eit)\n        return ASN1_item_d2i(NULL, \u0026p, extlen, ASN1_ITEM_ptr(method-\u003eit));\n    return method-\u003ed2i(NULL, \u0026p, extlen);\n}","filepath":"crypto/x509/v3_lib.c","line_number":129,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha7"},"270236000":{"score":0.8633058,"function_name":"X509V3_EXT_get_nid","code":"const X509V3_EXT_METHOD *X509V3_EXT_get_nid(int nid)\n{\n    X509V3_EXT_METHOD tmp;\n    const X509V3_EXT_METHOD *t = \u0026tmp, *const *ret;\n    int idx;\n\n    if (nid \u003c 0)\n        return NULL;\n    tmp.ext_nid = nid;\n    ret = OBJ_bsearch_ext(\u0026t, standard_exts, STANDARD_EXTENSION_COUNT);\n    if (ret)\n        return *ret;\n    if (!ext_list)\n        return NULL;\n    idx = sk_X509V3_EXT_METHOD_find(ext_list, \u0026tmp);\n    return sk_X509V3_EXT_METHOD_value(ext_list, idx);\n}","filepath":"crypto/x509/v3_lib.c","line_number":52,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha7"},"270236112":{"score":0.8236495,"function_name":"X509V3_get_d2i","code":"void *X509V3_get_d2i(const STACK_OF(X509_EXTENSION) *x, int nid, int *crit,\n                     int *idx)\n{\n    int lastpos, i;\n    X509_EXTENSION *ex, *found_ex = NULL;\n\n    if (!x) {\n        if (idx)\n            *idx = -1;\n        if (crit)\n            *crit = -1;\n        return NULL;\n    }\n    if (idx)\n        lastpos = *idx + 1;\n    else\n        lastpos = 0;\n    if (lastpos \u003c 0)\n        lastpos = 0;\n    for (i = lastpos; i \u003c sk_X509_EXTENSION_num(x); i++) {\n        ex = sk_X509_EXTENSION_value(x, i);\n        if (OBJ_obj2nid(X509_EXTENSION_get_object(ex)) == nid) {\n            if (idx) {\n                *idx = i;\n                found_ex = ex;\n                break;\n            } else if (found_ex) {\n                /* Found more than one */\n                if (crit)\n                    *crit = -2;\n                return NULL;\n            }\n            found_ex = ex;\n        }\n    }\n    if (found_ex) {\n        /* Found it */\n        if (crit)\n            *crit = X509_EXTENSION_get_critical(found_ex);\n        return X509V3_EXT_d2i(found_ex);\n    }\n\n    /* Extension not found */\n    if (idx)\n        *idx = -1;\n    if (crit)\n        *crit = -1;\n    return NULL;\n}","filepath":"crypto/x509/v3_lib.c","line_number":162,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha7"},"270236832":{"score":0.91241443,"function_name":"X509_NAME_add_entry","code":"int X509_NAME_add_entry(X509_NAME *name, X509_NAME_ENTRY *ne, int loc,\n\t     int set)\n\t{\n\tX509_NAME_ENTRY *new_name=NULL;\n\tint n,i,inc;\n\tSTACK_OF(X509_NAME_ENTRY) *sk;\n\n\tif (name == NULL) return(0);\n\tsk=name-\u003eentries;\n\tn=sk_X509_NAME_ENTRY_num(sk);\n\tif (loc \u003e n) loc=n;\n\telse if (loc \u003c 0) loc=n;\n\n\tname-\u003emodified=1;\n\n\tif (set == -1)\n\t\t{\n\t\tif (loc == 0)\n\t\t\t{\n\t\t\tset=0;\n\t\t\tinc=1;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tset=sk_X509_NAME_ENTRY_value(sk,loc-1)-\u003eset;\n\t\t\tinc=0;\n\t\t\t}\n\t\t}\n\telse /* if (set \u003e= 0) */\n\t\t{\n\t\tif (loc \u003e= n)\n\t\t\t{\n\t\t\tif (loc != 0)\n\t\t\t\tset=sk_X509_NAME_ENTRY_value(sk,loc-1)-\u003eset+1;\n\t\t\telse\n\t\t\t\tset=0;\n\t\t\t}\n\t\telse\n\t\t\tset=sk_X509_NAME_ENTRY_value(sk,loc)-\u003eset;\n\t\tinc=(set == 0)?1:0;\n\t\t}\n\n\tif ((new_name=X509_NAME_ENTRY_dup(ne)) == NULL)\n\t\tgoto err;\n\tnew_name-\u003eset=set;\n\tif (!sk_X509_NAME_ENTRY_insert(sk,new_name,loc))\n\t\t{\n\t\tX509err(X509_F_X509_NAME_ADD_ENTRY,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\tif (inc)\n\t\t{\n\t\tn=sk_X509_NAME_ENTRY_num(sk);\n\t\tfor (i=loc+1; i\u003cn; i++)\n\t\t\tsk_X509_NAME_ENTRY_value(sk,i-1)-\u003eset+=1;\n\t\t}\t\n\treturn(1);\nerr:\n\tif (new_name != NULL)\n\t\tX509_NAME_ENTRY_free(new_name);\n\treturn(0);\n\t}","filepath":"crypto/x509/x509name.c","line_number":214,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_0_9_8-pre-auto-reformat"},"270237104":{"score":0.8450904,"function_name":"X509_NAME_ENTRY_create_by_txt","code":"X509_NAME_ENTRY *X509_NAME_ENTRY_create_by_txt(X509_NAME_ENTRY **ne,\n\t\tconst char *field, int type, const unsigned char *bytes, int len)\n\t{\n\tASN1_OBJECT *obj;\n\tX509_NAME_ENTRY *nentry;\n\n\tobj=OBJ_txt2obj(field, 0);\n\tif (obj == NULL)\n\t\t{\n\t\tX509err(X509_F_X509_NAME_ENTRY_CREATE_BY_TXT,\n\t\t\t\t\t\tX509_R_INVALID_FIELD_NAME);\n\t\tERR_add_error_data(2, \"name=\", field);\n\t\treturn(NULL);\n\t\t}\n\tnentry = X509_NAME_ENTRY_create_by_OBJ(ne,obj,type,bytes,len);\n\tASN1_OBJECT_free(obj);\n\treturn nentry;\n\t}","filepath":"crypto/x509/x509name.c","line_number":277,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_0_9_8-pre-auto-reformat"},"270237264":{"score":0.9299629,"function_name":"X509_NAME_delete_entry","code":"X509_NAME_ENTRY *X509_NAME_delete_entry(X509_NAME *name, int loc)\n\t{\n\tX509_NAME_ENTRY *ret;\n\tint i,n,set_prev,set_next;\n\tSTACK_OF(X509_NAME_ENTRY) *sk;\n\n\tif (name == NULL || sk_X509_NAME_ENTRY_num(name-\u003eentries) \u003c= loc\n\t    || loc \u003c 0)\n\t\treturn(NULL);\n\tsk=name-\u003eentries;\n\tret=sk_X509_NAME_ENTRY_delete(sk,loc);\n\tn=sk_X509_NAME_ENTRY_num(sk);\n\tname-\u003emodified=1;\n\tif (loc == n) return(ret);\n\n\t/* else we need to fixup the set field */\n\tif (loc != 0)\n\t\tset_prev=(sk_X509_NAME_ENTRY_value(sk,loc-1))-\u003eset;\n\telse\n\t\tset_prev=ret-\u003eset-1;\n\tset_next=sk_X509_NAME_ENTRY_value(sk,loc)-\u003eset;\n\n\t/* set_prev is the previous set\n\t * set is the current set\n\t * set_next is the following\n\t * prev  1 1\t1 1\t1 1\t1 1\n\t * set   1\t1\t2\t2\n\t * next  1 1\t2 2\t2 2\t3 2\n\t * so basically only if prev and next differ by 2, then\n\t * re-number down by 1 */\n\tif (set_prev+1 \u003c set_next)\n\t\tfor (i=loc; i\u003cn; i++)\n\t\t\tsk_X509_NAME_ENTRY_value(sk,i)-\u003eset--;\n\treturn(ret);\n\t}"},"270237456":{"score":0.90385765,"function_name":"X509_NAME_get_entry","code":"X509_NAME_ENTRY *X509_NAME_get_entry(X509_NAME *name, int loc)\n\t{\n\tif(name == NULL || sk_X509_NAME_ENTRY_num(name-\u003eentries) \u003c= loc\n\t   || loc \u003c 0)\n\t\treturn(NULL);\n\telse\n\t\treturn(sk_X509_NAME_ENTRY_value(name-\u003eentries,loc));\n\t}","filepath":"crypto/x509/x509name.c","line_number":129,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_0_9_8-pre-auto-reformat"},"270237504":{"score":0.7245147,"function_name":"X509_NAME_get_index_by_OBJ","code":"int X509_NAME_get_index_by_OBJ(X509_NAME *name, ASN1_OBJECT *obj,\n\t     int lastpos)\n\t{\n\tint n;\n\tX509_NAME_ENTRY *ne;\n\tSTACK_OF(X509_NAME_ENTRY) *sk;\n\n\tif (name == NULL) return(-1);\n\tif (lastpos \u003c 0)\n\t\tlastpos= -1;\n\tsk=name-\u003eentries;\n\tn=sk_X509_NAME_ENTRY_num(sk);\n\tfor (lastpos++; lastpos \u003c n; lastpos++)\n\t\t{\n\t\tne=sk_X509_NAME_ENTRY_value(sk,lastpos);\n\t\tif (OBJ_cmp(ne-\u003eobject,obj) == 0)\n\t\t\treturn(lastpos);\n\t\t}\n\treturn(-1);\n\t}","filepath":"crypto/x509/x509name.c","line_number":108,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_0_9_8-pre-auto-reformat"},"270238368":{"score":0.893556,"function_name":"v2i_subject_alt","code":"static GENERAL_NAMES *v2i_subject_alt(X509V3_EXT_METHOD *method,\n                                      X509V3_CTX *ctx,\n                                      STACK_OF(CONF_VALUE) *nval)\n{\n    GENERAL_NAMES *gens;\n    CONF_VALUE *cnf;\n    const int num = sk_CONF_VALUE_num(nval);\n    int i;\n\n    gens = sk_GENERAL_NAME_new_reserve(NULL, num);\n    if (gens == NULL) {\n        X509V3err(X509V3_F_V2I_SUBJECT_ALT, ERR_R_MALLOC_FAILURE);\n        sk_GENERAL_NAME_free(gens);\n        return NULL;\n    }\n\n    for (i = 0; i \u003c num; i++) {\n        cnf = sk_CONF_VALUE_value(nval, i);\n        if (!name_cmp(cnf-\u003ename, \"email\")\n            \u0026\u0026 cnf-\u003evalue \u0026\u0026 strcmp(cnf-\u003evalue, \"copy\") == 0) {\n            if (!copy_email(ctx, gens, 0))\n                goto err;\n        } else if (!name_cmp(cnf-\u003ename, \"email\")\n                   \u0026\u0026 cnf-\u003evalue \u0026\u0026 strcmp(cnf-\u003evalue, \"move\") == 0) {\n            if (!copy_email(ctx, gens, 1))\n                goto err;\n        } else {\n            GENERAL_NAME *gen;\n            if ((gen = v2i_GENERAL_NAME(method, ctx, cnf)) == NULL)\n                goto err;\n            sk_GENERAL_NAME_push(gens, gen); /* no failure as it was reserved */\n        }\n    }\n    return gens;\n err:\n    sk_GENERAL_NAME_pop_free(gens, GENERAL_NAME_free);\n    return NULL;\n}","filepath":"crypto/x509v3/v3_alt.c","line_number":294,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270238736":{"score":0.8957254,"function_name":"v2i_issuer_alt","code":"static GENERAL_NAMES *v2i_issuer_alt(X509V3_EXT_METHOD *method,\n                                     X509V3_CTX *ctx,\n                                     STACK_OF(CONF_VALUE) *nval)\n{\n    const int num = sk_CONF_VALUE_num(nval);\n    GENERAL_NAMES *gens = sk_GENERAL_NAME_new_reserve(NULL, num);\n    int i;\n\n    if (gens == NULL) {\n        X509V3err(X509V3_F_V2I_ISSUER_ALT, ERR_R_MALLOC_FAILURE);\n        sk_GENERAL_NAME_free(gens);\n        return NULL;\n    }\n    for (i = 0; i \u003c num; i++) {\n        CONF_VALUE *cnf = sk_CONF_VALUE_value(nval, i);\n\n        if (!name_cmp(cnf-\u003ename, \"issuer\")\n            \u0026\u0026 cnf-\u003evalue \u0026\u0026 strcmp(cnf-\u003evalue, \"copy\") == 0) {\n            if (!copy_issuer(ctx, gens))\n                goto err;\n        } else {\n            GENERAL_NAME *gen = v2i_GENERAL_NAME(method, ctx, cnf);\n\n            if (gen == NULL)\n                goto err;\n            sk_GENERAL_NAME_push(gens, gen); /* no failure as it was reserved */\n        }\n    }\n    return gens;\n err:\n    sk_GENERAL_NAME_pop_free(gens, GENERAL_NAME_free);\n    return NULL;\n}","filepath":"crypto/x509v3/v3_alt.c","line_number":217,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270239248":{"score":0.92963314,"function_name":"GENERAL_NAME_print","code":"int GENERAL_NAME_print(BIO *out, GENERAL_NAME *gen)\n{\n    unsigned char *p;\n    int i;\n    switch (gen-\u003etype) {\n    case GEN_OTHERNAME:\n        BIO_printf(out, \"othername:\u003cunsupported\u003e\");\n        break;\n\n    case GEN_X400:\n        BIO_printf(out, \"X400Name:\u003cunsupported\u003e\");\n        break;\n\n    case GEN_EDIPARTY:\n        /* Maybe fix this: it is supported now */\n        BIO_printf(out, \"EdiPartyName:\u003cunsupported\u003e\");\n        break;\n\n    case GEN_EMAIL:\n        BIO_printf(out, \"email:\");\n        ASN1_STRING_print(out, gen-\u003ed.ia5);\n        break;\n\n    case GEN_DNS:\n        BIO_printf(out, \"DNS:\");\n        ASN1_STRING_print(out, gen-\u003ed.ia5);\n        break;\n\n    case GEN_URI:\n        BIO_printf(out, \"URI:\");\n        ASN1_STRING_print(out, gen-\u003ed.ia5);\n        break;\n\n    case GEN_DIRNAME:\n        BIO_printf(out, \"DirName:\");\n        X509_NAME_print_ex(out, gen-\u003ed.dirn, 0, XN_FLAG_ONELINE);\n        break;\n\n    case GEN_IPADD:\n        p = gen-\u003ed.ip-\u003edata;\n        if (gen-\u003ed.ip-\u003elength == 4)\n            BIO_printf(out, \"IP Address:%d.%d.%d.%d\", p[0], p[1], p[2], p[3]);\n        else if (gen-\u003ed.ip-\u003elength == 16) {\n            BIO_printf(out, \"IP Address\");\n            for (i = 0; i \u003c 8; i++) {\n                BIO_printf(out, \":%X\", p[0] \u003c\u003c 8 | p[1]);\n                p += 2;\n            }\n            BIO_puts(out, \"\\n\");\n        } else {\n            BIO_printf(out, \"IP Address:\u003cinvalid\u003e\");\n            break;\n        }\n        break;\n\n    case GEN_RID:\n        BIO_printf(out, \"Registered ID:\");\n        i2a_ASN1_OBJECT(out, gen-\u003ed.rid);\n        break;\n    }\n    return 1;\n}","filepath":"crypto/x509v3/v3_alt.c","line_number":154,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270239680":{"score":0.85423315,"function_name":"a2i_GENERAL_NAME","code":"GENERAL_NAME *a2i_GENERAL_NAME(GENERAL_NAME *out,\n                               const X509V3_EXT_METHOD *method,\n                               X509V3_CTX *ctx, int gen_type, const char *value,\n                               int is_nc)\n{\n    char is_string = 0;\n    GENERAL_NAME *gen = NULL;\n\n    if (!value) {\n        X509V3err(X509V3_F_A2I_GENERAL_NAME, X509V3_R_MISSING_VALUE);\n        return NULL;\n    }\n\n    if (out)\n        gen = out;\n    else {\n        gen = GENERAL_NAME_new();\n        if (gen == NULL) {\n            X509V3err(X509V3_F_A2I_GENERAL_NAME, ERR_R_MALLOC_FAILURE);\n            return NULL;\n        }\n    }\n\n    switch (gen_type) {\n    case GEN_URI:\n    case GEN_EMAIL:\n    case GEN_DNS:\n        is_string = 1;\n        break;\n\n    case GEN_RID:\n        {\n            ASN1_OBJECT *obj;\n            if ((obj = OBJ_txt2obj(value, 0)) == NULL) {\n                X509V3err(X509V3_F_A2I_GENERAL_NAME, X509V3_R_BAD_OBJECT);\n                ERR_add_error_data(2, \"value=\", value);\n                goto err;\n            }\n            gen-\u003ed.rid = obj;\n        }\n        break;\n\n    case GEN_IPADD:\n        if (is_nc)\n            gen-\u003ed.ip = a2i_IPADDRESS_NC(value);\n        else\n            gen-\u003ed.ip = a2i_IPADDRESS(value);\n        if (gen-\u003ed.ip == NULL) {\n            X509V3err(X509V3_F_A2I_GENERAL_NAME, X509V3_R_BAD_IP_ADDRESS);\n            ERR_add_error_data(2, \"value=\", value);\n            goto err;\n        }\n        break;\n\n    case GEN_DIRNAME:\n        if (!do_dirname(gen, value, ctx)) {\n            X509V3err(X509V3_F_A2I_GENERAL_NAME, X509V3_R_DIRNAME_ERROR);\n            goto err;\n        }\n        break;\n\n    case GEN_OTHERNAME:\n        if (!do_othername(gen, value, ctx)) {\n            X509V3err(X509V3_F_A2I_GENERAL_NAME, X509V3_R_OTHERNAME_ERROR);\n            goto err;\n        }\n        break;\n    default:\n        X509V3err(X509V3_F_A2I_GENERAL_NAME, X509V3_R_UNSUPPORTED_TYPE);\n        goto err;\n    }\n\n    if (is_string) {\n        if ((gen-\u003ed.ia5 = ASN1_IA5STRING_new()) == NULL ||\n            !ASN1_STRING_set(gen-\u003ed.ia5, (unsigned char *)value,\n                             strlen(value))) {\n            X509V3err(X509V3_F_A2I_GENERAL_NAME, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n    }\n\n    gen-\u003etype = gen_type;\n\n    return gen;\n\n err:\n    if (!out)\n        GENERAL_NAME_free(gen);\n    return NULL;\n}","filepath":"crypto/x509v3/v3_alt.c","line_number":425,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270240416":{"score":0.8850815,"function_name":"copy_email","code":"static int copy_email(X509V3_CTX *ctx, GENERAL_NAMES *gens, int move_p)\n{\n    X509_NAME *nm;\n    ASN1_IA5STRING *email = NULL;\n    X509_NAME_ENTRY *ne;\n    GENERAL_NAME *gen = NULL;\n    int i = -1;\n\n    if (ctx != NULL \u0026\u0026 ctx-\u003eflags == CTX_TEST)\n        return 1;\n    if (ctx == NULL\n        || (ctx-\u003esubject_cert == NULL \u0026\u0026 ctx-\u003esubject_req == NULL)) {\n        X509V3err(X509V3_F_COPY_EMAIL, X509V3_R_NO_SUBJECT_DETAILS);\n        goto err;\n    }\n    /* Find the subject name */\n    if (ctx-\u003esubject_cert)\n        nm = X509_get_subject_name(ctx-\u003esubject_cert);\n    else\n        nm = X509_REQ_get_subject_name(ctx-\u003esubject_req);\n\n    /* Now add any email address(es) to STACK */\n    while ((i = X509_NAME_get_index_by_NID(nm,\n                                           NID_pkcs9_emailAddress, i)) \u003e= 0) {\n        ne = X509_NAME_get_entry(nm, i);\n        email = ASN1_STRING_dup(X509_NAME_ENTRY_get_data(ne));\n        if (move_p) {\n            X509_NAME_delete_entry(nm, i);\n            X509_NAME_ENTRY_free(ne);\n            i--;\n        }\n        if (email == NULL || (gen = GENERAL_NAME_new()) == NULL) {\n            X509V3err(X509V3_F_COPY_EMAIL, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        gen-\u003ed.ia5 = email;\n        email = NULL;\n        gen-\u003etype = GEN_EMAIL;\n        if (!sk_GENERAL_NAME_push(gens, gen)) {\n            X509V3err(X509V3_F_COPY_EMAIL, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        gen = NULL;\n    }\n\n    return 1;\n\n err:\n    GENERAL_NAME_free(gen);\n    ASN1_IA5STRING_free(email);\n    return 0;\n\n}","filepath":"crypto/x509v3/v3_alt.c","line_number":337,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270242128":{"score":0.8751029,"function_name":"v2i_GENERAL_NAME_ex","code":"GENERAL_NAME *v2i_GENERAL_NAME_ex(GENERAL_NAME *out,\n                                  const X509V3_EXT_METHOD *method,\n                                  X509V3_CTX *ctx, CONF_VALUE *cnf, int is_nc)\n{\n    int type;\n\n    char *name, *value;\n\n    name = cnf-\u003ename;\n    value = cnf-\u003evalue;\n\n    if (!value) {\n        X509V3err(X509V3_F_V2I_GENERAL_NAME_EX, X509V3_R_MISSING_VALUE);\n        return NULL;\n    }\n\n    if (!name_cmp(name, \"email\"))\n        type = GEN_EMAIL;\n    else if (!name_cmp(name, \"URI\"))\n        type = GEN_URI;\n    else if (!name_cmp(name, \"DNS\"))\n        type = GEN_DNS;\n    else if (!name_cmp(name, \"RID\"))\n        type = GEN_RID;\n    else if (!name_cmp(name, \"IP\"))\n        type = GEN_IPADD;\n    else if (!name_cmp(name, \"dirName\"))\n        type = GEN_DIRNAME;\n    else if (!name_cmp(name, \"otherName\"))\n        type = GEN_OTHERNAME;\n    else {\n        X509V3err(X509V3_F_V2I_GENERAL_NAME_EX, X509V3_R_UNSUPPORTED_OPTION);\n        ERR_add_error_data(2, \"name=\", name);\n        return NULL;\n    }\n\n    return a2i_GENERAL_NAME(out, method, ctx, type, value, is_nc);\n\n}","filepath":"crypto/x509v3/v3_alt.c","line_number":516,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270244272":{"score":0.8801351,"function_name":"ASN1_TYPE_get_int_octetstring","code":"int ASN1_TYPE_get_int_octetstring(const ASN1_TYPE *a, long *num,\n                                  unsigned char *data, int max_len)\n{\n    asn1_int_oct *atmp = NULL;\n    int ret = -1, n;\n\n    if ((a-\u003etype != V_ASN1_SEQUENCE) || (a-\u003evalue.sequence == NULL)) {\n        goto err;\n    }\n\n    atmp = ASN1_TYPE_unpack_sequence(ASN1_ITEM_rptr(asn1_int_oct), a);\n\n    if (atmp == NULL)\n        goto err;\n\n    if (num != NULL)\n        *num = atmp-\u003enum;\n\n    ret = ASN1_STRING_length(atmp-\u003eoct);\n    if (max_len \u003e ret)\n        n = ret;\n    else\n        n = max_len;\n\n    if (data != NULL)\n        memcpy(data, ASN1_STRING_get0_data(atmp-\u003eoct), n);\n    if (ret == -1) {\n err:\n        ASN1err(ASN1_F_ASN1_TYPE_GET_INT_OCTETSTRING, ASN1_R_DATA_IS_WRONG);\n    }\n    M_ASN1_free_of(atmp, asn1_int_oct);\n    return ret;\n}","filepath":"crypto/asn1/evp_asn1.c","line_number":83,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"270244432":{"score":0.89524966,"function_name":"ASN1_TYPE_get_octetstring","code":"int ASN1_TYPE_get_octetstring(const ASN1_TYPE *a, unsigned char *data, int max_len)\n{\n    int ret, num;\n    const unsigned char *p;\n\n    if ((a-\u003etype != V_ASN1_OCTET_STRING) || (a-\u003evalue.octet_string == NULL)) {\n        ASN1err(ASN1_F_ASN1_TYPE_GET_OCTETSTRING, ASN1_R_DATA_IS_WRONG);\n        return -1;\n    }\n    p = ASN1_STRING_get0_data(a-\u003evalue.octet_string);\n    ret = ASN1_STRING_length(a-\u003evalue.octet_string);\n    if (ret \u003c max_len)\n        num = ret;\n    else\n        num = max_len;\n    memcpy(data, p, num);\n    return ret;\n}","filepath":"crypto/asn1/evp_asn1.c","line_number":30,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"270244528":{"score":0.6410157,"function_name":"DECLARE_ASN1_ITEM","code":"static_ASN1_SEQUENCE_END(asn1_int_oct)\n\nDECLARE_ASN1_ITEM(asn1_int_oct)\n\nint ASN1_TYPE_set_int_octetstring(ASN1_TYPE *a, long num, unsigned char *data,\n                                  int len)\n{\n    asn1_int_oct atmp;\n    ASN1_OCTET_STRING oct;\n\n    atmp.num = num;\n    atmp.oct = \u0026oct;\n    oct.data = data;\n    oct.type = V_ASN1_OCTET_STRING;\n    oct.length = len;\n    oct.flags = 0;\n\n    if (ASN1_TYPE_pack_sequence(ASN1_ITEM_rptr(asn1_int_oct), \u0026atmp, \u0026a))\n        return 1;\n    return 0;\n}","filepath":"crypto/asn1/evp_asn1.c","line_number":57,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"270244624":{"score":0.8242366,"function_name":"ASN1_TYPE_set_octetstring","code":"int ASN1_TYPE_set_octetstring(ASN1_TYPE *a, unsigned char *data, int len)\n{\n    ASN1_STRING *os;\n\n    if ((os = ASN1_OCTET_STRING_new()) == NULL)\n        return 0;\n    if (!ASN1_OCTET_STRING_set(os, data, len)) {\n        ASN1_OCTET_STRING_free(os);\n        return 0;\n    }\n    ASN1_TYPE_set(a, V_ASN1_OCTET_STRING, os);\n    return 1;\n}","filepath":"crypto/asn1/evp_asn1.c","line_number":15,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha1"},"270249152":{"score":0.7583041,"function_name":"drbg_ctr_generate","code":"__owur static int drbg_ctr_generate(RAND_DRBG *drbg,\n                                    unsigned char *out, size_t outlen,\n                                    const unsigned char *adin, size_t adinlen)\n{\n    RAND_DRBG_CTR *ctr = \u0026drbg-\u003edata.ctr;\n\n    if (adin != NULL \u0026\u0026 adinlen != 0) {\n        if (!ctr_update(drbg, adin, adinlen, NULL, 0, NULL, 0))\n            return 0;\n        /* This means we reuse derived value */\n        if ((drbg-\u003eflags \u0026 RAND_DRBG_FLAG_CTR_NO_DF) == 0) {\n            adin = NULL;\n            adinlen = 1;\n        }\n    } else {\n        adinlen = 0;\n    }\n\n    for ( ; ; ) {\n        int outl = AES_BLOCK_SIZE;\n\n        inc_128(ctr);\n        if (outlen \u003c 16) {\n            /* Use K as temp space as it will be updated */\n            if (!EVP_CipherUpdate(ctr-\u003ectx, ctr-\u003eK, \u0026outl, ctr-\u003eV,\n                                  AES_BLOCK_SIZE)\n                || outl != AES_BLOCK_SIZE)\n                return 0;\n            memcpy(out, ctr-\u003eK, outlen);\n            break;\n        }\n        if (!EVP_CipherUpdate(ctr-\u003ectx, out, \u0026outl, ctr-\u003eV, AES_BLOCK_SIZE)\n            || outl != AES_BLOCK_SIZE)\n            return 0;\n        out += 16;\n        outlen -= 16;\n        if (outlen == 0)\n            break;\n    }\n\n    if (!ctr_update(drbg, adin, adinlen, NULL, 0, NULL, 0))\n        return 0;\n    return 1;\n}","filepath":"crypto/rand/drbg_ctr.c","line_number":306,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1g"},"270249488":{"score":0.8351164,"function_name":"ctr_BCC_block","code":"__owur static int ctr_BCC_block(RAND_DRBG_CTR *ctr, unsigned char *out,\n                                const unsigned char *in)\n{\n    int i, outlen = AES_BLOCK_SIZE;\n\n    for (i = 0; i \u003c 16; i++)\n        out[i] ^= in[i];\n\n    if (!EVP_CipherUpdate(ctr-\u003ectx_df, out, \u0026outlen, out, AES_BLOCK_SIZE)\n        || outlen != AES_BLOCK_SIZE)\n        return 0;\n    return 1;\n}","filepath":"crypto/rand/drbg_ctr.c","line_number":65,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1g"},"270249616":{"score":0.8725771,"function_name":"ctr_BCC_blocks","code":"__owur static int ctr_BCC_blocks(RAND_DRBG_CTR *ctr, const unsigned char *in)\n{\n    if (!ctr_BCC_block(ctr, ctr-\u003eKX, in)\n        || !ctr_BCC_block(ctr, ctr-\u003eKX + 16, in))\n        return 0;\n    if (ctr-\u003ekeylen != 16 \u0026\u0026 !ctr_BCC_block(ctr, ctr-\u003eKX + 32, in))\n        return 0;\n    return 1;\n}","filepath":"crypto/rand/drbg_ctr.c","line_number":83,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1g"},"270249712":{"score":0.88542354,"function_name":"ctr_BCC_update","code":"__owur static int ctr_BCC_update(RAND_DRBG_CTR *ctr,\n                                 const unsigned char *in, size_t inlen)\n{\n    if (in == NULL || inlen == 0)\n        return 1;\n\n    /* If we have partial block handle it first */\n    if (ctr-\u003ebltmp_pos) {\n        size_t left = 16 - ctr-\u003ebltmp_pos;\n\n        /* If we now have a complete block process it */\n        if (inlen \u003e= left) {\n            memcpy(ctr-\u003ebltmp + ctr-\u003ebltmp_pos, in, left);\n            if (!ctr_BCC_blocks(ctr, ctr-\u003ebltmp))\n                return 0;\n            ctr-\u003ebltmp_pos = 0;\n            inlen -= left;\n            in += left;\n        }\n    }\n\n    /* Process zero or more complete blocks */\n    for (; inlen \u003e= 16; in += 16, inlen -= 16) {\n        if (!ctr_BCC_blocks(ctr, in))\n            return 0;\n    }\n\n    /* Copy any remaining partial block to the temporary buffer */\n    if (inlen \u003e 0) {\n        memcpy(ctr-\u003ebltmp + ctr-\u003ebltmp_pos, in, inlen);\n        ctr-\u003ebltmp_pos += inlen;\n    }\n    return 1;\n}","filepath":"crypto/rand/drbg_ctr.c","line_number":117,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1g"},"270249936":{"score":0.8807033,"function_name":"ctr_XOR","code":"static void ctr_XOR(RAND_DRBG_CTR *ctr, const unsigned char *in, size_t inlen)\n{\n    size_t i, n;\n\n    if (in == NULL || inlen == 0)\n        return;\n\n    /*\n     * Any zero padding will have no effect on the result as we\n     * are XORing. So just process however much input we have.\n     */\n    n = inlen \u003c ctr-\u003ekeylen ? inlen : ctr-\u003ekeylen;\n    for (i = 0; i \u003c n; i++)\n        ctr-\u003eK[i] ^= in[i];\n    if (inlen \u003c= ctr-\u003ekeylen)\n        return;\n\n    n = inlen - ctr-\u003ekeylen;\n    if (n \u003e 16) {\n        /* Should never happen */\n        n = 16;\n    }\n    for (i = 0; i \u003c n; i++)\n        ctr-\u003eV[i] ^= in[i + ctr-\u003ekeylen];\n}","filepath":"crypto/rand/drbg_ctr.c","line_number":36,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1g"},"270250048":{"score":0.78274935,"function_name":"ctr_df","code":"__owur static int ctr_df(RAND_DRBG_CTR *ctr,\n                         const unsigned char *in1, size_t in1len,\n                         const unsigned char *in2, size_t in2len,\n                         const unsigned char *in3, size_t in3len)\n{\n    static unsigned char c80 = 0x80;\n    size_t inlen;\n    unsigned char *p = ctr-\u003ebltmp;\n    int outlen = AES_BLOCK_SIZE;\n\n    if (!ctr_BCC_init(ctr))\n        return 0;\n    if (in1 == NULL)\n        in1len = 0;\n    if (in2 == NULL)\n        in2len = 0;\n    if (in3 == NULL)\n        in3len = 0;\n    inlen = in1len + in2len + in3len;\n    /* Initialise L||N in temporary block */\n    *p++ = (inlen \u003e\u003e 24) \u0026 0xff;\n    *p++ = (inlen \u003e\u003e 16) \u0026 0xff;\n    *p++ = (inlen \u003e\u003e 8) \u0026 0xff;\n    *p++ = inlen \u0026 0xff;\n\n    /* NB keylen is at most 32 bytes */\n    *p++ = 0;\n    *p++ = 0;\n    *p++ = 0;\n    *p = (unsigned char)((ctr-\u003ekeylen + 16) \u0026 0xff);\n    ctr-\u003ebltmp_pos = 8;\n    if (!ctr_BCC_update(ctr, in1, in1len)\n        || !ctr_BCC_update(ctr, in2, in2len)\n        || !ctr_BCC_update(ctr, in3, in3len)\n        || !ctr_BCC_update(ctr, \u0026c80, 1)\n        || !ctr_BCC_final(ctr))\n        return 0;\n    /* Set up key K */\n    if (!EVP_CipherInit_ex(ctr-\u003ectx, ctr-\u003ecipher, NULL, ctr-\u003eKX, NULL, 1))\n        return 0;\n    /* X follows key K */\n    if (!EVP_CipherUpdate(ctr-\u003ectx, ctr-\u003eKX, \u0026outlen, ctr-\u003eKX + ctr-\u003ekeylen,\n                          AES_BLOCK_SIZE)\n        || outlen != AES_BLOCK_SIZE)\n        return 0;\n    if (!EVP_CipherUpdate(ctr-\u003ectx, ctr-\u003eKX + 16, \u0026outlen, ctr-\u003eKX,\n                          AES_BLOCK_SIZE)\n        || outlen != AES_BLOCK_SIZE)\n        return 0;\n    if (ctr-\u003ekeylen != 16)\n        if (!EVP_CipherUpdate(ctr-\u003ectx, ctr-\u003eKX + 32, \u0026outlen, ctr-\u003eKX + 16,\n                              AES_BLOCK_SIZE)\n            || outlen != AES_BLOCK_SIZE)\n            return 0;\n    return 1;\n}","filepath":"crypto/rand/drbg_ctr.c","line_number":162,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1g"},"270250608":{"score":0.7237103,"function_name":"ctr_update","code":"__owur static int ctr_update(RAND_DRBG *drbg,\n                             const unsigned char *in1, size_t in1len,\n                             const unsigned char *in2, size_t in2len,\n                             const unsigned char *nonce, size_t noncelen)\n{\n    RAND_DRBG_CTR *ctr = \u0026drbg-\u003edata.ctr;\n    int outlen = AES_BLOCK_SIZE;\n\n    /* correct key is already set up. */\n    inc_128(ctr);\n    if (!EVP_CipherUpdate(ctr-\u003ectx, ctr-\u003eK, \u0026outlen, ctr-\u003eV, AES_BLOCK_SIZE)\n        || outlen != AES_BLOCK_SIZE)\n        return 0;\n\n    /* If keylen longer than 128 bits need extra encrypt */\n    if (ctr-\u003ekeylen != 16) {\n        inc_128(ctr);\n        if (!EVP_CipherUpdate(ctr-\u003ectx, ctr-\u003eK+16, \u0026outlen, ctr-\u003eV,\n                              AES_BLOCK_SIZE)\n            || outlen != AES_BLOCK_SIZE)\n            return 0;\n    }\n    inc_128(ctr);\n    if (!EVP_CipherUpdate(ctr-\u003ectx, ctr-\u003eV, \u0026outlen, ctr-\u003eV, AES_BLOCK_SIZE)\n        || outlen != AES_BLOCK_SIZE)\n        return 0;\n\n    /* If 192 bit key part of V is on end of K */\n    if (ctr-\u003ekeylen == 24) {\n        memcpy(ctr-\u003eV + 8, ctr-\u003eV, 8);\n        memcpy(ctr-\u003eV, ctr-\u003eK + 24, 8);\n    }\n\n    if ((drbg-\u003eflags \u0026 RAND_DRBG_FLAG_CTR_NO_DF) == 0) {\n        /* If no input reuse existing derived value */\n        if (in1 != NULL || nonce != NULL || in2 != NULL)\n            if (!ctr_df(ctr, in1, in1len, nonce, noncelen, in2, in2len))\n                return 0;\n        /* If this a reuse input in1len != 0 */\n        if (in1len)\n            ctr_XOR(ctr, ctr-\u003eKX, drbg-\u003eseedlen);\n    } else {\n        ctr_XOR(ctr, in1, in1len);\n        ctr_XOR(ctr, in2, in2len);\n    }\n\n    if (!EVP_CipherInit_ex(ctr-\u003ectx, ctr-\u003ecipher, NULL, ctr-\u003eK, NULL, 1))\n        return 0;\n    return 1;\n}","filepath":"crypto/rand/drbg_ctr.c","line_number":225,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1g"},"270250976":{"score":0.85264355,"function_name":"drbg_ctr_init","code":"int drbg_ctr_init(RAND_DRBG *drbg)\n{\n    RAND_DRBG_CTR *ctr = \u0026drbg-\u003edata.ctr;\n    size_t keylen;\n\n    switch (drbg-\u003etype) {\n    default:\n        /* This can't happen, but silence the compiler warning. */\n        return 0;\n    case NID_aes_128_ctr:\n        keylen = 16;\n        ctr-\u003ecipher = EVP_aes_128_ecb();\n        break;\n    case NID_aes_192_ctr:\n        keylen = 24;\n        ctr-\u003ecipher = EVP_aes_192_ecb();\n        break;\n    case NID_aes_256_ctr:\n        keylen = 32;\n        ctr-\u003ecipher = EVP_aes_256_ecb();\n        break;\n    }\n\n    drbg-\u003emeth = \u0026drbg_ctr_meth;\n\n    ctr-\u003ekeylen = keylen;\n    if (ctr-\u003ectx == NULL)\n        ctr-\u003ectx = EVP_CIPHER_CTX_new();\n    if (ctr-\u003ectx == NULL)\n        return 0;\n    drbg-\u003estrength = keylen * 8;\n    drbg-\u003eseedlen = keylen + 16;\n\n    if ((drbg-\u003eflags \u0026 RAND_DRBG_FLAG_CTR_NO_DF) == 0) {\n        /* df initialisation */\n        static const unsigned char df_key[32] = {\n            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n            0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n            0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n            0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f\n        };\n\n        if (ctr-\u003ectx_df == NULL)\n            ctr-\u003ectx_df = EVP_CIPHER_CTX_new();\n        if (ctr-\u003ectx_df == NULL)\n            return 0;\n        /* Set key schedule for df_key */\n        if (!EVP_CipherInit_ex(ctr-\u003ectx_df, ctr-\u003ecipher, NULL, df_key, NULL, 1))\n            return 0;\n\n        drbg-\u003emin_entropylen = ctr-\u003ekeylen;\n        drbg-\u003emax_entropylen = DRBG_MAX_LENGTH;\n        drbg-\u003emin_noncelen = drbg-\u003emin_entropylen / 2;\n        drbg-\u003emax_noncelen = DRBG_MAX_LENGTH;\n        drbg-\u003emax_perslen = DRBG_MAX_LENGTH;\n        drbg-\u003emax_adinlen = DRBG_MAX_LENGTH;\n    } else {\n        drbg-\u003emin_entropylen = drbg-\u003eseedlen;\n        drbg-\u003emax_entropylen = drbg-\u003eseedlen;\n        /* Nonce not used */\n        drbg-\u003emin_noncelen = 0;\n        drbg-\u003emax_noncelen = 0;\n        drbg-\u003emax_perslen = drbg-\u003eseedlen;\n        drbg-\u003emax_adinlen = drbg-\u003eseedlen;\n    }\n\n    drbg-\u003emax_request = 1 \u003c\u003c 16;\n\n    return 1;\n}","filepath":"crypto/rand/drbg_ctr.c","line_number":366,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1g"},"270253440":{"score":0.8527964,"function_name":"des_ede_cbc_cipher","code":"static int des_ede_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\n                              const unsigned char *in, size_t inl)\n{\n    DES_EDE_KEY *dat = data(ctx);\n\n    if (dat-\u003estream.cbc != NULL) {\n        (*dat-\u003estream.cbc) (in, out, inl, dat-\u003eks.ks,\n                            EVP_CIPHER_CTX_iv_noconst(ctx));\n        return 1;\n    }\n\n    while (inl \u003e= EVP_MAXCHUNK) {\n        DES_ede3_cbc_encrypt(in, out, (long)EVP_MAXCHUNK,\n                             \u0026dat-\u003eks1, \u0026dat-\u003eks2, \u0026dat-\u003eks3,\n                             (DES_cblock *)EVP_CIPHER_CTX_iv_noconst(ctx),\n                             EVP_CIPHER_CTX_encrypting(ctx));\n        inl -= EVP_MAXCHUNK;\n        in += EVP_MAXCHUNK;\n        out += EVP_MAXCHUNK;\n    }\n    if (inl)\n        DES_ede3_cbc_encrypt(in, out, (long)inl,\n                             \u0026dat-\u003eks1, \u0026dat-\u003eks2, \u0026dat-\u003eks3,\n                             (DES_cblock *)EVP_CIPHER_CTX_iv_noconst(ctx),\n                             EVP_CIPHER_CTX_encrypting(ctx));\n    return 1;\n}","filepath":"crypto/evp/e_des3.c","line_number":103,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0d"},"270254000":{"score":0.80592155,"function_name":"des_ede3_cfb1_cipher","code":"static int des_ede3_cfb1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\n                                const unsigned char *in, size_t inl)\n{\n    size_t n;\n    unsigned char c[1], d[1];\n\n    if (!EVP_CIPHER_CTX_test_flags(ctx, EVP_CIPH_FLAG_LENGTH_BITS))\n            inl *= 8;\n    for (n = 0; n \u003c inl; ++n) {\n        c[0] = (in[n / 8] \u0026 (1 \u003c\u003c (7 - n % 8))) ? 0x80 : 0;\n        DES_ede3_cfb_encrypt(c, d, 1, 1,\n                             \u0026data(ctx)-\u003eks1, \u0026data(ctx)-\u003eks2,\n                             \u0026data(ctx)-\u003eks3,\n                             (DES_cblock *)EVP_CIPHER_CTX_iv_noconst(ctx),\n                             EVP_CIPHER_CTX_encrypting(ctx));\n        out[n / 8] = (out[n / 8] \u0026 ~(0x80 \u003e\u003e (unsigned int)(n % 8)))\n            | ((d[0] \u0026 0x80) \u003e\u003e (unsigned int)(n % 8));\n    }\n\n    return 1;\n}","filepath":"crypto/evp/e_des3.c","line_number":162,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0d"},"270254496":{"score":0.65647066,"function_name":"des_ede3_wrap_cipher","code":"static int des_ede3_wrap_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\n                                const unsigned char *in, size_t inl)\n{\n    /*\n     * Sanity check input length: we typically only wrap keys so EVP_MAXCHUNK\n     * is more than will ever be needed. Also input length must be a multiple\n     * of 8 bits.\n     */\n    if (inl \u003e= EVP_MAXCHUNK || inl % 8)\n        return -1;\n\n    if (is_partially_overlapping(out, in, inl)) {\n        EVPerr(EVP_F_DES_EDE3_WRAP_CIPHER, EVP_R_PARTIALLY_OVERLAPPING);\n        return 0;\n    }\n\n    if (EVP_CIPHER_CTX_encrypting(ctx))\n        return des_ede3_wrap(ctx, out, in, inl);\n    else\n        return des_ede3_unwrap(ctx, out, in, inl);\n}","filepath":"crypto/evp/e_des3.c","line_number":386,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0d"},"270255904":{"score":0.76821494,"function_name":"rc4_hmac_md5_init_key","code":"static int rc4_hmac_md5_init_key(EVP_CIPHER_CTX *ctx,\n                                 const unsigned char *inkey,\n                                 const unsigned char *iv, int enc)\n{\n    EVP_RC4_HMAC_MD5 *key = data(ctx);\n\n    RC4_set_key(\u0026key-\u003eks, EVP_CIPHER_CTX_key_length(ctx), inkey);\n\n    MD5_Init(\u0026key-\u003ehead);       /* handy when benchmarking */\n    key-\u003etail = key-\u003ehead;\n    key-\u003emd = key-\u003ehead;\n\n    key-\u003epayload_length = NO_PAYLOAD_LENGTH;\n\n    return 1;\n}","filepath":"crypto/evp/e_rc4_hmac_md5.c","line_number":37,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0d"},"270256016":{"score":0.76102006,"function_name":"rc4_hmac_md5_cipher","code":"static int rc4_hmac_md5_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\n                               const unsigned char *in, size_t len)\n{\n    EVP_RC4_HMAC_MD5 *key = data(ctx);\n# if defined(STITCHED_CALL)\n    size_t rc4_off = 32 - 1 - (key-\u003eks.x \u0026 (32 - 1)), /* 32 is $MOD from\n                                                       * rc4_md5-x86_64.pl */\n        md5_off = MD5_CBLOCK - key-\u003emd.num, blocks;\n    unsigned int l;\n    extern unsigned int OPENSSL_ia32cap_P[];\n# endif\n    size_t plen = key-\u003epayload_length;\n\n    if (plen != NO_PAYLOAD_LENGTH \u0026\u0026 len != (plen + MD5_DIGEST_LENGTH))\n        return 0;\n\n    if (EVP_CIPHER_CTX_encrypting(ctx)) {\n        if (plen == NO_PAYLOAD_LENGTH)\n            plen = len;\n# if defined(STITCHED_CALL)\n        /* cipher has to \"fall behind\" */\n        if (rc4_off \u003e md5_off)\n            md5_off += MD5_CBLOCK;\n\n        if (plen \u003e md5_off \u0026\u0026 (blocks = (plen - md5_off) / MD5_CBLOCK) \u0026\u0026\n            (OPENSSL_ia32cap_P[0] \u0026 (1 \u003c\u003c 20)) == 0) {\n            MD5_Update(\u0026key-\u003emd, in, md5_off);\n            RC4(\u0026key-\u003eks, rc4_off, in, out);\n\n            rc4_md5_enc(\u0026key-\u003eks, in + rc4_off, out + rc4_off,\n                        \u0026key-\u003emd, in + md5_off, blocks);\n            blocks *= MD5_CBLOCK;\n            rc4_off += blocks;\n            md5_off += blocks;\n            key-\u003emd.Nh += blocks \u003e\u003e 29;\n            key-\u003emd.Nl += blocks \u003c\u003c= 3;\n            if (key-\u003emd.Nl \u003c (unsigned int)blocks)\n                key-\u003emd.Nh++;\n        } else {\n            rc4_off = 0;\n            md5_off = 0;\n        }\n# endif\n        MD5_Update(\u0026key-\u003emd, in + md5_off, plen - md5_off);\n\n        if (plen != len) {      /* \"TLS\" mode of operation */\n            if (in != out)\n                memcpy(out + rc4_off, in + rc4_off, plen - rc4_off);\n\n            /* calculate HMAC and append it to payload */\n            MD5_Final(out + plen, \u0026key-\u003emd);\n            key-\u003emd = key-\u003etail;\n            MD5_Update(\u0026key-\u003emd, out + plen, MD5_DIGEST_LENGTH);\n            MD5_Final(out + plen, \u0026key-\u003emd);\n            /* encrypt HMAC at once */\n            RC4(\u0026key-\u003eks, len - rc4_off, out + rc4_off, out + rc4_off);\n        } else {\n            RC4(\u0026key-\u003eks, len - rc4_off, in + rc4_off, out + rc4_off);\n        }\n    } else {\n        unsigned char mac[MD5_DIGEST_LENGTH];\n# if defined(STITCHED_CALL)\n        /* digest has to \"fall behind\" */\n        if (md5_off \u003e rc4_off)\n            rc4_off += 2 * MD5_CBLOCK;\n        else\n            rc4_off += MD5_CBLOCK;\n\n        if (len \u003e rc4_off \u0026\u0026 (blocks = (len - rc4_off) / MD5_CBLOCK) \u0026\u0026\n            (OPENSSL_ia32cap_P[0] \u0026 (1 \u003c\u003c 20)) == 0) {\n            RC4(\u0026key-\u003eks, rc4_off, in, out);\n            MD5_Update(\u0026key-\u003emd, out, md5_off);\n\n            rc4_md5_enc(\u0026key-\u003eks, in + rc4_off, out + rc4_off,\n                        \u0026key-\u003emd, out + md5_off, blocks);\n            blocks *= MD5_CBLOCK;\n            rc4_off += blocks;\n            md5_off += blocks;\n            l = (key-\u003emd.Nl + (blocks \u003c\u003c 3)) \u0026 0xffffffffU;\n            if (l \u003c key-\u003emd.Nl)\n                key-\u003emd.Nh++;\n            key-\u003emd.Nl = l;\n            key-\u003emd.Nh += blocks \u003e\u003e 29;\n        } else {\n            md5_off = 0;\n            rc4_off = 0;\n        }\n# endif\n        /* decrypt HMAC at once */\n        RC4(\u0026key-\u003eks, len - rc4_off, in + rc4_off, out + rc4_off);\n        if (plen != NO_PAYLOAD_LENGTH) { /* \"TLS\" mode of operation */\n            MD5_Update(\u0026key-\u003emd, out + md5_off, plen - md5_off);\n\n            /* calculate HMAC and verify it */\n            MD5_Final(mac, \u0026key-\u003emd);\n            key-\u003emd = key-\u003etail;\n            MD5_Update(\u0026key-\u003emd, mac, MD5_DIGEST_LENGTH);\n            MD5_Final(mac, \u0026key-\u003emd);\n\n            if (CRYPTO_memcmp(out + plen, mac, MD5_DIGEST_LENGTH))\n                return 0;\n        } else {\n            MD5_Update(\u0026key-\u003emd, out + md5_off, len - md5_off);\n        }\n    }\n\n    key-\u003epayload_length = NO_PAYLOAD_LENGTH;\n\n    return 1;\n}","filepath":"crypto/evp/e_rc4_hmac_md5.c","line_number":65,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0d"},"270256464":{"score":0.66323096,"function_name":"rc4_hmac_md5_ctrl","code":"static int rc4_hmac_md5_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,\n                             void *ptr)\n{\n    EVP_RC4_HMAC_MD5 *key = data(ctx);\n\n    switch (type) {\n    case EVP_CTRL_AEAD_SET_MAC_KEY:\n        {\n            unsigned int i;\n            unsigned char hmac_key[64];\n\n            memset(hmac_key, 0, sizeof(hmac_key));\n\n            if (arg \u003e (int)sizeof(hmac_key)) {\n                MD5_Init(\u0026key-\u003ehead);\n                MD5_Update(\u0026key-\u003ehead, ptr, arg);\n                MD5_Final(hmac_key, \u0026key-\u003ehead);\n            } else {\n                memcpy(hmac_key, ptr, arg);\n            }\n\n            for (i = 0; i \u003c sizeof(hmac_key); i++)\n                hmac_key[i] ^= 0x36; /* ipad */\n            MD5_Init(\u0026key-\u003ehead);\n            MD5_Update(\u0026key-\u003ehead, hmac_key, sizeof(hmac_key));\n\n            for (i = 0; i \u003c sizeof(hmac_key); i++)\n                hmac_key[i] ^= 0x36 ^ 0x5c; /* opad */\n            MD5_Init(\u0026key-\u003etail);\n            MD5_Update(\u0026key-\u003etail, hmac_key, sizeof(hmac_key));\n\n            OPENSSL_cleanse(hmac_key, sizeof(hmac_key));\n\n            return 1;\n        }\n    case EVP_CTRL_AEAD_TLS1_AAD:\n        {\n            unsigned char *p = ptr;\n            unsigned int len;\n\n            if (arg != EVP_AEAD_TLS1_AAD_LEN)\n                return -1;\n\n            len = p[arg - 2] \u003c\u003c 8 | p[arg - 1];\n\n            if (!EVP_CIPHER_CTX_encrypting(ctx)) {\n                if (len \u003c MD5_DIGEST_LENGTH)\n                    return -1;\n                len -= MD5_DIGEST_LENGTH;\n                p[arg - 2] = len \u003e\u003e 8;\n                p[arg - 1] = len;\n            }\n            key-\u003epayload_length = len;\n            key-\u003emd = key-\u003ehead;\n            MD5_Update(\u0026key-\u003emd, p, arg);\n\n            return MD5_DIGEST_LENGTH;\n        }\n    default:\n        return -1;\n    }\n}","filepath":"crypto/evp/e_rc4_hmac_md5.c","line_number":176,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0d"},"270261216":{"score":0.7816334,"function_name":"aes_ofb_cipher","code":"static int aes_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\n                          const unsigned char *in, size_t len)\n{\n    EVP_AES_KEY *dat = EVP_C_DATA(EVP_AES_KEY,ctx);\n\n    int num = EVP_CIPHER_CTX_num(ctx);\n    CRYPTO_ofb128_encrypt(in, out, len, \u0026dat-\u003eks,\n                          EVP_CIPHER_CTX_iv_noconst(ctx), \u0026num, dat-\u003eblock);\n    EVP_CIPHER_CTX_set_num(ctx, num);\n    return 1;\n}","filepath":"crypto/evp/e_aes.c","line_number":2737,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1l"},"270261328":{"score":0.7376144,"function_name":"aes_cfb8_cipher","code":"static int aes_cfb8_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\n                           const unsigned char *in, size_t len)\n{\n    EVP_AES_KEY *dat = EVP_C_DATA(EVP_AES_KEY,ctx);\n\n    int num = EVP_CIPHER_CTX_num(ctx);\n    CRYPTO_cfb128_8_encrypt(in, out, len, \u0026dat-\u003eks,\n                            EVP_CIPHER_CTX_iv_noconst(ctx), \u0026num,\n                            EVP_CIPHER_CTX_encrypting(ctx), dat-\u003eblock);\n    EVP_CIPHER_CTX_set_num(ctx, num);\n    return 1;\n}","filepath":"crypto/evp/e_aes.c","line_number":2762,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1l"},"270261920":{"score":0.8019532,"function_name":"aes_ctr_cipher","code":"static int aes_ctr_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\n                          const unsigned char *in, size_t len)\n{\n    unsigned int num = EVP_CIPHER_CTX_num(ctx);\n    EVP_AES_KEY *dat = EVP_C_DATA(EVP_AES_KEY,ctx);\n\n    if (dat-\u003estream.ctr)\n        CRYPTO_ctr128_encrypt_ctr32(in, out, len, \u0026dat-\u003eks,\n                                    EVP_CIPHER_CTX_iv_noconst(ctx),\n                                    EVP_CIPHER_CTX_buf_noconst(ctx),\n                                    \u0026num, dat-\u003estream.ctr);\n    else\n        CRYPTO_ctr128_encrypt(in, out, len, \u0026dat-\u003eks,\n                              EVP_CIPHER_CTX_iv_noconst(ctx),\n                              EVP_CIPHER_CTX_buf_noconst(ctx), \u0026num,\n                              dat-\u003eblock);\n    EVP_CIPHER_CTX_set_num(ctx, num);\n    return 1;\n}","filepath":"crypto/evp/e_aes.c","line_number":2810,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1l"},"270262096":{"score":0.8042148,"function_name":"aesni_gcm_init_key","code":"static int aesni_gcm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\n                              const unsigned char *iv, int enc)\n{\n    EVP_AES_GCM_CTX *gctx = EVP_C_DATA(EVP_AES_GCM_CTX,ctx);\n    if (!iv \u0026\u0026 !key)\n        return 1;\n    if (key) {\n        aesni_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,\n                              \u0026gctx-\u003eks.ks);\n        CRYPTO_gcm128_init(\u0026gctx-\u003egcm, \u0026gctx-\u003eks, (block128_f) aesni_encrypt);\n        gctx-\u003ectr = (ctr128_f) aesni_ctr32_encrypt_blocks;\n        /*\n         * If we have an iv can set it directly, otherwise use saved IV.\n         */\n        if (iv == NULL \u0026\u0026 gctx-\u003eiv_set)\n            iv = gctx-\u003eiv;\n        if (iv) {\n            CRYPTO_gcm128_setiv(\u0026gctx-\u003egcm, iv, gctx-\u003eivlen);\n            gctx-\u003eiv_set = 1;\n        }\n        gctx-\u003ekey_set = 1;\n    } else {\n        /* If key set use IV, otherwise copy */\n        if (gctx-\u003ekey_set)\n            CRYPTO_gcm128_setiv(\u0026gctx-\u003egcm, iv, gctx-\u003eivlen);\n        else\n            memcpy(gctx-\u003eiv, iv, gctx-\u003eivlen);\n        gctx-\u003eiv_set = 1;\n        gctx-\u003eiv_gen = 0;\n    }\n    return 1;\n}","filepath":"crypto/evp/e_aes.c","line_number":345,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1l"},"270262960":{"score":0.8612963,"function_name":"aes_xts_cipher","code":"static int aes_xts_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\n                          const unsigned char *in, size_t len)\n{\n    EVP_AES_XTS_CTX *xctx = EVP_C_DATA(EVP_AES_XTS_CTX,ctx);\n    if (!xctx-\u003exts.key1 || !xctx-\u003exts.key2)\n        return 0;\n    if (!out || !in || len \u003c AES_BLOCK_SIZE)\n        return 0;\n    if (xctx-\u003estream)\n        (*xctx-\u003estream) (in, out, len,\n                         xctx-\u003exts.key1, xctx-\u003exts.key2,\n                         EVP_CIPHER_CTX_iv_noconst(ctx));\n    else if (CRYPTO_xts128_encrypt(\u0026xctx-\u003exts, EVP_CIPHER_CTX_iv_noconst(ctx),\n                                   in, out, len,\n                                   EVP_CIPHER_CTX_encrypting(ctx)))\n        return 0;\n    return 1;\n}","filepath":"crypto/evp/e_aes.c","line_number":3473,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1l"},"270264064":{"score":0.83616954,"function_name":"aes_ocb_init_key","code":"static int aes_ocb_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\n                            const unsigned char *iv, int enc)\n{\n    EVP_AES_OCB_CTX *octx = EVP_C_DATA(EVP_AES_OCB_CTX,ctx);\n    if (!iv \u0026\u0026 !key)\n        return 1;\n    if (key) {\n        do {\n            /*\n             * We set both the encrypt and decrypt key here because decrypt\n             * needs both. We could possibly optimise to remove setting the\n             * decrypt for an encryption operation.\n             */\n# ifdef HWAES_CAPABLE\n            if (HWAES_CAPABLE) {\n                HWAES_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,\n                                      \u0026octx-\u003eksenc.ks);\n                HWAES_set_decrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,\n                                      \u0026octx-\u003eksdec.ks);\n                if (!CRYPTO_ocb128_init(\u0026octx-\u003eocb,\n                                        \u0026octx-\u003eksenc.ks, \u0026octx-\u003eksdec.ks,\n                                        (block128_f) HWAES_encrypt,\n                                        (block128_f) HWAES_decrypt,\n                                        enc ? HWAES_ocb_encrypt\n                                            : HWAES_ocb_decrypt))\n                    return 0;\n                break;\n            }\n# endif\n# ifdef VPAES_CAPABLE\n            if (VPAES_CAPABLE) {\n                vpaes_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,\n                                      \u0026octx-\u003eksenc.ks);\n                vpaes_set_decrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,\n                                      \u0026octx-\u003eksdec.ks);\n                if (!CRYPTO_ocb128_init(\u0026octx-\u003eocb,\n                                        \u0026octx-\u003eksenc.ks, \u0026octx-\u003eksdec.ks,\n                                        (block128_f) vpaes_encrypt,\n                                        (block128_f) vpaes_decrypt,\n                                        NULL))\n                    return 0;\n                break;\n            }\n# endif\n            AES_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,\n                                \u0026octx-\u003eksenc.ks);\n            AES_set_decrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,\n                                \u0026octx-\u003eksdec.ks);\n            if (!CRYPTO_ocb128_init(\u0026octx-\u003eocb,\n                                    \u0026octx-\u003eksenc.ks, \u0026octx-\u003eksdec.ks,\n                                    (block128_f) AES_encrypt,\n                                    (block128_f) AES_decrypt,\n                                    NULL))\n                return 0;\n        }\n        while (0);\n\n        /*\n         * If we have an iv we can set it directly, otherwise use saved IV.\n         */\n        if (iv == NULL \u0026\u0026 octx-\u003eiv_set)\n            iv = octx-\u003eiv;\n        if (iv) {\n            if (CRYPTO_ocb128_setiv(\u0026octx-\u003eocb, iv, octx-\u003eivlen, octx-\u003etaglen)\n                != 1)\n                return 0;\n            octx-\u003eiv_set = 1;\n        }\n        octx-\u003ekey_set = 1;\n    } else {\n        /* If key set use IV, otherwise copy */\n        if (octx-\u003ekey_set)\n            CRYPTO_ocb128_setiv(\u0026octx-\u003eocb, iv, octx-\u003eivlen, octx-\u003etaglen);\n        else\n            memcpy(octx-\u003eiv, iv, octx-\u003eivlen);\n        octx-\u003eiv_set = 1;\n    }\n    return 1;\n}","filepath":"crypto/evp/e_aes.c","line_number":4041,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1l"},"270264400":{"score":0.8216133,"function_name":"aes_ocb_cipher","code":"static int aes_ocb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\n                          const unsigned char *in, size_t len)\n{\n    unsigned char *buf;\n    int *buf_len;\n    int written_len = 0;\n    size_t trailing_len;\n    EVP_AES_OCB_CTX *octx = EVP_C_DATA(EVP_AES_OCB_CTX,ctx);\n\n    /* If IV or Key not set then return error */\n    if (!octx-\u003eiv_set)\n        return -1;\n\n    if (!octx-\u003ekey_set)\n        return -1;\n\n    if (in != NULL) {\n        /*\n         * Need to ensure we are only passing full blocks to low level OCB\n         * routines. We do it here rather than in EVP_EncryptUpdate/\n         * EVP_DecryptUpdate because we need to pass full blocks of AAD too\n         * and those routines don't support that\n         */\n\n        /* Are we dealing with AAD or normal data here? */\n        if (out == NULL) {\n            buf = octx-\u003eaad_buf;\n            buf_len = \u0026(octx-\u003eaad_buf_len);\n        } else {\n            buf = octx-\u003edata_buf;\n            buf_len = \u0026(octx-\u003edata_buf_len);\n\n            if (is_partially_overlapping(out + *buf_len, in, len)) {\n                EVPerr(EVP_F_AES_OCB_CIPHER, EVP_R_PARTIALLY_OVERLAPPING);\n                return 0;\n            }\n        }\n\n        /*\n         * If we've got a partially filled buffer from a previous call then\n         * use that data first\n         */\n        if (*buf_len \u003e 0) {\n            unsigned int remaining;\n\n            remaining = AES_BLOCK_SIZE - (*buf_len);\n            if (remaining \u003e len) {\n                memcpy(buf + (*buf_len), in, len);\n                *(buf_len) += len;\n                return 0;\n            }\n            memcpy(buf + (*buf_len), in, remaining);\n\n            /*\n             * If we get here we've filled the buffer, so process it\n             */\n            len -= remaining;\n            in += remaining;\n            if (out == NULL) {\n                if (!CRYPTO_ocb128_aad(\u0026octx-\u003eocb, buf, AES_BLOCK_SIZE))\n                    return -1;\n            } else if (EVP_CIPHER_CTX_encrypting(ctx)) {\n                if (!CRYPTO_ocb128_encrypt(\u0026octx-\u003eocb, buf, out,\n                                           AES_BLOCK_SIZE))\n                    return -1;\n            } else {\n                if (!CRYPTO_ocb128_decrypt(\u0026octx-\u003eocb, buf, out,\n                                           AES_BLOCK_SIZE))\n                    return -1;\n            }\n            written_len = AES_BLOCK_SIZE;\n            *buf_len = 0;\n            if (out != NULL)\n                out += AES_BLOCK_SIZE;\n        }\n\n        /* Do we have a partial block to handle at the end? */\n        trailing_len = len % AES_BLOCK_SIZE;\n\n        /*\n         * If we've got some full blocks to handle, then process these first\n         */\n        if (len != trailing_len) {\n            if (out == NULL) {\n                if (!CRYPTO_ocb128_aad(\u0026octx-\u003eocb, in, len - trailing_len))\n                    return -1;\n            } else if (EVP_CIPHER_CTX_encrypting(ctx)) {\n                if (!CRYPTO_ocb128_encrypt\n                    (\u0026octx-\u003eocb, in, out, len - trailing_len))\n                    return -1;\n            } else {\n                if (!CRYPTO_ocb128_decrypt\n                    (\u0026octx-\u003eocb, in, out, len - trailing_len))\n                    return -1;\n            }\n            written_len += len - trailing_len;\n            in += len - trailing_len;\n        }\n\n        /* Handle any trailing partial block */\n        if (trailing_len \u003e 0) {\n            memcpy(buf, in, trailing_len);\n            *buf_len = trailing_len;\n        }\n\n        return written_len;\n    } else {\n        /*\n         * First of all empty the buffer of any partial block that we might\n         * have been provided - both for data and AAD\n         */\n        if (octx-\u003edata_buf_len \u003e 0) {\n            if (EVP_CIPHER_CTX_encrypting(ctx)) {\n                if (!CRYPTO_ocb128_encrypt(\u0026octx-\u003eocb, octx-\u003edata_buf, out,\n                                           octx-\u003edata_buf_len))\n                    return -1;\n            } else {\n                if (!CRYPTO_ocb128_decrypt(\u0026octx-\u003eocb, octx-\u003edata_buf, out,\n                                           octx-\u003edata_buf_len))\n                    return -1;\n            }\n            written_len = octx-\u003edata_buf_len;\n            octx-\u003edata_buf_len = 0;\n        }\n        if (octx-\u003eaad_buf_len \u003e 0) {\n            if (!CRYPTO_ocb128_aad\n                (\u0026octx-\u003eocb, octx-\u003eaad_buf, octx-\u003eaad_buf_len))\n                return -1;\n            octx-\u003eaad_buf_len = 0;\n        }\n        /* If decrypting then verify */\n        if (!EVP_CIPHER_CTX_encrypting(ctx)) {\n            if (octx-\u003etaglen \u003c 0)\n                return -1;\n            if (CRYPTO_ocb128_finish(\u0026octx-\u003eocb,\n                                     octx-\u003etag, octx-\u003etaglen) != 0)\n                return -1;\n            octx-\u003eiv_set = 0;\n            return written_len;\n        }\n        /* If encrypting then just get the tag */\n        if (CRYPTO_ocb128_tag(\u0026octx-\u003eocb, octx-\u003etag, 16) != 1)\n            return -1;\n        /* Don't reuse the IV */\n        octx-\u003eiv_set = 0;\n        return written_len;\n    }\n}","filepath":"crypto/evp/e_aes.c","line_number":4121,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1l"},"270265696":{"score":0.87634706,"function_name":"aes_ecb_cipher","code":"static int aes_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\n                          const unsigned char *in, size_t len)\n{\n    size_t bl = EVP_CIPHER_CTX_block_size(ctx);\n    size_t i;\n    EVP_AES_KEY *dat = EVP_C_DATA(EVP_AES_KEY,ctx);\n\n    if (len \u003c bl)\n        return 1;\n\n    for (i = 0, len -= bl; i \u003c= len; i += bl)\n        (*dat-\u003eblock) (in + i, out + i, \u0026dat-\u003eks);\n\n    return 1;\n}","filepath":"crypto/evp/e_aes.c","line_number":2721,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1l"},"270265904":{"score":0.88556165,"function_name":"aes_gcm_ctrl","code":"static int aes_gcm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)\n{\n    EVP_AES_GCM_CTX *gctx = EVP_C_DATA(EVP_AES_GCM_CTX,c);\n    switch (type) {\n    case EVP_CTRL_INIT:\n        gctx-\u003ekey_set = 0;\n        gctx-\u003eiv_set = 0;\n        gctx-\u003eivlen = EVP_CIPHER_iv_length(c-\u003ecipher);\n        gctx-\u003eiv = c-\u003eiv;\n        gctx-\u003etaglen = -1;\n        gctx-\u003eiv_gen = 0;\n        gctx-\u003etls_aad_len = -1;\n        return 1;\n\n    case EVP_CTRL_GET_IVLEN:\n        *(int *)ptr = gctx-\u003eivlen;\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_IVLEN:\n        if (arg \u003c= 0)\n            return 0;\n        /* Allocate memory for IV if needed */\n        if ((arg \u003e EVP_MAX_IV_LENGTH) \u0026\u0026 (arg \u003e gctx-\u003eivlen)) {\n            if (gctx-\u003eiv != c-\u003eiv)\n                OPENSSL_free(gctx-\u003eiv);\n            if ((gctx-\u003eiv = OPENSSL_malloc(arg)) == NULL) {\n                EVPerr(EVP_F_AES_GCM_CTRL, ERR_R_MALLOC_FAILURE);\n                return 0;\n            }\n        }\n        gctx-\u003eivlen = arg;\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_TAG:\n        if (arg \u003c= 0 || arg \u003e 16 || c-\u003eencrypt)\n            return 0;\n        memcpy(c-\u003ebuf, ptr, arg);\n        gctx-\u003etaglen = arg;\n        return 1;\n\n    case EVP_CTRL_AEAD_GET_TAG:\n        if (arg \u003c= 0 || arg \u003e 16 || !c-\u003eencrypt\n            || gctx-\u003etaglen \u003c 0)\n            return 0;\n        memcpy(ptr, c-\u003ebuf, arg);\n        return 1;\n\n    case EVP_CTRL_GCM_SET_IV_FIXED:\n        /* Special case: -1 length restores whole IV */\n        if (arg == -1) {\n            memcpy(gctx-\u003eiv, ptr, gctx-\u003eivlen);\n            gctx-\u003eiv_gen = 1;\n            return 1;\n        }\n        /*\n         * Fixed field must be at least 4 bytes and invocation field at least\n         * 8.\n         */\n        if ((arg \u003c 4) || (gctx-\u003eivlen - arg) \u003c 8)\n            return 0;\n        if (arg)\n            memcpy(gctx-\u003eiv, ptr, arg);\n        if (c-\u003eencrypt \u0026\u0026 RAND_bytes(gctx-\u003eiv + arg, gctx-\u003eivlen - arg) \u003c= 0)\n            return 0;\n        gctx-\u003eiv_gen = 1;\n        return 1;\n\n    case EVP_CTRL_GCM_IV_GEN:\n        if (gctx-\u003eiv_gen == 0 || gctx-\u003ekey_set == 0)\n            return 0;\n        CRYPTO_gcm128_setiv(\u0026gctx-\u003egcm, gctx-\u003eiv, gctx-\u003eivlen);\n        if (arg \u003c= 0 || arg \u003e gctx-\u003eivlen)\n            arg = gctx-\u003eivlen;\n        memcpy(ptr, gctx-\u003eiv + gctx-\u003eivlen - arg, arg);\n        /*\n         * Invocation field will be at least 8 bytes in size and so no need\n         * to check wrap around or increment more than last 8 bytes.\n         */\n        ctr64_inc(gctx-\u003eiv + gctx-\u003eivlen - 8);\n        gctx-\u003eiv_set = 1;\n        return 1;\n\n    case EVP_CTRL_GCM_SET_IV_INV:\n        if (gctx-\u003eiv_gen == 0 || gctx-\u003ekey_set == 0 || c-\u003eencrypt)\n            return 0;\n        memcpy(gctx-\u003eiv + gctx-\u003eivlen - arg, ptr, arg);\n        CRYPTO_gcm128_setiv(\u0026gctx-\u003egcm, gctx-\u003eiv, gctx-\u003eivlen);\n        gctx-\u003eiv_set = 1;\n        return 1;\n\n    case EVP_CTRL_AEAD_TLS1_AAD:\n        /* Save the AAD for later use */\n        if (arg != EVP_AEAD_TLS1_AAD_LEN)\n            return 0;\n        memcpy(c-\u003ebuf, ptr, arg);\n        gctx-\u003etls_aad_len = arg;\n        {\n            unsigned int len = c-\u003ebuf[arg - 2] \u003c\u003c 8 | c-\u003ebuf[arg - 1];\n            /* Correct length for explicit IV */\n            if (len \u003c EVP_GCM_TLS_EXPLICIT_IV_LEN)\n                return 0;\n            len -= EVP_GCM_TLS_EXPLICIT_IV_LEN;\n            /* If decrypting correct for tag too */\n            if (!c-\u003eencrypt) {\n                if (len \u003c EVP_GCM_TLS_TAG_LEN)\n                    return 0;\n                len -= EVP_GCM_TLS_TAG_LEN;\n            }\n            c-\u003ebuf[arg - 2] = len \u003e\u003e 8;\n            c-\u003ebuf[arg - 1] = len \u0026 0xff;\n        }\n        /* Extra padding: tag appended to record */\n        return EVP_GCM_TLS_TAG_LEN;\n\n    case EVP_CTRL_COPY:\n        {\n            EVP_CIPHER_CTX *out = ptr;\n            EVP_AES_GCM_CTX *gctx_out = EVP_C_DATA(EVP_AES_GCM_CTX,out);\n            if (gctx-\u003egcm.key) {\n                if (gctx-\u003egcm.key != \u0026gctx-\u003eks)\n                    return 0;\n                gctx_out-\u003egcm.key = \u0026gctx_out-\u003eks;\n            }\n            if (gctx-\u003eiv == c-\u003eiv)\n                gctx_out-\u003eiv = out-\u003eiv;\n            else {\n                if ((gctx_out-\u003eiv = OPENSSL_malloc(gctx-\u003eivlen)) == NULL) {\n                    EVPerr(EVP_F_AES_GCM_CTRL, ERR_R_MALLOC_FAILURE);\n                    return 0;\n                }\n                memcpy(gctx_out-\u003eiv, gctx-\u003eiv, gctx-\u003eivlen);\n            }\n            return 1;\n        }\n\n    default:\n        return -1;\n\n    }\n}","filepath":"crypto/evp/e_aes.c","line_number":2845,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1l"},"270268608":{"score":0.8137277,"function_name":"aes_t4_ccm_init_key","code":"static int aes_t4_ccm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\n                               const unsigned char *iv, int enc)\n{\n    EVP_AES_CCM_CTX *cctx = EVP_C_DATA(EVP_AES_CCM_CTX,ctx);\n    if (!iv \u0026\u0026 !key)\n        return 1;\n    if (key) {\n        int bits = EVP_CIPHER_CTX_key_length(ctx) * 8;\n        aes_t4_set_encrypt_key(key, bits, \u0026cctx-\u003eks.ks);\n        CRYPTO_ccm128_init(\u0026cctx-\u003eccm, cctx-\u003eM, cctx-\u003eL,\n                           \u0026cctx-\u003eks, (block128_f) aes_t4_encrypt);\n        cctx-\u003estr = NULL;\n        cctx-\u003ekey_set = 1;\n    }\n    if (iv) {\n        memcpy(EVP_CIPHER_CTX_iv_noconst(ctx), iv, 15 - cctx-\u003eL);\n        cctx-\u003eiv_set = 1;\n    }\n    return 1;\n}","filepath":"crypto/evp/e_aes.c","line_number":876,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1l"},"270268992":{"score":0.8538216,"function_name":"aes_wrap_cipher","code":"static int aes_wrap_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\n                           const unsigned char *in, size_t inlen)\n{\n    EVP_AES_WRAP_CTX *wctx = EVP_C_DATA(EVP_AES_WRAP_CTX,ctx);\n    size_t rv;\n    /* AES wrap with padding has IV length of 4, without padding 8 */\n    int pad = EVP_CIPHER_CTX_iv_length(ctx) == 4;\n    /* No final operation so always return zero length */\n    if (!in)\n        return 0;\n    /* Input length must always be non-zero */\n    if (!inlen)\n        return -1;\n    /* If decrypting need at least 16 bytes and multiple of 8 */\n    if (!EVP_CIPHER_CTX_encrypting(ctx) \u0026\u0026 (inlen \u003c 16 || inlen \u0026 0x7))\n        return -1;\n    /* If not padding input must be multiple of 8 */\n    if (!pad \u0026\u0026 inlen \u0026 0x7)\n        return -1;\n    if (is_partially_overlapping(out, in, inlen)) {\n        EVPerr(EVP_F_AES_WRAP_CIPHER, EVP_R_PARTIALLY_OVERLAPPING);\n        return 0;\n    }\n    if (!out) {\n        if (EVP_CIPHER_CTX_encrypting(ctx)) {\n            /* If padding round up to multiple of 8 */\n            if (pad)\n                inlen = (inlen + 7) / 8 * 8;\n            /* 8 byte prefix */\n            return inlen + 8;\n        } else {\n            /*\n             * If not padding output will be exactly 8 bytes smaller than\n             * input. If padding it will be at least 8 bytes smaller but we\n             * don't know how much.\n             */\n            return inlen - 8;\n        }\n    }\n    if (pad) {\n        if (EVP_CIPHER_CTX_encrypting(ctx))\n            rv = CRYPTO_128_wrap_pad(\u0026wctx-\u003eks.ks, wctx-\u003eiv,\n                                     out, in, inlen,\n                                     (block128_f) AES_encrypt);\n        else\n            rv = CRYPTO_128_unwrap_pad(\u0026wctx-\u003eks.ks, wctx-\u003eiv,\n                                       out, in, inlen,\n                                       (block128_f) AES_decrypt);\n    } else {\n        if (EVP_CIPHER_CTX_encrypting(ctx))\n            rv = CRYPTO_128_wrap(\u0026wctx-\u003eks.ks, wctx-\u003eiv,\n                                 out, in, inlen, (block128_f) AES_encrypt);\n        else\n            rv = CRYPTO_128_unwrap(\u0026wctx-\u003eks.ks, wctx-\u003eiv,\n                                   out, in, inlen, (block128_f) AES_decrypt);\n    }\n    return rv ? (int)rv : -1;\n}","filepath":"crypto/evp/e_aes.c","line_number":3807,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1l"},"270269824":{"score":0.7538966,"function_name":"aes_t4_gcm_init_key","code":"static int aes_t4_gcm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\n                               const unsigned char *iv, int enc)\n{\n    EVP_AES_GCM_CTX *gctx = EVP_C_DATA(EVP_AES_GCM_CTX,ctx);\n    if (!iv \u0026\u0026 !key)\n        return 1;\n    if (key) {\n        int bits = EVP_CIPHER_CTX_key_length(ctx) * 8;\n        aes_t4_set_encrypt_key(key, bits, \u0026gctx-\u003eks.ks);\n        CRYPTO_gcm128_init(\u0026gctx-\u003egcm, \u0026gctx-\u003eks,\n                           (block128_f) aes_t4_encrypt);\n        switch (bits) {\n        case 128:\n            gctx-\u003ectr = (ctr128_f) aes128_t4_ctr32_encrypt;\n            break;\n        case 192:\n            gctx-\u003ectr = (ctr128_f) aes192_t4_ctr32_encrypt;\n            break;\n        case 256:\n            gctx-\u003ectr = (ctr128_f) aes256_t4_ctr32_encrypt;\n            break;\n        default:\n            return 0;\n        }\n        /*\n         * If we have an iv can set it directly, otherwise use saved IV.\n         */\n        if (iv == NULL \u0026\u0026 gctx-\u003eiv_set)\n            iv = gctx-\u003eiv;\n        if (iv) {\n            CRYPTO_gcm128_setiv(\u0026gctx-\u003egcm, iv, gctx-\u003eivlen);\n            gctx-\u003eiv_set = 1;\n        }\n        gctx-\u003ekey_set = 1;\n    } else {\n        /* If key set use IV, otherwise copy */\n        if (gctx-\u003ekey_set)\n            CRYPTO_gcm128_setiv(\u0026gctx-\u003egcm, iv, gctx-\u003eivlen);\n        else\n            memcpy(gctx-\u003eiv, iv, gctx-\u003eivlen);\n        gctx-\u003eiv_set = 1;\n        gctx-\u003eiv_gen = 0;\n    }\n    return 1;\n}","filepath":"crypto/evp/e_aes.c","line_number":751,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1l"},"270271376":{"score":0.7210083,"function_name":"aes_ccm_tls_cipher","code":"static int aes_ccm_tls_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\n                              const unsigned char *in, size_t len)\n{\n    EVP_AES_CCM_CTX *cctx = EVP_C_DATA(EVP_AES_CCM_CTX,ctx);\n    CCM128_CONTEXT *ccm = \u0026cctx-\u003eccm;\n    /* Encrypt/decrypt must be performed in place */\n    if (out != in || len \u003c (EVP_CCM_TLS_EXPLICIT_IV_LEN + (size_t)cctx-\u003eM))\n        return -1;\n    /* If encrypting set explicit IV from sequence number (start of AAD) */\n    if (EVP_CIPHER_CTX_encrypting(ctx))\n        memcpy(out, EVP_CIPHER_CTX_buf_noconst(ctx),\n               EVP_CCM_TLS_EXPLICIT_IV_LEN);\n    /* Get rest of IV from explicit IV */\n    memcpy(EVP_CIPHER_CTX_iv_noconst(ctx) + EVP_CCM_TLS_FIXED_IV_LEN, in,\n           EVP_CCM_TLS_EXPLICIT_IV_LEN);\n    /* Correct length value */\n    len -= EVP_CCM_TLS_EXPLICIT_IV_LEN + cctx-\u003eM;\n    if (CRYPTO_ccm128_setiv(ccm, EVP_CIPHER_CTX_iv_noconst(ctx), 15 - cctx-\u003eL,\n                            len))\n            return -1;\n    /* Use saved AAD */\n    CRYPTO_ccm128_aad(ccm, EVP_CIPHER_CTX_buf_noconst(ctx), cctx-\u003etls_aad_len);\n    /* Fix buffer to point to payload */\n    in += EVP_CCM_TLS_EXPLICIT_IV_LEN;\n    out += EVP_CCM_TLS_EXPLICIT_IV_LEN;\n    if (EVP_CIPHER_CTX_encrypting(ctx)) {\n        if (cctx-\u003estr ? CRYPTO_ccm128_encrypt_ccm64(ccm, in, out, len,\n                                                    cctx-\u003estr) :\n            CRYPTO_ccm128_encrypt(ccm, in, out, len))\n            return -1;\n        if (!CRYPTO_ccm128_tag(ccm, out + len, cctx-\u003eM))\n            return -1;\n        return len + EVP_CCM_TLS_EXPLICIT_IV_LEN + cctx-\u003eM;\n    } else {\n        if (cctx-\u003estr ? !CRYPTO_ccm128_decrypt_ccm64(ccm, in, out, len,\n                                                     cctx-\u003estr) :\n            !CRYPTO_ccm128_decrypt(ccm, in, out, len)) {\n            unsigned char tag[16];\n            if (CRYPTO_ccm128_tag(ccm, tag, cctx-\u003eM)) {\n                if (!CRYPTO_memcmp(tag, in + len, cctx-\u003eM))\n                    return len;\n            }\n        }\n        OPENSSL_cleanse(out, len);\n        return -1;\n    }\n}","filepath":"crypto/evp/e_aes.c","line_number":3645,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1l"},"270279360":{"score":0.8135854,"function_name":"aes_cfb1_cipher","code":"static int aes_cfb1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\n                           const unsigned char *in, size_t len)\n{\n    EVP_AES_KEY *dat = EVP_C_DATA(EVP_AES_KEY,ctx);\n\n    if (EVP_CIPHER_CTX_test_flags(ctx, EVP_CIPH_FLAG_LENGTH_BITS)) {\n        int num = EVP_CIPHER_CTX_num(ctx);\n        CRYPTO_cfb128_1_encrypt(in, out, len, \u0026dat-\u003eks,\n                                EVP_CIPHER_CTX_iv_noconst(ctx), \u0026num,\n                                EVP_CIPHER_CTX_encrypting(ctx), dat-\u003eblock);\n        EVP_CIPHER_CTX_set_num(ctx, num);\n        return 1;\n    }\n\n    while (len \u003e= MAXBITCHUNK) {\n        int num = EVP_CIPHER_CTX_num(ctx);\n        CRYPTO_cfb128_1_encrypt(in, out, MAXBITCHUNK * 8, \u0026dat-\u003eks,\n                                EVP_CIPHER_CTX_iv_noconst(ctx), \u0026num,\n                                EVP_CIPHER_CTX_encrypting(ctx), dat-\u003eblock);\n        EVP_CIPHER_CTX_set_num(ctx, num);\n        len -= MAXBITCHUNK;\n        out += MAXBITCHUNK;\n        in  += MAXBITCHUNK;\n    }\n    if (len) {\n        int num = EVP_CIPHER_CTX_num(ctx);\n        CRYPTO_cfb128_1_encrypt(in, out, len * 8, \u0026dat-\u003eks,\n                                EVP_CIPHER_CTX_iv_noconst(ctx), \u0026num,\n                                EVP_CIPHER_CTX_encrypting(ctx), dat-\u003eblock);\n        EVP_CIPHER_CTX_set_num(ctx, num);\n    }\n\n    return 1;\n}","filepath":"crypto/evp/e_aes.c","line_number":2775,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1l"},"270280240":{"score":0.8169512,"function_name":"chacha_init_key","code":"static int chacha_init_key(EVP_CIPHER_CTX *ctx,\n                           const unsigned char user_key[CHACHA_KEY_SIZE],\n                           const unsigned char iv[CHACHA_CTR_SIZE], int enc)\n{\n    EVP_CHACHA_KEY *key = data(ctx);\n    unsigned int i;\n\n    if (user_key)\n        for (i = 0; i \u003c CHACHA_KEY_SIZE; i+=4) {\n            key-\u003ekey.d[i/4] = CHACHA_U8TOU32(user_key+i);\n        }\n\n    if (iv)\n        for (i = 0; i \u003c CHACHA_CTR_SIZE; i+=4) {\n            key-\u003ecounter[i/4] = CHACHA_U8TOU32(iv+i);\n        }\n\n    key-\u003epartial_len = 0;\n\n    return 1;\n}","filepath":"crypto/evp/e_chacha20_poly1305.c","line_number":35,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270280416":{"score":0.87077373,"function_name":"chacha_cipher","code":"static int chacha_cipher(EVP_CIPHER_CTX * ctx, unsigned char *out,\n                         const unsigned char *inp, size_t len)\n{\n    EVP_CHACHA_KEY *key = data(ctx);\n    unsigned int n, rem, ctr32;\n\n    if ((n = key-\u003epartial_len)) {\n        while (len \u0026\u0026 n \u003c CHACHA_BLK_SIZE) {\n            *out++ = *inp++ ^ key-\u003ebuf[n++];\n            len--;\n        }\n        key-\u003epartial_len = n;\n\n        if (len == 0)\n            return 1;\n\n        if (n == CHACHA_BLK_SIZE) {\n            key-\u003epartial_len = 0;\n            key-\u003ecounter[0]++;\n            if (key-\u003ecounter[0] == 0)\n                key-\u003ecounter[1]++;\n        }\n    }\n\n    rem = (unsigned int)(len % CHACHA_BLK_SIZE);\n    len -= rem;\n    ctr32 = key-\u003ecounter[0];\n    while (len \u003e= CHACHA_BLK_SIZE) {\n        size_t blocks = len / CHACHA_BLK_SIZE;\n        /*\n         * 1\u003c\u003c28 is just a not-so-small yet not-so-large number...\n         * Below condition is practically never met, but it has to\n         * be checked for code correctness.\n         */\n        if (sizeof(size_t)\u003esizeof(unsigned int) \u0026\u0026 blocks\u003e(1U\u003c\u003c28))\n            blocks = (1U\u003c\u003c28);\n\n        /*\n         * As ChaCha20_ctr32 operates on 32-bit counter, caller\n         * has to handle overflow. 'if' below detects the\n         * overflow, which is then handled by limiting the\n         * amount of blocks to the exact overflow point...\n         */\n        ctr32 += (unsigned int)blocks;\n        if (ctr32 \u003c blocks) {\n            blocks -= ctr32;\n            ctr32 = 0;\n        }\n        blocks *= CHACHA_BLK_SIZE;\n        ChaCha20_ctr32(out, inp, blocks, key-\u003ekey.d, key-\u003ecounter);\n        len -= blocks;\n        inp += blocks;\n        out += blocks;\n\n        key-\u003ecounter[0] = ctr32;\n        if (ctr32 == 0) key-\u003ecounter[1]++;\n    }\n\n    if (rem) {\n        memset(key-\u003ebuf, 0, sizeof(key-\u003ebuf));\n        ChaCha20_ctr32(key-\u003ebuf, key-\u003ebuf, CHACHA_BLK_SIZE,\n                       key-\u003ekey.d, key-\u003ecounter);\n        for (n = 0; n \u003c rem; n++)\n            out[n] = inp[n] ^ key-\u003ebuf[n];\n        key-\u003epartial_len = rem;\n    }\n\n    return 1;\n}","filepath":"crypto/evp/e_chacha20_poly1305.c","line_number":57,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270280720":{"score":0.6877096,"function_name":"chacha20_poly1305_init_key","code":"static int chacha20_poly1305_init_key(EVP_CIPHER_CTX *ctx,\n                                      const unsigned char *inkey,\n                                      const unsigned char *iv, int enc)\n{\n    EVP_CHACHA_AEAD_CTX *actx = aead_data(ctx);\n\n    if (!inkey \u0026\u0026 !iv)\n        return 1;\n\n    actx-\u003elen.aad = 0;\n    actx-\u003elen.text = 0;\n    actx-\u003eaad = 0;\n    actx-\u003emac_inited = 0;\n    actx-\u003etls_payload_length = NO_TLS_PAYLOAD_LENGTH;\n\n    if (iv != NULL) {\n        unsigned char temp[CHACHA_CTR_SIZE] = { 0 };\n\n        /* pad on the left */\n        if (actx-\u003enonce_len \u003c= CHACHA_CTR_SIZE)\n            memcpy(temp + CHACHA_CTR_SIZE - actx-\u003enonce_len, iv,\n                   actx-\u003enonce_len);\n\n        chacha_init_key(ctx, inkey, temp, enc);\n\n        actx-\u003enonce[0] = actx-\u003ekey.counter[1];\n        actx-\u003enonce[1] = actx-\u003ekey.counter[2];\n        actx-\u003enonce[2] = actx-\u003ekey.counter[3];\n    } else {\n        chacha_init_key(ctx, inkey, NULL, enc);\n    }\n\n    return 1;\n}","filepath":"crypto/evp/e_chacha20_poly1305.c","line_number":165,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270282864":{"score":0.68959713,"function_name":"chacha20_poly1305_tls_cipher","code":"static int chacha20_poly1305_tls_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\n                                        const unsigned char *in, size_t len)\n{\n    EVP_CHACHA_AEAD_CTX *actx = aead_data(ctx);\n    size_t tail, tohash_len, buf_len, plen = actx-\u003etls_payload_length;\n    unsigned char *buf, *tohash, *ctr, storage[sizeof(zero) + 32];\n\n    if (len != plen + POLY1305_BLOCK_SIZE)\n        return -1;\n\n    buf = storage + ((0 - (size_t)storage) \u0026 15);   /* align */\n    ctr = buf + CHACHA_BLK_SIZE;\n    tohash = buf + CHACHA_BLK_SIZE - POLY1305_BLOCK_SIZE;\n\n#   ifdef XOR128_HELPERS\n    if (plen \u003c= 3 * CHACHA_BLK_SIZE) {\n        actx-\u003ekey.counter[0] = 0;\n        buf_len = (plen + 2 * CHACHA_BLK_SIZE - 1) \u0026 (0 - CHACHA_BLK_SIZE);\n        ChaCha20_ctr32(buf, zero, buf_len, actx-\u003ekey.key.d,\n                       actx-\u003ekey.counter);\n        Poly1305_Init(POLY1305_ctx(actx), buf);\n        actx-\u003ekey.partial_len = 0;\n        memcpy(tohash, actx-\u003etls_aad, POLY1305_BLOCK_SIZE);\n        tohash_len = POLY1305_BLOCK_SIZE;\n        actx-\u003elen.aad = EVP_AEAD_TLS1_AAD_LEN;\n        actx-\u003elen.text = plen;\n\n        if (plen) {\n            if (ctx-\u003eencrypt)\n                ctr = xor128_encrypt_n_pad(out, in, ctr, plen);\n            else\n                ctr = xor128_decrypt_n_pad(out, in, ctr, plen);\n\n            in += plen;\n            out += plen;\n            tohash_len = (size_t)(ctr - tohash);\n        }\n    }\n#   else\n    if (plen \u003c= CHACHA_BLK_SIZE) {\n        size_t i;\n\n        actx-\u003ekey.counter[0] = 0;\n        ChaCha20_ctr32(buf, zero, (buf_len = 2 * CHACHA_BLK_SIZE),\n                       actx-\u003ekey.key.d, actx-\u003ekey.counter);\n        Poly1305_Init(POLY1305_ctx(actx), buf);\n        actx-\u003ekey.partial_len = 0;\n        memcpy(tohash, actx-\u003etls_aad, POLY1305_BLOCK_SIZE);\n        tohash_len = POLY1305_BLOCK_SIZE;\n        actx-\u003elen.aad = EVP_AEAD_TLS1_AAD_LEN;\n        actx-\u003elen.text = plen;\n\n        if (ctx-\u003eencrypt) {\n            for (i = 0; i \u003c plen; i++) {\n                out[i] = ctr[i] ^= in[i];\n            }\n        } else {\n            for (i = 0; i \u003c plen; i++) {\n                unsigned char c = in[i];\n                out[i] = ctr[i] ^ c;\n                ctr[i] = c;\n            }\n        }\n\n        in += i;\n        out += i;\n\n        tail = (0 - i) \u0026 (POLY1305_BLOCK_SIZE - 1);\n        memset(ctr + i, 0, tail);\n        ctr += i + tail;\n        tohash_len += i + tail;\n    }\n#   endif\n    else {\n        actx-\u003ekey.counter[0] = 0;\n        ChaCha20_ctr32(buf, zero, (buf_len = CHACHA_BLK_SIZE),\n                       actx-\u003ekey.key.d, actx-\u003ekey.counter);\n        Poly1305_Init(POLY1305_ctx(actx), buf);\n        actx-\u003ekey.counter[0] = 1;\n        actx-\u003ekey.partial_len = 0;\n        Poly1305_Update(POLY1305_ctx(actx), actx-\u003etls_aad, POLY1305_BLOCK_SIZE);\n        tohash = ctr;\n        tohash_len = 0;\n        actx-\u003elen.aad = EVP_AEAD_TLS1_AAD_LEN;\n        actx-\u003elen.text = plen;\n\n        if (ctx-\u003eencrypt) {\n            ChaCha20_ctr32(out, in, plen, actx-\u003ekey.key.d, actx-\u003ekey.counter);\n            Poly1305_Update(POLY1305_ctx(actx), out, plen);\n        } else {\n            Poly1305_Update(POLY1305_ctx(actx), in, plen);\n            ChaCha20_ctr32(out, in, plen, actx-\u003ekey.key.d, actx-\u003ekey.counter);\n        }\n\n        in += plen;\n        out += plen;\n        tail = (0 - plen) \u0026 (POLY1305_BLOCK_SIZE - 1);\n        Poly1305_Update(POLY1305_ctx(actx), zero, tail);\n    }\n\n    {\n        const union {\n            long one;\n            char little;\n        } is_endian = { 1 };\n\n        if (is_endian.little) {\n            memcpy(ctr, (unsigned char *)\u0026actx-\u003elen, POLY1305_BLOCK_SIZE);\n        } else {\n            ctr[0]  = (unsigned char)(actx-\u003elen.aad);\n            ctr[1]  = (unsigned char)(actx-\u003elen.aad\u003e\u003e8);\n            ctr[2]  = (unsigned char)(actx-\u003elen.aad\u003e\u003e16);\n            ctr[3]  = (unsigned char)(actx-\u003elen.aad\u003e\u003e24);\n            ctr[4]  = (unsigned char)(actx-\u003elen.aad\u003e\u003e32);\n            ctr[5]  = (unsigned char)(actx-\u003elen.aad\u003e\u003e40);\n            ctr[6]  = (unsigned char)(actx-\u003elen.aad\u003e\u003e48);\n            ctr[7]  = (unsigned char)(actx-\u003elen.aad\u003e\u003e56);\n\n            ctr[8]  = (unsigned char)(actx-\u003elen.text);\n            ctr[9]  = (unsigned char)(actx-\u003elen.text\u003e\u003e8);\n            ctr[10] = (unsigned char)(actx-\u003elen.text\u003e\u003e16);\n            ctr[11] = (unsigned char)(actx-\u003elen.text\u003e\u003e24);\n            ctr[12] = (unsigned char)(actx-\u003elen.text\u003e\u003e32);\n            ctr[13] = (unsigned char)(actx-\u003elen.text\u003e\u003e40);\n            ctr[14] = (unsigned char)(actx-\u003elen.text\u003e\u003e48);\n            ctr[15] = (unsigned char)(actx-\u003elen.text\u003e\u003e56);\n        }\n        tohash_len += POLY1305_BLOCK_SIZE;\n    }\n\n    Poly1305_Update(POLY1305_ctx(actx), tohash, tohash_len);\n    OPENSSL_cleanse(buf, buf_len);\n    Poly1305_Final(POLY1305_ctx(actx), ctx-\u003eencrypt ? actx-\u003etag\n                                                    : tohash);\n\n    actx-\u003etls_payload_length = NO_TLS_PAYLOAD_LENGTH;\n\n    if (ctx-\u003eencrypt) {\n        memcpy(out, actx-\u003etag, POLY1305_BLOCK_SIZE);\n    } else {\n        if (CRYPTO_memcmp(tohash, in, POLY1305_BLOCK_SIZE)) {\n            memset(out - (len - POLY1305_BLOCK_SIZE), 0,\n                   len - POLY1305_BLOCK_SIZE);\n            return -1;\n        }\n    }\n\n    return len;\n}","filepath":"crypto/evp/e_chacha20_poly1305.c","line_number":212,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270287712":{"score":0.75435865,"function_name":"CONF_free","code":"void CONF_free(LHASH *conf)\n\t{\n\tCONF ctmp;\n\n\tif (default_CONF_method == NULL)\n\t\tdefault_CONF_method = NCONF_default();\n\n\tdefault_CONF_method-\u003einit(\u0026ctmp);\n\tctmp.data = conf;\n\tNCONF_free_data(\u0026ctmp);\n\t}","filepath":"crypto/conf/conf_lib.c","line_number":176,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"BEFORE_engine"},"270288128":{"score":0.8000103,"function_name":"NCONF_get_number_e","code":"int NCONF_get_number_e(CONF *conf,char *group,char *name,long *result)\n\t{\n\tchar *str;\n\n\tif (result == NULL)\n\t\t{\n\t\tCONFerr(CONF_F_NCONF_GET_NUMBER_E,ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn 0;\n\t\t}\n\n\tstr = NCONF_get_string(conf,group,name);\n\n\tif (str == NULL)\n\t\treturn 0;\n\n\tfor (;conf-\u003emeth-\u003eis_number(conf, *str);)\n\t\t{\n\t\t*result = (*result)*10 + conf-\u003emeth-\u003eto_int(conf, *str);\n\t\tstr++;\n\t\t}\n\n\treturn 1;\n\t}","filepath":"crypto/conf/conf_lib.c","line_number":327,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"BEFORE_engine"},"270288400":{"score":0.80260265,"function_name":"NCONF_get_section","code":"STACK_OF(CONF_VALUE) *NCONF_get_section(CONF *conf,char *section)\n\t{\n\tif (conf == NULL)\n\t\t{\n\t\tCONFerr(CONF_F_NCONF_GET_SECTION,CONF_R_NO_CONF);\n\t\treturn NULL;\n\t\t}\n\n\tif (section == NULL)\n\t\t{\n\t\tCONFerr(CONF_F_NCONF_GET_SECTION,CONF_R_NO_SECTION);\n\t\treturn NULL;\n\t\t}\n\n\treturn _CONF_get_section_values(conf, section);\n\t}","filepath":"crypto/conf/conf_lib.c","line_number":291,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"BEFORE_engine"},"270288496":{"score":0.61535025,"function_name":"NCONF_get_string","code":"char *NCONF_get_string(CONF *conf,char *group,char *name)\n\t{\n\tchar *s = _CONF_get_string(conf, group, name);\n\n        /* Since we may get a value from an environment variable even\n           if conf is NULL, let's check the value first */\n        if (s) return s;\n\n\tif (conf == NULL)\n\t\t{\n\t\tCONFerr(CONF_F_NCONF_GET_STRING,\n                        CONF_R_NO_CONF_OR_ENVIRONMENT_VARIABLE);\n\t\treturn NULL;\n\t\t}\n\tCONFerr(CONF_F_NCONF_GET_STRING,\n\t\tCONF_R_NO_VALUE);\n\treturn NULL;\n\t}","filepath":"crypto/conf/conf_lib.c","line_number":308,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"BEFORE_engine"},"270288608":{"score":0.8686215,"function_name":"NCONF_load","code":"int NCONF_load(CONF *conf, const char *file, long *eline)\n\t{\n\tif (conf == NULL)\n\t\t{\n\t\tCONFerr(CONF_F_NCONF_LOAD,CONF_R_NO_CONF);\n\t\treturn 0;\n\t\t}\n\n\treturn conf-\u003emeth-\u003eload(conf, file, eline);\n\t}","filepath":"crypto/conf/conf_lib.c","line_number":253,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"BEFORE_engine"},"270288656":{"score":0.85479486,"function_name":"NCONF_new","code":"CONF *NCONF_new(CONF_METHOD *meth)\n\t{\n\tCONF *ret;\n\n\tif (meth == NULL)\n\t\tmeth = NCONF_default();\n\n\tret = meth-\u003ecreate(meth);\n\tif (ret == NULL)\n\t\t{\n\t\tCONFerr(CONF_F_NCONF_NEW,ERR_R_MALLOC_FAILURE);\n\t\treturn(NULL);\n\t\t}\n\n\treturn ret;\n\t}","filepath":"crypto/conf/conf_lib.c","line_number":222,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"BEFORE_engine"},"270288752":{"score":0.89093757,"function_name":"DSO_bind_func","code":"DSO_FUNC_TYPE DSO_bind_func(DSO *dso, const char *symname)\n{\n    DSO_FUNC_TYPE ret = NULL;\n\n    if ((dso == NULL) || (symname == NULL)) {\n        DSOerr(DSO_F_DSO_BIND_FUNC, ERR_R_PASSED_NULL_PARAMETER);\n        return NULL;\n    }\n    if (dso-\u003emeth-\u003edso_bind_func == NULL) {\n        DSOerr(DSO_F_DSO_BIND_FUNC, DSO_R_UNSUPPORTED);\n        return NULL;\n    }\n    if ((ret = dso-\u003emeth-\u003edso_bind_func(dso, symname)) == NULL) {\n        DSOerr(DSO_F_DSO_BIND_FUNC, DSO_R_SYM_FAILURE);\n        return NULL;\n    }\n    /* Success */\n    return ret;\n}","filepath":"crypto/dso/dso_lib.c","line_number":173,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre1"},"270288880":{"score":0.8391258,"function_name":"DSO_convert_filename","code":"char *DSO_convert_filename(DSO *dso, const char *filename)\n{\n    char *result = NULL;\n\n    if (dso == NULL) {\n        DSOerr(DSO_F_DSO_CONVERT_FILENAME, ERR_R_PASSED_NULL_PARAMETER);\n        return NULL;\n    }\n    if (filename == NULL)\n        filename = dso-\u003efilename;\n    if (filename == NULL) {\n        DSOerr(DSO_F_DSO_CONVERT_FILENAME, DSO_R_NO_FILENAME);\n        return NULL;\n    }\n    if ((dso-\u003eflags \u0026 DSO_FLAG_NO_NAME_TRANSLATION) == 0) {\n        if (dso-\u003ename_converter != NULL)\n            result = dso-\u003ename_converter(dso, filename);\n        else if (dso-\u003emeth-\u003edso_name_converter != NULL)\n            result = dso-\u003emeth-\u003edso_name_converter(dso, filename);\n    }\n    if (result == NULL) {\n        result = OPENSSL_strdup(filename);\n        if (result == NULL) {\n            DSOerr(DSO_F_DSO_CONVERT_FILENAME, ERR_R_MALLOC_FAILURE);\n            return NULL;\n        }\n    }\n    return result;\n}","filepath":"crypto/dso/dso_lib.c","line_number":280,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre1"},"270289056":{"score":0.9098491,"function_name":"DSO_ctrl","code":"long DSO_ctrl(DSO *dso, int cmd, long larg, void *parg)\n{\n    if (dso == NULL) {\n        DSOerr(DSO_F_DSO_CTRL, ERR_R_PASSED_NULL_PARAMETER);\n        return -1;\n    }\n    /*\n     * We should intercept certain generic commands and only pass control to\n     * the method-specific ctrl() function if it's something we don't handle.\n     */\n    switch (cmd) {\n    case DSO_CTRL_GET_FLAGS:\n        return dso-\u003eflags;\n    case DSO_CTRL_SET_FLAGS:\n        dso-\u003eflags = (int)larg;\n        return 0;\n    case DSO_CTRL_OR_FLAGS:\n        dso-\u003eflags |= (int)larg;\n        return 0;\n    default:\n        break;\n    }\n    if ((dso-\u003emeth == NULL) || (dso-\u003emeth-\u003edso_ctrl == NULL)) {\n        DSOerr(DSO_F_DSO_CTRL, DSO_R_UNSUPPORTED);\n        return -1;\n    }\n    return dso-\u003emeth-\u003edso_ctrl(dso, cmd, larg, parg);\n}","filepath":"crypto/dso/dso_lib.c","line_number":202,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre1"},"270289200":{"score":0.7376714,"function_name":"DSO_free","code":"int DSO_free(DSO *dso)\n{\n    int i;\n\n    if (dso == NULL)\n        return 1;\n\n    if (CRYPTO_DOWN_REF(\u0026dso-\u003ereferences, \u0026i, dso-\u003elock) \u003c= 0)\n        return 0;\n\n    REF_PRINT_COUNT(\"DSO\", dso);\n    if (i \u003e 0)\n        return 1;\n    REF_ASSERT_ISNT(i \u003c 0);\n\n    if ((dso-\u003eflags \u0026 DSO_FLAG_NO_UNLOAD_ON_FREE) == 0) {\n        if ((dso-\u003emeth-\u003edso_unload != NULL) \u0026\u0026 !dso-\u003emeth-\u003edso_unload(dso)) {\n            DSOerr(DSO_F_DSO_FREE, DSO_R_UNLOAD_FAILED);\n            return 0;\n        }\n    }\n\n    if ((dso-\u003emeth-\u003efinish != NULL) \u0026\u0026 !dso-\u003emeth-\u003efinish(dso)) {\n        DSOerr(DSO_F_DSO_FREE, DSO_R_FINISH_FAILED);\n        return 0;\n    }\n\n    sk_void_free(dso-\u003emeth_data);\n    OPENSSL_free(dso-\u003efilename);\n    OPENSSL_free(dso-\u003eloaded_filename);\n    CRYPTO_THREAD_lock_free(dso-\u003elock);\n    OPENSSL_free(dso);\n    return 1;\n}","filepath":"crypto/dso/dso_lib.c","line_number":62,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre1"},"270289408":{"score":0.7556343,"function_name":"DSO_load","code":"DSO *DSO_load(DSO *dso, const char *filename, DSO_METHOD *meth, int flags)\n{\n    DSO *ret;\n    int allocated = 0;\n\n    if (dso == NULL) {\n        ret = DSO_new_method(meth);\n        if (ret == NULL) {\n            DSOerr(DSO_F_DSO_LOAD, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        allocated = 1;\n        /* Pass the provided flags to the new DSO object */\n        if (DSO_ctrl(ret, DSO_CTRL_SET_FLAGS, flags, NULL) \u003c 0) {\n            DSOerr(DSO_F_DSO_LOAD, DSO_R_CTRL_FAILED);\n            goto err;\n        }\n    } else\n        ret = dso;\n    /* Don't load if we're currently already loaded */\n    if (ret-\u003efilename != NULL) {\n        DSOerr(DSO_F_DSO_LOAD, DSO_R_DSO_ALREADY_LOADED);\n        goto err;\n    }\n    /*\n     * filename can only be NULL if we were passed a dso that already has one\n     * set.\n     */\n    if (filename != NULL)\n        if (!DSO_set_filename(ret, filename)) {\n            DSOerr(DSO_F_DSO_LOAD, DSO_R_SET_FILENAME_FAILED);\n            goto err;\n        }\n    filename = ret-\u003efilename;\n    if (filename == NULL) {\n        DSOerr(DSO_F_DSO_LOAD, DSO_R_NO_FILENAME);\n        goto err;\n    }\n    if (ret-\u003emeth-\u003edso_load == NULL) {\n        DSOerr(DSO_F_DSO_LOAD, DSO_R_UNSUPPORTED);\n        goto err;\n    }\n    if (!ret-\u003emeth-\u003edso_load(ret)) {\n        DSOerr(DSO_F_DSO_LOAD, DSO_R_LOAD_FAILED);\n        goto err;\n    }\n    /* Load succeeded */\n    return ret;\n err:\n    if (allocated)\n        DSO_free(ret);\n    return NULL;\n}","filepath":"crypto/dso/dso_lib.c","line_number":119,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre1"},"270289696":{"score":0.90447015,"function_name":"DSO_merge","code":"char *DSO_merge(DSO *dso, const char *filespec1, const char *filespec2)\n{\n    char *result = NULL;\n\n    if (dso == NULL || filespec1 == NULL) {\n        DSOerr(DSO_F_DSO_MERGE, ERR_R_PASSED_NULL_PARAMETER);\n        return NULL;\n    }\n    if ((dso-\u003eflags \u0026 DSO_FLAG_NO_NAME_TRANSLATION) == 0) {\n        if (dso-\u003emerger != NULL)\n            result = dso-\u003emerger(dso, filespec1, filespec2);\n        else if (dso-\u003emeth-\u003edso_merger != NULL)\n            result = dso-\u003emeth-\u003edso_merger(dso, filespec1, filespec2);\n    }\n    return result;\n}","filepath":"crypto/dso/dso_lib.c","line_number":263,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre1"},"270289808":{"score":0.92362165,"function_name":"DSO_new_method","code":"static DSO *DSO_new_method(DSO_METHOD *meth)\n{\n    DSO *ret;\n\n    if (default_DSO_meth == NULL) {\n        /*\n         * We default to DSO_METH_openssl() which in turn defaults to\n         * stealing the \"best available\" method. Will fallback to\n         * DSO_METH_null() in the worst case.\n         */\n        default_DSO_meth = DSO_METHOD_openssl();\n    }\n    ret = OPENSSL_zalloc(sizeof(*ret));\n    if (ret == NULL) {\n        DSOerr(DSO_F_DSO_NEW_METHOD, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    ret-\u003emeth_data = sk_void_new_null();\n    if (ret-\u003emeth_data == NULL) {\n        /* sk_new doesn't generate any errors so we do */\n        DSOerr(DSO_F_DSO_NEW_METHOD, ERR_R_MALLOC_FAILURE);\n        OPENSSL_free(ret);\n        return NULL;\n    }\n    ret-\u003emeth = default_DSO_meth;\n    ret-\u003ereferences = 1;\n    ret-\u003elock = CRYPTO_THREAD_lock_new();\n    if (ret-\u003elock == NULL) {\n        DSOerr(DSO_F_DSO_NEW_METHOD, ERR_R_MALLOC_FAILURE);\n        sk_void_free(ret-\u003emeth_data);\n        OPENSSL_free(ret);\n        return NULL;\n    }\n\n    if ((ret-\u003emeth-\u003einit != NULL) \u0026\u0026 !ret-\u003emeth-\u003einit(ret)) {\n        DSO_free(ret);\n        ret = NULL;\n    }\n\n    return ret;\n}","filepath":"crypto/dso/dso_lib.c","line_number":15,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre1"},"270291968":{"score":0.8643096,"function_name":"try_decode_PKCS12","code":"static OSSL_STORE_INFO *try_decode_PKCS12(const char *pem_name,\n                                          const char *pem_header,\n                                          const unsigned char *blob,\n                                          size_t len, void **pctx,\n                                          int *matchcount,\n                                          const UI_METHOD *ui_method,\n                                          void *ui_data)\n{\n    OSSL_STORE_INFO *store_info = NULL;\n    STACK_OF(OSSL_STORE_INFO) *ctx = *pctx;\n\n    if (ctx == NULL) {\n        /* Initial parsing */\n        PKCS12 *p12;\n        int ok = 0;\n\n        if (pem_name != NULL)\n            /* No match, there is no PEM PKCS12 tag */\n            return NULL;\n\n        if ((p12 = d2i_PKCS12(NULL, \u0026blob, len)) != NULL) {\n            char *pass = NULL;\n            char tpass[PEM_BUFSIZE];\n            EVP_PKEY *pkey = NULL;\n            X509 *cert = NULL;\n            STACK_OF(X509) *chain = NULL;\n\n            *matchcount = 1;\n\n            if (PKCS12_verify_mac(p12, \"\", 0)\n                || PKCS12_verify_mac(p12, NULL, 0)) {\n                pass = \"\";\n            } else {\n                if ((pass = file_get_pass(ui_method, tpass, PEM_BUFSIZE,\n                                          \"PKCS12 import password\",\n                                          ui_data)) == NULL) {\n                    OSSL_STOREerr(OSSL_STORE_F_TRY_DECODE_PKCS12,\n                                  OSSL_STORE_R_PASSPHRASE_CALLBACK_ERROR);\n                    goto p12_end;\n                }\n                if (!PKCS12_verify_mac(p12, pass, strlen(pass))) {\n                    OSSL_STOREerr(OSSL_STORE_F_TRY_DECODE_PKCS12,\n                                  OSSL_STORE_R_ERROR_VERIFYING_PKCS12_MAC);\n                    goto p12_end;\n                }\n            }\n\n            if (PKCS12_parse(p12, pass, \u0026pkey, \u0026cert, \u0026chain)) {\n                OSSL_STORE_INFO *osi_pkey = NULL;\n                OSSL_STORE_INFO *osi_cert = NULL;\n                OSSL_STORE_INFO *osi_ca = NULL;\n\n                if ((ctx = sk_OSSL_STORE_INFO_new_null()) != NULL\n                    \u0026\u0026 (osi_pkey = OSSL_STORE_INFO_new_PKEY(pkey)) != NULL\n                    \u0026\u0026 sk_OSSL_STORE_INFO_push(ctx, osi_pkey) != 0\n                    \u0026\u0026 (osi_cert = OSSL_STORE_INFO_new_CERT(cert)) != NULL\n                    \u0026\u0026 sk_OSSL_STORE_INFO_push(ctx, osi_cert) != 0) {\n                    ok = 1;\n                    osi_pkey = NULL;\n                    osi_cert = NULL;\n\n                    while(sk_X509_num(chain) \u003e 0) {\n                        X509 *ca = sk_X509_value(chain, 0);\n\n                        if ((osi_ca = OSSL_STORE_INFO_new_CERT(ca)) == NULL\n                            || sk_OSSL_STORE_INFO_push(ctx, osi_ca) == 0) {\n                            ok = 0;\n                            break;\n                        }\n                        osi_ca = NULL;\n                        (void)sk_X509_shift(chain);\n                    }\n                }\n                if (!ok) {\n                    OSSL_STORE_INFO_free(osi_ca);\n                    OSSL_STORE_INFO_free(osi_cert);\n                    OSSL_STORE_INFO_free(osi_pkey);\n                    sk_OSSL_STORE_INFO_pop_free(ctx, OSSL_STORE_INFO_free);\n                    EVP_PKEY_free(pkey);\n                    X509_free(cert);\n                    sk_X509_pop_free(chain, X509_free);\n                    ctx = NULL;\n                }\n                *pctx = ctx;\n            }\n        }\n     p12_end:\n        PKCS12_free(p12);\n        if (!ok)\n            return NULL;\n    }\n\n    if (ctx != NULL) {\n        *matchcount = 1;\n        store_info = sk_OSSL_STORE_INFO_shift(ctx);\n    }\n\n    return store_info;\n}","filepath":"openssl/crypto/store/loader_file.c","line_number":195,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.47"},"270292752":{"score":0.87112427,"function_name":"try_decode_PKCS8Encrypted","code":"static OSSL_STORE_INFO *try_decode_PKCS8Encrypted(const char *pem_name,\n                                                  const char *pem_header,\n                                                  const unsigned char *blob,\n                                                  size_t len, void **pctx,\n                                                  int *matchcount,\n                                                  const UI_METHOD *ui_method,\n                                                  void *ui_data)\n{\n    X509_SIG *p8 = NULL;\n    char kbuf[PEM_BUFSIZE];\n    char *pass = NULL;\n    const X509_ALGOR *dalg = NULL;\n    const ASN1_OCTET_STRING *doct = NULL;\n    OSSL_STORE_INFO *store_info = NULL;\n    BUF_MEM *mem = NULL;\n    unsigned char *new_data = NULL;\n    int new_data_len;\n\n    if (pem_name != NULL) {\n        if (strcmp(pem_name, PEM_STRING_PKCS8) != 0)\n            return NULL;\n        *matchcount = 1;\n    }\n\n    if ((p8 = d2i_X509_SIG(NULL, \u0026blob, len)) == NULL)\n        return NULL;\n\n    *matchcount = 1;\n\n    if ((mem = BUF_MEM_new()) == NULL) {\n        OSSL_STOREerr(OSSL_STORE_F_TRY_DECODE_PKCS8ENCRYPTED,\n                      ERR_R_MALLOC_FAILURE);\n        goto nop8;\n    }\n\n    if ((pass = file_get_pass(ui_method, kbuf, PEM_BUFSIZE,\n                              \"PKCS8 decrypt password\", ui_data)) == NULL) {\n        OSSL_STOREerr(OSSL_STORE_F_TRY_DECODE_PKCS8ENCRYPTED,\n                      OSSL_STORE_R_BAD_PASSWORD_READ);\n        goto nop8;\n    }\n\n    X509_SIG_get0(p8, \u0026dalg, \u0026doct);\n    if (!PKCS12_pbe_crypt(dalg, pass, strlen(pass), doct-\u003edata, doct-\u003elength,\n                          \u0026new_data, \u0026new_data_len, 0))\n        goto nop8;\n\n    mem-\u003edata = (char *)new_data;\n    mem-\u003emax = mem-\u003elength = (size_t)new_data_len;\n    X509_SIG_free(p8);\n\n    store_info = ossl_store_info_new_EMBEDDED(PEM_STRING_PKCS8INF, mem);\n    if (store_info == NULL) {\n        OSSL_STOREerr(OSSL_STORE_F_TRY_DECODE_PKCS8ENCRYPTED,\n                      ERR_R_MALLOC_FAILURE);\n        goto nop8;\n    }\n\n    return store_info;\n nop8:\n    X509_SIG_free(p8);\n    BUF_MEM_free(mem);\n    return NULL;\n}","filepath":"openssl/crypto/store/loader_file.c","line_number":323,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.47"},"270294512":{"score":0.80333817,"function_name":"file_open","code":"static OSSL_STORE_LOADER_CTX *file_open(const OSSL_STORE_LOADER *loader,\n                                        const char *uri,\n                                        const UI_METHOD *ui_method,\n                                        void *ui_data)\n{\n    OSSL_STORE_LOADER_CTX *ctx = NULL;\n    struct stat st;\n    struct {\n        const char *path;\n        unsigned int check_absolute:1;\n    } path_data[2];\n    size_t path_data_n = 0, i;\n    const char *path;\n\n    /*\n     * First step, just take the URI as is.\n     */\n    path_data[path_data_n].check_absolute = 0;\n    path_data[path_data_n++].path = uri;\n\n    /*\n     * Second step, if the URI appears to start with the 'file' scheme,\n     * extract the path and make that the second path to check.\n     * There's a special case if the URI also contains an authority, then\n     * the full URI shouldn't be used as a path anywhere.\n     */\n    if (strncasecmp(uri, \"file:\", 5) == 0) {\n        const char *p = \u0026uri[5];\n\n        if (strncmp(\u0026uri[5], \"//\", 2) == 0) {\n            path_data_n--;           /* Invalidate using the full URI */\n            if (strncasecmp(\u0026uri[7], \"localhost/\", 10) == 0) {\n                p = \u0026uri[16];\n            } else if (uri[7] == '/') {\n                p = \u0026uri[7];\n            } else {\n                OSSL_STOREerr(OSSL_STORE_F_FILE_OPEN,\n                              OSSL_STORE_R_URI_AUTHORITY_UNSUPPORTED);\n                return NULL;\n            }\n        }\n\n        path_data[path_data_n].check_absolute = 1;\n#ifdef _WIN32\n        /* Windows file: URIs with a drive letter start with a / */\n        if (p[0] == '/' \u0026\u0026 p[2] == ':' \u0026\u0026 p[3] == '/') {\n            char c = ossl_tolower(p[1]);\n\n            if (c \u003e= 'a' \u0026\u0026 c \u003c= 'z') {\n                p++;\n                /* We know it's absolute, so no need to check */\n                path_data[path_data_n].check_absolute = 0;\n            }\n        }\n#endif\n        path_data[path_data_n++].path = p;\n    }\n\n\n    for (i = 0, path = NULL; path == NULL \u0026\u0026 i \u003c path_data_n; i++) {\n        /*\n         * If the scheme \"file\" was an explicit part of the URI, the path must\n         * be absolute.  So says RFC 8089\n         */\n        if (path_data[i].check_absolute \u0026\u0026 path_data[i].path[0] != '/') {\n            OSSL_STOREerr(OSSL_STORE_F_FILE_OPEN,\n                          OSSL_STORE_R_PATH_MUST_BE_ABSOLUTE);\n            ERR_add_error_data(1, path_data[i].path);\n            return NULL;\n        }\n\n        if (stat(path_data[i].path, \u0026st) \u003c 0) {\n            SYSerr(SYS_F_STAT, errno);\n            ERR_add_error_data(1, path_data[i].path);\n        } else {\n            path = path_data[i].path;\n        }\n    }\n    if (path == NULL) {\n        return NULL;\n    }\n\n    /* Successfully found a working path, clear possible collected errors */\n    ERR_clear_error();\n\n    ctx = OPENSSL_zalloc(sizeof(*ctx));\n    if (ctx == NULL) {\n        OSSL_STOREerr(OSSL_STORE_F_FILE_OPEN, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    if (S_ISDIR(st.st_mode)) {\n        /*\n         * Try to copy everything, even if we know that some of them must be\n         * NULL for the moment.  This prevents errors in the future, when more\n         * components may be used.\n         */\n        ctx-\u003e_.dir.uri = OPENSSL_strdup(uri);\n        ctx-\u003etype = is_dir;\n\n        if (ctx-\u003e_.dir.uri == NULL)\n            goto err;\n\n        ctx-\u003e_.dir.last_entry = OPENSSL_DIR_read(\u0026ctx-\u003e_.dir.ctx, path);\n        ctx-\u003e_.dir.last_errno = errno;\n        if (ctx-\u003e_.dir.last_entry == NULL) {\n            if (ctx-\u003e_.dir.last_errno != 0) {\n                char errbuf[256];\n                OSSL_STOREerr(OSSL_STORE_F_FILE_OPEN, ERR_R_SYS_LIB);\n                errno = ctx-\u003e_.dir.last_errno;\n                if (openssl_strerror_r(errno, errbuf, sizeof(errbuf)))\n                    ERR_add_error_data(1, errbuf);\n                goto err;\n            }\n            ctx-\u003e_.dir.end_reached = 1;\n        }\n    } else {\n        BIO *buff = NULL;\n        char peekbuf[4096] = { 0, };\n\n        if ((buff = BIO_new(BIO_f_buffer())) == NULL\n            || (ctx-\u003e_.file.file = BIO_new_file(path, \"rb\")) == NULL) {\n            BIO_free_all(buff);\n            goto err;\n        }\n\n        ctx-\u003e_.file.file = BIO_push(buff, ctx-\u003e_.file.file);\n        if (BIO_buffer_peek(ctx-\u003e_.file.file, peekbuf, sizeof(peekbuf) - 1) \u003e 0) {\n            peekbuf[sizeof(peekbuf) - 1] = '\\0';\n            if (strstr(peekbuf, \"-----BEGIN \") != NULL)\n                ctx-\u003etype = is_pem;\n        }\n    }\n\n    return ctx;\n err:\n    OSSL_STORE_LOADER_CTX_free(ctx);\n    return NULL;\n}","filepath":"openssl/crypto/store/loader_file.c","line_number":755,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.47"},"270295648":{"score":0.7472321,"function_name":"file_load","code":"static OSSL_STORE_INFO *file_load(OSSL_STORE_LOADER_CTX *ctx,\n                                  const UI_METHOD *ui_method, void *ui_data)\n{\n    OSSL_STORE_INFO *result = NULL;\n\n    ctx-\u003eerrcnt = 0;\n    ERR_clear_error();\n\n    if (ctx-\u003etype == is_dir) {\n        do {\n            char *newname = NULL;\n\n            if (ctx-\u003e_.dir.last_entry == NULL) {\n                if (!ctx-\u003e_.dir.end_reached) {\n                    char errbuf[256];\n                    assert(ctx-\u003e_.dir.last_errno != 0);\n                    OSSL_STOREerr(OSSL_STORE_F_FILE_LOAD, ERR_R_SYS_LIB);\n                    errno = ctx-\u003e_.dir.last_errno;\n                    ctx-\u003eerrcnt++;\n                    if (openssl_strerror_r(errno, errbuf, sizeof(errbuf)))\n                        ERR_add_error_data(1, errbuf);\n                }\n                return NULL;\n            }\n\n            if (ctx-\u003e_.dir.last_entry[0] != '.'\n                \u0026\u0026 file_name_check(ctx, ctx-\u003e_.dir.last_entry)\n                \u0026\u0026 !file_name_to_uri(ctx, ctx-\u003e_.dir.last_entry, \u0026newname))\n                return NULL;\n\n            /*\n             * On the first call (with a NULL context), OPENSSL_DIR_read()\n             * cares about the second argument.  On the following calls, it\n             * only cares that it isn't NULL.  Therefore, we can safely give\n             * it our URI here.\n             */\n            ctx-\u003e_.dir.last_entry = OPENSSL_DIR_read(\u0026ctx-\u003e_.dir.ctx,\n                                                     ctx-\u003e_.dir.uri);\n            ctx-\u003e_.dir.last_errno = errno;\n            if (ctx-\u003e_.dir.last_entry == NULL \u0026\u0026 ctx-\u003e_.dir.last_errno == 0)\n                ctx-\u003e_.dir.end_reached = 1;\n\n            if (newname != NULL\n                \u0026\u0026 (result = OSSL_STORE_INFO_new_NAME(newname)) == NULL) {\n                OPENSSL_free(newname);\n                OSSL_STOREerr(OSSL_STORE_F_FILE_LOAD, ERR_R_OSSL_STORE_LIB);\n                return NULL;\n            }\n        } while (result == NULL \u0026\u0026 !file_eof(ctx));\n    } else {\n        int matchcount = -1;\n\n     again:\n        result = file_load_try_repeat(ctx, ui_method, ui_data);\n        if (result != NULL)\n            return result;\n\n        if (file_eof(ctx))\n            return NULL;\n\n        do {\n            char *pem_name = NULL;      /* PEM record name */\n            char *pem_header = NULL;    /* PEM record header */\n            unsigned char *data = NULL; /* DER encoded data */\n            long len = 0;               /* DER encoded data length */\n\n            matchcount = -1;\n            if (ctx-\u003etype == is_pem) {\n                if (!file_read_pem(ctx-\u003e_.file.file, \u0026pem_name, \u0026pem_header,\n                                   \u0026data, \u0026len, ui_method, ui_data,\n                                   (ctx-\u003eflags \u0026 FILE_FLAG_SECMEM) != 0)) {\n                    ctx-\u003eerrcnt++;\n                    goto endloop;\n                }\n            } else {\n                if (!file_read_asn1(ctx-\u003e_.file.file, \u0026data, \u0026len)) {\n                    ctx-\u003eerrcnt++;\n                    goto endloop;\n                }\n            }\n\n            result = file_load_try_decode(ctx, pem_name, pem_header, data, len,\n                                          ui_method, ui_data, \u0026matchcount);\n\n            if (result != NULL)\n                goto endloop;\n\n            /*\n             * If a PEM name matches more than one handler, the handlers are\n             * badly coded.\n             */\n            if (!ossl_assert(pem_name == NULL || matchcount \u003c= 1)) {\n                ctx-\u003eerrcnt++;\n                goto endloop;\n            }\n\n            if (matchcount \u003e 1) {\n                OSSL_STOREerr(OSSL_STORE_F_FILE_LOAD,\n                              OSSL_STORE_R_AMBIGUOUS_CONTENT_TYPE);\n            } else if (matchcount == 1) {\n                /*\n                 * If there are other errors on the stack, they already show\n                 * what the problem is.\n                 */\n                if (ERR_peek_error() == 0) {\n                    OSSL_STOREerr(OSSL_STORE_F_FILE_LOAD,\n                                  OSSL_STORE_R_UNSUPPORTED_CONTENT_TYPE);\n                    if (pem_name != NULL)\n                        ERR_add_error_data(3, \"PEM type is '\", pem_name, \"'\");\n                }\n            }\n            if (matchcount \u003e 0)\n                ctx-\u003eerrcnt++;\n\n         endloop:\n            pem_free_flag(pem_name, (ctx-\u003eflags \u0026 FILE_FLAG_SECMEM) != 0, 0);\n            pem_free_flag(pem_header, (ctx-\u003eflags \u0026 FILE_FLAG_SECMEM) != 0, 0);\n            pem_free_flag(data, (ctx-\u003eflags \u0026 FILE_FLAG_SECMEM) != 0, len);\n        } while (matchcount == 0 \u0026\u0026 !file_eof(ctx) \u0026\u0026 !file_error(ctx));\n\n        /* We bail out on ambiguity */\n        if (matchcount \u003e 1)\n            return NULL;\n\n        if (result != NULL\n            \u0026\u0026 ctx-\u003eexpected_type != 0\n            \u0026\u0026 ctx-\u003eexpected_type != OSSL_STORE_INFO_get_type(result)) {\n            OSSL_STORE_INFO_free(result);\n            goto again;\n        }\n    }\n\n    return result;\n}","filepath":"openssl/crypto/store/loader_file.c","line_number":1247,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.47"},"270297392":{"score":0.8834002,"function_name":"OSSL_STORE_LOADER_CTX_free","code":"static void OSSL_STORE_LOADER_CTX_free(OSSL_STORE_LOADER_CTX *ctx)\n{\n    if (ctx-\u003etype == is_dir) {\n        OPENSSL_free(ctx-\u003e_.dir.uri);\n    } else {\n        if (ctx-\u003e_.file.last_handler != NULL) {\n            ctx-\u003e_.file.last_handler-\u003edestroy_ctx(\u0026ctx-\u003e_.file.last_handler_ctx);\n            ctx-\u003e_.file.last_handler_ctx = NULL;\n            ctx-\u003e_.file.last_handler = NULL;\n        }\n    }\n    OPENSSL_free(ctx);\n}","filepath":"openssl/crypto/store/loader_file.c","line_number":741,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.47"},"270297488":{"score":0.88859713,"function_name":"file_get_pass","code":"static char *file_get_pass(const UI_METHOD *ui_method, char *pass,\n                           size_t maxsize, const char *prompt_info, void *data)\n{\n    UI *ui = UI_new();\n    char *prompt = NULL;\n\n    if (ui == NULL) {\n        OSSL_STOREerr(OSSL_STORE_F_FILE_GET_PASS, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    if (ui_method != NULL)\n        UI_set_method(ui, ui_method);\n    UI_add_user_data(ui, data);\n\n    if ((prompt = UI_construct_prompt(ui, \"pass phrase\",\n                                      prompt_info)) == NULL) {\n        OSSL_STOREerr(OSSL_STORE_F_FILE_GET_PASS, ERR_R_MALLOC_FAILURE);\n        pass = NULL;\n    } else if (!UI_add_input_string(ui, prompt, UI_INPUT_FLAG_DEFAULT_PWD,\n                                    pass, 0, maxsize - 1)) {\n        OSSL_STOREerr(OSSL_STORE_F_FILE_GET_PASS, ERR_R_UI_LIB);\n        pass = NULL;\n    } else {\n        switch (UI_process(ui)) {\n        case -2:\n            OSSL_STOREerr(OSSL_STORE_F_FILE_GET_PASS,\n                          OSSL_STORE_R_UI_PROCESS_INTERRUPTED_OR_CANCELLED);\n            pass = NULL;\n            break;\n        case -1:\n            OSSL_STOREerr(OSSL_STORE_F_FILE_GET_PASS, ERR_R_UI_LIB);\n            pass = NULL;\n            break;\n        default:\n            break;\n        }\n    }\n\n    OPENSSL_free(prompt);\n    UI_free(ui);\n    return pass;\n}","filepath":"openssl/crypto/store/loader_file.c","line_number":47,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.47"},"270297760":{"score":0.89263386,"function_name":"file_load_try_decode","code":"static OSSL_STORE_INFO *file_load_try_decode(OSSL_STORE_LOADER_CTX *ctx,\n                                             const char *pem_name,\n                                             const char *pem_header,\n                                             unsigned char *data, size_t len,\n                                             const UI_METHOD *ui_method,\n                                             void *ui_data, int *matchcount)\n{\n    OSSL_STORE_INFO *result = NULL;\n    BUF_MEM *new_mem = NULL;\n    char *new_pem_name = NULL;\n    int t = 0;\n\n again:\n    {\n        size_t i = 0;\n        void *handler_ctx = NULL;\n        const FILE_HANDLER **matching_handlers =\n            OPENSSL_zalloc(sizeof(*matching_handlers)\n                           * OSSL_NELEM(file_handlers));\n\n        if (matching_handlers == NULL) {\n            OSSL_STOREerr(OSSL_STORE_F_FILE_LOAD_TRY_DECODE,\n                          ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        *matchcount = 0;\n        for (i = 0; i \u003c OSSL_NELEM(file_handlers); i++) {\n            const FILE_HANDLER *handler = file_handlers[i];\n            int try_matchcount = 0;\n            void *tmp_handler_ctx = NULL;\n            OSSL_STORE_INFO *tmp_result =\n                handler-\u003etry_decode(pem_name, pem_header, data, len,\n                                    \u0026tmp_handler_ctx, \u0026try_matchcount,\n                                    ui_method, ui_data);\n\n            if (try_matchcount \u003e 0) {\n\n                matching_handlers[*matchcount] = handler;\n\n                if (handler_ctx)\n                    handler-\u003edestroy_ctx(\u0026handler_ctx);\n                handler_ctx = tmp_handler_ctx;\n\n                if ((*matchcount += try_matchcount) \u003e 1) {\n                    /* more than one match =\u003e ambiguous, kill any result */\n                    OSSL_STORE_INFO_free(result);\n                    OSSL_STORE_INFO_free(tmp_result);\n                    if (handler-\u003edestroy_ctx != NULL)\n                        handler-\u003edestroy_ctx(\u0026handler_ctx);\n                    handler_ctx = NULL;\n                    tmp_result = NULL;\n                    result = NULL;\n                }\n                if (result == NULL)\n                    result = tmp_result;\n            }\n        }\n\n        if (*matchcount == 1 \u0026\u0026 matching_handlers[0]-\u003erepeatable) {\n            ctx-\u003e_.file.last_handler = matching_handlers[0];\n            ctx-\u003e_.file.last_handler_ctx = handler_ctx;\n        }\n\n        OPENSSL_free(matching_handlers);\n    }\n\n err:\n    OPENSSL_free(new_pem_name);\n    BUF_MEM_free(new_mem);\n\n    if (result != NULL\n        \u0026\u0026 (t = OSSL_STORE_INFO_get_type(result)) == OSSL_STORE_INFO_EMBEDDED) {\n        pem_name = new_pem_name =\n            ossl_store_info_get0_EMBEDDED_pem_name(result);\n        new_mem = ossl_store_info_get0_EMBEDDED_buffer(result);\n        data = (unsigned char *)new_mem-\u003edata;\n        len = new_mem-\u003elength;\n        OPENSSL_free(result);\n        result = NULL;\n        goto again;\n    }\n\n    if (result != NULL)\n        ERR_clear_error();\n\n    return result;\n}","filepath":"openssl/crypto/store/loader_file.c","line_number":980,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.47"},"270298528":{"score":0.9257219,"function_name":"BN_GENCB_call","code":"int BN_GENCB_call(BN_GENCB *cb, int a, int b)\n{\n    /* No callback means continue */\n    if (!cb)\n        return 1;\n    switch (cb-\u003ever) {\n    case 1:\n        /* Deprecated-style callbacks */\n        if (!cb-\u003ecb.cb_1)\n            return 1;\n        cb-\u003ecb.cb_1(a, b, cb-\u003earg);\n        return 1;\n    case 2:\n        /* New-style callbacks */\n        return cb-\u003ecb.cb_2(a, b, cb);\n    default:\n        break;\n    }\n    /* Unrecognised callback type */\n    return 0;\n}","filepath":"crypto/bn/bn_prime.c","line_number":30,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270298608":{"score":0.8516888,"function_name":"BN_generate_prime_ex","code":"int BN_generate_prime_ex(BIGNUM *ret, int bits, int safe,\n                         const BIGNUM *add, const BIGNUM *rem, BN_GENCB *cb)\n{\n    BIGNUM *t;\n    int found = 0;\n    int i, j, c1 = 0;\n    BN_CTX *ctx = NULL;\n    prime_t *mods = NULL;\n    int checks = BN_prime_checks_for_size(bits);\n\n    if (bits \u003c 2) {\n        /* There are no prime numbers this small. */\n        BNerr(BN_F_BN_GENERATE_PRIME_EX, BN_R_BITS_TOO_SMALL);\n        return 0;\n    } else if (add == NULL \u0026\u0026 safe \u0026\u0026 bits \u003c 6 \u0026\u0026 bits != 3) {\n        /*\n         * The smallest safe prime (7) is three bits.\n         * But the following two safe primes with less than 6 bits (11, 23)\n         * are unreachable for BN_rand with BN_RAND_TOP_TWO.\n         */\n        BNerr(BN_F_BN_GENERATE_PRIME_EX, BN_R_BITS_TOO_SMALL);\n        return 0;\n    }\n\n    mods = OPENSSL_zalloc(sizeof(*mods) * NUMPRIMES);\n    if (mods == NULL)\n        goto err;\n\n    ctx = BN_CTX_new();\n    if (ctx == NULL)\n        goto err;\n    BN_CTX_start(ctx);\n    t = BN_CTX_get(ctx);\n    if (t == NULL)\n        goto err;\n loop:\n    /* make a random number and set the top and bottom bits */\n    if (add == NULL) {\n        if (!probable_prime(ret, bits, mods))\n            goto err;\n    } else {\n        if (safe) {\n            if (!probable_prime_dh_safe(ret, bits, add, rem, ctx))\n                goto err;\n        } else {\n            if (!bn_probable_prime_dh(ret, bits, add, rem, ctx))\n                goto err;\n        }\n    }\n\n    if (!BN_GENCB_call(cb, 0, c1++))\n        /* aborted */\n        goto err;\n\n    if (!safe) {\n        i = BN_is_prime_fasttest_ex(ret, checks, ctx, 0, cb);\n        if (i == -1)\n            goto err;\n        if (i == 0)\n            goto loop;\n    } else {\n        /*\n         * for \"safe prime\" generation, check that (p-1)/2 is prime. Since a\n         * prime is odd, We just need to divide by 2\n         */\n        if (!BN_rshift1(t, ret))\n            goto err;\n\n        for (i = 0; i \u003c checks; i++) {\n            j = BN_is_prime_fasttest_ex(ret, 1, ctx, 0, cb);\n            if (j == -1)\n                goto err;\n            if (j == 0)\n                goto loop;\n\n            j = BN_is_prime_fasttest_ex(t, 1, ctx, 0, cb);\n            if (j == -1)\n                goto err;\n            if (j == 0)\n                goto loop;\n\n            if (!BN_GENCB_call(cb, 2, c1 - 1))\n                goto err;\n            /* We have a safe prime test pass */\n        }\n    }\n    /* we have a prime :-) */\n    found = 1;\n err:\n    OPENSSL_free(mods);\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    bn_check_top(ret);\n    return found;\n}","filepath":"crypto/bn/bn_prime.c","line_number":52,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270299856":{"score":0.8498399,"function_name":"BN_is_prime_fasttest_ex","code":"int BN_is_prime_fasttest_ex(const BIGNUM *a, int checks, BN_CTX *ctx_passed,\n                            int do_trial_division, BN_GENCB *cb)\n{\n    int i, j, ret = -1;\n    int k;\n    BN_CTX *ctx = NULL;\n    BIGNUM *A1, *A1_odd, *A3, *check; /* taken from ctx */\n    BN_MONT_CTX *mont = NULL;\n\n    /* Take care of the really small primes 2 \u0026 3 */\n    if (BN_is_word(a, 2) || BN_is_word(a, 3))\n        return 1;\n\n    /* Check odd and bigger than 1 */\n    if (!BN_is_odd(a) || BN_cmp(a, BN_value_one()) \u003c= 0)\n        return 0;\n\n    if (checks == BN_prime_checks)\n        checks = BN_prime_checks_for_size(BN_num_bits(a));\n\n    /* first look for small factors */\n    if (do_trial_division) {\n        for (i = 1; i \u003c NUMPRIMES; i++) {\n            BN_ULONG mod = BN_mod_word(a, primes[i]);\n            if (mod == (BN_ULONG)-1)\n                goto err;\n            if (mod == 0)\n                return BN_is_word(a, primes[i]);\n        }\n        if (!BN_GENCB_call(cb, 1, -1))\n            goto err;\n    }\n\n    if (ctx_passed != NULL)\n        ctx = ctx_passed;\n    else if ((ctx = BN_CTX_new()) == NULL)\n        goto err;\n    BN_CTX_start(ctx);\n\n    A1 = BN_CTX_get(ctx);\n    A3 = BN_CTX_get(ctx);\n    A1_odd = BN_CTX_get(ctx);\n    check = BN_CTX_get(ctx);\n    if (check == NULL)\n        goto err;\n\n    /* compute A1 := a - 1 */\n    if (!BN_copy(A1, a) || !BN_sub_word(A1, 1))\n        goto err;\n    /* compute A3 := a - 3 */\n    if (!BN_copy(A3, a) || !BN_sub_word(A3, 3))\n        goto err;\n\n    /* write  A1  as  A1_odd * 2^k */\n    k = 1;\n    while (!BN_is_bit_set(A1, k))\n        k++;\n    if (!BN_rshift(A1_odd, A1, k))\n        goto err;\n\n    /* Montgomery setup for computations mod a */\n    mont = BN_MONT_CTX_new();\n    if (mont == NULL)\n        goto err;\n    if (!BN_MONT_CTX_set(mont, a, ctx))\n        goto err;\n\n    for (i = 0; i \u003c checks; i++) {\n        /* 1 \u003c check \u003c a-1 */\n        if (!BN_priv_rand_range(check, A3) || !BN_add_word(check, 2))\n            goto err;\n\n        j = witness(check, a, A1, A1_odd, k, ctx, mont);\n        if (j == -1)\n            goto err;\n        if (j) {\n            ret = 0;\n            goto err;\n        }\n        if (!BN_GENCB_call(cb, 1, i))\n            goto err;\n    }\n    ret = 1;\n err:\n    if (ctx != NULL) {\n        BN_CTX_end(ctx);\n        if (ctx_passed == NULL)\n            BN_CTX_free(ctx);\n    }\n    BN_MONT_CTX_free(mont);\n\n    return ret;\n}","filepath":"crypto/bn/bn_prime.c","line_number":154,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270301280":{"score":0.89859086,"function_name":"DH_check","code":"int DH_check(const DH *dh, int *ret)\n{\n    int ok = 0, r;\n    BN_CTX *ctx = NULL;\n    BIGNUM *t1 = NULL, *t2 = NULL;\n\n    if (!DH_check_params(dh, ret))\n        return 0;\n\n    ctx = BN_CTX_new();\n    if (ctx == NULL)\n        goto err;\n    BN_CTX_start(ctx);\n    t1 = BN_CTX_get(ctx);\n    t2 = BN_CTX_get(ctx);\n    if (t2 == NULL)\n        goto err;\n\n    if (dh-\u003eq) {\n        if (BN_cmp(dh-\u003eg, BN_value_one()) \u003c= 0)\n            *ret |= DH_NOT_SUITABLE_GENERATOR;\n        else if (BN_cmp(dh-\u003eg, dh-\u003ep) \u003e= 0)\n            *ret |= DH_NOT_SUITABLE_GENERATOR;\n        else {\n            /* Check g^q == 1 mod p */\n            if (!BN_mod_exp(t1, dh-\u003eg, dh-\u003eq, dh-\u003ep, ctx))\n                goto err;\n            if (!BN_is_one(t1))\n                *ret |= DH_NOT_SUITABLE_GENERATOR;\n        }\n        r = BN_is_prime_ex(dh-\u003eq, DH_NUMBER_ITERATIONS_FOR_PRIME, ctx, NULL);\n        if (r \u003c 0)\n            goto err;\n        if (!r)\n            *ret |= DH_CHECK_Q_NOT_PRIME;\n        /* Check p == 1 mod q  i.e. q divides p - 1 */\n        if (!BN_div(t1, t2, dh-\u003ep, dh-\u003eq, ctx))\n            goto err;\n        if (!BN_is_one(t2))\n            *ret |= DH_CHECK_INVALID_Q_VALUE;\n        if (dh-\u003ej \u0026\u0026 BN_cmp(dh-\u003ej, t1))\n            *ret |= DH_CHECK_INVALID_J_VALUE;\n    }\n\n    r = BN_is_prime_ex(dh-\u003ep, DH_NUMBER_ITERATIONS_FOR_PRIME, ctx, NULL);\n    if (r \u003c 0)\n        goto err;\n    if (!r)\n        *ret |= DH_CHECK_P_NOT_PRIME;\n    else if (!dh-\u003eq) {\n        if (!BN_rshift1(t1, dh-\u003ep))\n            goto err;\n        r = BN_is_prime_ex(t1, DH_NUMBER_ITERATIONS_FOR_PRIME, ctx, NULL);\n        if (r \u003c 0)\n            goto err;\n        if (!r)\n            *ret |= DH_CHECK_P_NOT_SAFE_PRIME;\n    }\n    ok = 1;\n err:\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    return ok;\n}","filepath":"crypto/dh/dh_check.c","line_number":98,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270301680":{"score":0.83601743,"function_name":"DH_check_ex","code":"int DH_check_ex(const DH *dh)\n{\n    int errflags = 0;\n\n    if (!DH_check(dh, \u0026errflags))\n        return 0;\n\n    if ((errflags \u0026 DH_NOT_SUITABLE_GENERATOR) != 0)\n        DHerr(DH_F_DH_CHECK_EX, DH_R_NOT_SUITABLE_GENERATOR);\n    if ((errflags \u0026 DH_CHECK_Q_NOT_PRIME) != 0)\n        DHerr(DH_F_DH_CHECK_EX, DH_R_CHECK_Q_NOT_PRIME);\n    if ((errflags \u0026 DH_CHECK_INVALID_Q_VALUE) != 0)\n        DHerr(DH_F_DH_CHECK_EX, DH_R_CHECK_INVALID_Q_VALUE);\n    if ((errflags \u0026 DH_CHECK_INVALID_J_VALUE) != 0)\n        DHerr(DH_F_DH_CHECK_EX, DH_R_CHECK_INVALID_J_VALUE);\n    if ((errflags \u0026 DH_UNABLE_TO_CHECK_GENERATOR) != 0)\n        DHerr(DH_F_DH_CHECK_EX, DH_R_UNABLE_TO_CHECK_GENERATOR);\n    if ((errflags \u0026 DH_CHECK_P_NOT_PRIME) != 0)\n        DHerr(DH_F_DH_CHECK_EX, DH_R_CHECK_P_NOT_PRIME);\n    if ((errflags \u0026 DH_CHECK_P_NOT_SAFE_PRIME) != 0)\n        DHerr(DH_F_DH_CHECK_EX, DH_R_CHECK_P_NOT_SAFE_PRIME);\n\n    return errflags == 0;\n}","filepath":"crypto/dh/dh_check.c","line_number":73,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270301920":{"score":0.9327058,"function_name":"DH_check_params","code":"int DH_check_params(const DH *dh, int *ret)\n{\n    int ok = 0;\n    BIGNUM *tmp = NULL;\n    BN_CTX *ctx = NULL;\n\n    *ret = 0;\n    ctx = BN_CTX_new();\n    if (ctx == NULL)\n        goto err;\n    BN_CTX_start(ctx);\n    tmp = BN_CTX_get(ctx);\n    if (tmp == NULL)\n        goto err;\n\n    if (!BN_is_odd(dh-\u003ep))\n        *ret |= DH_CHECK_P_NOT_PRIME;\n    if (BN_is_negative(dh-\u003eg) || BN_is_zero(dh-\u003eg) || BN_is_one(dh-\u003eg))\n        *ret |= DH_NOT_SUITABLE_GENERATOR;\n    if (BN_copy(tmp, dh-\u003ep) == NULL || !BN_sub_word(tmp, 1))\n        goto err;\n    if (BN_cmp(dh-\u003eg, tmp) \u003e= 0)\n        *ret |= DH_NOT_SUITABLE_GENERATOR;\n\n    ok = 1;\n err:\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    return ok;\n}","filepath":"crypto/dh/dh_check.c","line_number":38,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270302160":{"score":0.9314696,"function_name":"DH_check_pub_key","code":"int DH_check_pub_key(const DH *dh, const BIGNUM *pub_key, int *ret)\n{\n    int ok = 0;\n    BIGNUM *tmp = NULL;\n    BN_CTX *ctx = NULL;\n\n    *ret = 0;\n    ctx = BN_CTX_new();\n    if (ctx == NULL)\n        goto err;\n    BN_CTX_start(ctx);\n    tmp = BN_CTX_get(ctx);\n    if (tmp == NULL || !BN_set_word(tmp, 1))\n        goto err;\n    if (BN_cmp(pub_key, tmp) \u003c= 0)\n        *ret |= DH_CHECK_PUBKEY_TOO_SMALL;\n    if (BN_copy(tmp, dh-\u003ep) == NULL || !BN_sub_word(tmp, 1))\n        goto err;\n    if (BN_cmp(pub_key, tmp) \u003e= 0)\n        *ret |= DH_CHECK_PUBKEY_TOO_LARGE;\n\n    if (dh-\u003eq != NULL) {\n        /* Check pub_key^q == 1 mod p */\n        if (!BN_mod_exp(tmp, pub_key, dh-\u003eq, dh-\u003ep, ctx))\n            goto err;\n        if (!BN_is_one(tmp))\n            *ret |= DH_CHECK_PUBKEY_INVALID;\n    }\n\n    ok = 1;\n err:\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    return ok;\n}","filepath":"crypto/dh/dh_check.c","line_number":180,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270320368":{"score":0.7064918,"function_name":"curve448_scalar_decode_long","code":"void curve448_scalar_decode_long(curve448_scalar_t s,\n                                 const unsigned char *ser, size_t ser_len)\n{\n    size_t i;\n    curve448_scalar_t t1, t2;\n\n    if (ser_len == 0) {\n        curve448_scalar_copy(s, curve448_scalar_zero);\n        return;\n    }\n\n    i = ser_len - (ser_len % C448_SCALAR_BYTES);\n    if (i == ser_len)\n        i -= C448_SCALAR_BYTES;\n\n    scalar_decode_short(t1, \u0026ser[i], ser_len - i);\n\n    if (ser_len == sizeof(curve448_scalar_t)) {\n        assert(i == 0);\n        /* ham-handed reduce */\n        curve448_scalar_mul(s, t1, curve448_scalar_one);\n        curve448_scalar_destroy(t1);\n        return;\n    }\n\n    while (i) {\n        i -= C448_SCALAR_BYTES;\n        sc_montmul(t1, t1, sc_r2);\n        (void)curve448_scalar_decode(t2, ser + i);\n        curve448_scalar_add(t1, t1, t2);\n    }\n\n    curve448_scalar_copy(s, t1);\n    curve448_scalar_destroy(t1);\n    curve448_scalar_destroy(t2);\n}","filepath":"crypto/ec/curve448/scalar.c","line_number":173,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre2"},"270320928":{"score":0.7358741,"function_name":"curve448_scalar_encode","code":"void curve448_scalar_encode(unsigned char ser[C448_SCALAR_BYTES],\n                            const curve448_scalar_t s)\n{\n    unsigned int i, j, k = 0;\n\n    for (i = 0; i \u003c C448_SCALAR_LIMBS; i++) {\n        for (j = 0; j \u003c sizeof(c448_word_t); j++, k++)\n            ser[k] = s-\u003elimb[i] \u003e\u003e (8 * j);\n    }\n}","filepath":"crypto/ec/curve448/scalar.c","line_number":210,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre2"},"270320992":{"score":0.73935235,"function_name":"curve448_scalar_halve","code":"void curve448_scalar_halve(curve448_scalar_t out, const curve448_scalar_t a)\n{\n    c448_word_t mask = 0 - (a-\u003elimb[0] \u0026 1);\n    c448_dword_t chain = 0;\n    unsigned int i;\n\n    for (i = 0; i \u003c C448_SCALAR_LIMBS; i++) {\n        chain = (chain + a-\u003elimb[i]) + (sc_p-\u003elimb[i] \u0026 mask);\n        out-\u003elimb[i] = (c448_word_t)chain;\n        chain \u003e\u003e= C448_WORD_BITS;\n    }\n    for (i = 0; i \u003c C448_SCALAR_LIMBS - 1; i++)\n        out-\u003elimb[i] = out-\u003elimb[i] \u003e\u003e 1 | out-\u003elimb[i + 1] \u003c\u003c (WBITS - 1);\n    out-\u003elimb[i] = out-\u003elimb[i] \u003e\u003e 1 | (c448_word_t)(chain \u003c\u003c (WBITS - 1));\n}","filepath":"crypto/ec/curve448/scalar.c","line_number":221,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre2"},"270321360":{"score":0.7747761,"function_name":"sc_montmul","code":"static void sc_montmul(curve448_scalar_t out, const curve448_scalar_t a,\n                       const curve448_scalar_t b)\n{\n    unsigned int i, j;\n    c448_word_t accum[C448_SCALAR_LIMBS + 1] = { 0 };\n    c448_word_t hi_carry = 0;\n\n    for (i = 0; i \u003c C448_SCALAR_LIMBS; i++) {\n        c448_word_t mand = a-\u003elimb[i];\n        const c448_word_t *mier = b-\u003elimb;\n\n        c448_dword_t chain = 0;\n        for (j = 0; j \u003c C448_SCALAR_LIMBS; j++) {\n            chain += ((c448_dword_t) mand) * mier[j] + accum[j];\n            accum[j] = (c448_word_t)chain;\n            chain \u003e\u003e= WBITS;\n        }\n        accum[j] = (c448_word_t)chain;\n\n        mand = accum[0] * MONTGOMERY_FACTOR;\n        chain = 0;\n        mier = sc_p-\u003elimb;\n        for (j = 0; j \u003c C448_SCALAR_LIMBS; j++) {\n            chain += (c448_dword_t) mand *mier[j] + accum[j];\n            if (j)\n                accum[j - 1] = (c448_word_t)chain;\n            chain \u003e\u003e= WBITS;\n        }\n        chain += accum[j];\n        chain += hi_carry;\n        accum[j - 1] = (c448_word_t)chain;\n        hi_carry = chain \u003e\u003e WBITS;\n    }\n\n    sc_subx(out, accum, sc_p, sc_p, hi_carry);\n}","filepath":"crypto/ec/curve448/scalar.c","line_number":72,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre2"},"270321728":{"score":0.74301636,"function_name":"sc_subx","code":"static void sc_subx(curve448_scalar_t out,\n                    const c448_word_t accum[C448_SCALAR_LIMBS],\n                    const curve448_scalar_t sub,\n                    const curve448_scalar_t p, c448_word_t extra)\n{\n    c448_dsword_t chain = 0;\n    unsigned int i;\n    c448_word_t borrow;\n\n    for (i = 0; i \u003c C448_SCALAR_LIMBS; i++) {\n        chain = (chain + accum[i]) - sub-\u003elimb[i];\n        out-\u003elimb[i] = (c448_word_t)chain;\n        chain \u003e\u003e= WBITS;\n    }\n    borrow = (c448_word_t)chain + extra;     /* = 0 or -1 */\n\n    chain = 0;\n    for (i = 0; i \u003c C448_SCALAR_LIMBS; i++) {\n        chain = (chain + out-\u003elimb[i]) + (p-\u003elimb[i] \u0026 borrow);\n        out-\u003elimb[i] = (c448_word_t)chain;\n        chain \u003e\u003e= WBITS;\n    }\n}","filepath":"crypto/ec/curve448/scalar.c","line_number":48,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre2"},"270322000":{"score":0.8563426,"function_name":"scalar_decode_short","code":"static ossl_inline void scalar_decode_short(curve448_scalar_t s,\n                                            const unsigned char *ser,\n                                            unsigned int nbytes)\n{\n    unsigned int i, j, k = 0;\n\n    for (i = 0; i \u003c C448_SCALAR_LIMBS; i++) {\n        c448_word_t out = 0;\n\n        for (j = 0; j \u003c sizeof(c448_word_t) \u0026\u0026 k \u003c nbytes; j++, k++)\n            out |= ((c448_word_t) ser[k]) \u003c\u003c (8 * j);\n        s-\u003elimb[i] = out;\n    }\n}","filepath":"crypto/ec/curve448/scalar.c","line_number":136,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre2"},"270325808":{"score":0.9083606,"function_name":"CMS_SignerInfo_get0_algs","code":"void CMS_SignerInfo_get0_algs(CMS_SignerInfo *si, EVP_PKEY **pk,\n                              X509 **signer, X509_ALGOR **pdig,\n                              X509_ALGOR **psig)\n{\n    if (pk)\n        *pk = si-\u003epkey;\n    if (signer)\n        *signer = si-\u003esigner;\n    if (pdig)\n        *pdig = si-\u003edigestAlgorithm;\n    if (psig)\n        *psig = si-\u003esignatureAlgorithm;\n}","filepath":"crypto/cms/cms_sd.c","line_number":537,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1h"},"270325872":{"score":0.8887941,"function_name":"CMS_SignerInfo_sign","code":"int CMS_SignerInfo_sign(CMS_SignerInfo *si)\n{\n    EVP_MD_CTX *mctx = si-\u003emctx;\n    EVP_PKEY_CTX *pctx = NULL;\n    unsigned char *abuf = NULL;\n    int alen;\n    size_t siglen;\n    const EVP_MD *md = NULL;\n\n    md = EVP_get_digestbyobj(si-\u003edigestAlgorithm-\u003ealgorithm);\n    if (md == NULL)\n        return 0;\n\n    if (CMS_signed_get_attr_by_NID(si, NID_pkcs9_signingTime, -1) \u003c 0) {\n        if (!cms_add1_signingTime(si, NULL))\n            goto err;\n    }\n\n    if (!CMS_si_check_attributes(si))\n        goto err;\n\n    if (si-\u003epctx)\n        pctx = si-\u003epctx;\n    else {\n        EVP_MD_CTX_reset(mctx);\n        if (EVP_DigestSignInit(mctx, \u0026pctx, md, NULL, si-\u003epkey) \u003c= 0)\n            goto err;\n        si-\u003epctx = pctx;\n    }\n\n    if (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_SIGN,\n                          EVP_PKEY_CTRL_CMS_SIGN, 0, si) \u003c= 0) {\n        CMSerr(CMS_F_CMS_SIGNERINFO_SIGN, CMS_R_CTRL_ERROR);\n        goto err;\n    }\n\n    alen = ASN1_item_i2d((ASN1_VALUE *)si-\u003esignedAttrs, \u0026abuf,\n                         ASN1_ITEM_rptr(CMS_Attributes_Sign));\n    if (!abuf)\n        goto err;\n    if (EVP_DigestSignUpdate(mctx, abuf, alen) \u003c= 0)\n        goto err;\n    if (EVP_DigestSignFinal(mctx, NULL, \u0026siglen) \u003c= 0)\n        goto err;\n    OPENSSL_free(abuf);\n    abuf = OPENSSL_malloc(siglen);\n    if (abuf == NULL)\n        goto err;\n    if (EVP_DigestSignFinal(mctx, abuf, \u0026siglen) \u003c= 0)\n        goto err;\n\n    if (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_SIGN,\n                          EVP_PKEY_CTRL_CMS_SIGN, 1, si) \u003c= 0) {\n        CMSerr(CMS_F_CMS_SIGNERINFO_SIGN, CMS_R_CTRL_ERROR);\n        goto err;\n    }\n\n    EVP_MD_CTX_reset(mctx);\n\n    ASN1_STRING_set0(si-\u003esignature, abuf, siglen);\n\n    return 1;\n\n err:\n    OPENSSL_free(abuf);\n    EVP_MD_CTX_reset(mctx);\n    return 0;\n}","filepath":"crypto/cms/cms_sd.c","line_number":656,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1h"},"270326464":{"score":0.793927,"function_name":"cms_SignedData_final","code":"int cms_SignedData_final(CMS_ContentInfo *cms, BIO *chain)\n{\n    STACK_OF(CMS_SignerInfo) *sinfos;\n    CMS_SignerInfo *si;\n    int i;\n    sinfos = CMS_get0_SignerInfos(cms);\n    for (i = 0; i \u003c sk_CMS_SignerInfo_num(sinfos); i++) {\n        si = sk_CMS_SignerInfo_value(sinfos, i);\n        if (!cms_SignerInfo_content_sign(cms, si, chain))\n            return 0;\n    }\n    cms-\u003ed.signedData-\u003eencapContentInfo-\u003epartial = 0;\n    return 1;\n}","filepath":"crypto/cms/cms_sd.c","line_number":641,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1h"},"270326624":{"score":0.7775409,"function_name":"cms_SignedData_init_bio","code":"BIO *cms_SignedData_init_bio(CMS_ContentInfo *cms)\n{\n    int i;\n    CMS_SignedData *sd;\n    BIO *chain = NULL;\n    sd = cms_get0_signed(cms);\n    if (!sd)\n        return NULL;\n    if (cms-\u003ed.signedData-\u003eencapContentInfo-\u003epartial)\n        cms_sd_set_version(sd);\n    for (i = 0; i \u003c sk_X509_ALGOR_num(sd-\u003edigestAlgorithms); i++) {\n        X509_ALGOR *digestAlgorithm;\n        BIO *mdbio;\n        digestAlgorithm = sk_X509_ALGOR_value(sd-\u003edigestAlgorithms, i);\n        mdbio = cms_DigestAlgorithm_init_bio(digestAlgorithm);\n        if (!mdbio)\n            goto err;\n        if (chain)\n            BIO_push(chain, mdbio);\n        else\n            chain = mdbio;\n    }\n    return chain;\n err:\n    BIO_free_all(chain);\n    return NULL;\n}","filepath":"crypto/cms/cms_sd.c","line_number":775,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1h"},"270326800":{"score":0.84530365,"function_name":"cms_SignerInfo_content_sign","code":"static int cms_SignerInfo_content_sign(CMS_ContentInfo *cms,\n                                       CMS_SignerInfo *si, BIO *chain)\n{\n    EVP_MD_CTX *mctx = EVP_MD_CTX_new();\n    int r = 0;\n    EVP_PKEY_CTX *pctx = NULL;\n\n    if (mctx == NULL) {\n        CMSerr(CMS_F_CMS_SIGNERINFO_CONTENT_SIGN, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n\n    if (!si-\u003epkey) {\n        CMSerr(CMS_F_CMS_SIGNERINFO_CONTENT_SIGN, CMS_R_NO_PRIVATE_KEY);\n        goto err;\n    }\n\n    if (!cms_DigestAlgorithm_find_ctx(mctx, chain, si-\u003edigestAlgorithm))\n        goto err;\n    /* Set SignerInfo algorithm details if we used custom parameter */\n    if (si-\u003epctx \u0026\u0026 !cms_sd_asn1_ctrl(si, 0))\n        goto err;\n\n    /*\n     * If any signed attributes calculate and add messageDigest attribute\n     */\n\n    if (CMS_signed_get_attr_count(si) \u003e= 0) {\n        unsigned char md[EVP_MAX_MD_SIZE];\n        unsigned int mdlen;\n        if (!EVP_DigestFinal_ex(mctx, md, \u0026mdlen))\n            goto err;\n        if (!CMS_signed_add1_attr_by_NID(si, NID_pkcs9_messageDigest,\n                                         V_ASN1_OCTET_STRING, md, mdlen))\n            goto err;\n        /* Copy content type across */\n        if (!cms_set_si_contentType_attr(cms, si))\n            goto err;\n\n        if (!CMS_SignerInfo_sign(si))\n            goto err;\n    } else if (si-\u003epctx) {\n        unsigned char *sig;\n        size_t siglen;\n        unsigned char md[EVP_MAX_MD_SIZE];\n        unsigned int mdlen;\n        pctx = si-\u003epctx;\n        if (!EVP_DigestFinal_ex(mctx, md, \u0026mdlen))\n            goto err;\n        siglen = EVP_PKEY_size(si-\u003epkey);\n        sig = OPENSSL_malloc(siglen);\n        if (sig == NULL) {\n            CMSerr(CMS_F_CMS_SIGNERINFO_CONTENT_SIGN, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        if (EVP_PKEY_sign(pctx, sig, \u0026siglen, md, mdlen) \u003c= 0) {\n            OPENSSL_free(sig);\n            goto err;\n        }\n        ASN1_STRING_set0(si-\u003esignature, sig, siglen);\n    } else {\n        unsigned char *sig;\n        unsigned int siglen;\n        sig = OPENSSL_malloc(EVP_PKEY_size(si-\u003epkey));\n        if (sig == NULL) {\n            CMSerr(CMS_F_CMS_SIGNERINFO_CONTENT_SIGN, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        if (!EVP_SignFinal(mctx, sig, \u0026siglen, si-\u003epkey)) {\n            CMSerr(CMS_F_CMS_SIGNERINFO_CONTENT_SIGN, CMS_R_SIGNFINAL_ERROR);\n            OPENSSL_free(sig);\n            goto err;\n        }\n        ASN1_STRING_set0(si-\u003esignature, sig, siglen);\n    }\n\n    r = 1;\n\n err:\n    EVP_MD_CTX_free(mctx);\n    EVP_PKEY_CTX_free(pctx);\n    return r;\n\n}","filepath":"crypto/cms/cms_sd.c","line_number":556,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1h"},"270327456":{"score":0.94782543,"function_name":"cms_sd_asn1_ctrl","code":"static int cms_sd_asn1_ctrl(CMS_SignerInfo *si, int cmd)\n{\n    EVP_PKEY *pkey = si-\u003epkey;\n    int i;\n    if (!pkey-\u003eameth || !pkey-\u003eameth-\u003epkey_ctrl)\n        return 1;\n    i = pkey-\u003eameth-\u003epkey_ctrl(pkey, ASN1_PKEY_CTRL_CMS_SIGN, cmd, si);\n    if (i == -2) {\n        CMSerr(CMS_F_CMS_SD_ASN1_CTRL, CMS_R_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);\n        return 0;\n    }\n    if (i \u003c= 0) {\n        CMSerr(CMS_F_CMS_SD_ASN1_CTRL, CMS_R_CTRL_FAILURE);\n        return 0;\n    }\n    return 1;\n}","filepath":"crypto/cms/cms_sd.c","line_number":223,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1h"},"270327568":{"score":0.89966786,"function_name":"cms_sd_set_version","code":"static void cms_sd_set_version(CMS_SignedData *sd)\n{\n    int i;\n    CMS_CertificateChoices *cch;\n    CMS_RevocationInfoChoice *rch;\n    CMS_SignerInfo *si;\n\n    for (i = 0; i \u003c sk_CMS_CertificateChoices_num(sd-\u003ecertificates); i++) {\n        cch = sk_CMS_CertificateChoices_value(sd-\u003ecertificates, i);\n        if (cch-\u003etype == CMS_CERTCHOICE_OTHER) {\n            if (sd-\u003eversion \u003c 5)\n                sd-\u003eversion = 5;\n        } else if (cch-\u003etype == CMS_CERTCHOICE_V2ACERT) {\n            if (sd-\u003eversion \u003c 4)\n                sd-\u003eversion = 4;\n        } else if (cch-\u003etype == CMS_CERTCHOICE_V1ACERT) {\n            if (sd-\u003eversion \u003c 3)\n                sd-\u003eversion = 3;\n        }\n    }\n\n    for (i = 0; i \u003c sk_CMS_RevocationInfoChoice_num(sd-\u003ecrls); i++) {\n        rch = sk_CMS_RevocationInfoChoice_value(sd-\u003ecrls, i);\n        if (rch-\u003etype == CMS_REVCHOICE_OTHER) {\n            if (sd-\u003eversion \u003c 5)\n                sd-\u003eversion = 5;\n        }\n    }\n\n    if ((OBJ_obj2nid(sd-\u003eencapContentInfo-\u003eeContentType) != NID_pkcs7_data)\n        \u0026\u0026 (sd-\u003eversion \u003c 3))\n        sd-\u003eversion = 3;\n\n    for (i = 0; i \u003c sk_CMS_SignerInfo_num(sd-\u003esignerInfos); i++) {\n        si = sk_CMS_SignerInfo_value(sd-\u003esignerInfos, i);\n        if (si-\u003esid-\u003etype == CMS_SIGNERINFO_KEYIDENTIFIER) {\n            if (si-\u003eversion \u003c 3)\n                si-\u003eversion = 3;\n            if (sd-\u003eversion \u003c 3)\n                sd-\u003eversion = 3;\n        } else if (si-\u003eversion \u003c 1)\n            si-\u003eversion = 1;\n    }\n\n    if (sd-\u003eversion \u003c 1)\n        sd-\u003eversion = 1;\n\n}","filepath":"crypto/cms/cms_sd.c","line_number":63,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1h"},"270331520":{"score":0.93797845,"function_name":"CMS_RecipientInfo_kari_get0_alg","code":"int CMS_RecipientInfo_kari_get0_alg(CMS_RecipientInfo *ri,\n                                    X509_ALGOR **palg,\n                                    ASN1_OCTET_STRING **pukm)\n{\n    if (ri-\u003etype != CMS_RECIPINFO_AGREE) {\n        ERR_raise(ERR_LIB_CMS, CMS_R_NOT_KEY_AGREEMENT);\n        return 0;\n    }\n    if (palg)\n        *palg = ri-\u003ed.kari-\u003ekeyEncryptionAlgorithm;\n    if (pukm)\n        *pukm = ri-\u003ed.kari-\u003eukm;\n    return 1;\n}","filepath":"crypto/cms/cms_kari.c","line_number":28,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha11"},"270331632":{"score":0.93303764,"function_name":"CMS_RecipientInfo_kari_get0_orig_id","code":"int CMS_RecipientInfo_kari_get0_orig_id(CMS_RecipientInfo *ri,\n                                        X509_ALGOR **pubalg,\n                                        ASN1_BIT_STRING **pubkey,\n                                        ASN1_OCTET_STRING **keyid,\n                                        X509_NAME **issuer,\n                                        ASN1_INTEGER **sno)\n{\n    CMS_OriginatorIdentifierOrKey *oik;\n\n    if (ri-\u003etype != CMS_RECIPINFO_AGREE) {\n        ERR_raise(ERR_LIB_CMS, CMS_R_NOT_KEY_AGREEMENT);\n        return 0;\n    }\n    oik = ri-\u003ed.kari-\u003eoriginator;\n    if (issuer)\n        *issuer = NULL;\n    if (sno)\n        *sno = NULL;\n    if (keyid)\n        *keyid = NULL;\n    if (pubalg)\n        *pubalg = NULL;\n    if (pubkey)\n        *pubkey = NULL;\n    if (oik-\u003etype == CMS_OIK_ISSUER_SERIAL) {\n        if (issuer)\n            *issuer = oik-\u003ed.issuerAndSerialNumber-\u003eissuer;\n        if (sno)\n            *sno = oik-\u003ed.issuerAndSerialNumber-\u003eserialNumber;\n    } else if (oik-\u003etype == CMS_OIK_KEYIDENTIFIER) {\n        if (keyid)\n            *keyid = oik-\u003ed.subjectKeyIdentifier;\n    } else if (oik-\u003etype == CMS_OIK_PUBKEY) {\n        if (pubalg)\n            *pubalg = oik-\u003ed.originatorKey-\u003ealgorithm;\n        if (pubkey)\n            *pubkey = oik-\u003ed.originatorKey-\u003epublicKey;\n    } else\n        return 0;\n    return 1;\n}","filepath":"crypto/cms/cms_kari.c","line_number":55,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha11"},"270331872":{"score":0.8718066,"function_name":"cms_RecipientInfo_kari_encrypt","code":"int cms_RecipientInfo_kari_encrypt(const CMS_ContentInfo *cms,\n                                   CMS_RecipientInfo *ri)\n{\n    CMS_KeyAgreeRecipientInfo *kari;\n    CMS_EncryptedContentInfo *ec;\n    CMS_RecipientEncryptedKey *rek;\n    STACK_OF(CMS_RecipientEncryptedKey) *reks;\n    int i;\n\n    if (ri-\u003etype != CMS_RECIPINFO_AGREE) {\n        ERR_raise(ERR_LIB_CMS, CMS_R_NOT_KEY_AGREEMENT);\n        return 0;\n    }\n    kari = ri-\u003ed.kari;\n    reks = kari-\u003erecipientEncryptedKeys;\n    ec = cms_get0_env_enc_content(cms);\n    /* Initialise wrap algorithm parameters */\n    if (!cms_wrap_init(kari, ec-\u003ecipher))\n        return 0;\n    /*\n     * If no originator key set up initialise for ephemeral key the public key\n     * ASN1 structure will set the actual public key value.\n     */\n    if (kari-\u003eoriginator-\u003etype == -1) {\n        CMS_OriginatorIdentifierOrKey *oik = kari-\u003eoriginator;\n        oik-\u003etype = CMS_OIK_PUBKEY;\n        oik-\u003ed.originatorKey = M_ASN1_new_of(CMS_OriginatorPublicKey);\n        if (!oik-\u003ed.originatorKey)\n            return 0;\n    }\n    /* Initialise KDF algorithm */\n    if (!cms_env_asn1_ctrl(ri, 0))\n        return 0;\n    /* For each rek, derive KEK, encrypt CEK */\n    for (i = 0; i \u003c sk_CMS_RecipientEncryptedKey_num(reks); i++) {\n        unsigned char *enckey;\n        size_t enckeylen;\n        rek = sk_CMS_RecipientEncryptedKey_value(reks, i);\n        if (EVP_PKEY_derive_set_peer(kari-\u003epctx, rek-\u003epkey) \u003c= 0)\n            return 0;\n        if (!cms_kek_cipher(\u0026enckey, \u0026enckeylen, ec-\u003ekey, ec-\u003ekeylen,\n                            kari, 1))\n            return 0;\n        ASN1_STRING_set0(rek-\u003eencryptedKey, enckey, enckeylen);\n    }\n\n    return 1;\n}","filepath":"crypto/cms/cms_kari.c","line_number":474,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha11"},"270332304":{"score":0.7751088,"function_name":"cms_kek_cipher","code":"static int cms_kek_cipher(unsigned char **pout, size_t *poutlen,\n                          const unsigned char *in, size_t inlen,\n                          CMS_KeyAgreeRecipientInfo *kari, int enc)\n{\n    /* Key encryption key */\n    unsigned char kek[EVP_MAX_KEY_LENGTH];\n    size_t keklen;\n    int rv = 0;\n    unsigned char *out = NULL;\n    int outlen;\n\n    keklen = EVP_CIPHER_CTX_key_length(kari-\u003ectx);\n    if (keklen \u003e EVP_MAX_KEY_LENGTH)\n        return 0;\n    /* Derive KEK */\n    if (EVP_PKEY_derive(kari-\u003epctx, kek, \u0026keklen) \u003c= 0)\n        goto err;\n    /* Set KEK in context */\n    if (!EVP_CipherInit_ex(kari-\u003ectx, NULL, NULL, kek, NULL, enc))\n        goto err;\n    /* obtain output length of ciphered key */\n    if (!EVP_CipherUpdate(kari-\u003ectx, NULL, \u0026outlen, in, inlen))\n        goto err;\n    out = OPENSSL_malloc(outlen);\n    if (out == NULL)\n        goto err;\n    if (!EVP_CipherUpdate(kari-\u003ectx, out, \u0026outlen, in, inlen))\n        goto err;\n    *pout = out;\n    *poutlen = (size_t)outlen;\n    rv = 1;\n\n err:\n    OPENSSL_cleanse(kek, keklen);\n    if (!rv)\n        OPENSSL_free(out);\n    EVP_CIPHER_CTX_reset(kari-\u003ectx);\n    /* FIXME: WHY IS kari-\u003epctx freed here?  /RL */\n    EVP_PKEY_CTX_free(kari-\u003epctx);\n    kari-\u003epctx = NULL;\n    return rv;\n}","filepath":"crypto/cms/cms_kari.c","line_number":207,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha11"},"270334416":{"score":0.9234521,"function_name":"ec_GFp_simple_group_init","code":"int ec_GFp_simple_group_init(EC_GROUP *group)\n{\n    group-\u003efield = BN_new();\n    group-\u003ea = BN_new();\n    group-\u003eb = BN_new();\n    if (group-\u003efield == NULL || group-\u003ea == NULL || group-\u003eb == NULL) {\n        BN_free(group-\u003efield);\n        BN_free(group-\u003ea);\n        BN_free(group-\u003eb);\n        return 0;\n    }\n    group-\u003ea_is_minus3 = 0;\n    return 1;\n}","filepath":"crypto/ec/ecp_smpl.c","line_number":91,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270334608":{"score":0.8664635,"function_name":"ec_GFp_simple_group_copy","code":"int ec_GFp_simple_group_copy(EC_GROUP *dest, const EC_GROUP *src)\n{\n    if (!BN_copy(dest-\u003efield, src-\u003efield))\n        return 0;\n    if (!BN_copy(dest-\u003ea, src-\u003ea))\n        return 0;\n    if (!BN_copy(dest-\u003eb, src-\u003eb))\n        return 0;\n\n    dest-\u003ea_is_minus3 = src-\u003ea_is_minus3;\n\n    return 1;\n}","filepath":"crypto/ec/ecp_smpl.c","line_number":120,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270334704":{"score":0.87092507,"function_name":"ec_GFp_simple_group_set_curve","code":"int ec_GFp_simple_group_set_curve(EC_GROUP *group,\n                                  const BIGNUM *p, const BIGNUM *a,\n                                  const BIGNUM *b, BN_CTX *ctx)\n{\n    int ret = 0;\n    BN_CTX *new_ctx = NULL;\n    BIGNUM *tmp_a;\n\n    /* p must be a prime \u003e 3 */\n    if (BN_num_bits(p) \u003c= 2 || !BN_is_odd(p)) {\n        ECerr(EC_F_EC_GFP_SIMPLE_GROUP_SET_CURVE, EC_R_INVALID_FIELD);\n        return 0;\n    }\n\n    if (ctx == NULL) {\n        ctx = new_ctx = BN_CTX_new();\n        if (ctx == NULL)\n            return 0;\n    }\n\n    BN_CTX_start(ctx);\n    tmp_a = BN_CTX_get(ctx);\n    if (tmp_a == NULL)\n        goto err;\n\n    /* group-\u003efield */\n    if (!BN_copy(group-\u003efield, p))\n        goto err;\n    BN_set_negative(group-\u003efield, 0);\n\n    /* group-\u003ea */\n    if (!BN_nnmod(tmp_a, a, p, ctx))\n        goto err;\n    if (group-\u003emeth-\u003efield_encode) {\n        if (!group-\u003emeth-\u003efield_encode(group, group-\u003ea, tmp_a, ctx))\n            goto err;\n    } else if (!BN_copy(group-\u003ea, tmp_a))\n        goto err;\n\n    /* group-\u003eb */\n    if (!BN_nnmod(group-\u003eb, b, p, ctx))\n        goto err;\n    if (group-\u003emeth-\u003efield_encode)\n        if (!group-\u003emeth-\u003efield_encode(group, group-\u003eb, group-\u003eb, ctx))\n            goto err;\n\n    /* group-\u003ea_is_minus3 */\n    if (!BN_add_word(tmp_a, 3))\n        goto err;\n    group-\u003ea_is_minus3 = (0 == BN_cmp(tmp_a, group-\u003efield));\n\n    ret = 1;\n\n err:\n    BN_CTX_end(ctx);\n    BN_CTX_free(new_ctx);\n    return ret;\n}","filepath":"crypto/ec/ecp_smpl.c","line_number":134,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270335088":{"score":0.8360632,"function_name":"ec_GFp_simple_group_get_curve","code":"int ec_GFp_simple_group_get_curve(const EC_GROUP *group, BIGNUM *p, BIGNUM *a,\n                                  BIGNUM *b, BN_CTX *ctx)\n{\n    int ret = 0;\n    BN_CTX *new_ctx = NULL;\n\n    if (p != NULL) {\n        if (!BN_copy(p, group-\u003efield))\n            return 0;\n    }\n\n    if (a != NULL || b != NULL) {\n        if (group-\u003emeth-\u003efield_decode) {\n            if (ctx == NULL) {\n                ctx = new_ctx = BN_CTX_new();\n                if (ctx == NULL)\n                    return 0;\n            }\n            if (a != NULL) {\n                if (!group-\u003emeth-\u003efield_decode(group, a, group-\u003ea, ctx))\n                    goto err;\n            }\n            if (b != NULL) {\n                if (!group-\u003emeth-\u003efield_decode(group, b, group-\u003eb, ctx))\n                    goto err;\n            }\n        } else {\n            if (a != NULL) {\n                if (!BN_copy(a, group-\u003ea))\n                    goto err;\n            }\n            if (b != NULL) {\n                if (!BN_copy(b, group-\u003eb))\n                    goto err;\n            }\n        }\n    }\n\n    ret = 1;\n\n err:\n    BN_CTX_free(new_ctx);\n    return ret;\n}","filepath":"crypto/ec/ecp_smpl.c","line_number":193,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270336000":{"score":0.8039743,"function_name":"ec_GFp_simple_set_Jprojective_coordinates_GFp","code":"int ec_GFp_simple_set_Jprojective_coordinates_GFp(const EC_GROUP *group,\n                                                  EC_POINT *point,\n                                                  const BIGNUM *x,\n                                                  const BIGNUM *y,\n                                                  const BIGNUM *z,\n                                                  BN_CTX *ctx)\n{\n    BN_CTX *new_ctx = NULL;\n    int ret = 0;\n\n    if (ctx == NULL) {\n        ctx = new_ctx = BN_CTX_new();\n        if (ctx == NULL)\n            return 0;\n    }\n\n    if (x != NULL) {\n        if (!BN_nnmod(point-\u003eX, x, group-\u003efield, ctx))\n            goto err;\n        if (group-\u003emeth-\u003efield_encode) {\n            if (!group-\u003emeth-\u003efield_encode(group, point-\u003eX, point-\u003eX, ctx))\n                goto err;\n        }\n    }\n\n    if (y != NULL) {\n        if (!BN_nnmod(point-\u003eY, y, group-\u003efield, ctx))\n            goto err;\n        if (group-\u003emeth-\u003efield_encode) {\n            if (!group-\u003emeth-\u003efield_encode(group, point-\u003eY, point-\u003eY, ctx))\n                goto err;\n        }\n    }\n\n    if (z != NULL) {\n        int Z_is_one;\n\n        if (!BN_nnmod(point-\u003eZ, z, group-\u003efield, ctx))\n            goto err;\n        Z_is_one = BN_is_one(point-\u003eZ);\n        if (group-\u003emeth-\u003efield_encode) {\n            if (Z_is_one \u0026\u0026 (group-\u003emeth-\u003efield_set_to_one != 0)) {\n                if (!group-\u003emeth-\u003efield_set_to_one(group, point-\u003eZ, ctx))\n                    goto err;\n            } else {\n                if (!group-\u003e\n                    meth-\u003efield_encode(group, point-\u003eZ, point-\u003eZ, ctx))\n                    goto err;\n            }\n        }\n        point-\u003eZ_is_one = Z_is_one;\n    }\n\n    ret = 1;\n\n err:\n    BN_CTX_free(new_ctx);\n    return ret;\n}","filepath":"crypto/ec/ecp_smpl.c","line_number":368,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270336320":{"score":0.8457222,"function_name":"ec_GFp_simple_get_Jprojective_coordinates_GFp","code":"int ec_GFp_simple_get_Jprojective_coordinates_GFp(const EC_GROUP *group,\n                                                  const EC_POINT *point,\n                                                  BIGNUM *x, BIGNUM *y,\n                                                  BIGNUM *z, BN_CTX *ctx)\n{\n    BN_CTX *new_ctx = NULL;\n    int ret = 0;\n\n    if (group-\u003emeth-\u003efield_decode != 0) {\n        if (ctx == NULL) {\n            ctx = new_ctx = BN_CTX_new();\n            if (ctx == NULL)\n                return 0;\n        }\n\n        if (x != NULL) {\n            if (!group-\u003emeth-\u003efield_decode(group, x, point-\u003eX, ctx))\n                goto err;\n        }\n        if (y != NULL) {\n            if (!group-\u003emeth-\u003efield_decode(group, y, point-\u003eY, ctx))\n                goto err;\n        }\n        if (z != NULL) {\n            if (!group-\u003emeth-\u003efield_decode(group, z, point-\u003eZ, ctx))\n                goto err;\n        }\n    } else {\n        if (x != NULL) {\n            if (!BN_copy(x, point-\u003eX))\n                goto err;\n        }\n        if (y != NULL) {\n            if (!BN_copy(y, point-\u003eY))\n                goto err;\n        }\n        if (z != NULL) {\n            if (!BN_copy(z, point-\u003eZ))\n                goto err;\n        }\n    }\n\n    ret = 1;\n\n err:\n    BN_CTX_free(new_ctx);\n    return ret;\n}","filepath":"crypto/ec/ecp_smpl.c","line_number":428,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270337280":{"score":0.7895053,"function_name":"ec_GFp_simple_add","code":"int ec_GFp_simple_add(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,\n                      const EC_POINT *b, BN_CTX *ctx)\n{\n    int (*field_mul) (const EC_GROUP *, BIGNUM *, const BIGNUM *,\n                      const BIGNUM *, BN_CTX *);\n    int (*field_sqr) (const EC_GROUP *, BIGNUM *, const BIGNUM *, BN_CTX *);\n    const BIGNUM *p;\n    BN_CTX *new_ctx = NULL;\n    BIGNUM *n0, *n1, *n2, *n3, *n4, *n5, *n6;\n    int ret = 0;\n\n    if (a == b)\n        return EC_POINT_dbl(group, r, a, ctx);\n    if (EC_POINT_is_at_infinity(group, a))\n        return EC_POINT_copy(r, b);\n    if (EC_POINT_is_at_infinity(group, b))\n        return EC_POINT_copy(r, a);\n\n    field_mul = group-\u003emeth-\u003efield_mul;\n    field_sqr = group-\u003emeth-\u003efield_sqr;\n    p = group-\u003efield;\n\n    if (ctx == NULL) {\n        ctx = new_ctx = BN_CTX_new();\n        if (ctx == NULL)\n            return 0;\n    }\n\n    BN_CTX_start(ctx);\n    n0 = BN_CTX_get(ctx);\n    n1 = BN_CTX_get(ctx);\n    n2 = BN_CTX_get(ctx);\n    n3 = BN_CTX_get(ctx);\n    n4 = BN_CTX_get(ctx);\n    n5 = BN_CTX_get(ctx);\n    n6 = BN_CTX_get(ctx);\n    if (n6 == NULL)\n        goto end;\n\n    /*\n     * Note that in this function we must not read components of 'a' or 'b'\n     * once we have written the corresponding components of 'r'. ('r' might\n     * be one of 'a' or 'b'.)\n     */\n\n    /* n1, n2 */\n    if (b-\u003eZ_is_one) {\n        if (!BN_copy(n1, a-\u003eX))\n            goto end;\n        if (!BN_copy(n2, a-\u003eY))\n            goto end;\n        /* n1 = X_a */\n        /* n2 = Y_a */\n    } else {\n        if (!field_sqr(group, n0, b-\u003eZ, ctx))\n            goto end;\n        if (!field_mul(group, n1, a-\u003eX, n0, ctx))\n            goto end;\n        /* n1 = X_a * Z_b^2 */\n\n        if (!field_mul(group, n0, n0, b-\u003eZ, ctx))\n            goto end;\n        if (!field_mul(group, n2, a-\u003eY, n0, ctx))\n            goto end;\n        /* n2 = Y_a * Z_b^3 */\n    }\n\n    /* n3, n4 */\n    if (a-\u003eZ_is_one) {\n        if (!BN_copy(n3, b-\u003eX))\n            goto end;\n        if (!BN_copy(n4, b-\u003eY))\n            goto end;\n        /* n3 = X_b */\n        /* n4 = Y_b */\n    } else {\n        if (!field_sqr(group, n0, a-\u003eZ, ctx))\n            goto end;\n        if (!field_mul(group, n3, b-\u003eX, n0, ctx))\n            goto end;\n        /* n3 = X_b * Z_a^2 */\n\n        if (!field_mul(group, n0, n0, a-\u003eZ, ctx))\n            goto end;\n        if (!field_mul(group, n4, b-\u003eY, n0, ctx))\n            goto end;\n        /* n4 = Y_b * Z_a^3 */\n    }\n\n    /* n5, n6 */\n    if (!BN_mod_sub_quick(n5, n1, n3, p))\n        goto end;\n    if (!BN_mod_sub_quick(n6, n2, n4, p))\n        goto end;\n    /* n5 = n1 - n3 */\n    /* n6 = n2 - n4 */\n\n    if (BN_is_zero(n5)) {\n        if (BN_is_zero(n6)) {\n            /* a is the same point as b */\n            BN_CTX_end(ctx);\n            ret = EC_POINT_dbl(group, r, a, ctx);\n            ctx = NULL;\n            goto end;\n        } else {\n            /* a is the inverse of b */\n            BN_zero(r-\u003eZ);\n            r-\u003eZ_is_one = 0;\n            ret = 1;\n            goto end;\n        }\n    }\n\n    /* 'n7', 'n8' */\n    if (!BN_mod_add_quick(n1, n1, n3, p))\n        goto end;\n    if (!BN_mod_add_quick(n2, n2, n4, p))\n        goto end;\n    /* 'n7' = n1 + n3 */\n    /* 'n8' = n2 + n4 */\n\n    /* Z_r */\n    if (a-\u003eZ_is_one \u0026\u0026 b-\u003eZ_is_one) {\n        if (!BN_copy(r-\u003eZ, n5))\n            goto end;\n    } else {\n        if (a-\u003eZ_is_one) {\n            if (!BN_copy(n0, b-\u003eZ))\n                goto end;\n        } else if (b-\u003eZ_is_one) {\n            if (!BN_copy(n0, a-\u003eZ))\n                goto end;\n        } else {\n            if (!field_mul(group, n0, a-\u003eZ, b-\u003eZ, ctx))\n                goto end;\n        }\n        if (!field_mul(group, r-\u003eZ, n0, n5, ctx))\n            goto end;\n    }\n    r-\u003eZ_is_one = 0;\n    /* Z_r = Z_a * Z_b * n5 */\n\n    /* X_r */\n    if (!field_sqr(group, n0, n6, ctx))\n        goto end;\n    if (!field_sqr(group, n4, n5, ctx))\n        goto end;\n    if (!field_mul(group, n3, n1, n4, ctx))\n        goto end;\n    if (!BN_mod_sub_quick(r-\u003eX, n0, n3, p))\n        goto end;\n    /* X_r = n6^2 - n5^2 * 'n7' */\n\n    /* 'n9' */\n    if (!BN_mod_lshift1_quick(n0, r-\u003eX, p))\n        goto end;\n    if (!BN_mod_sub_quick(n0, n3, n0, p))\n        goto end;\n    /* n9 = n5^2 * 'n7' - 2 * X_r */\n\n    /* Y_r */\n    if (!field_mul(group, n0, n0, n6, ctx))\n        goto end;\n    if (!field_mul(group, n5, n4, n5, ctx))\n        goto end;               /* now n5 is n5^3 */\n    if (!field_mul(group, n1, n2, n5, ctx))\n        goto end;\n    if (!BN_mod_sub_quick(n0, n0, n1, p))\n        goto end;\n    if (BN_is_odd(n0))\n        if (!BN_add(n0, n0, p))\n            goto end;\n    /* now  0 \u003c= n0 \u003c 2*p,  and n0 is even */\n    if (!BN_rshift1(r-\u003eY, n0))\n        goto end;\n    /* Y_r = (n6 * 'n9' - 'n8' * 'n5^3') / 2 */\n\n    ret = 1;\n\n end:\n    BN_CTX_end(ctx);\n    BN_CTX_free(new_ctx);\n    return ret;\n}","filepath":"crypto/ec/ecp_smpl.c","line_number":609,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270338544":{"score":0.73650616,"function_name":"ec_GFp_simple_dbl","code":"int ec_GFp_simple_dbl(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,\n                      BN_CTX *ctx)\n{\n    int (*field_mul) (const EC_GROUP *, BIGNUM *, const BIGNUM *,\n                      const BIGNUM *, BN_CTX *);\n    int (*field_sqr) (const EC_GROUP *, BIGNUM *, const BIGNUM *, BN_CTX *);\n    const BIGNUM *p;\n    BN_CTX *new_ctx = NULL;\n    BIGNUM *n0, *n1, *n2, *n3;\n    int ret = 0;\n\n    if (EC_POINT_is_at_infinity(group, a)) {\n        BN_zero(r-\u003eZ);\n        r-\u003eZ_is_one = 0;\n        return 1;\n    }\n\n    field_mul = group-\u003emeth-\u003efield_mul;\n    field_sqr = group-\u003emeth-\u003efield_sqr;\n    p = group-\u003efield;\n\n    if (ctx == NULL) {\n        ctx = new_ctx = BN_CTX_new();\n        if (ctx == NULL)\n            return 0;\n    }\n\n    BN_CTX_start(ctx);\n    n0 = BN_CTX_get(ctx);\n    n1 = BN_CTX_get(ctx);\n    n2 = BN_CTX_get(ctx);\n    n3 = BN_CTX_get(ctx);\n    if (n3 == NULL)\n        goto err;\n\n    /*\n     * Note that in this function we must not read components of 'a' once we\n     * have written the corresponding components of 'r'. ('r' might the same\n     * as 'a'.)\n     */\n\n    /* n1 */\n    if (a-\u003eZ_is_one) {\n        if (!field_sqr(group, n0, a-\u003eX, ctx))\n            goto err;\n        if (!BN_mod_lshift1_quick(n1, n0, p))\n            goto err;\n        if (!BN_mod_add_quick(n0, n0, n1, p))\n            goto err;\n        if (!BN_mod_add_quick(n1, n0, group-\u003ea, p))\n            goto err;\n        /* n1 = 3 * X_a^2 + a_curve */\n    } else if (group-\u003ea_is_minus3) {\n        if (!field_sqr(group, n1, a-\u003eZ, ctx))\n            goto err;\n        if (!BN_mod_add_quick(n0, a-\u003eX, n1, p))\n            goto err;\n        if (!BN_mod_sub_quick(n2, a-\u003eX, n1, p))\n            goto err;\n        if (!field_mul(group, n1, n0, n2, ctx))\n            goto err;\n        if (!BN_mod_lshift1_quick(n0, n1, p))\n            goto err;\n        if (!BN_mod_add_quick(n1, n0, n1, p))\n            goto err;\n        /*-\n         * n1 = 3 * (X_a + Z_a^2) * (X_a - Z_a^2)\n         *    = 3 * X_a^2 - 3 * Z_a^4\n         */\n    } else {\n        if (!field_sqr(group, n0, a-\u003eX, ctx))\n            goto err;\n        if (!BN_mod_lshift1_quick(n1, n0, p))\n            goto err;\n        if (!BN_mod_add_quick(n0, n0, n1, p))\n            goto err;\n        if (!field_sqr(group, n1, a-\u003eZ, ctx))\n            goto err;\n        if (!field_sqr(group, n1, n1, ctx))\n            goto err;\n        if (!field_mul(group, n1, n1, group-\u003ea, ctx))\n            goto err;\n        if (!BN_mod_add_quick(n1, n1, n0, p))\n            goto err;\n        /* n1 = 3 * X_a^2 + a_curve * Z_a^4 */\n    }\n\n    /* Z_r */\n    if (a-\u003eZ_is_one) {\n        if (!BN_copy(n0, a-\u003eY))\n            goto err;\n    } else {\n        if (!field_mul(group, n0, a-\u003eY, a-\u003eZ, ctx))\n            goto err;\n    }\n    if (!BN_mod_lshift1_quick(r-\u003eZ, n0, p))\n        goto err;\n    r-\u003eZ_is_one = 0;\n    /* Z_r = 2 * Y_a * Z_a */\n\n    /* n2 */\n    if (!field_sqr(group, n3, a-\u003eY, ctx))\n        goto err;\n    if (!field_mul(group, n2, a-\u003eX, n3, ctx))\n        goto err;\n    if (!BN_mod_lshift_quick(n2, n2, 2, p))\n        goto err;\n    /* n2 = 4 * X_a * Y_a^2 */\n\n    /* X_r */\n    if (!BN_mod_lshift1_quick(n0, n2, p))\n        goto err;\n    if (!field_sqr(group, r-\u003eX, n1, ctx))\n        goto err;\n    if (!BN_mod_sub_quick(r-\u003eX, r-\u003eX, n0, p))\n        goto err;\n    /* X_r = n1^2 - 2 * n2 */\n\n    /* n3 */\n    if (!field_sqr(group, n0, n3, ctx))\n        goto err;\n    if (!BN_mod_lshift_quick(n3, n0, 3, p))\n        goto err;\n    /* n3 = 8 * Y_a^4 */\n\n    /* Y_r */\n    if (!BN_mod_sub_quick(n0, n2, r-\u003eX, p))\n        goto err;\n    if (!field_mul(group, n0, n1, n0, ctx))\n        goto err;\n    if (!BN_mod_sub_quick(r-\u003eY, n0, n3, p))\n        goto err;\n    /* Y_r = n1 * (n2 - X_r) - n3 */\n\n    ret = 1;\n\n err:\n    BN_CTX_end(ctx);\n    BN_CTX_free(new_ctx);\n    return ret;\n}","filepath":"crypto/ec/ecp_smpl.c","line_number":794,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270339632":{"score":0.7220273,"function_name":"ec_GFp_simple_is_on_curve","code":"int ec_GFp_simple_is_on_curve(const EC_GROUP *group, const EC_POINT *point,\n                              BN_CTX *ctx)\n{\n    int (*field_mul) (const EC_GROUP *, BIGNUM *, const BIGNUM *,\n                      const BIGNUM *, BN_CTX *);\n    int (*field_sqr) (const EC_GROUP *, BIGNUM *, const BIGNUM *, BN_CTX *);\n    const BIGNUM *p;\n    BN_CTX *new_ctx = NULL;\n    BIGNUM *rh, *tmp, *Z4, *Z6;\n    int ret = -1;\n\n    if (EC_POINT_is_at_infinity(group, point))\n        return 1;\n\n    field_mul = group-\u003emeth-\u003efield_mul;\n    field_sqr = group-\u003emeth-\u003efield_sqr;\n    p = group-\u003efield;\n\n    if (ctx == NULL) {\n        ctx = new_ctx = BN_CTX_new();\n        if (ctx == NULL)\n            return -1;\n    }\n\n    BN_CTX_start(ctx);\n    rh = BN_CTX_get(ctx);\n    tmp = BN_CTX_get(ctx);\n    Z4 = BN_CTX_get(ctx);\n    Z6 = BN_CTX_get(ctx);\n    if (Z6 == NULL)\n        goto err;\n\n    /*-\n     * We have a curve defined by a Weierstrass equation\n     *      y^2 = x^3 + a*x + b.\n     * The point to consider is given in Jacobian projective coordinates\n     * where  (X, Y, Z)  represents  (x, y) = (X/Z^2, Y/Z^3).\n     * Substituting this and multiplying by  Z^6  transforms the above equation into\n     *      Y^2 = X^3 + a*X*Z^4 + b*Z^6.\n     * To test this, we add up the right-hand side in 'rh'.\n     */\n\n    /* rh := X^2 */\n    if (!field_sqr(group, rh, point-\u003eX, ctx))\n        goto err;\n\n    if (!point-\u003eZ_is_one) {\n        if (!field_sqr(group, tmp, point-\u003eZ, ctx))\n            goto err;\n        if (!field_sqr(group, Z4, tmp, ctx))\n            goto err;\n        if (!field_mul(group, Z6, Z4, tmp, ctx))\n            goto err;\n\n        /* rh := (rh + a*Z^4)*X */\n        if (group-\u003ea_is_minus3) {\n            if (!BN_mod_lshift1_quick(tmp, Z4, p))\n                goto err;\n            if (!BN_mod_add_quick(tmp, tmp, Z4, p))\n                goto err;\n            if (!BN_mod_sub_quick(rh, rh, tmp, p))\n                goto err;\n            if (!field_mul(group, rh, rh, point-\u003eX, ctx))\n                goto err;\n        } else {\n            if (!field_mul(group, tmp, Z4, group-\u003ea, ctx))\n                goto err;\n            if (!BN_mod_add_quick(rh, rh, tmp, p))\n                goto err;\n            if (!field_mul(group, rh, rh, point-\u003eX, ctx))\n                goto err;\n        }\n\n        /* rh := rh + b*Z^6 */\n        if (!field_mul(group, tmp, group-\u003eb, Z6, ctx))\n            goto err;\n        if (!BN_mod_add_quick(rh, rh, tmp, p))\n            goto err;\n    } else {\n        /* point-\u003eZ_is_one */\n\n        /* rh := (rh + a)*X */\n        if (!BN_mod_add_quick(rh, rh, group-\u003ea, p))\n            goto err;\n        if (!field_mul(group, rh, rh, point-\u003eX, ctx))\n            goto err;\n        /* rh := rh + b */\n        if (!BN_mod_add_quick(rh, rh, group-\u003eb, p))\n            goto err;\n    }\n\n    /* 'lh' := Y^2 */\n    if (!field_sqr(group, tmp, point-\u003eY, ctx))\n        goto err;\n\n    ret = (0 == BN_ucmp(tmp, rh));\n\n err:\n    BN_CTX_end(ctx);\n    BN_CTX_free(new_ctx);\n    return ret;\n}","filepath":"crypto/ec/ecp_smpl.c","line_number":950,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270340256":{"score":0.8382379,"function_name":"ec_GFp_simple_cmp","code":"int ec_GFp_simple_cmp(const EC_GROUP *group, const EC_POINT *a,\n                      const EC_POINT *b, BN_CTX *ctx)\n{\n    /*-\n     * return values:\n     *  -1   error\n     *   0   equal (in affine coordinates)\n     *   1   not equal\n     */\n\n    int (*field_mul) (const EC_GROUP *, BIGNUM *, const BIGNUM *,\n                      const BIGNUM *, BN_CTX *);\n    int (*field_sqr) (const EC_GROUP *, BIGNUM *, const BIGNUM *, BN_CTX *);\n    BN_CTX *new_ctx = NULL;\n    BIGNUM *tmp1, *tmp2, *Za23, *Zb23;\n    const BIGNUM *tmp1_, *tmp2_;\n    int ret = -1;\n\n    if (EC_POINT_is_at_infinity(group, a)) {\n        return EC_POINT_is_at_infinity(group, b) ? 0 : 1;\n    }\n\n    if (EC_POINT_is_at_infinity(group, b))\n        return 1;\n\n    if (a-\u003eZ_is_one \u0026\u0026 b-\u003eZ_is_one) {\n        return ((BN_cmp(a-\u003eX, b-\u003eX) == 0) \u0026\u0026 BN_cmp(a-\u003eY, b-\u003eY) == 0) ? 0 : 1;\n    }\n\n    field_mul = group-\u003emeth-\u003efield_mul;\n    field_sqr = group-\u003emeth-\u003efield_sqr;\n\n    if (ctx == NULL) {\n        ctx = new_ctx = BN_CTX_new();\n        if (ctx == NULL)\n            return -1;\n    }\n\n    BN_CTX_start(ctx);\n    tmp1 = BN_CTX_get(ctx);\n    tmp2 = BN_CTX_get(ctx);\n    Za23 = BN_CTX_get(ctx);\n    Zb23 = BN_CTX_get(ctx);\n    if (Zb23 == NULL)\n        goto end;\n\n    /*-\n     * We have to decide whether\n     *     (X_a/Z_a^2, Y_a/Z_a^3) = (X_b/Z_b^2, Y_b/Z_b^3),\n     * or equivalently, whether\n     *     (X_a*Z_b^2, Y_a*Z_b^3) = (X_b*Z_a^2, Y_b*Z_a^3).\n     */\n\n    if (!b-\u003eZ_is_one) {\n        if (!field_sqr(group, Zb23, b-\u003eZ, ctx))\n            goto end;\n        if (!field_mul(group, tmp1, a-\u003eX, Zb23, ctx))\n            goto end;\n        tmp1_ = tmp1;\n    } else\n        tmp1_ = a-\u003eX;\n    if (!a-\u003eZ_is_one) {\n        if (!field_sqr(group, Za23, a-\u003eZ, ctx))\n            goto end;\n        if (!field_mul(group, tmp2, b-\u003eX, Za23, ctx))\n            goto end;\n        tmp2_ = tmp2;\n    } else\n        tmp2_ = b-\u003eX;\n\n    /* compare  X_a*Z_b^2  with  X_b*Z_a^2 */\n    if (BN_cmp(tmp1_, tmp2_) != 0) {\n        ret = 1;                /* points differ */\n        goto end;\n    }\n\n    if (!b-\u003eZ_is_one) {\n        if (!field_mul(group, Zb23, Zb23, b-\u003eZ, ctx))\n            goto end;\n        if (!field_mul(group, tmp1, a-\u003eY, Zb23, ctx))\n            goto end;\n        /* tmp1_ = tmp1 */\n    } else\n        tmp1_ = a-\u003eY;\n    if (!a-\u003eZ_is_one) {\n        if (!field_mul(group, Za23, Za23, a-\u003eZ, ctx))\n            goto end;\n        if (!field_mul(group, tmp2, b-\u003eY, Za23, ctx))\n            goto end;\n        /* tmp2_ = tmp2 */\n    } else\n        tmp2_ = b-\u003eY;\n\n    /* compare  Y_a*Z_b^3  with  Y_b*Z_a^3 */\n    if (BN_cmp(tmp1_, tmp2_) != 0) {\n        ret = 1;                /* points differ */\n        goto end;\n    }\n\n    /* points are equal */\n    ret = 0;\n\n end:\n    BN_CTX_end(ctx);\n    BN_CTX_free(new_ctx);\n    return ret;\n}","filepath":"crypto/ec/ecp_smpl.c","line_number":1053,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270340896":{"score":0.90469265,"function_name":"ec_GFp_simple_make_affine","code":"int ec_GFp_simple_make_affine(const EC_GROUP *group, EC_POINT *point,\n                              BN_CTX *ctx)\n{\n    BN_CTX *new_ctx = NULL;\n    BIGNUM *x, *y;\n    int ret = 0;\n\n    if (point-\u003eZ_is_one || EC_POINT_is_at_infinity(group, point))\n        return 1;\n\n    if (ctx == NULL) {\n        ctx = new_ctx = BN_CTX_new();\n        if (ctx == NULL)\n            return 0;\n    }\n\n    BN_CTX_start(ctx);\n    x = BN_CTX_get(ctx);\n    y = BN_CTX_get(ctx);\n    if (y == NULL)\n        goto err;\n\n    if (!EC_POINT_get_affine_coordinates(group, point, x, y, ctx))\n        goto err;\n    if (!EC_POINT_set_affine_coordinates(group, point, x, y, ctx))\n        goto err;\n    if (!point-\u003eZ_is_one) {\n        ECerr(EC_F_EC_GFP_SIMPLE_MAKE_AFFINE, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    ret = 1;\n\n err:\n    BN_CTX_end(ctx);\n    BN_CTX_free(new_ctx);\n    return ret;\n}","filepath":"crypto/ec/ecp_smpl.c","line_number":1161,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270341136":{"score":0.8833821,"function_name":"ec_GFp_simple_points_make_affine","code":"int ec_GFp_simple_points_make_affine(const EC_GROUP *group, size_t num,\n                                     EC_POINT *points[], BN_CTX *ctx)\n{\n    BN_CTX *new_ctx = NULL;\n    BIGNUM *tmp, *tmp_Z;\n    BIGNUM **prod_Z = NULL;\n    size_t i;\n    int ret = 0;\n\n    if (num == 0)\n        return 1;\n\n    if (ctx == NULL) {\n        ctx = new_ctx = BN_CTX_new();\n        if (ctx == NULL)\n            return 0;\n    }\n\n    BN_CTX_start(ctx);\n    tmp = BN_CTX_get(ctx);\n    tmp_Z = BN_CTX_get(ctx);\n    if (tmp_Z == NULL)\n        goto err;\n\n    prod_Z = OPENSSL_malloc(num * sizeof(prod_Z[0]));\n    if (prod_Z == NULL)\n        goto err;\n    for (i = 0; i \u003c num; i++) {\n        prod_Z[i] = BN_new();\n        if (prod_Z[i] == NULL)\n            goto err;\n    }\n\n    /*\n     * Set each prod_Z[i] to the product of points[0]-\u003eZ .. points[i]-\u003eZ,\n     * skipping any zero-valued inputs (pretend that they're 1).\n     */\n\n    if (!BN_is_zero(points[0]-\u003eZ)) {\n        if (!BN_copy(prod_Z[0], points[0]-\u003eZ))\n            goto err;\n    } else {\n        if (group-\u003emeth-\u003efield_set_to_one != 0) {\n            if (!group-\u003emeth-\u003efield_set_to_one(group, prod_Z[0], ctx))\n                goto err;\n        } else {\n            if (!BN_one(prod_Z[0]))\n                goto err;\n        }\n    }\n\n    for (i = 1; i \u003c num; i++) {\n        if (!BN_is_zero(points[i]-\u003eZ)) {\n            if (!group-\u003e\n                meth-\u003efield_mul(group, prod_Z[i], prod_Z[i - 1], points[i]-\u003eZ,\n                                ctx))\n                goto err;\n        } else {\n            if (!BN_copy(prod_Z[i], prod_Z[i - 1]))\n                goto err;\n        }\n    }\n\n    /*\n     * Now use a single explicit inversion to replace every non-zero\n     * points[i]-\u003eZ by its inverse.\n     */\n\n    if (!group-\u003emeth-\u003efield_inv(group, tmp, prod_Z[num - 1], ctx)) {\n        ECerr(EC_F_EC_GFP_SIMPLE_POINTS_MAKE_AFFINE, ERR_R_BN_LIB);\n        goto err;\n    }\n    if (group-\u003emeth-\u003efield_encode != 0) {\n        /*\n         * In the Montgomery case, we just turned R*H (representing H) into\n         * 1/(R*H), but we need R*(1/H) (representing 1/H); i.e. we need to\n         * multiply by the Montgomery factor twice.\n         */\n        if (!group-\u003emeth-\u003efield_encode(group, tmp, tmp, ctx))\n            goto err;\n        if (!group-\u003emeth-\u003efield_encode(group, tmp, tmp, ctx))\n            goto err;\n    }\n\n    for (i = num - 1; i \u003e 0; --i) {\n        /*\n         * Loop invariant: tmp is the product of the inverses of points[0]-\u003eZ\n         * .. points[i]-\u003eZ (zero-valued inputs skipped).\n         */\n        if (!BN_is_zero(points[i]-\u003eZ)) {\n            /*\n             * Set tmp_Z to the inverse of points[i]-\u003eZ (as product of Z\n             * inverses 0 .. i, Z values 0 .. i - 1).\n             */\n            if (!group-\u003e\n                meth-\u003efield_mul(group, tmp_Z, prod_Z[i - 1], tmp, ctx))\n                goto err;\n            /*\n             * Update tmp to satisfy the loop invariant for i - 1.\n             */\n            if (!group-\u003emeth-\u003efield_mul(group, tmp, tmp, points[i]-\u003eZ, ctx))\n                goto err;\n            /* Replace points[i]-\u003eZ by its inverse. */\n            if (!BN_copy(points[i]-\u003eZ, tmp_Z))\n                goto err;\n        }\n    }\n\n    if (!BN_is_zero(points[0]-\u003eZ)) {\n        /* Replace points[0]-\u003eZ by its inverse. */\n        if (!BN_copy(points[0]-\u003eZ, tmp))\n            goto err;\n    }\n\n    /* Finally, fix up the X and Y coordinates for all points. */\n\n    for (i = 0; i \u003c num; i++) {\n        EC_POINT *p = points[i];\n\n        if (!BN_is_zero(p-\u003eZ)) {\n            /* turn  (X, Y, 1/Z)  into  (X/Z^2, Y/Z^3, 1) */\n\n            if (!group-\u003emeth-\u003efield_sqr(group, tmp, p-\u003eZ, ctx))\n                goto err;\n            if (!group-\u003emeth-\u003efield_mul(group, p-\u003eX, p-\u003eX, tmp, ctx))\n                goto err;\n\n            if (!group-\u003emeth-\u003efield_mul(group, tmp, tmp, p-\u003eZ, ctx))\n                goto err;\n            if (!group-\u003emeth-\u003efield_mul(group, p-\u003eY, p-\u003eY, tmp, ctx))\n                goto err;\n\n            if (group-\u003emeth-\u003efield_set_to_one != 0) {\n                if (!group-\u003emeth-\u003efield_set_to_one(group, p-\u003eZ, ctx))\n                    goto err;\n            } else {\n                if (!BN_one(p-\u003eZ))\n                    goto err;\n            }\n            p-\u003eZ_is_one = 1;\n        }\n    }\n\n    ret = 1;\n\n err:\n    BN_CTX_end(ctx);\n    BN_CTX_free(new_ctx);\n    if (prod_Z != NULL) {\n        for (i = 0; i \u003c num; i++) {\n            if (prod_Z[i] == NULL)\n                break;\n            BN_clear_free(prod_Z[i]);\n        }\n        OPENSSL_free(prod_Z);\n    }\n    return ret;\n}","filepath":"crypto/ec/ecp_smpl.c","line_number":1200,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270342272":{"score":0.8041499,"function_name":"ec_GFp_simple_field_inv","code":"int ec_GFp_simple_field_inv(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,\n                            BN_CTX *ctx)\n{\n    BIGNUM *e = NULL;\n    BN_CTX *new_ctx = NULL;\n    int ret = 0;\n\n    if (ctx == NULL \u0026\u0026 (ctx = new_ctx = BN_CTX_secure_new()) == NULL)\n        return 0;\n\n    BN_CTX_start(ctx);\n    if ((e = BN_CTX_get(ctx)) == NULL)\n        goto err;\n\n    do {\n        if (!BN_priv_rand_range(e, group-\u003efield))\n        goto err;\n    } while (BN_is_zero(e));\n\n    /* r := a * e */\n    if (!group-\u003emeth-\u003efield_mul(group, r, a, e, ctx))\n        goto err;\n    /* r := 1/(a * e) */\n    if (!BN_mod_inverse(r, r, group-\u003efield, ctx)) {\n        ECerr(EC_F_EC_GFP_SIMPLE_FIELD_INV, EC_R_CANNOT_INVERT);\n        goto err;\n    }\n    /* r := e/(a * e) = 1/a */\n    if (!group-\u003emeth-\u003efield_mul(group, r, r, e, ctx))\n        goto err;\n\n    ret = 1;\n\n err:\n    BN_CTX_end(ctx);\n    BN_CTX_free(new_ctx);\n    return ret;\n}","filepath":"crypto/ec/ecp_smpl.c","line_number":1376,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270342544":{"score":0.91244584,"function_name":"ec_GFp_simple_blind_coordinates","code":"int ec_GFp_simple_blind_coordinates(const EC_GROUP *group, EC_POINT *p,\n                                    BN_CTX *ctx)\n{\n    int ret = 0;\n    BIGNUM *lambda = NULL;\n    BIGNUM *temp = NULL;\n\n    BN_CTX_start(ctx);\n    lambda = BN_CTX_get(ctx);\n    temp = BN_CTX_get(ctx);\n    if (temp == NULL) {\n        ECerr(EC_F_EC_GFP_SIMPLE_BLIND_COORDINATES, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    /* make sure lambda is not zero */\n    do {\n        if (!BN_priv_rand_range(lambda, group-\u003efield)) {\n            ECerr(EC_F_EC_GFP_SIMPLE_BLIND_COORDINATES, ERR_R_BN_LIB);\n            goto err;\n        }\n    } while (BN_is_zero(lambda));\n\n    /* if field_encode defined convert between representations */\n    if (group-\u003emeth-\u003efield_encode != NULL\n        \u0026\u0026 !group-\u003emeth-\u003efield_encode(group, lambda, lambda, ctx))\n        goto err;\n    if (!group-\u003emeth-\u003efield_mul(group, p-\u003eZ, p-\u003eZ, lambda, ctx))\n        goto err;\n    if (!group-\u003emeth-\u003efield_sqr(group, temp, lambda, ctx))\n        goto err;\n    if (!group-\u003emeth-\u003efield_mul(group, p-\u003eX, p-\u003eX, temp, ctx))\n        goto err;\n    if (!group-\u003emeth-\u003efield_mul(group, temp, temp, lambda, ctx))\n        goto err;\n    if (!group-\u003emeth-\u003efield_mul(group, p-\u003eY, p-\u003eY, temp, ctx))\n        goto err;\n    p-\u003eZ_is_one = 0;\n\n    ret = 1;\n\n err:\n    BN_CTX_end(ctx);\n    return ret;\n}","filepath":"crypto/ec/ecp_smpl.c","line_number":1422,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270342944":{"score":0.83993065,"function_name":"ec_GFp_simple_ladder_pre","code":"int ec_GFp_simple_ladder_pre(const EC_GROUP *group,\n                             EC_POINT *r, EC_POINT *s,\n                             EC_POINT *p, BN_CTX *ctx)\n{\n    BIGNUM *t1, *t2, *t3, *t4, *t5, *t6 = NULL;\n\n    t1 = r-\u003eZ;\n    t2 = r-\u003eY;\n    t3 = s-\u003eX;\n    t4 = r-\u003eX;\n    t5 = s-\u003eY;\n    t6 = s-\u003eZ;\n\n    /* convert p: (X,Y,Z) -\u003e (XZ,Y,Z**3) */\n    if (!group-\u003emeth-\u003efield_mul(group, p-\u003eX, p-\u003eX, p-\u003eZ, ctx)\n        || !group-\u003emeth-\u003efield_sqr(group, t1, p-\u003eZ, ctx)\n        || !group-\u003emeth-\u003efield_mul(group, p-\u003eZ, p-\u003eZ, t1, ctx)\n        /* r := 2p */\n        || !group-\u003emeth-\u003efield_sqr(group, t2, p-\u003eX, ctx)\n        || !group-\u003emeth-\u003efield_sqr(group, t3, p-\u003eZ, ctx)\n        || !group-\u003emeth-\u003efield_mul(group, t4, t3, group-\u003ea, ctx)\n        || !BN_mod_sub_quick(t5, t2, t4, group-\u003efield)\n        || !BN_mod_add_quick(t2, t2, t4, group-\u003efield)\n        || !group-\u003emeth-\u003efield_sqr(group, t5, t5, ctx)\n        || !group-\u003emeth-\u003efield_mul(group, t6, t3, group-\u003eb, ctx)\n        || !group-\u003emeth-\u003efield_mul(group, t1, p-\u003eX, p-\u003eZ, ctx)\n        || !group-\u003emeth-\u003efield_mul(group, t4, t1, t6, ctx)\n        || !BN_mod_lshift_quick(t4, t4, 3, group-\u003efield)\n        /* r-\u003eX coord output */\n        || !BN_mod_sub_quick(r-\u003eX, t5, t4, group-\u003efield)\n        || !group-\u003emeth-\u003efield_mul(group, t1, t1, t2, ctx)\n        || !group-\u003emeth-\u003efield_mul(group, t2, t3, t6, ctx)\n        || !BN_mod_add_quick(t1, t1, t2, group-\u003efield)\n        /* r-\u003eZ coord output */\n        || !BN_mod_lshift_quick(r-\u003eZ, t1, 2, group-\u003efield)\n        || !EC_POINT_copy(s, p))\n        return 0;\n\n    r-\u003eZ_is_one = 0;\n    s-\u003eZ_is_one = 0;\n    p-\u003eZ_is_one = 0;\n\n    return 1;\n}","filepath":"crypto/ec/ecp_smpl.c","line_number":1483,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270343616":{"score":0.7729733,"function_name":"ec_GFp_simple_ladder_step","code":"int ec_GFp_simple_ladder_step(const EC_GROUP *group,\n                              EC_POINT *r, EC_POINT *s,\n                              EC_POINT *p, BN_CTX *ctx)\n{\n    int ret = 0;\n    BIGNUM *t0, *t1, *t2, *t3, *t4, *t5, *t6, *t7 = NULL;\n\n    BN_CTX_start(ctx);\n    t0 = BN_CTX_get(ctx);\n    t1 = BN_CTX_get(ctx);\n    t2 = BN_CTX_get(ctx);\n    t3 = BN_CTX_get(ctx);\n    t4 = BN_CTX_get(ctx);\n    t5 = BN_CTX_get(ctx);\n    t6 = BN_CTX_get(ctx);\n    t7 = BN_CTX_get(ctx);\n\n    if (t7 == NULL\n        || !group-\u003emeth-\u003efield_mul(group, t0, r-\u003eX, s-\u003eX, ctx)\n        || !group-\u003emeth-\u003efield_mul(group, t1, r-\u003eZ, s-\u003eZ, ctx)\n        || !group-\u003emeth-\u003efield_mul(group, t2, r-\u003eX, s-\u003eZ, ctx)\n        || !group-\u003emeth-\u003efield_mul(group, t3, r-\u003eZ, s-\u003eX, ctx)\n        || !group-\u003emeth-\u003efield_mul(group, t4, group-\u003ea, t1, ctx)\n        || !BN_mod_add_quick(t0, t0, t4, group-\u003efield)\n        || !BN_mod_add_quick(t4, t3, t2, group-\u003efield)\n        || !group-\u003emeth-\u003efield_mul(group, t0, t4, t0, ctx)\n        || !group-\u003emeth-\u003efield_sqr(group, t1, t1, ctx)\n        || !BN_mod_lshift_quick(t7, group-\u003eb, 2, group-\u003efield)\n        || !group-\u003emeth-\u003efield_mul(group, t1, t7, t1, ctx)\n        || !BN_mod_lshift1_quick(t0, t0, group-\u003efield)\n        || !BN_mod_add_quick(t0, t1, t0, group-\u003efield)\n        || !BN_mod_sub_quick(t1, t2, t3, group-\u003efield)\n        || !group-\u003emeth-\u003efield_sqr(group, t1, t1, ctx)\n        || !group-\u003emeth-\u003efield_mul(group, t3, t1, p-\u003eX, ctx)\n        || !group-\u003emeth-\u003efield_mul(group, t0, p-\u003eZ, t0, ctx)\n        /* s-\u003eX coord output */\n        || !BN_mod_sub_quick(s-\u003eX, t0, t3, group-\u003efield)\n        /* s-\u003eZ coord output */\n        || !group-\u003emeth-\u003efield_mul(group, s-\u003eZ, p-\u003eZ, t1, ctx)\n        || !group-\u003emeth-\u003efield_sqr(group, t3, r-\u003eX, ctx)\n        || !group-\u003emeth-\u003efield_sqr(group, t2, r-\u003eZ, ctx)\n        || !group-\u003emeth-\u003efield_mul(group, t4, t2, group-\u003ea, ctx)\n        || !BN_mod_add_quick(t5, r-\u003eX, r-\u003eZ, group-\u003efield)\n        || !group-\u003emeth-\u003efield_sqr(group, t5, t5, ctx)\n        || !BN_mod_sub_quick(t5, t5, t3, group-\u003efield)\n        || !BN_mod_sub_quick(t5, t5, t2, group-\u003efield)\n        || !BN_mod_sub_quick(t6, t3, t4, group-\u003efield)\n        || !group-\u003emeth-\u003efield_sqr(group, t6, t6, ctx)\n        || !group-\u003emeth-\u003efield_mul(group, t0, t2, t5, ctx)\n        || !group-\u003emeth-\u003efield_mul(group, t0, t7, t0, ctx)\n        /* r-\u003eX coord output */\n        || !BN_mod_sub_quick(r-\u003eX, t6, t0, group-\u003efield)\n        || !BN_mod_add_quick(t6, t3, t4, group-\u003efield)\n        || !group-\u003emeth-\u003efield_sqr(group, t3, t2, ctx)\n        || !group-\u003emeth-\u003efield_mul(group, t7, t3, t7, ctx)\n        || !group-\u003emeth-\u003efield_mul(group, t5, t5, t6, ctx)\n        || !BN_mod_lshift1_quick(t5, t5, group-\u003efield)\n        /* r-\u003eZ coord output */\n        || !BN_mod_add_quick(r-\u003eZ, t7, t5, group-\u003efield))\n        goto err;\n\n    ret = 1;\n\n err:\n    BN_CTX_end(ctx);\n    return ret;\n}","filepath":"crypto/ec/ecp_smpl.c","line_number":1534,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270344912":{"score":0.85665405,"function_name":"ec_GFp_simple_ladder_post","code":"int ec_GFp_simple_ladder_post(const EC_GROUP *group,\n                              EC_POINT *r, EC_POINT *s,\n                              EC_POINT *p, BN_CTX *ctx)\n{\n    int ret = 0;\n    BIGNUM *t0, *t1, *t2, *t3, *t4, *t5, *t6 = NULL;\n\n    if (BN_is_zero(r-\u003eZ))\n        return EC_POINT_set_to_infinity(group, r);\n\n    if (BN_is_zero(s-\u003eZ)) {\n        /* (X,Y,Z) -\u003e (XZ,YZ**2,Z) */\n        if (!group-\u003emeth-\u003efield_mul(group, r-\u003eX, p-\u003eX, p-\u003eZ, ctx)\n            || !group-\u003emeth-\u003efield_sqr(group, r-\u003eZ, p-\u003eZ, ctx)\n            || !group-\u003emeth-\u003efield_mul(group, r-\u003eY, p-\u003eY, r-\u003eZ, ctx)\n            || !BN_copy(r-\u003eZ, p-\u003eZ)\n            || !EC_POINT_invert(group, r, ctx))\n            return 0;\n        return 1;\n    }\n\n    BN_CTX_start(ctx);\n    t0 = BN_CTX_get(ctx);\n    t1 = BN_CTX_get(ctx);\n    t2 = BN_CTX_get(ctx);\n    t3 = BN_CTX_get(ctx);\n    t4 = BN_CTX_get(ctx);\n    t5 = BN_CTX_get(ctx);\n    t6 = BN_CTX_get(ctx);\n\n    if (t6 == NULL\n        || !BN_mod_lshift1_quick(t0, p-\u003eY, group-\u003efield)\n        || !group-\u003emeth-\u003efield_mul(group, t1, r-\u003eX, p-\u003eZ, ctx)\n        || !group-\u003emeth-\u003efield_mul(group, t2, r-\u003eZ, s-\u003eZ, ctx)\n        || !group-\u003emeth-\u003efield_mul(group, t2, t1, t2, ctx)\n        || !group-\u003emeth-\u003efield_mul(group, t3, t2, t0, ctx)\n        || !group-\u003emeth-\u003efield_mul(group, t2, r-\u003eZ, p-\u003eZ, ctx)\n        || !group-\u003emeth-\u003efield_sqr(group, t4, t2, ctx)\n        || !BN_mod_lshift1_quick(t5, group-\u003eb, group-\u003efield)\n        || !group-\u003emeth-\u003efield_mul(group, t4, t4, t5, ctx)\n        || !group-\u003emeth-\u003efield_mul(group, t6, t2, group-\u003ea, ctx)\n        || !group-\u003emeth-\u003efield_mul(group, t5, r-\u003eX, p-\u003eX, ctx)\n        || !BN_mod_add_quick(t5, t6, t5, group-\u003efield)\n        || !group-\u003emeth-\u003efield_mul(group, t6, r-\u003eZ, p-\u003eX, ctx)\n        || !BN_mod_add_quick(t2, t6, t1, group-\u003efield)\n        || !group-\u003emeth-\u003efield_mul(group, t5, t5, t2, ctx)\n        || !BN_mod_sub_quick(t6, t6, t1, group-\u003efield)\n        || !group-\u003emeth-\u003efield_sqr(group, t6, t6, ctx)\n        || !group-\u003emeth-\u003efield_mul(group, t6, t6, s-\u003eX, ctx)\n        || !BN_mod_add_quick(t4, t5, t4, group-\u003efield)\n        || !group-\u003emeth-\u003efield_mul(group, t4, t4, s-\u003eZ, ctx)\n        || !BN_mod_sub_quick(t4, t4, t6, group-\u003efield)\n        || !group-\u003emeth-\u003efield_sqr(group, t5, r-\u003eZ, ctx)\n        || !group-\u003emeth-\u003efield_mul(group, r-\u003eZ, p-\u003eZ, s-\u003eZ, ctx)\n        || !group-\u003emeth-\u003efield_mul(group, r-\u003eZ, t5, r-\u003eZ, ctx)\n        || !group-\u003emeth-\u003efield_mul(group, r-\u003eZ, r-\u003eZ, t0, ctx)\n        /* t3 := X, t4 := Y */\n        /* (X,Y,Z) -\u003e (XZ,YZ**2,Z) */\n        || !group-\u003emeth-\u003efield_mul(group, r-\u003eX, t3, r-\u003eZ, ctx)\n        || !group-\u003emeth-\u003efield_sqr(group, t3, r-\u003eZ, ctx)\n        || !group-\u003emeth-\u003efield_mul(group, r-\u003eY, t4, t3, ctx))\n        goto err;\n\n    ret = 1;\n\n err:\n    BN_CTX_end(ctx);\n    return ret;\n}","filepath":"crypto/ec/ecp_smpl.c","line_number":1619,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270346144":{"score":0.9411406,"function_name":"BN_GF2m_add","code":"int BN_GF2m_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)\n{\n    int i;\n    const BIGNUM *at, *bt;\n\n    bn_check_top(a);\n    bn_check_top(b);\n\n    if (a-\u003etop \u003c b-\u003etop) {\n        at = b;\n        bt = a;\n    } else {\n        at = a;\n        bt = b;\n    }\n\n    if (bn_wexpand(r, at-\u003etop) == NULL)\n        return 0;\n\n    for (i = 0; i \u003c bt-\u003etop; i++) {\n        r-\u003ed[i] = at-\u003ed[i] ^ bt-\u003ed[i];\n    }\n    for (; i \u003c at-\u003etop; i++) {\n        r-\u003ed[i] = at-\u003ed[i];\n    }\n\n    r-\u003etop = at-\u003etop;\n    bn_correct_top(r);\n\n    return 1;\n}","filepath":"crypto/bn/bn_gf2m.c","line_number":252,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270346288":{"score":0.95372385,"function_name":"BN_GF2m_mod_arr","code":"int BN_GF2m_mod_arr(BIGNUM *r, const BIGNUM *a, const int p[])\n{\n    int j, k;\n    int n, dN, d0, d1;\n    BN_ULONG zz, *z;\n\n    bn_check_top(a);\n\n    if (!p[0]) {\n        /* reduction mod 1 =\u003e return 0 */\n        BN_zero(r);\n        return 1;\n    }\n\n    /*\n     * Since the algorithm does reduction in the r value, if a != r, copy the\n     * contents of a into r so we can do reduction in r.\n     */\n    if (a != r) {\n        if (!bn_wexpand(r, a-\u003etop))\n            return 0;\n        for (j = 0; j \u003c a-\u003etop; j++) {\n            r-\u003ed[j] = a-\u003ed[j];\n        }\n        r-\u003etop = a-\u003etop;\n    }\n    z = r-\u003ed;\n\n    /* start reduction */\n    dN = p[0] / BN_BITS2;\n    for (j = r-\u003etop - 1; j \u003e dN;) {\n        zz = z[j];\n        if (z[j] == 0) {\n            j--;\n            continue;\n        }\n        z[j] = 0;\n\n        for (k = 1; p[k] != 0; k++) {\n            /* reducing component t^p[k] */\n            n = p[0] - p[k];\n            d0 = n % BN_BITS2;\n            d1 = BN_BITS2 - d0;\n            n /= BN_BITS2;\n            z[j - n] ^= (zz \u003e\u003e d0);\n            if (d0)\n                z[j - n - 1] ^= (zz \u003c\u003c d1);\n        }\n\n        /* reducing component t^0 */\n        n = dN;\n        d0 = p[0] % BN_BITS2;\n        d1 = BN_BITS2 - d0;\n        z[j - n] ^= (zz \u003e\u003e d0);\n        if (d0)\n            z[j - n - 1] ^= (zz \u003c\u003c d1);\n    }\n\n    /* final round of reduction */\n    while (j == dN) {\n\n        d0 = p[0] % BN_BITS2;\n        zz = z[dN] \u003e\u003e d0;\n        if (zz == 0)\n            break;\n        d1 = BN_BITS2 - d0;\n\n        /* clear up the top d1 bits */\n        if (d0)\n            z[dN] = (z[dN] \u003c\u003c d1) \u003e\u003e d1;\n        else\n            z[dN] = 0;\n        z[0] ^= zz;             /* reduction t^0 component */\n\n        for (k = 1; p[k] != 0; k++) {\n            BN_ULONG tmp_ulong;\n\n            /* reducing component t^p[k] */\n            n = p[k] / BN_BITS2;\n            d0 = p[k] % BN_BITS2;\n            d1 = BN_BITS2 - d0;\n            z[n] ^= (zz \u003c\u003c d0);\n            if (d0 \u0026\u0026 (tmp_ulong = zz \u003e\u003e d1))\n                z[n + 1] ^= tmp_ulong;\n        }\n\n    }\n\n    bn_correct_top(r);\n    return 1;\n}","filepath":"crypto/bn/bn_gf2m.c","line_number":292,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270346848":{"score":0.8703277,"function_name":"BN_GF2m_mod_div","code":"int BN_GF2m_mod_div(BIGNUM *r, const BIGNUM *y, const BIGNUM *x,\n                    const BIGNUM *p, BN_CTX *ctx)\n{\n    BIGNUM *xinv = NULL;\n    int ret = 0;\n\n    bn_check_top(y);\n    bn_check_top(x);\n    bn_check_top(p);\n\n    BN_CTX_start(ctx);\n    xinv = BN_CTX_get(ctx);\n    if (xinv == NULL)\n        goto err;\n\n    if (!BN_GF2m_mod_inv(xinv, x, p, ctx))\n        goto err;\n    if (!BN_GF2m_mod_mul(r, y, xinv, p, ctx))\n        goto err;\n    bn_check_top(r);\n    ret = 1;\n\n err:\n    BN_CTX_end(ctx);\n    return ret;\n}","filepath":"crypto/bn/bn_gf2m.c","line_number":790,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270346960":{"score":0.9000266,"function_name":"BN_GF2m_mod_exp_arr","code":"int BN_GF2m_mod_exp_arr(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,\n                        const int p[], BN_CTX *ctx)\n{\n    int ret = 0, i, n;\n    BIGNUM *u;\n\n    bn_check_top(a);\n    bn_check_top(b);\n\n    if (BN_is_zero(b))\n        return BN_one(r);\n\n    if (BN_abs_is_word(b, 1))\n        return (BN_copy(r, a) != NULL);\n\n    BN_CTX_start(ctx);\n    if ((u = BN_CTX_get(ctx)) == NULL)\n        goto err;\n\n    if (!BN_GF2m_mod_arr(u, a, p))\n        goto err;\n\n    n = BN_num_bits(b) - 1;\n    for (i = n - 1; i \u003e= 0; i--) {\n        if (!BN_GF2m_mod_sqr_arr(u, u, p, ctx))\n            goto err;\n        if (BN_is_bit_set(b, i)) {\n            if (!BN_GF2m_mod_mul_arr(u, u, a, p, ctx))\n                goto err;\n        }\n    }\n    if (!BN_copy(r, u))\n        goto err;\n    bn_check_top(r);\n    ret = 1;\n err:\n    BN_CTX_end(ctx);\n    return ret;\n}","filepath":"crypto/bn/bn_gf2m.c","line_number":851,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270347232":{"score":0.8531125,"function_name":"BN_GF2m_mod_inv","code":"int BN_GF2m_mod_inv(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)\n{\n    BIGNUM *b = NULL;\n    int ret = 0;\n\n    BN_CTX_start(ctx);\n    if ((b = BN_CTX_get(ctx)) == NULL)\n        goto err;\n\n    /* generate blinding value */\n    do {\n        if (!BN_priv_rand(b, BN_num_bits(p) - 1,\n                          BN_RAND_TOP_ANY, BN_RAND_BOTTOM_ANY))\n            goto err;\n    } while (BN_is_zero(b));\n\n    /* r := a * b */\n    if (!BN_GF2m_mod_mul(r, a, b, p, ctx))\n        goto err;\n\n    /* r := 1/(a * b) */\n    if (!BN_GF2m_mod_inv_vartime(r, r, p, ctx))\n        goto err;\n\n    /* r := b/(a * b) = 1/a */\n    if (!BN_GF2m_mod_mul(r, r, b, p, ctx))\n        goto err;\n\n    ret = 1;\n\n err:\n    BN_CTX_end(ctx);\n    return ret;\n}","filepath":"crypto/bn/bn_gf2m.c","line_number":724,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270348672":{"score":0.9158759,"function_name":"BN_GF2m_mod_mul","code":"int BN_GF2m_mod_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,\n                    const BIGNUM *p, BN_CTX *ctx)\n{\n    int ret = 0;\n    const int max = BN_num_bits(p) + 1;\n    int *arr = NULL;\n    bn_check_top(a);\n    bn_check_top(b);\n    bn_check_top(p);\n    if ((arr = OPENSSL_malloc(sizeof(*arr) * max)) == NULL)\n        goto err;\n    ret = BN_GF2m_poly2arr(p, arr, max);\n    if (!ret || ret \u003e max) {\n        BNerr(BN_F_BN_GF2M_MOD_MUL, BN_R_INVALID_LENGTH);\n        goto err;\n    }\n    ret = BN_GF2m_mod_mul_arr(r, a, b, arr, ctx);\n    bn_check_top(r);\n err:\n    OPENSSL_free(arr);\n    return ret;\n}","filepath":"crypto/bn/bn_gf2m.c","line_number":465,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270348832":{"score":0.810495,"function_name":"BN_GF2m_mod_mul_arr","code":"int BN_GF2m_mod_mul_arr(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,\n                        const int p[], BN_CTX *ctx)\n{\n    int zlen, i, j, k, ret = 0;\n    BIGNUM *s;\n    BN_ULONG x1, x0, y1, y0, zz[4];\n\n    bn_check_top(a);\n    bn_check_top(b);\n\n    if (a == b) {\n        return BN_GF2m_mod_sqr_arr(r, a, p, ctx);\n    }\n\n    BN_CTX_start(ctx);\n    if ((s = BN_CTX_get(ctx)) == NULL)\n        goto err;\n\n    zlen = a-\u003etop + b-\u003etop + 4;\n    if (!bn_wexpand(s, zlen))\n        goto err;\n    s-\u003etop = zlen;\n\n    for (i = 0; i \u003c zlen; i++)\n        s-\u003ed[i] = 0;\n\n    for (j = 0; j \u003c b-\u003etop; j += 2) {\n        y0 = b-\u003ed[j];\n        y1 = ((j + 1) == b-\u003etop) ? 0 : b-\u003ed[j + 1];\n        for (i = 0; i \u003c a-\u003etop; i += 2) {\n            x0 = a-\u003ed[i];\n            x1 = ((i + 1) == a-\u003etop) ? 0 : a-\u003ed[i + 1];\n            bn_GF2m_mul_2x2(zz, x1, x0, y1, y0);\n            for (k = 0; k \u003c 4; k++)\n                s-\u003ed[i + j + k] ^= zz[k];\n        }\n    }\n\n    bn_correct_top(s);\n    if (BN_GF2m_mod_arr(r, s, p))\n        ret = 1;\n    bn_check_top(r);\n\n err:\n    BN_CTX_end(ctx);\n    return ret;\n}","filepath":"crypto/bn/bn_gf2m.c","line_number":410,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270349408":{"score":0.9381948,"function_name":"BN_GF2m_mod_solve_quad_arr","code":"int BN_GF2m_mod_solve_quad_arr(BIGNUM *r, const BIGNUM *a_, const int p[],\n                               BN_CTX *ctx)\n{\n    int ret = 0, count = 0, j;\n    BIGNUM *a, *z, *rho, *w, *w2, *tmp;\n\n    bn_check_top(a_);\n\n    if (!p[0]) {\n        /* reduction mod 1 =\u003e return 0 */\n        BN_zero(r);\n        return 1;\n    }\n\n    BN_CTX_start(ctx);\n    a = BN_CTX_get(ctx);\n    z = BN_CTX_get(ctx);\n    w = BN_CTX_get(ctx);\n    if (w == NULL)\n        goto err;\n\n    if (!BN_GF2m_mod_arr(a, a_, p))\n        goto err;\n\n    if (BN_is_zero(a)) {\n        BN_zero(r);\n        ret = 1;\n        goto err;\n    }\n\n    if (p[0] \u0026 0x1) {           /* m is odd */\n        /* compute half-trace of a */\n        if (!BN_copy(z, a))\n            goto err;\n        for (j = 1; j \u003c= (p[0] - 1) / 2; j++) {\n            if (!BN_GF2m_mod_sqr_arr(z, z, p, ctx))\n                goto err;\n            if (!BN_GF2m_mod_sqr_arr(z, z, p, ctx))\n                goto err;\n            if (!BN_GF2m_add(z, z, a))\n                goto err;\n        }\n\n    } else {                    /* m is even */\n\n        rho = BN_CTX_get(ctx);\n        w2 = BN_CTX_get(ctx);\n        tmp = BN_CTX_get(ctx);\n        if (tmp == NULL)\n            goto err;\n        do {\n            if (!BN_priv_rand(rho, p[0], BN_RAND_TOP_ONE, BN_RAND_BOTTOM_ANY))\n                goto err;\n            if (!BN_GF2m_mod_arr(rho, rho, p))\n                goto err;\n            BN_zero(z);\n            if (!BN_copy(w, rho))\n                goto err;\n            for (j = 1; j \u003c= p[0] - 1; j++) {\n                if (!BN_GF2m_mod_sqr_arr(z, z, p, ctx))\n                    goto err;\n                if (!BN_GF2m_mod_sqr_arr(w2, w, p, ctx))\n                    goto err;\n                if (!BN_GF2m_mod_mul_arr(tmp, w2, a, p, ctx))\n                    goto err;\n                if (!BN_GF2m_add(z, z, tmp))\n                    goto err;\n                if (!BN_GF2m_add(w, w2, rho))\n                    goto err;\n            }\n            count++;\n        } while (BN_is_zero(w) \u0026\u0026 (count \u003c MAX_ITERATIONS));\n        if (BN_is_zero(w)) {\n            BNerr(BN_F_BN_GF2M_MOD_SOLVE_QUAD_ARR, BN_R_TOO_MANY_ITERATIONS);\n            goto err;\n        }\n    }\n\n    if (!BN_GF2m_mod_sqr_arr(w, z, p, ctx))\n        goto err;\n    if (!BN_GF2m_add(w, z, w))\n        goto err;\n    if (BN_GF2m_cmp(w, a)) {\n        BNerr(BN_F_BN_GF2M_MOD_SOLVE_QUAD_ARR, BN_R_NO_SOLUTION);\n        goto err;\n    }\n\n    if (!BN_copy(r, z))\n        goto err;\n    bn_check_top(r);\n\n    ret = 1;\n\n err:\n    BN_CTX_end(ctx);\n    return ret;\n}","filepath":"crypto/bn/bn_gf2m.c","line_number":983,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270350272":{"score":0.8473313,"function_name":"BN_GF2m_mod_sqr_arr","code":"int BN_GF2m_mod_sqr_arr(BIGNUM *r, const BIGNUM *a, const int p[],\n                        BN_CTX *ctx)\n{\n    int i, ret = 0;\n    BIGNUM *s;\n\n    bn_check_top(a);\n    BN_CTX_start(ctx);\n    if ((s = BN_CTX_get(ctx)) == NULL)\n        goto err;\n    if (!bn_wexpand(s, 2 * a-\u003etop))\n        goto err;\n\n    for (i = a-\u003etop - 1; i \u003e= 0; i--) {\n        s-\u003ed[2 * i + 1] = SQR1(a-\u003ed[i]);\n        s-\u003ed[2 * i] = SQR0(a-\u003ed[i]);\n    }\n\n    s-\u003etop = 2 * a-\u003etop;\n    bn_correct_top(s);\n    if (!BN_GF2m_mod_arr(r, s, p))\n        goto err;\n    bn_check_top(r);\n    ret = 1;\n err:\n    BN_CTX_end(ctx);\n    return ret;\n}","filepath":"crypto/bn/bn_gf2m.c","line_number":489,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270350784":{"score":0.8983239,"function_name":"BN_GF2m_mod_sqrt_arr","code":"int BN_GF2m_mod_sqrt_arr(BIGNUM *r, const BIGNUM *a, const int p[],\n                         BN_CTX *ctx)\n{\n    int ret = 0;\n    BIGNUM *u;\n\n    bn_check_top(a);\n\n    if (!p[0]) {\n        /* reduction mod 1 =\u003e return 0 */\n        BN_zero(r);\n        return 1;\n    }\n\n    BN_CTX_start(ctx);\n    if ((u = BN_CTX_get(ctx)) == NULL)\n        goto err;\n\n    if (!BN_set_bit(u, p[0] - 1))\n        goto err;\n    ret = BN_GF2m_mod_exp_arr(r, a, u, p, ctx);\n    bn_check_top(r);\n\n err:\n    BN_CTX_end(ctx);\n    return ret;\n}","filepath":"crypto/bn/bn_gf2m.c","line_number":924,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270350896":{"score":0.93637896,"function_name":"BN_GF2m_poly2arr","code":"int BN_GF2m_poly2arr(const BIGNUM *a, int p[], int max)\n{\n    int i, j, k = 0;\n    BN_ULONG mask;\n\n    if (BN_is_zero(a))\n        return 0;\n\n    for (i = a-\u003etop - 1; i \u003e= 0; i--) {\n        if (!a-\u003ed[i])\n            /* skip word if a-\u003ed[i] == 0 */\n            continue;\n        mask = BN_TBIT;\n        for (j = BN_BITS2 - 1; j \u003e= 0; j--) {\n            if (a-\u003ed[i] \u0026 mask) {\n                if (k \u003c max)\n                    p[k] = BN_BITS2 * i + j;\n                k++;\n            }\n            mask \u003e\u003e= 1;\n        }\n    }\n\n    if (k \u003c max) {\n        p[k] = -1;\n        k++;\n    }\n\n    return k;\n}","filepath":"crypto/bn/bn_gf2m.c","line_number":1116,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270356320":{"score":0.8660979,"function_name":"i2r_certpol","code":"static int i2r_certpol(X509V3_EXT_METHOD *method, STACK_OF(POLICYINFO) *pol,\n\t\tBIO *out, int indent)\n{\n\tint i;\n\tPOLICYINFO *pinfo;\n\t/* First print out the policy OIDs */\n\tfor(i = 0; i \u003c sk_POLICYINFO_num(pol); i++) {\n\t\tpinfo = sk_POLICYINFO_value(pol, i);\n\t\tBIO_printf(out, \"%*sPolicy: \", indent, \"\");\n\t\ti2a_ASN1_OBJECT(out, pinfo-\u003epolicyid);\n\t\tBIO_puts(out, \"\\n\");\n\t\tif(pinfo-\u003equalifiers)\n\t\t\t print_qualifiers(out, pinfo-\u003equalifiers, indent + 2);\n\t}\n\treturn 1;\n}","filepath":"crypto/x509v3/v3_cpols.c","line_number":365,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_0_0-beta1"},"270357648":{"score":0.80317694,"function_name":"notice_section","code":"static POLICYQUALINFO *notice_section(X509V3_CTX *ctx,\n\t\t\t\t\tSTACK_OF(CONF_VALUE) *unot, int ia5org)\n{\n\tint i, ret;\n\tCONF_VALUE *cnf;\n\tUSERNOTICE *not;\n\tPOLICYQUALINFO *qual;\n\tif(!(qual = POLICYQUALINFO_new())) goto merr;\n\tqual-\u003epqualid = OBJ_nid2obj(NID_id_qt_unotice);\n\tif(!(not = USERNOTICE_new())) goto merr;\n\tqual-\u003ed.usernotice = not;\n\tfor(i = 0; i \u003c sk_CONF_VALUE_num(unot); i++) {\n\t\tcnf = sk_CONF_VALUE_value(unot, i);\n\t\tif(!strcmp(cnf-\u003ename, \"explicitText\")) {\n\t\t\tnot-\u003eexptext = M_ASN1_VISIBLESTRING_new();\n\t\t\tif(!ASN1_STRING_set(not-\u003eexptext, cnf-\u003evalue,\n\t\t\t\t\t\t strlen(cnf-\u003evalue))) goto merr;\n\t\t} else if(!strcmp(cnf-\u003ename, \"organization\")) {\n\t\t\tNOTICEREF *nref;\n\t\t\tif(!not-\u003enoticeref) {\n\t\t\t\tif(!(nref = NOTICEREF_new())) goto merr;\n\t\t\t\tnot-\u003enoticeref = nref;\n\t\t\t} else nref = not-\u003enoticeref;\n\t\t\tif(ia5org) nref-\u003eorganization-\u003etype = V_ASN1_IA5STRING;\n\t\t\telse nref-\u003eorganization-\u003etype = V_ASN1_VISIBLESTRING;\n\t\t\tif(!ASN1_STRING_set(nref-\u003eorganization, cnf-\u003evalue,\n\t\t\t\t\t\t strlen(cnf-\u003evalue))) goto merr;\n\t\t} else if(!strcmp(cnf-\u003ename, \"noticeNumbers\")) {\n\t\t\tNOTICEREF *nref;\n\t\t\tSTACK_OF(CONF_VALUE) *nos;\n\t\t\tif(!not-\u003enoticeref) {\n\t\t\t\tif(!(nref = NOTICEREF_new())) goto merr;\n\t\t\t\tnot-\u003enoticeref = nref;\n\t\t\t} else nref = not-\u003enoticeref;\n\t\t\tnos = X509V3_parse_list(cnf-\u003evalue);\n\t\t\tif(!nos || !sk_CONF_VALUE_num(nos)) {\n\t\t\t\tX509V3err(X509V3_F_NOTICE_SECTION,X509V3_R_INVALID_NUMBERS);\n\t\t\t\tX509V3_conf_err(cnf);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tret = nref_nos(nref-\u003enoticenos, nos);\n\t\t\tsk_CONF_VALUE_pop_free(nos, X509V3_conf_free);\n\t\t\tif (!ret)\n\t\t\t\tgoto err;\n\t\t} else {\n\t\t\tX509V3err(X509V3_F_NOTICE_SECTION,X509V3_R_INVALID_OPTION);\n\t\t\tX509V3_conf_err(cnf);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif(not-\u003enoticeref \u0026\u0026 \n\t      (!not-\u003enoticeref-\u003enoticenos || !not-\u003enoticeref-\u003eorganization)) {\n\t\t\tX509V3err(X509V3_F_NOTICE_SECTION,X509V3_R_NEED_ORGANIZATION_AND_NUMBERS);\n\t\t\tgoto err;\n\t}\n\n\treturn qual;\n\n\tmerr:\n\tX509V3err(X509V3_F_NOTICE_SECTION,ERR_R_MALLOC_FAILURE);\n\n\terr:\n\tPOLICYQUALINFO_free(qual);\n\treturn NULL;\n}","filepath":"crypto/x509v3/v3_cpols.c","line_number":272,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_0_0-beta1"},"270358832":{"score":0.86870825,"function_name":"policy_section","code":"static POLICYINFO *policy_section(X509V3_CTX *ctx,\n\t\t\t\tSTACK_OF(CONF_VALUE) *polstrs, int ia5org)\n{\n\tint i;\n\tCONF_VALUE *cnf;\n\tPOLICYINFO *pol;\n\tPOLICYQUALINFO *qual;\n\tif(!(pol = POLICYINFO_new())) goto merr;\n\tfor(i = 0; i \u003c sk_CONF_VALUE_num(polstrs); i++) {\n\t\tcnf = sk_CONF_VALUE_value(polstrs, i);\n\t\tif(!strcmp(cnf-\u003ename, \"policyIdentifier\")) {\n\t\t\tASN1_OBJECT *pobj;\n\t\t\tif(!(pobj = OBJ_txt2obj(cnf-\u003evalue, 0))) {\n\t\t\t\tX509V3err(X509V3_F_POLICY_SECTION,X509V3_R_INVALID_OBJECT_IDENTIFIER);\n\t\t\t\tX509V3_conf_err(cnf);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tpol-\u003epolicyid = pobj;\n\n\t\t} else if(!name_cmp(cnf-\u003ename, \"CPS\")) {\n\t\t\tif(!pol-\u003equalifiers) pol-\u003equalifiers =\n\t\t\t\t\t\t sk_POLICYQUALINFO_new_null();\n\t\t\tif(!(qual = POLICYQUALINFO_new())) goto merr;\n\t\t\tif(!sk_POLICYQUALINFO_push(pol-\u003equalifiers, qual))\n\t\t\t\t\t\t\t\t goto merr;\n\t\t\tqual-\u003epqualid = OBJ_nid2obj(NID_id_qt_cps);\n\t\t\tqual-\u003ed.cpsuri = M_ASN1_IA5STRING_new();\n\t\t\tif(!ASN1_STRING_set(qual-\u003ed.cpsuri, cnf-\u003evalue,\n\t\t\t\t\t\t strlen(cnf-\u003evalue))) goto merr;\n\t\t} else if(!name_cmp(cnf-\u003ename, \"userNotice\")) {\n\t\t\tSTACK_OF(CONF_VALUE) *unot;\n\t\t\tif(*cnf-\u003evalue != '@') {\n\t\t\t\tX509V3err(X509V3_F_POLICY_SECTION,X509V3_R_EXPECTED_A_SECTION_NAME);\n\t\t\t\tX509V3_conf_err(cnf);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tunot = X509V3_get_section(ctx, cnf-\u003evalue + 1);\n\t\t\tif(!unot) {\n\t\t\t\tX509V3err(X509V3_F_POLICY_SECTION,X509V3_R_INVALID_SECTION);\n\n\t\t\t\tX509V3_conf_err(cnf);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tqual = notice_section(ctx, unot, ia5org);\n\t\t\tX509V3_section_free(ctx, unot);\n\t\t\tif(!qual) goto err;\n\t\t\tif(!pol-\u003equalifiers) pol-\u003equalifiers =\n\t\t\t\t\t\t sk_POLICYQUALINFO_new_null();\n\t\t\tif(!sk_POLICYQUALINFO_push(pol-\u003equalifiers, qual))\n\t\t\t\t\t\t\t\t goto merr;\n\t\t} else {\n\t\t\tX509V3err(X509V3_F_POLICY_SECTION,X509V3_R_INVALID_OPTION);\n\n\t\t\tX509V3_conf_err(cnf);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tif(!pol-\u003epolicyid) {\n\t\tX509V3err(X509V3_F_POLICY_SECTION,X509V3_R_NO_POLICY_IDENTIFIER);\n\t\tgoto err;\n\t}\n\n\treturn pol;\n\n\tmerr:\n\tX509V3err(X509V3_F_POLICY_SECTION,ERR_R_MALLOC_FAILURE);\n\n\terr:\n\tPOLICYINFO_free(pol);\n\treturn NULL;\n\t\n\t\n}","filepath":"crypto/x509v3/v3_cpols.c","line_number":198,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_0_0-beta1"},"270361504":{"score":0.79840386,"function_name":"ASN1_STRING_TABLE_add","code":"int ASN1_STRING_TABLE_add(int nid,\n                          long minsize, long maxsize, unsigned long mask,\n                          unsigned long flags)\n{\n    ASN1_STRING_TABLE *tmp;\n\n    tmp = stable_get(nid);\n    if (tmp == NULL) {\n        ASN1err(ASN1_F_ASN1_STRING_TABLE_ADD, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n    if (minsize \u003e= 0)\n        tmp-\u003eminsize = minsize;\n    if (maxsize \u003e= 0)\n        tmp-\u003emaxsize = maxsize;\n    if (mask)\n        tmp-\u003emask = mask;\n    if (flags)\n        tmp-\u003eflags = STABLE_FLAGS_MALLOC | flags;\n    return 1;\n}","filepath":"crypto/asn1/a_strnid.c","line_number":182,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre5"},"270361872":{"score":0.66196764,"function_name":"ASN1_STRING_TABLE_get","code":"ASN1_STRING_TABLE *ASN1_STRING_TABLE_get(int nid)\n{\n    int idx;\n    ASN1_STRING_TABLE fnd;\n\n    fnd.nid = nid;\n    if (stable) {\n        idx = sk_ASN1_STRING_TABLE_find(stable, \u0026fnd);\n        if (idx \u003e= 0)\n            return sk_ASN1_STRING_TABLE_value(stable, idx);\n    }\n    return OBJ_bsearch_table(\u0026fnd, tbl_standard, OSSL_NELEM(tbl_standard));\n}","filepath":"crypto/asn1/a_strnid.c","line_number":127,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre5"},"270362000":{"score":0.7661724,"function_name":"ASN1_STRING_set_by_NID","code":"ASN1_STRING *ASN1_STRING_set_by_NID(ASN1_STRING **out,\n                                    const unsigned char *in, int inlen,\n                                    int inform, int nid)\n{\n    ASN1_STRING_TABLE *tbl;\n    ASN1_STRING *str = NULL;\n    unsigned long mask;\n    int ret;\n\n    if (out == NULL)\n        out = \u0026str;\n    tbl = ASN1_STRING_TABLE_get(nid);\n    if (tbl != NULL) {\n        mask = tbl-\u003emask;\n        if (!(tbl-\u003eflags \u0026 STABLE_NO_MASK))\n            mask \u0026= global_mask;\n        ret = ASN1_mbstring_ncopy(out, in, inlen, inform, mask,\n                                  tbl-\u003eminsize, tbl-\u003emaxsize);\n    } else {\n        ret = ASN1_mbstring_copy(out, in, inlen, inform,\n                                 DIRSTRING_TYPE \u0026 global_mask);\n    }\n    if (ret \u003c= 0)\n        return NULL;\n    return *out;\n}","filepath":"crypto/asn1/a_strnid.c","line_number":79,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre5"},"270364096":{"score":0.8492782,"function_name":"sxnet_v2i","code":"static SXNET *sxnet_v2i(X509V3_EXT_METHOD *method, X509V3_CTX *ctx,\n                        STACK_OF(CONF_VALUE) *nval)\n{\n    CONF_VALUE *cnf;\n    SXNET *sx = NULL;\n    int i;\n    for (i = 0; i \u003c sk_CONF_VALUE_num(nval); i++) {\n        cnf = sk_CONF_VALUE_value(nval, i);\n        if (!SXNET_add_id_asc(\u0026sx, cnf-\u003ename, cnf-\u003evalue, -1))\n            return NULL;\n    }\n    return sx;\n}","filepath":"crypto/x509/v3_sxnet.c","line_number":96,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha14"},"270364240":{"score":0.89804363,"function_name":"SXNET_add_id_INTEGER","code":"int SXNET_add_id_INTEGER(SXNET **psx, ASN1_INTEGER *zone, const char *user,\n                         int userlen)\n{\n    SXNET *sx = NULL;\n    SXNETID *id = NULL;\n\n    if (psx == NULL || zone == NULL || user == NULL) {\n        ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_NULL_ARGUMENT);\n        return 0;\n    }\n    if (userlen == -1)\n        userlen = strlen(user);\n    if (userlen \u003e 64) {\n        ERR_raise(ERR_LIB_X509V3, X509V3_R_USER_TOO_LONG);\n        return 0;\n    }\n    if (*psx == NULL) {\n        if ((sx = SXNET_new()) == NULL)\n            goto err;\n        if (!ASN1_INTEGER_set(sx-\u003eversion, 0))\n            goto err;\n        *psx = sx;\n    } else\n        sx = *psx;\n    if (SXNET_get_id_INTEGER(sx, zone)) {\n        ERR_raise(ERR_LIB_X509V3, X509V3_R_DUPLICATE_ZONE_ID);\n        return 0;\n    }\n\n    if ((id = SXNETID_new()) == NULL)\n        goto err;\n    if (userlen == -1)\n        userlen = strlen(user);\n\n    if (!ASN1_OCTET_STRING_set(id-\u003euser, (const unsigned char *)user, userlen))\n        goto err;\n    if (!sk_SXNETID_push(sx-\u003eids, id))\n        goto err;\n    id-\u003ezone = zone;\n    return 1;\n\n err:\n    ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n    SXNETID_free(id);\n    SXNET_free(sx);\n    *psx = NULL;\n    return 0;\n}","filepath":"crypto/x509/v3_sxnet.c","line_number":149,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha14"},"270364640":{"score":0.8283836,"function_name":"SXNET_get_id_INTEGER","code":"ASN1_OCTET_STRING *SXNET_get_id_INTEGER(SXNET *sx, ASN1_INTEGER *zone)\n{\n    SXNETID *id;\n    int i;\n    for (i = 0; i \u003c sk_SXNETID_num(sx-\u003eids); i++) {\n        id = sk_SXNETID_value(sx-\u003eids, i);\n        if (!ASN1_INTEGER_cmp(id-\u003ezone, zone))\n            return id-\u003euser;\n    }\n    return NULL;\n}","filepath":"crypto/x509/v3_sxnet.c","line_number":228,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha14"},"270373312":{"score":0.9013616,"function_name":"ASN1_generate_v3","code":"ASN1_TYPE *ASN1_generate_v3(const char *str, X509V3_CTX *cnf)\n{\n    int err = 0;\n    ASN1_TYPE *ret = generate_v3(str, cnf, 0, \u0026err);\n    if (err)\n        ASN1err(ASN1_F_ASN1_GENERATE_V3, err);\n    return ret;\n}","filepath":"crypto/asn1/asn1_gen.c","line_number":89,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha7"},"270373440":{"score":0.92636776,"function_name":"append_exp","code":"static int append_exp(tag_exp_arg *arg, int exp_tag, int exp_class,\n                      int exp_constructed, int exp_pad, int imp_ok)\n{\n    tag_exp_type *exp_tmp;\n    /* Can only have IMPLICIT if permitted */\n    if ((arg-\u003eimp_tag != -1) \u0026\u0026 !imp_ok) {\n        ASN1err(ASN1_F_APPEND_EXP, ASN1_R_ILLEGAL_IMPLICIT_TAG);\n        return 0;\n    }\n\n    if (arg-\u003eexp_count == ASN1_FLAG_EXP_MAX) {\n        ASN1err(ASN1_F_APPEND_EXP, ASN1_R_DEPTH_EXCEEDED);\n        return 0;\n    }\n\n    exp_tmp = \u0026arg-\u003eexp_list[arg-\u003eexp_count++];\n\n    /*\n     * If IMPLICIT set tag to implicit value then reset implicit tag since it\n     * has been used.\n     */\n    if (arg-\u003eimp_tag != -1) {\n        exp_tmp-\u003eexp_tag = arg-\u003eimp_tag;\n        exp_tmp-\u003eexp_class = arg-\u003eimp_class;\n        arg-\u003eimp_tag = -1;\n        arg-\u003eimp_class = -1;\n    } else {\n        exp_tmp-\u003eexp_tag = exp_tag;\n        exp_tmp-\u003eexp_class = exp_class;\n    }\n    exp_tmp-\u003eexp_constructed = exp_constructed;\n    exp_tmp-\u003eexp_pad = exp_pad;\n\n    return 1;\n}","filepath":"crypto/asn1/asn1_gen.c","line_number":466,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha7"},"270373648":{"score":0.95037466,"function_name":"asn1_cb","code":"static int asn1_cb(const char *elem, int len, void *bitstr)\n{\n    tag_exp_arg *arg = bitstr;\n    int i;\n    int utype;\n    int vlen = 0;\n    const char *p, *vstart = NULL;\n\n    int tmp_tag, tmp_class;\n\n    if (elem == NULL)\n        return -1;\n\n    for (i = 0, p = elem; i \u003c len; p++, i++) {\n        /* Look for the ':' in name value pairs */\n        if (*p == ':') {\n            vstart = p + 1;\n            vlen = len - (vstart - elem);\n            len = p - elem;\n            break;\n        }\n    }\n\n    utype = asn1_str2tag(elem, len);\n\n    if (utype == -1) {\n        ASN1err(ASN1_F_ASN1_CB, ASN1_R_UNKNOWN_TAG);\n        ERR_add_error_data(2, \"tag=\", elem);\n        return -1;\n    }\n\n    /* If this is not a modifier mark end of string and exit */\n    if (!(utype \u0026 ASN1_GEN_FLAG)) {\n        arg-\u003eutype = utype;\n        arg-\u003estr = vstart;\n        /* If no value and not end of string, error */\n        if (!vstart \u0026\u0026 elem[len]) {\n            ASN1err(ASN1_F_ASN1_CB, ASN1_R_MISSING_VALUE);\n            return -1;\n        }\n        return 0;\n    }\n\n    switch (utype) {\n\n    case ASN1_GEN_FLAG_IMP:\n        /* Check for illegal multiple IMPLICIT tagging */\n        if (arg-\u003eimp_tag != -1) {\n            ASN1err(ASN1_F_ASN1_CB, ASN1_R_ILLEGAL_NESTED_TAGGING);\n            return -1;\n        }\n        if (!parse_tagging(vstart, vlen, \u0026arg-\u003eimp_tag, \u0026arg-\u003eimp_class))\n            return -1;\n        break;\n\n    case ASN1_GEN_FLAG_EXP:\n\n        if (!parse_tagging(vstart, vlen, \u0026tmp_tag, \u0026tmp_class))\n            return -1;\n        if (!append_exp(arg, tmp_tag, tmp_class, 1, 0, 0))\n            return -1;\n        break;\n\n    case ASN1_GEN_FLAG_SEQWRAP:\n        if (!append_exp(arg, V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL, 1, 0, 1))\n            return -1;\n        break;\n\n    case ASN1_GEN_FLAG_SETWRAP:\n        if (!append_exp(arg, V_ASN1_SET, V_ASN1_UNIVERSAL, 1, 0, 1))\n            return -1;\n        break;\n\n    case ASN1_GEN_FLAG_BITWRAP:\n        if (!append_exp(arg, V_ASN1_BIT_STRING, V_ASN1_UNIVERSAL, 0, 1, 1))\n            return -1;\n        break;\n\n    case ASN1_GEN_FLAG_OCTWRAP:\n        if (!append_exp(arg, V_ASN1_OCTET_STRING, V_ASN1_UNIVERSAL, 0, 0, 1))\n            return -1;\n        break;\n\n    case ASN1_GEN_FLAG_FORMAT:\n        if (!vstart) {\n            ASN1err(ASN1_F_ASN1_CB, ASN1_R_UNKNOWN_FORMAT);\n            return -1;\n        }\n        if (strncmp(vstart, \"ASCII\", 5) == 0)\n            arg-\u003eformat = ASN1_GEN_FORMAT_ASCII;\n        else if (strncmp(vstart, \"UTF8\", 4) == 0)\n            arg-\u003eformat = ASN1_GEN_FORMAT_UTF8;\n        else if (strncmp(vstart, \"HEX\", 3) == 0)\n            arg-\u003eformat = ASN1_GEN_FORMAT_HEX;\n        else if (strncmp(vstart, \"BITLIST\", 7) == 0)\n            arg-\u003eformat = ASN1_GEN_FORMAT_BITLIST;\n        else {\n            ASN1err(ASN1_F_ASN1_CB, ASN1_R_UNKNOWN_FORMAT);\n            return -1;\n        }\n        break;\n\n    }\n\n    return 1;\n\n}","filepath":"crypto/asn1/asn1_gen.c","line_number":240,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha7"},"270374288":{"score":0.7709323,"function_name":"asn1_str2tag","code":"static int asn1_str2tag(const char *tagstr, int len)\n{\n    unsigned int i;\n    static const struct tag_name_st *tntmp, tnst[] = {\n        ASN1_GEN_STR(\"BOOL\", V_ASN1_BOOLEAN),\n        ASN1_GEN_STR(\"BOOLEAN\", V_ASN1_BOOLEAN),\n        ASN1_GEN_STR(\"NULL\", V_ASN1_NULL),\n        ASN1_GEN_STR(\"INT\", V_ASN1_INTEGER),\n        ASN1_GEN_STR(\"INTEGER\", V_ASN1_INTEGER),\n        ASN1_GEN_STR(\"ENUM\", V_ASN1_ENUMERATED),\n        ASN1_GEN_STR(\"ENUMERATED\", V_ASN1_ENUMERATED),\n        ASN1_GEN_STR(\"OID\", V_ASN1_OBJECT),\n        ASN1_GEN_STR(\"OBJECT\", V_ASN1_OBJECT),\n        ASN1_GEN_STR(\"UTCTIME\", V_ASN1_UTCTIME),\n        ASN1_GEN_STR(\"UTC\", V_ASN1_UTCTIME),\n        ASN1_GEN_STR(\"GENERALIZEDTIME\", V_ASN1_GENERALIZEDTIME),\n        ASN1_GEN_STR(\"GENTIME\", V_ASN1_GENERALIZEDTIME),\n        ASN1_GEN_STR(\"OCT\", V_ASN1_OCTET_STRING),\n        ASN1_GEN_STR(\"OCTETSTRING\", V_ASN1_OCTET_STRING),\n        ASN1_GEN_STR(\"BITSTR\", V_ASN1_BIT_STRING),\n        ASN1_GEN_STR(\"BITSTRING\", V_ASN1_BIT_STRING),\n        ASN1_GEN_STR(\"UNIVERSALSTRING\", V_ASN1_UNIVERSALSTRING),\n        ASN1_GEN_STR(\"UNIV\", V_ASN1_UNIVERSALSTRING),\n        ASN1_GEN_STR(\"IA5\", V_ASN1_IA5STRING),\n        ASN1_GEN_STR(\"IA5STRING\", V_ASN1_IA5STRING),\n        ASN1_GEN_STR(\"UTF8\", V_ASN1_UTF8STRING),\n        ASN1_GEN_STR(\"UTF8String\", V_ASN1_UTF8STRING),\n        ASN1_GEN_STR(\"BMP\", V_ASN1_BMPSTRING),\n        ASN1_GEN_STR(\"BMPSTRING\", V_ASN1_BMPSTRING),\n        ASN1_GEN_STR(\"VISIBLESTRING\", V_ASN1_VISIBLESTRING),\n        ASN1_GEN_STR(\"VISIBLE\", V_ASN1_VISIBLESTRING),\n        ASN1_GEN_STR(\"PRINTABLESTRING\", V_ASN1_PRINTABLESTRING),\n        ASN1_GEN_STR(\"PRINTABLE\", V_ASN1_PRINTABLESTRING),\n        ASN1_GEN_STR(\"T61\", V_ASN1_T61STRING),\n        ASN1_GEN_STR(\"T61STRING\", V_ASN1_T61STRING),\n        ASN1_GEN_STR(\"TELETEXSTRING\", V_ASN1_T61STRING),\n        ASN1_GEN_STR(\"GeneralString\", V_ASN1_GENERALSTRING),\n        ASN1_GEN_STR(\"GENSTR\", V_ASN1_GENERALSTRING),\n        ASN1_GEN_STR(\"NUMERIC\", V_ASN1_NUMERICSTRING),\n        ASN1_GEN_STR(\"NUMERICSTRING\", V_ASN1_NUMERICSTRING),\n\n        /* Special cases */\n        ASN1_GEN_STR(\"SEQUENCE\", V_ASN1_SEQUENCE),\n        ASN1_GEN_STR(\"SEQ\", V_ASN1_SEQUENCE),\n        ASN1_GEN_STR(\"SET\", V_ASN1_SET),\n        /* type modifiers */\n        /* Explicit tag */\n        ASN1_GEN_STR(\"EXP\", ASN1_GEN_FLAG_EXP),\n        ASN1_GEN_STR(\"EXPLICIT\", ASN1_GEN_FLAG_EXP),\n        /* Implicit tag */\n        ASN1_GEN_STR(\"IMP\", ASN1_GEN_FLAG_IMP),\n        ASN1_GEN_STR(\"IMPLICIT\", ASN1_GEN_FLAG_IMP),\n        /* OCTET STRING wrapper */\n        ASN1_GEN_STR(\"OCTWRAP\", ASN1_GEN_FLAG_OCTWRAP),\n        /* SEQUENCE wrapper */\n        ASN1_GEN_STR(\"SEQWRAP\", ASN1_GEN_FLAG_SEQWRAP),\n        /* SET wrapper */\n        ASN1_GEN_STR(\"SETWRAP\", ASN1_GEN_FLAG_SETWRAP),\n        /* BIT STRING wrapper */\n        ASN1_GEN_STR(\"BITWRAP\", ASN1_GEN_FLAG_BITWRAP),\n        ASN1_GEN_STR(\"FORM\", ASN1_GEN_FLAG_FORMAT),\n        ASN1_GEN_STR(\"FORMAT\", ASN1_GEN_FLAG_FORMAT),\n    };\n\n    if (len == -1)\n        len = strlen(tagstr);\n\n    tntmp = tnst;\n    for (i = 0; i \u003c OSSL_NELEM(tnst); i++, tntmp++) {\n        if ((len == tntmp-\u003elen) \u0026\u0026 (strncmp(tntmp-\u003estrnam, tagstr, len) == 0))\n            return tntmp-\u003etag;\n    }\n\n    return -1;\n}","filepath":"crypto/asn1/asn1_gen.c","line_number":502,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha7"},"270374400":{"score":0.9264099,"function_name":"asn1_str2type","code":"static ASN1_TYPE *asn1_str2type(const char *str, int format, int utype)\n{\n    ASN1_TYPE *atmp = NULL;\n    CONF_VALUE vtmp;\n    unsigned char *rdata;\n    long rdlen;\n    int no_unused = 1;\n\n    if ((atmp = ASN1_TYPE_new()) == NULL) {\n        ASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    if (!str)\n        str = \"\";\n\n    switch (utype) {\n\n    case V_ASN1_NULL:\n        if (str \u0026\u0026 *str) {\n            ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_NULL_VALUE);\n            goto bad_form;\n        }\n        break;\n\n    case V_ASN1_BOOLEAN:\n        if (format != ASN1_GEN_FORMAT_ASCII) {\n            ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_NOT_ASCII_FORMAT);\n            goto bad_form;\n        }\n        vtmp.name = NULL;\n        vtmp.section = NULL;\n        vtmp.value = (char *)str;\n        if (!X509V3_get_value_bool(\u0026vtmp, \u0026atmp-\u003evalue.boolean)) {\n            ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_BOOLEAN);\n            goto bad_str;\n        }\n        break;\n\n    case V_ASN1_INTEGER:\n    case V_ASN1_ENUMERATED:\n        if (format != ASN1_GEN_FORMAT_ASCII) {\n            ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_INTEGER_NOT_ASCII_FORMAT);\n            goto bad_form;\n        }\n        if ((atmp-\u003evalue.integer\n                    = s2i_ASN1_INTEGER(NULL, str)) == NULL) {\n            ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_INTEGER);\n            goto bad_str;\n        }\n        break;\n\n    case V_ASN1_OBJECT:\n        if (format != ASN1_GEN_FORMAT_ASCII) {\n            ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_OBJECT_NOT_ASCII_FORMAT);\n            goto bad_form;\n        }\n        if ((atmp-\u003evalue.object = OBJ_txt2obj(str, 0)) == NULL) {\n            ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_OBJECT);\n            goto bad_str;\n        }\n        break;\n\n    case V_ASN1_UTCTIME:\n    case V_ASN1_GENERALIZEDTIME:\n        if (format != ASN1_GEN_FORMAT_ASCII) {\n            ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_TIME_NOT_ASCII_FORMAT);\n            goto bad_form;\n        }\n        if ((atmp-\u003evalue.asn1_string = ASN1_STRING_new()) == NULL) {\n            ASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE);\n            goto bad_str;\n        }\n        if (!ASN1_STRING_set(atmp-\u003evalue.asn1_string, str, -1)) {\n            ASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE);\n            goto bad_str;\n        }\n        atmp-\u003evalue.asn1_string-\u003etype = utype;\n        if (!ASN1_TIME_check(atmp-\u003evalue.asn1_string)) {\n            ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_TIME_VALUE);\n            goto bad_str;\n        }\n\n        break;\n\n    case V_ASN1_BMPSTRING:\n    case V_ASN1_PRINTABLESTRING:\n    case V_ASN1_IA5STRING:\n    case V_ASN1_T61STRING:\n    case V_ASN1_UTF8STRING:\n    case V_ASN1_VISIBLESTRING:\n    case V_ASN1_UNIVERSALSTRING:\n    case V_ASN1_GENERALSTRING:\n    case V_ASN1_NUMERICSTRING:\n        if (format == ASN1_GEN_FORMAT_ASCII)\n            format = MBSTRING_ASC;\n        else if (format == ASN1_GEN_FORMAT_UTF8)\n            format = MBSTRING_UTF8;\n        else {\n            ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_FORMAT);\n            goto bad_form;\n        }\n\n        if (ASN1_mbstring_copy(\u0026atmp-\u003evalue.asn1_string, (unsigned char *)str,\n                               -1, format, ASN1_tag2bit(utype)) \u003c= 0) {\n            ASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE);\n            goto bad_str;\n        }\n\n        break;\n\n    case V_ASN1_BIT_STRING:\n    case V_ASN1_OCTET_STRING:\n        if ((atmp-\u003evalue.asn1_string = ASN1_STRING_new()) == NULL) {\n            ASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE);\n            goto bad_form;\n        }\n\n        if (format == ASN1_GEN_FORMAT_HEX) {\n            if ((rdata = OPENSSL_hexstr2buf(str, \u0026rdlen)) == NULL) {\n                ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_HEX);\n                goto bad_str;\n            }\n            atmp-\u003evalue.asn1_string-\u003edata = rdata;\n            atmp-\u003evalue.asn1_string-\u003elength = rdlen;\n            atmp-\u003evalue.asn1_string-\u003etype = utype;\n        } else if (format == ASN1_GEN_FORMAT_ASCII)\n            ASN1_STRING_set(atmp-\u003evalue.asn1_string, str, -1);\n        else if ((format == ASN1_GEN_FORMAT_BITLIST)\n                 \u0026\u0026 (utype == V_ASN1_BIT_STRING)) {\n            if (!CONF_parse_list\n                (str, ',', 1, bitstr_cb, atmp-\u003evalue.bit_string)) {\n                ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_LIST_ERROR);\n                goto bad_str;\n            }\n            no_unused = 0;\n\n        } else {\n            ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_BITSTRING_FORMAT);\n            goto bad_form;\n        }\n\n        if ((utype == V_ASN1_BIT_STRING) \u0026\u0026 no_unused) {\n            atmp-\u003evalue.asn1_string-\u003eflags\n                \u0026= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);\n            atmp-\u003evalue.asn1_string-\u003eflags |= ASN1_STRING_FLAG_BITS_LEFT;\n        }\n\n        break;\n\n    default:\n        ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_UNSUPPORTED_TYPE);\n        goto bad_str;\n    }\n\n    atmp-\u003etype = utype;\n    return atmp;\n\n bad_str:\n    ERR_add_error_data(2, \"string=\", str);\n bad_form:\n\n    ASN1_TYPE_free(atmp);\n    return NULL;\n\n}","filepath":"crypto/asn1/asn1_gen.c","line_number":578,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha7"},"270375696":{"score":0.8352148,"function_name":"generate_v3","code":"static ASN1_TYPE *generate_v3(const char *str, X509V3_CTX *cnf, int depth,\n                              int *perr)\n{\n    ASN1_TYPE *ret;\n    tag_exp_arg asn1_tags;\n    tag_exp_type *etmp;\n\n    int i, len;\n\n    unsigned char *orig_der = NULL, *new_der = NULL;\n    const unsigned char *cpy_start;\n    unsigned char *p;\n    const unsigned char *cp;\n    int cpy_len;\n    long hdr_len = 0;\n    int hdr_constructed = 0, hdr_tag, hdr_class;\n    int r;\n\n    asn1_tags.imp_tag = -1;\n    asn1_tags.imp_class = -1;\n    asn1_tags.format = ASN1_GEN_FORMAT_ASCII;\n    asn1_tags.exp_count = 0;\n    if (CONF_parse_list(str, ',', 1, asn1_cb, \u0026asn1_tags) != 0) {\n        *perr = ASN1_R_UNKNOWN_TAG;\n        return NULL;\n    }\n\n    if ((asn1_tags.utype == V_ASN1_SEQUENCE)\n        || (asn1_tags.utype == V_ASN1_SET)) {\n        if (!cnf) {\n            *perr = ASN1_R_SEQUENCE_OR_SET_NEEDS_CONFIG;\n            return NULL;\n        }\n        if (depth \u003e= ASN1_GEN_SEQ_MAX_DEPTH) {\n            *perr = ASN1_R_ILLEGAL_NESTED_TAGGING;\n            return NULL;\n        }\n        ret = asn1_multi(asn1_tags.utype, asn1_tags.str, cnf, depth, perr);\n    } else\n        ret = asn1_str2type(asn1_tags.str, asn1_tags.format, asn1_tags.utype);\n\n    if (!ret)\n        return NULL;\n\n    /* If no tagging return base type */\n    if ((asn1_tags.imp_tag == -1) \u0026\u0026 (asn1_tags.exp_count == 0))\n        return ret;\n\n    /* Generate the encoding */\n    cpy_len = i2d_ASN1_TYPE(ret, \u0026orig_der);\n    ASN1_TYPE_free(ret);\n    ret = NULL;\n    /* Set point to start copying for modified encoding */\n    cpy_start = orig_der;\n\n    /* Do we need IMPLICIT tagging? */\n    if (asn1_tags.imp_tag != -1) {\n        /* If IMPLICIT we will replace the underlying tag */\n        /* Skip existing tag+len */\n        r = ASN1_get_object(\u0026cpy_start, \u0026hdr_len, \u0026hdr_tag, \u0026hdr_class,\n                            cpy_len);\n        if (r \u0026 0x80)\n            goto err;\n        /* Update copy length */\n        cpy_len -= cpy_start - orig_der;\n        /*\n         * For IMPLICIT tagging the length should match the original length\n         * and constructed flag should be consistent.\n         */\n        if (r \u0026 0x1) {\n            /* Indefinite length constructed */\n            hdr_constructed = 2;\n            hdr_len = 0;\n        } else\n            /* Just retain constructed flag */\n            hdr_constructed = r \u0026 V_ASN1_CONSTRUCTED;\n        /*\n         * Work out new length with IMPLICIT tag: ignore constructed because\n         * it will mess up if indefinite length\n         */\n        len = ASN1_object_size(0, hdr_len, asn1_tags.imp_tag);\n    } else\n        len = cpy_len;\n\n    /* Work out length in any EXPLICIT, starting from end */\n\n    for (i = 0, etmp = asn1_tags.exp_list + asn1_tags.exp_count - 1;\n         i \u003c asn1_tags.exp_count; i++, etmp--) {\n        /* Content length: number of content octets + any padding */\n        len += etmp-\u003eexp_pad;\n        etmp-\u003eexp_len = len;\n        /* Total object length: length including new header */\n        len = ASN1_object_size(0, len, etmp-\u003eexp_tag);\n    }\n\n    /* Allocate buffer for new encoding */\n\n    new_der = OPENSSL_malloc(len);\n    if (new_der == NULL)\n        goto err;\n\n    /* Generate tagged encoding */\n\n    p = new_der;\n\n    /* Output explicit tags first */\n\n    for (i = 0, etmp = asn1_tags.exp_list; i \u003c asn1_tags.exp_count;\n         i++, etmp++) {\n        ASN1_put_object(\u0026p, etmp-\u003eexp_constructed, etmp-\u003eexp_len,\n                        etmp-\u003eexp_tag, etmp-\u003eexp_class);\n        if (etmp-\u003eexp_pad)\n            *p++ = 0;\n    }\n\n    /* If IMPLICIT, output tag */\n\n    if (asn1_tags.imp_tag != -1) {\n        if (asn1_tags.imp_class == V_ASN1_UNIVERSAL\n            \u0026\u0026 (asn1_tags.imp_tag == V_ASN1_SEQUENCE\n                || asn1_tags.imp_tag == V_ASN1_SET))\n            hdr_constructed = V_ASN1_CONSTRUCTED;\n        ASN1_put_object(\u0026p, hdr_constructed, hdr_len,\n                        asn1_tags.imp_tag, asn1_tags.imp_class);\n    }\n\n    /* Copy across original encoding */\n    memcpy(p, cpy_start, cpy_len);\n\n    cp = new_der;\n\n    /* Obtain new ASN1_TYPE structure */\n    ret = d2i_ASN1_TYPE(NULL, \u0026cp, len);\n\n err:\n    OPENSSL_free(orig_der);\n    OPENSSL_free(new_der);\n\n    return ret;\n\n}","filepath":"crypto/asn1/asn1_gen.c","line_number":98,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha7"},"270376896":{"score":0.95118505,"function_name":"parse_tagging","code":"static int parse_tagging(const char *vstart, int vlen, int *ptag, int *pclass)\n{\n    char erch[2];\n    long tag_num;\n    char *eptr;\n    if (!vstart)\n        return 0;\n    tag_num = strtoul(vstart, \u0026eptr, 10);\n    /* Check we haven't gone past max length: should be impossible */\n    if (eptr \u0026\u0026 *eptr \u0026\u0026 (eptr \u003e vstart + vlen))\n        return 0;\n    if (tag_num \u003c 0) {\n        ASN1err(ASN1_F_PARSE_TAGGING, ASN1_R_INVALID_NUMBER);\n        return 0;\n    }\n    *ptag = tag_num;\n    /* If we have non numeric characters, parse them */\n    if (eptr)\n        vlen -= eptr - vstart;\n    else\n        vlen = 0;\n    if (vlen) {\n        switch (*eptr) {\n\n        case 'U':\n            *pclass = V_ASN1_UNIVERSAL;\n            break;\n\n        case 'A':\n            *pclass = V_ASN1_APPLICATION;\n            break;\n\n        case 'P':\n            *pclass = V_ASN1_PRIVATE;\n            break;\n\n        case 'C':\n            *pclass = V_ASN1_CONTEXT_SPECIFIC;\n            break;\n\n        default:\n            erch[0] = *eptr;\n            erch[1] = 0;\n            ASN1err(ASN1_F_PARSE_TAGGING, ASN1_R_INVALID_MODIFIER);\n            ERR_add_error_data(2, \"Char=\", erch);\n            return 0;\n\n        }\n    } else\n        *pclass = V_ASN1_CONTEXT_SPECIFIC;\n\n    return 1;\n\n}","filepath":"crypto/asn1/asn1_gen.c","line_number":348,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha7"},"270387760":{"score":0.87819713,"function_name":"idea_set_decrypt_key","code":"void idea_set_decrypt_key(IDEA_KEY_SCHEDULE *ek, IDEA_KEY_SCHEDULE *dk)\n\t{\n\tint r;\n\tregister IDEA_INT *fp,*tp,t;\n\n\ttp= \u0026(dk-\u003edata[0][0]);\n\tfp= \u0026(ek-\u003edata[8][0]);\n\tfor (r=0; r\u003c9; r++)\n\t\t{\n\t\t*(tp++)=inverse(fp[0]);\n\t\t*(tp++)=((int)(0x10000L-fp[2])\u00260xffff);\n\t\t*(tp++)=((int)(0x10000L-fp[1])\u00260xffff);\n\t\t*(tp++)=inverse(fp[3]);\n\t\tif (r == 8) break;\n\t\tfp-=6;\n\t\t*(tp++)=fp[4];\n\t\t*(tp++)=fp[5];\n\t\t}\n\n\ttp= \u0026(dk-\u003edata[0][0]);\n\tt=tp[1];\n\ttp[1]=tp[2];\n\ttp[2]=t;\n\n\tt=tp[49];\n\ttp[49]=tp[50];\n\ttp[50]=t;\n\t}","filepath":"crypto/idea/i_skey.c","line_number":97,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL-engine-0_9_6-beta1"},"270387904":{"score":0.79022264,"function_name":"idea_set_encrypt_key","code":"void idea_set_encrypt_key(const unsigned char *key, IDEA_KEY_SCHEDULE *ks)\n\t{\n\tint i;\n\tregister IDEA_INT *kt,*kf,r0,r1,r2;\n\n\tkt= \u0026(ks-\u003edata[0][0]);\n\tn2s(key,kt[0]); n2s(key,kt[1]); n2s(key,kt[2]); n2s(key,kt[3]);\n\tn2s(key,kt[4]); n2s(key,kt[5]); n2s(key,kt[6]); n2s(key,kt[7]);\n\n\tkf=kt;\n\tkt+=8;\n\tfor (i=0; i\u003c6; i++)\n\t\t{\n\t\tr2= kf[1];\n\t\tr1= kf[2];\n\t\t*(kt++)= ((r2\u003c\u003c9) | (r1\u003e\u003e7))\u00260xffff;\n\t\tr0= kf[3];\n\t\t*(kt++)= ((r1\u003c\u003c9) | (r0\u003e\u003e7))\u00260xffff;\n\t\tr1= kf[4];\n\t\t*(kt++)= ((r0\u003c\u003c9) | (r1\u003e\u003e7))\u00260xffff;\n\t\tr0= kf[5];\n\t\t*(kt++)= ((r1\u003c\u003c9) | (r0\u003e\u003e7))\u00260xffff;\n\t\tr1= kf[6];\n\t\t*(kt++)= ((r0\u003c\u003c9) | (r1\u003e\u003e7))\u00260xffff;\n\t\tr0= kf[7];\n\t\t*(kt++)= ((r1\u003c\u003c9) | (r0\u003e\u003e7))\u00260xffff;\n\t\tr1= kf[0];\n\t\tif (i \u003e= 5) break;\n\t\t*(kt++)= ((r0\u003c\u003c9) | (r1\u003e\u003e7))\u00260xffff;\n\t\t*(kt++)= ((r1\u003c\u003c9) | (r2\u003e\u003e7))\u00260xffff;\n\t\tkf+=8;\n\t\t}\n\t}","filepath":"crypto/idea/i_skey.c","line_number":63,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL-engine-0_9_6-beta1"},"270388272":{"score":0.86781895,"function_name":"inverse","code":"static IDEA_INT inverse(unsigned int xin)\n\t{\n\tlong n1,n2,q,r,b1,b2,t;\n\n\tif (xin == 0)\n\t\tb2=0;\n\telse\n\t\t{\n\t\tn1=0x10001;\n\t\tn2=xin;\n\t\tb2=1;\n\t\tb1=0;\n\n\t\tdo\t{\n\t\t\tr=(n1%n2);\n\t\t\tq=(n1-r)/n2;\n\t\t\tif (r == 0)\n\t\t\t\t{ if (b2 \u003c 0) b2=0x10001+b2; }\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tn1=n2;\n\t\t\t\tn2=r;\n\t\t\t\tt=b2;\n\t\t\t\tb2=b1-q*b2;\n\t\t\t\tb1=t;\n\t\t\t\t}\n\t\t\t} while (r != 0);\n\t\t}\n\treturn((IDEA_INT)b2);\n\t}","filepath":"crypto/idea/i_skey.c","line_number":127,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL-engine-0_9_6-beta1"},"270406960":{"score":0.88229984,"function_name":"CRYPTO_ctr128_encrypt","code":"void CRYPTO_ctr128_encrypt(const unsigned char *in, unsigned char *out,\n                           size_t len, const void *key,\n                           unsigned char ivec[16],\n                           unsigned char ecount_buf[16], unsigned int *num,\n                           block128_f block)\n{\n    unsigned int n;\n    size_t l = 0;\n\n    n = *num;\n\n#if !defined(OPENSSL_SMALL_FOOTPRINT)\n    if (16 % sizeof(size_t) == 0) { /* always true actually */\n        do {\n            while (n \u0026\u0026 len) {\n                *(out++) = *(in++) ^ ecount_buf[n];\n                --len;\n                n = (n + 1) % 16;\n            }\n\n# if defined(STRICT_ALIGNMENT)\n            if (((size_t)in | (size_t)out | (size_t)ecount_buf)\n                % sizeof(size_t) != 0)\n                break;\n# endif\n            while (len \u003e= 16) {\n                (*block) (ivec, ecount_buf, key);\n                ctr128_inc_aligned(ivec);\n                for (n = 0; n \u003c 16; n += sizeof(size_t))\n                    *(size_t_aX *)(out + n) =\n                        *(size_t_aX *)(in + n)\n                        ^ *(size_t_aX *)(ecount_buf + n);\n                len -= 16;\n                out += 16;\n                in += 16;\n                n = 0;\n            }\n            if (len) {\n                (*block) (ivec, ecount_buf, key);\n                ctr128_inc_aligned(ivec);\n                while (len--) {\n                    out[n] = in[n] ^ ecount_buf[n];\n                    ++n;\n                }\n            }\n            *num = n;\n            return;\n        } while (0);\n    }\n    /* the rest would be commonly eliminated by x86* compiler */\n#endif\n    while (l \u003c len) {\n        if (n == 0) {\n            (*block) (ivec, ecount_buf, key);\n            ctr128_inc(ivec);\n        }\n        out[l] = in[l] ^ ecount_buf[n];\n        ++l;\n        n = (n + 1) % 16;\n    }\n\n    *num = n;\n}","filepath":"crypto/modes/ctr128.c","line_number":77,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1h"},"270407248":{"score":0.91067684,"function_name":"CRYPTO_ctr128_encrypt_ctr32","code":"void CRYPTO_ctr128_encrypt_ctr32(const unsigned char *in, unsigned char *out,\n                                 size_t len, const void *key,\n                                 unsigned char ivec[16],\n                                 unsigned char ecount_buf[16],\n                                 unsigned int *num, ctr128_f func)\n{\n    unsigned int n, ctr32;\n\n    n = *num;\n\n    while (n \u0026\u0026 len) {\n        *(out++) = *(in++) ^ ecount_buf[n];\n        --len;\n        n = (n + 1) % 16;\n    }\n\n    ctr32 = GETU32(ivec + 12);\n    while (len \u003e= 16) {\n        size_t blocks = len / 16;\n        /*\n         * 1\u003c\u003c28 is just a not-so-small yet not-so-large number...\n         * Below condition is practically never met, but it has to\n         * be checked for code correctness.\n         */\n        if (sizeof(size_t) \u003e sizeof(unsigned int) \u0026\u0026 blocks \u003e (1U \u003c\u003c 28))\n            blocks = (1U \u003c\u003c 28);\n        /*\n         * As (*func) operates on 32-bit counter, caller\n         * has to handle overflow. 'if' below detects the\n         * overflow, which is then handled by limiting the\n         * amount of blocks to the exact overflow point...\n         */\n        ctr32 += (u32)blocks;\n        if (ctr32 \u003c blocks) {\n            blocks -= ctr32;\n            ctr32 = 0;\n        }\n        (*func) (in, out, blocks, key, ivec);\n        /* (*ctr) does not update ivec, caller does: */\n        PUTU32(ivec + 12, ctr32);\n        /* ... overflow was detected, propagate carry. */\n        if (ctr32 == 0)\n            ctr96_inc(ivec);\n        blocks *= 16;\n        len -= blocks;\n        out += blocks;\n        in += blocks;\n    }\n    if (len) {\n        memset(ecount_buf, 0, 16);\n        (*func) (ecount_buf, ecount_buf, 1, key, ivec);\n        ++ctr32;\n        PUTU32(ivec + 12, ctr32);\n        if (ctr32 == 0)\n            ctr96_inc(ivec);\n        while (len--) {\n            out[n] = in[n] ^ ecount_buf[n];\n            ++n;\n        }\n    }\n\n    *num = n;\n}","filepath":"crypto/modes/ctr128.c","line_number":154,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1h"},"270407600":{"score":0.8754482,"function_name":"ctr128_inc","code":"static void ctr128_inc(unsigned char *counter)\n{\n    u32 n = 16, c = 1;\n\n    do {\n        --n;\n        c += counter[n];\n        counter[n] = (u8)c;\n        c \u003e\u003e= 8;\n    } while (n);\n}","filepath":"crypto/modes/ctr128.c","line_number":26,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1h"},"270407648":{"score":0.8739105,"function_name":"ctr96_inc","code":"static void ctr96_inc(unsigned char *counter)\n{\n    u32 n = 12, c = 1;\n\n    do {\n        --n;\n        c += counter[n];\n        counter[n] = (u8)c;\n        c \u003e\u003e= 8;\n    } while (n);\n}","filepath":"crypto/modes/ctr128.c","line_number":142,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1h"},"270409136":{"score":0.7509806,"function_name":"CRYPTO_gcm128_aad","code":"int CRYPTO_gcm128_aad(GCM128_CONTEXT *ctx, const unsigned char *aad,\n                      size_t len)\n{\n    size_t i;\n    unsigned int n;\n    u64 alen = ctx-\u003elen.u[0];\n\n    if (ctx-\u003elen.u[1])\n        return -2;\n\n    alen += len;\n    if (alen \u003e (U64(1) \u003c\u003c 61) || (sizeof(len) == 8 \u0026\u0026 alen \u003c len))\n        return -1;\n    ctx-\u003elen.u[0] = alen;\n\n    n = ctx-\u003eares;\n    if (n) {\n        while (n \u0026\u0026 len) {\n            ctx-\u003eXi.c[n] ^= *(aad++);\n            --len;\n            n = (n + 1) % 16;\n        }\n        if (n == 0)\n            GCM_MUL(ctx);\n        else {\n            ctx-\u003eares = n;\n            return 0;\n        }\n    }\n#ifdef GHASH\n    if ((i = (len \u0026 (size_t)-16))) {\n        GHASH(ctx, aad, i);\n        aad += i;\n        len -= i;\n    }\n#else\n    while (len \u003e= 16) {\n        for (i = 0; i \u003c 16; ++i)\n            ctx-\u003eXi.c[i] ^= aad[i];\n        GCM_MUL(ctx);\n        aad += 16;\n        len -= 16;\n    }\n#endif\n    if (len) {\n        n = (unsigned int)len;\n        for (i = 0; i \u003c len; ++i)\n            ctx-\u003eXi.c[i] ^= aad[i];\n    }\n\n    ctx-\u003eares = n;\n    return 0;\n}","filepath":"crypto/modes/gcm128.c","line_number":630,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.1.0-alpha1"},"270410976":{"score":0.880811,"function_name":"CRYPTO_gcm128_decrypt","code":"int CRYPTO_gcm128_decrypt(GCM128_CONTEXT *ctx,\n                          const unsigned char *in, unsigned char *out,\n                          size_t len)\n{\n    DECLARE_IS_ENDIAN;\n    unsigned int n, ctr, mres;\n    size_t i;\n    u64 mlen = ctx-\u003elen.u[1];\n    block128_f block = ctx-\u003eblock;\n    void *key = ctx-\u003ekey;\n\n    mlen += len;\n    if (mlen \u003e ((U64(1) \u003c\u003c 36) - 32) || (sizeof(len) == 8 \u0026\u0026 mlen \u003c len))\n        return -1;\n    ctx-\u003elen.u[1] = mlen;\n\n    mres = ctx-\u003emres;\n\n    if (ctx-\u003eares) {\n        /* First call to decrypt finalizes GHASH(AAD) */\n#if defined(GHASH) \u0026\u0026 !defined(OPENSSL_SMALL_FOOTPRINT)\n        if (len == 0) {\n            GCM_MUL(ctx);\n            ctx-\u003eares = 0;\n            return 0;\n        }\n        memcpy(ctx-\u003eXn, ctx-\u003eXi.c, sizeof(ctx-\u003eXi));\n        ctx-\u003eXi.u[0] = 0;\n        ctx-\u003eXi.u[1] = 0;\n        mres = sizeof(ctx-\u003eXi);\n#else\n        GCM_MUL(ctx);\n#endif\n        ctx-\u003eares = 0;\n    }\n\n    if (IS_LITTLE_ENDIAN)\n#ifdef BSWAP4\n        ctr = BSWAP4(ctx-\u003eYi.d[3]);\n#else\n        ctr = GETU32(ctx-\u003eYi.c + 12);\n#endif\n    else\n        ctr = ctx-\u003eYi.d[3];\n\n    n = mres % 16;\n#if !defined(OPENSSL_SMALL_FOOTPRINT)\n    if (16 % sizeof(size_t) == 0) { /* always true actually */\n        do {\n            if (n) {\n# if defined(GHASH)\n                while (n \u0026\u0026 len) {\n                    *(out++) = (ctx-\u003eXn[mres++] = *(in++)) ^ ctx-\u003eEKi.c[n];\n                    --len;\n                    n = (n + 1) % 16;\n                }\n                if (n == 0) {\n                    GHASH(ctx, ctx-\u003eXn, mres);\n                    mres = 0;\n                } else {\n                    ctx-\u003emres = mres;\n                    return 0;\n                }\n# else\n                while (n \u0026\u0026 len) {\n                    u8 c = *(in++);\n                    *(out++) = c ^ ctx-\u003eEKi.c[n];\n                    ctx-\u003eXi.c[n] ^= c;\n                    --len;\n                    n = (n + 1) % 16;\n                }\n                if (n == 0) {\n                    GCM_MUL(ctx);\n                    mres = 0;\n                } else {\n                    ctx-\u003emres = n;\n                    return 0;\n                }\n# endif\n            }\n# if defined(STRICT_ALIGNMENT)\n            if (((size_t)in | (size_t)out) % sizeof(size_t) != 0)\n                break;\n# endif\n# if defined(GHASH)\n            if (len \u003e= 16 \u0026\u0026 mres) {\n                GHASH(ctx, ctx-\u003eXn, mres);\n                mres = 0;\n            }\n#  if defined(GHASH_CHUNK)\n            while (len \u003e= GHASH_CHUNK) {\n                size_t j = GHASH_CHUNK;\n\n                GHASH(ctx, in, GHASH_CHUNK);\n                while (j) {\n                    size_t_aX *out_t = (size_t_aX *)out;\n                    const size_t_aX *in_t = (const size_t_aX *)in;\n\n                    (*block) (ctx-\u003eYi.c, ctx-\u003eEKi.c, key);\n                    ++ctr;\n                    if (IS_LITTLE_ENDIAN)\n#   ifdef BSWAP4\n                        ctx-\u003eYi.d[3] = BSWAP4(ctr);\n#   else\n                        PUTU32(ctx-\u003eYi.c + 12, ctr);\n#   endif\n                    else\n                        ctx-\u003eYi.d[3] = ctr;\n                    for (i = 0; i \u003c 16 / sizeof(size_t); ++i)\n                        out_t[i] = in_t[i] ^ ctx-\u003eEKi.t[i];\n                    out += 16;\n                    in += 16;\n                    j -= 16;\n                }\n                len -= GHASH_CHUNK;\n            }\n#  endif\n            if ((i = (len \u0026 (size_t)-16))) {\n                GHASH(ctx, in, i);\n                while (len \u003e= 16) {\n                    size_t_aX *out_t = (size_t_aX *)out;\n                    const size_t_aX *in_t = (const size_t_aX *)in;\n\n                    (*block) (ctx-\u003eYi.c, ctx-\u003eEKi.c, key);\n                    ++ctr;\n                    if (IS_LITTLE_ENDIAN)\n#  ifdef BSWAP4\n                        ctx-\u003eYi.d[3] = BSWAP4(ctr);\n#  else\n                        PUTU32(ctx-\u003eYi.c + 12, ctr);\n#  endif\n                    else\n                        ctx-\u003eYi.d[3] = ctr;\n                    for (i = 0; i \u003c 16 / sizeof(size_t); ++i)\n                        out_t[i] = in_t[i] ^ ctx-\u003eEKi.t[i];\n                    out += 16;\n                    in += 16;\n                    len -= 16;\n                }\n            }\n# else\n            while (len \u003e= 16) {\n                size_t *out_t = (size_t *)out;\n                const size_t *in_t = (const size_t *)in;\n\n                (*block) (ctx-\u003eYi.c, ctx-\u003eEKi.c, key);\n                ++ctr;\n                if (IS_LITTLE_ENDIAN)\n#  ifdef BSWAP4\n                    ctx-\u003eYi.d[3] = BSWAP4(ctr);\n#  else\n                    PUTU32(ctx-\u003eYi.c + 12, ctr);\n#  endif\n                else\n                    ctx-\u003eYi.d[3] = ctr;\n                for (i = 0; i \u003c 16 / sizeof(size_t); ++i) {\n                    size_t c = in_t[i];\n                    out_t[i] = c ^ ctx-\u003eEKi.t[i];\n                    ctx-\u003eXi.t[i] ^= c;\n                }\n                GCM_MUL(ctx);\n                out += 16;\n                in += 16;\n                len -= 16;\n            }\n# endif\n            if (len) {\n                (*block) (ctx-\u003eYi.c, ctx-\u003eEKi.c, key);\n                ++ctr;\n                if (IS_LITTLE_ENDIAN)\n# ifdef BSWAP4\n                    ctx-\u003eYi.d[3] = BSWAP4(ctr);\n# else\n                    PUTU32(ctx-\u003eYi.c + 12, ctr);\n# endif\n                else\n                    ctx-\u003eYi.d[3] = ctr;\n# if defined(GHASH)\n                while (len--) {\n                    out[n] = (ctx-\u003eXn[mres++] = in[n]) ^ ctx-\u003eEKi.c[n];\n                    ++n;\n                }\n# else\n                while (len--) {\n                    u8 c = in[n];\n                    ctx-\u003eXi.c[n] ^= c;\n                    out[n] = c ^ ctx-\u003eEKi.c[n];\n                    ++n;\n                }\n                mres = n;\n# endif\n            }\n\n            ctx-\u003emres = mres;\n            return 0;\n        } while (0);\n    }\n#endif\n    for (i = 0; i \u003c len; ++i) {\n        u8 c;\n        if (n == 0) {\n            (*block) (ctx-\u003eYi.c, ctx-\u003eEKi.c, key);\n            ++ctr;\n            if (IS_LITTLE_ENDIAN)\n#ifdef BSWAP4\n                ctx-\u003eYi.d[3] = BSWAP4(ctr);\n#else\n                PUTU32(ctx-\u003eYi.c + 12, ctr);\n#endif\n            else\n                ctx-\u003eYi.d[3] = ctr;\n        }\n#if defined(GHASH) \u0026\u0026 !defined(OPENSSL_SMALL_FOOTPRINT)\n        out[i] = (ctx-\u003eXn[mres++] = c = in[i]) ^ ctx-\u003eEKi.c[n];\n        n = (n + 1) % 16;\n        if (mres == sizeof(ctx-\u003eXn)) {\n            GHASH(ctx,ctx-\u003eXn,sizeof(ctx-\u003eXn));\n            mres = 0;\n        }\n#else\n        c = in[i];\n        out[i] = c ^ ctx-\u003eEKi.c[n];\n        ctx-\u003eXi.c[n] ^= c;\n        mres = n = (n + 1) % 16;\n        if (n == 0)\n            GCM_MUL(ctx);\n#endif\n    }\n\n    ctx-\u003emres = mres;\n    return 0;\n}","filepath":"crypto/modes/gcm128.c","line_number":909,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.1.0-alpha1"},"270412576":{"score":0.7988943,"function_name":"CRYPTO_gcm128_finish","code":"int CRYPTO_gcm128_finish(GCM128_CONTEXT *ctx, const unsigned char *tag,\n                         size_t len)\n{\n    DECLARE_IS_ENDIAN;\n    u64 alen = ctx-\u003elen.u[0] \u003c\u003c 3;\n    u64 clen = ctx-\u003elen.u[1] \u003c\u003c 3;\n\n#if defined(GHASH) \u0026\u0026 !defined(OPENSSL_SMALL_FOOTPRINT)\n    u128 bitlen;\n    unsigned int mres = ctx-\u003emres;\n\n    if (mres) {\n        unsigned blocks = (mres + 15) \u0026 -16;\n\n        memset(ctx-\u003eXn + mres, 0, blocks - mres);\n        mres = blocks;\n        if (mres == sizeof(ctx-\u003eXn)) {\n            GHASH(ctx, ctx-\u003eXn, mres);\n            mres = 0;\n        }\n    } else if (ctx-\u003eares) {\n        GCM_MUL(ctx);\n    }\n#else\n    if (ctx-\u003emres || ctx-\u003eares)\n        GCM_MUL(ctx);\n#endif\n\n    if (IS_LITTLE_ENDIAN) {\n#ifdef BSWAP8\n        alen = BSWAP8(alen);\n        clen = BSWAP8(clen);\n#else\n        u8 *p = ctx-\u003elen.c;\n\n        ctx-\u003elen.u[0] = alen;\n        ctx-\u003elen.u[1] = clen;\n\n        alen = (u64)GETU32(p) \u003c\u003c 32 | GETU32(p + 4);\n        clen = (u64)GETU32(p + 8) \u003c\u003c 32 | GETU32(p + 12);\n#endif\n    }\n\n#if defined(GHASH) \u0026\u0026 !defined(OPENSSL_SMALL_FOOTPRINT)\n    bitlen.hi = alen;\n    bitlen.lo = clen;\n    memcpy(ctx-\u003eXn + mres, \u0026bitlen, sizeof(bitlen));\n    mres += sizeof(bitlen);\n    GHASH(ctx, ctx-\u003eXn, mres);\n#else\n    ctx-\u003eXi.u[0] ^= alen;\n    ctx-\u003eXi.u[1] ^= clen;\n    GCM_MUL(ctx);\n#endif\n\n    ctx-\u003eXi.u[0] ^= ctx-\u003eEK0.u[0];\n    ctx-\u003eXi.u[1] ^= ctx-\u003eEK0.u[1];\n\n    if (tag \u0026\u0026 len \u003c= sizeof(ctx-\u003eXi))\n        return CRYPTO_memcmp(ctx-\u003eXi.c, tag, len);\n    else\n        return -1;\n}","filepath":"crypto/modes/gcm128.c","line_number":1457,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.1.0-alpha1"},"270412912":{"score":0.7553324,"function_name":"CRYPTO_gcm128_init","code":"void CRYPTO_gcm128_init(GCM128_CONTEXT *ctx, void *key, block128_f block)\n{\n    DECLARE_IS_ENDIAN;\n\n    memset(ctx, 0, sizeof(*ctx));\n    ctx-\u003eblock = block;\n    ctx-\u003ekey = key;\n\n    (*block) (ctx-\u003eH.c, ctx-\u003eH.c, key);\n\n    if (IS_LITTLE_ENDIAN) {\n        /* H is stored in host byte order */\n#ifdef BSWAP8\n        ctx-\u003eH.u[0] = BSWAP8(ctx-\u003eH.u[0]);\n        ctx-\u003eH.u[1] = BSWAP8(ctx-\u003eH.u[1]);\n#else\n        u8 *p = ctx-\u003eH.c;\n        u64 hi, lo;\n        hi = (u64)GETU32(p) \u003c\u003c 32 | GETU32(p + 4);\n        lo = (u64)GETU32(p + 8) \u003c\u003c 32 | GETU32(p + 12);\n        ctx-\u003eH.u[0] = hi;\n        ctx-\u003eH.u[1] = lo;\n#endif\n    }\n\n    gcm_get_funcs(\u0026ctx-\u003efuncs);\n    ctx-\u003efuncs.ginit(ctx-\u003eHtable, ctx-\u003eH.u);\n}","filepath":"crypto/modes/gcm128.c","line_number":514,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.1.0-alpha1"},"270413120":{"score":0.81721747,"function_name":"CRYPTO_gcm128_setiv","code":"void CRYPTO_gcm128_setiv(GCM128_CONTEXT *ctx, const unsigned char *iv,\n                         size_t len)\n{\n    DECLARE_IS_ENDIAN;\n    unsigned int ctr;\n\n    ctx-\u003elen.u[0] = 0;          /* AAD length */\n    ctx-\u003elen.u[1] = 0;          /* message length */\n    ctx-\u003eares = 0;\n    ctx-\u003emres = 0;\n\n    if (len == 12) {\n        memcpy(ctx-\u003eYi.c, iv, 12);\n        ctx-\u003eYi.c[12] = 0;\n        ctx-\u003eYi.c[13] = 0;\n        ctx-\u003eYi.c[14] = 0;\n        ctx-\u003eYi.c[15] = 1;\n        ctr = 1;\n    } else {\n        size_t i;\n        u64 len0 = len;\n\n        /* Borrow ctx-\u003eXi to calculate initial Yi */\n        ctx-\u003eXi.u[0] = 0;\n        ctx-\u003eXi.u[1] = 0;\n\n        while (len \u003e= 16) {\n            for (i = 0; i \u003c 16; ++i)\n                ctx-\u003eXi.c[i] ^= iv[i];\n            GCM_MUL(ctx);\n            iv += 16;\n            len -= 16;\n        }\n        if (len) {\n            for (i = 0; i \u003c len; ++i)\n                ctx-\u003eXi.c[i] ^= iv[i];\n            GCM_MUL(ctx);\n        }\n        len0 \u003c\u003c= 3;\n        if (IS_LITTLE_ENDIAN) {\n#ifdef BSWAP8\n            ctx-\u003eXi.u[1] ^= BSWAP8(len0);\n#else\n            ctx-\u003eXi.c[8] ^= (u8)(len0 \u003e\u003e 56);\n            ctx-\u003eXi.c[9] ^= (u8)(len0 \u003e\u003e 48);\n            ctx-\u003eXi.c[10] ^= (u8)(len0 \u003e\u003e 40);\n            ctx-\u003eXi.c[11] ^= (u8)(len0 \u003e\u003e 32);\n            ctx-\u003eXi.c[12] ^= (u8)(len0 \u003e\u003e 24);\n            ctx-\u003eXi.c[13] ^= (u8)(len0 \u003e\u003e 16);\n            ctx-\u003eXi.c[14] ^= (u8)(len0 \u003e\u003e 8);\n            ctx-\u003eXi.c[15] ^= (u8)(len0);\n#endif\n        } else {\n            ctx-\u003eXi.u[1] ^= len0;\n        }\n\n        GCM_MUL(ctx);\n\n        if (IS_LITTLE_ENDIAN)\n#ifdef BSWAP4\n            ctr = BSWAP4(ctx-\u003eXi.d[3]);\n#else\n            ctr = GETU32(ctx-\u003eXi.c + 12);\n#endif\n        else\n            ctr = ctx-\u003eXi.d[3];\n\n        /* Copy borrowed Xi to Yi */\n        ctx-\u003eYi.u[0] = ctx-\u003eXi.u[0];\n        ctx-\u003eYi.u[1] = ctx-\u003eXi.u[1];\n    }\n\n    ctx-\u003eXi.u[0] = 0;\n    ctx-\u003eXi.u[1] = 0;\n\n    (*ctx-\u003eblock) (ctx-\u003eYi.c, ctx-\u003eEK0.c, ctx-\u003ekey);\n    ++ctr;\n    if (IS_LITTLE_ENDIAN)\n#ifdef BSWAP4\n        ctx-\u003eYi.d[3] = BSWAP4(ctr);\n#else\n        PUTU32(ctx-\u003eYi.c + 12, ctr);\n#endif\n    else\n        ctx-\u003eYi.d[3] = ctr;\n}","filepath":"crypto/modes/gcm128.c","line_number":543,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.1.0-alpha1"},"270413904":{"score":0.75935566,"function_name":"gcm_init_4bit","code":"static void gcm_init_4bit(u128 Htable[16], const u64 H[2])\n{\n    u128 V;\n# if defined(OPENSSL_SMALL_FOOTPRINT)\n    int i;\n# endif\n\n    Htable[0].hi = 0;\n    Htable[0].lo = 0;\n    V.hi = H[0];\n    V.lo = H[1];\n\n# if defined(OPENSSL_SMALL_FOOTPRINT)\n    for (Htable[8] = V, i = 4; i \u003e 0; i \u003e\u003e= 1) {\n        REDUCE1BIT(V);\n        Htable[i] = V;\n    }\n\n    for (i = 2; i \u003c 16; i \u003c\u003c= 1) {\n        u128 *Hi = Htable + i;\n        int j;\n        for (V = *Hi, j = 1; j \u003c i; ++j) {\n            Hi[j].hi = V.hi ^ Htable[j].hi;\n            Hi[j].lo = V.lo ^ Htable[j].lo;\n        }\n    }\n# else\n    Htable[8] = V;\n    REDUCE1BIT(V);\n    Htable[4] = V;\n    REDUCE1BIT(V);\n    Htable[2] = V;\n    REDUCE1BIT(V);\n    Htable[1] = V;\n    Htable[3].hi = V.hi ^ Htable[2].hi, Htable[3].lo = V.lo ^ Htable[2].lo;\n    V = Htable[4];\n    Htable[5].hi = V.hi ^ Htable[1].hi, Htable[5].lo = V.lo ^ Htable[1].lo;\n    Htable[6].hi = V.hi ^ Htable[2].hi, Htable[6].lo = V.lo ^ Htable[2].lo;\n    Htable[7].hi = V.hi ^ Htable[3].hi, Htable[7].lo = V.lo ^ Htable[3].lo;\n    V = Htable[8];\n    Htable[9].hi = V.hi ^ Htable[1].hi, Htable[9].lo = V.lo ^ Htable[1].lo;\n    Htable[10].hi = V.hi ^ Htable[2].hi, Htable[10].lo = V.lo ^ Htable[2].lo;\n    Htable[11].hi = V.hi ^ Htable[3].hi, Htable[11].lo = V.lo ^ Htable[3].lo;\n    Htable[12].hi = V.hi ^ Htable[4].hi, Htable[12].lo = V.lo ^ Htable[4].lo;\n    Htable[13].hi = V.hi ^ Htable[5].hi, Htable[13].lo = V.lo ^ Htable[5].lo;\n    Htable[14].hi = V.hi ^ Htable[6].hi, Htable[14].lo = V.lo ^ Htable[6].lo;\n    Htable[15].hi = V.hi ^ Htable[7].hi, Htable[15].lo = V.lo ^ Htable[7].lo;\n# endif\n# if defined(GHASH_ASM) \u0026\u0026 (defined(__arm__) || defined(__arm))\n    /*\n     * ARM assembler expects specific dword order in Htable.\n     */\n    {\n        int j;\n        DECLARE_IS_ENDIAN;\n\n        if (IS_LITTLE_ENDIAN)\n            for (j = 0; j \u003c 16; ++j) {\n                V = Htable[j];\n                Htable[j].hi = V.lo;\n                Htable[j].lo = V.hi;\n        } else\n            for (j = 0; j \u003c 16; ++j) {\n                V = Htable[j];\n                Htable[j].hi = V.lo \u003c\u003c 32 | V.lo \u003e\u003e 32;\n                Htable[j].lo = V.hi \u003c\u003c 32 | V.hi \u003e\u003e 32;\n            }\n    }\n# endif\n}","filepath":"crypto/modes/gcm128.c","line_number":87,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.1.0-alpha1"},"270414880":{"score":0.79865307,"function_name":"CRYPTO_ccm128_aad","code":"void CRYPTO_ccm128_aad(CCM128_CONTEXT *ctx,\n                       const unsigned char *aad, size_t alen)\n{\n    unsigned int i;\n    block128_f block = ctx-\u003eblock;\n\n    if (alen == 0)\n        return;\n\n    ctx-\u003enonce.c[0] |= 0x40;    /* set Adata flag */\n    (*block) (ctx-\u003enonce.c, ctx-\u003ecmac.c, ctx-\u003ekey), ctx-\u003eblocks++;\n\n    if (alen \u003c (0x10000 - 0x100)) {\n        ctx-\u003ecmac.c[0] ^= (u8)(alen \u003e\u003e 8);\n        ctx-\u003ecmac.c[1] ^= (u8)alen;\n        i = 2;\n    } else if (sizeof(alen) == 8\n               \u0026\u0026 alen \u003e= (size_t)1 \u003c\u003c (32 % (sizeof(alen) * 8))) {\n        ctx-\u003ecmac.c[0] ^= 0xFF;\n        ctx-\u003ecmac.c[1] ^= 0xFF;\n        ctx-\u003ecmac.c[2] ^= (u8)(alen \u003e\u003e (56 % (sizeof(alen) * 8)));\n        ctx-\u003ecmac.c[3] ^= (u8)(alen \u003e\u003e (48 % (sizeof(alen) * 8)));\n        ctx-\u003ecmac.c[4] ^= (u8)(alen \u003e\u003e (40 % (sizeof(alen) * 8)));\n        ctx-\u003ecmac.c[5] ^= (u8)(alen \u003e\u003e (32 % (sizeof(alen) * 8)));\n        ctx-\u003ecmac.c[6] ^= (u8)(alen \u003e\u003e 24);\n        ctx-\u003ecmac.c[7] ^= (u8)(alen \u003e\u003e 16);\n        ctx-\u003ecmac.c[8] ^= (u8)(alen \u003e\u003e 8);\n        ctx-\u003ecmac.c[9] ^= (u8)alen;\n        i = 10;\n    } else {\n        ctx-\u003ecmac.c[0] ^= 0xFF;\n        ctx-\u003ecmac.c[1] ^= 0xFE;\n        ctx-\u003ecmac.c[2] ^= (u8)(alen \u003e\u003e 24);\n        ctx-\u003ecmac.c[3] ^= (u8)(alen \u003e\u003e 16);\n        ctx-\u003ecmac.c[4] ^= (u8)(alen \u003e\u003e 8);\n        ctx-\u003ecmac.c[5] ^= (u8)alen;\n        i = 6;\n    }\n\n    do {\n        for (; i \u003c 16 \u0026\u0026 alen; ++i, ++aad, --alen)\n            ctx-\u003ecmac.c[i] ^= *aad;\n        (*block) (ctx-\u003ecmac.c, ctx-\u003ecmac.c, ctx-\u003ekey), ctx-\u003eblocks++;\n        i = 0;\n    } while (alen);\n}","filepath":"crypto/modes/ccm128.c","line_number":60,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270415072":{"score":0.7773329,"function_name":"CRYPTO_ccm128_encrypt","code":"int CRYPTO_ccm128_encrypt(CCM128_CONTEXT *ctx,\n                          const unsigned char *inp, unsigned char *out,\n                          size_t len)\n{\n    size_t n;\n    unsigned int i, L;\n    unsigned char flags0 = ctx-\u003enonce.c[0];\n    block128_f block = ctx-\u003eblock;\n    void *key = ctx-\u003ekey;\n    union {\n        u64 u[2];\n        u8 c[16];\n    } scratch;\n\n    if (!(flags0 \u0026 0x40))\n        (*block) (ctx-\u003enonce.c, ctx-\u003ecmac.c, key), ctx-\u003eblocks++;\n\n    ctx-\u003enonce.c[0] = L = flags0 \u0026 7;\n    for (n = 0, i = 15 - L; i \u003c 15; ++i) {\n        n |= ctx-\u003enonce.c[i];\n        ctx-\u003enonce.c[i] = 0;\n        n \u003c\u003c= 8;\n    }\n    n |= ctx-\u003enonce.c[15];      /* reconstructed length */\n    ctx-\u003enonce.c[15] = 1;\n\n    if (n != len)\n        return -1;              /* length mismatch */\n\n    ctx-\u003eblocks += ((len + 15) \u003e\u003e 3) | 1;\n    if (ctx-\u003eblocks \u003e (U64(1) \u003c\u003c 61))\n        return -2;              /* too much data */\n\n    while (len \u003e= 16) {\n#if defined(STRICT_ALIGNMENT)\n        union {\n            u64 u[2];\n            u8 c[16];\n        } temp;\n\n        memcpy(temp.c, inp, 16);\n        ctx-\u003ecmac.u[0] ^= temp.u[0];\n        ctx-\u003ecmac.u[1] ^= temp.u[1];\n#else\n        ctx-\u003ecmac.u[0] ^= ((u64 *)inp)[0];\n        ctx-\u003ecmac.u[1] ^= ((u64 *)inp)[1];\n#endif\n        (*block) (ctx-\u003ecmac.c, ctx-\u003ecmac.c, key);\n        (*block) (ctx-\u003enonce.c, scratch.c, key);\n        ctr64_inc(ctx-\u003enonce.c);\n#if defined(STRICT_ALIGNMENT)\n        temp.u[0] ^= scratch.u[0];\n        temp.u[1] ^= scratch.u[1];\n        memcpy(out, temp.c, 16);\n#else\n        ((u64 *)out)[0] = scratch.u[0] ^ ((u64 *)inp)[0];\n        ((u64 *)out)[1] = scratch.u[1] ^ ((u64 *)inp)[1];\n#endif\n        inp += 16;\n        out += 16;\n        len -= 16;\n    }\n\n    if (len) {\n        for (i = 0; i \u003c len; ++i)\n            ctx-\u003ecmac.c[i] ^= inp[i];\n        (*block) (ctx-\u003ecmac.c, ctx-\u003ecmac.c, key);\n        (*block) (ctx-\u003enonce.c, scratch.c, key);\n        for (i = 0; i \u003c len; ++i)\n            out[i] = scratch.c[i] ^ inp[i];\n    }\n\n    for (i = 15 - L; i \u003c 16; ++i)\n        ctx-\u003enonce.c[i] = 0;\n\n    (*block) (ctx-\u003enonce.c, scratch.c, key);\n    ctx-\u003ecmac.u[0] ^= scratch.u[0];\n    ctx-\u003ecmac.u[1] ^= scratch.u[1];\n\n    ctx-\u003enonce.c[0] = flags0;\n\n    return 0;\n}","filepath":"crypto/modes/ccm128.c","line_number":129,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270415584":{"score":0.7671736,"function_name":"CRYPTO_ccm128_decrypt_ccm64","code":"int CRYPTO_ccm128_decrypt_ccm64(CCM128_CONTEXT *ctx,\n                                const unsigned char *inp, unsigned char *out,\n                                size_t len, ccm128_f stream)\n{\n    size_t n;\n    unsigned int i, L;\n    unsigned char flags0 = ctx-\u003enonce.c[0];\n    block128_f block = ctx-\u003eblock;\n    void *key = ctx-\u003ekey;\n    union {\n        u64 u[2];\n        u8 c[16];\n    } scratch;\n\n    if (!(flags0 \u0026 0x40))\n        (*block) (ctx-\u003enonce.c, ctx-\u003ecmac.c, key);\n\n    ctx-\u003enonce.c[0] = L = flags0 \u0026 7;\n    for (n = 0, i = 15 - L; i \u003c 15; ++i) {\n        n |= ctx-\u003enonce.c[i];\n        ctx-\u003enonce.c[i] = 0;\n        n \u003c\u003c= 8;\n    }\n    n |= ctx-\u003enonce.c[15];      /* reconstructed length */\n    ctx-\u003enonce.c[15] = 1;\n\n    if (n != len)\n        return -1;\n\n    if ((n = len / 16)) {\n        (*stream) (inp, out, n, key, ctx-\u003enonce.c, ctx-\u003ecmac.c);\n        n *= 16;\n        inp += n;\n        out += n;\n        len -= n;\n        if (len)\n            ctr64_add(ctx-\u003enonce.c, n / 16);\n    }\n\n    if (len) {\n        (*block) (ctx-\u003enonce.c, scratch.c, key);\n        for (i = 0; i \u003c len; ++i)\n            ctx-\u003ecmac.c[i] ^= (out[i] = scratch.c[i] ^ inp[i]);\n        (*block) (ctx-\u003ecmac.c, ctx-\u003ecmac.c, key);\n    }\n\n    for (i = 15 - L; i \u003c 16; ++i)\n        ctx-\u003enonce.c[i] = 0;\n\n    (*block) (ctx-\u003enonce.c, scratch.c, key);\n    ctx-\u003ecmac.u[0] ^= scratch.u[0];\n    ctx-\u003ecmac.u[1] ^= scratch.u[1];\n\n    ctx-\u003enonce.c[0] = flags0;\n\n    return 0;\n}","filepath":"crypto/modes/ccm128.c","line_number":364,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270416768":{"score":0.7453921,"function_name":"CRYPTO_ccm128_encrypt_ccm64","code":"int CRYPTO_ccm128_encrypt_ccm64(CCM128_CONTEXT *ctx,\n                                const unsigned char *inp, unsigned char *out,\n                                size_t len, ccm128_f stream)\n{\n    size_t n;\n    unsigned int i, L;\n    unsigned char flags0 = ctx-\u003enonce.c[0];\n    block128_f block = ctx-\u003eblock;\n    void *key = ctx-\u003ekey;\n    union {\n        u64 u[2];\n        u8 c[16];\n    } scratch;\n\n    if (!(flags0 \u0026 0x40))\n        (*block) (ctx-\u003enonce.c, ctx-\u003ecmac.c, key), ctx-\u003eblocks++;\n\n    ctx-\u003enonce.c[0] = L = flags0 \u0026 7;\n    for (n = 0, i = 15 - L; i \u003c 15; ++i) {\n        n |= ctx-\u003enonce.c[i];\n        ctx-\u003enonce.c[i] = 0;\n        n \u003c\u003c= 8;\n    }\n    n |= ctx-\u003enonce.c[15];      /* reconstructed length */\n    ctx-\u003enonce.c[15] = 1;\n\n    if (n != len)\n        return -1;              /* length mismatch */\n\n    ctx-\u003eblocks += ((len + 15) \u003e\u003e 3) | 1;\n    if (ctx-\u003eblocks \u003e (U64(1) \u003c\u003c 61))\n        return -2;              /* too much data */\n\n    if ((n = len / 16)) {\n        (*stream) (inp, out, n, key, ctx-\u003enonce.c, ctx-\u003ecmac.c);\n        n *= 16;\n        inp += n;\n        out += n;\n        len -= n;\n        if (len)\n            ctr64_add(ctx-\u003enonce.c, n / 16);\n    }\n\n    if (len) {\n        for (i = 0; i \u003c len; ++i)\n            ctx-\u003ecmac.c[i] ^= inp[i];\n        (*block) (ctx-\u003ecmac.c, ctx-\u003ecmac.c, key);\n        (*block) (ctx-\u003enonce.c, scratch.c, key);\n        for (i = 0; i \u003c len; ++i)\n            out[i] = scratch.c[i] ^ inp[i];\n    }\n\n    for (i = 15 - L; i \u003c 16; ++i)\n        ctx-\u003enonce.c[i] = 0;\n\n    (*block) (ctx-\u003enonce.c, scratch.c, key);\n    ctx-\u003ecmac.u[0] ^= scratch.u[0];\n    ctx-\u003ecmac.u[1] ^= scratch.u[1];\n\n    ctx-\u003enonce.c[0] = flags0;\n\n    return 0;\n}","filepath":"crypto/modes/ccm128.c","line_number":300,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270417440":{"score":0.75191253,"function_name":"CRYPTO_ccm128_init","code":"void CRYPTO_ccm128_init(CCM128_CONTEXT *ctx,\n                        unsigned int M, unsigned int L, void *key,\n                        block128_f block)\n{\n    memset(ctx-\u003enonce.c, 0, sizeof(ctx-\u003enonce.c));\n    ctx-\u003enonce.c[0] = ((u8)(L - 1) \u0026 7) | (u8)(((M - 2) / 2) \u0026 7) \u003c\u003c 3;\n    ctx-\u003eblocks = 0;\n    ctx-\u003eblock = block;\n    ctx-\u003ekey = key;\n}","filepath":"crypto/modes/ccm128.c","line_number":18,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270417520":{"score":0.59896165,"function_name":"CRYPTO_ocb128_tag","code":"int CRYPTO_ocb128_tag(OCB128_CONTEXT * ctx, unsigned char *tag, size_t len)\n{\n    if (len \u003e 16 || len \u003c 1) {\n        return -1;\n    }\n\n    /* Calculate the tag */\n    CRYPTO_ocb128_finish(ctx, NULL, 0);\n\n    /* Copy the tag into the supplied buffer */\n    memcpy(tag, \u0026ctx-\u003etag, len);\n\n    return 1;\n}","filepath":"crypto/modes/ocb128.c","line_number":562,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"master-pre-reformat"},"270417632":{"score":0.9586533,"function_name":"CRYPTO_ccm128_tag","code":"size_t CRYPTO_ccm128_tag(CCM128_CONTEXT *ctx, unsigned char *tag, size_t len)\n{\n    unsigned int M = (ctx-\u003enonce.c[0] \u003e\u003e 3) \u0026 7; /* the M parameter */\n\n    M *= 2;\n    M += 2;\n    if (len != M)\n        return 0;\n    memcpy(tag, ctx-\u003ecmac.c, M);\n    return M;\n}","filepath":"crypto/modes/ccm128.c","line_number":422,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270417696":{"score":0.7567713,"function_name":"ctr64_add","code":"static void ctr64_add(unsigned char *counter, size_t inc)\n{\n    size_t n = 8, val = 0;\n\n    counter += 8;\n    do {\n        --n;\n        val += counter[n] + (inc \u0026 0xff);\n        counter[n] = (unsigned char)val;\n        val \u003e\u003e= 8;              /* carry bit */\n        inc \u003e\u003e= 8;\n    } while (n \u0026\u0026 (inc || val));\n}","filepath":"crypto/modes/ccm128.c","line_number":286,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270420288":{"score":0.65808594,"function_name":"CRYPTO_ocb128_aad","code":"int CRYPTO_ocb128_aad(OCB128_CONTEXT *ctx, const unsigned char *aad,\n                      size_t len)\n{\n    u64 i, all_num_blocks;\n    size_t num_blocks, last_len;\n    OCB_BLOCK tmp;\n\n    /* Calculate the number of blocks of AAD provided now, and so far */\n    num_blocks = len / 16;\n    all_num_blocks = num_blocks + ctx-\u003esess.blocks_hashed;\n\n    /* Loop through all full blocks of AAD */\n    for (i = ctx-\u003esess.blocks_hashed + 1; i \u003c= all_num_blocks; i++) {\n        OCB_BLOCK *lookup;\n\n        /* Offset_i = Offset_{i-1} xor L_{ntz(i)} */\n        lookup = ocb_lookup_l(ctx, ocb_ntz(i));\n        if (lookup == NULL)\n            return 0;\n        ocb_block16_xor(\u0026ctx-\u003esess.offset_aad, lookup, \u0026ctx-\u003esess.offset_aad);\n\n        memcpy(tmp.c, aad, 16);\n        aad += 16;\n\n        /* Sum_i = Sum_{i-1} xor ENCIPHER(K, A_i xor Offset_i) */\n        ocb_block16_xor(\u0026ctx-\u003esess.offset_aad, \u0026tmp, \u0026tmp);\n        ctx-\u003eencrypt(tmp.c, tmp.c, ctx-\u003ekeyenc);\n        ocb_block16_xor(\u0026tmp, \u0026ctx-\u003esess.sum, \u0026ctx-\u003esess.sum);\n    }\n\n    /*\n     * Check if we have any partial blocks left over. This is only valid in the\n     * last call to this function\n     */\n    last_len = len % 16;\n\n    if (last_len \u003e 0) {\n        /* Offset_* = Offset_m xor L_* */\n        ocb_block16_xor(\u0026ctx-\u003esess.offset_aad, \u0026ctx-\u003el_star,\n                        \u0026ctx-\u003esess.offset_aad);\n\n        /* CipherInput = (A_* || 1 || zeros(127-bitlen(A_*))) xor Offset_* */\n        memset(tmp.c, 0, 16);\n        memcpy(tmp.c, aad, last_len);\n        tmp.c[last_len] = 0x80;\n        ocb_block16_xor(\u0026ctx-\u003esess.offset_aad, \u0026tmp, \u0026tmp);\n\n        /* Sum = Sum_m xor ENCIPHER(K, CipherInput) */\n        ctx-\u003eencrypt(tmp.c, tmp.c, ctx-\u003ekeyenc);\n        ocb_block16_xor(\u0026tmp, \u0026ctx-\u003esess.sum, \u0026ctx-\u003esess.sum);\n    }\n\n    ctx-\u003esess.blocks_hashed = all_num_blocks;\n\n    return 1;\n}","filepath":"crypto/modes/ocb128.c","line_number":278,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre8"},"270420848":{"score":0.86411965,"function_name":"CRYPTO_ocb128_copy_ctx","code":"int CRYPTO_ocb128_copy_ctx(OCB128_CONTEXT * dest, OCB128_CONTEXT * src,\n                           void *keyenc, void *keydec)\n{\n    memcpy(dest, src, sizeof(OCB128_CONTEXT));\n    if (keyenc)\n        dest-\u003ekeyenc = keyenc;\n    if (keydec)\n        dest-\u003ekeydec = keydec;\n    if (src-\u003el) {\n        dest-\u003el = OPENSSL_malloc(src-\u003emax_l_index * 16);\n        if (!dest-\u003el)\n            return 0;\n        memcpy(dest-\u003el, src-\u003el, (src-\u003el_index + 1) * 16);\n    }\n    return 1;\n}","filepath":"crypto/modes/ocb128.c","line_number":260,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"master-pre-reformat"},"270421008":{"score":0.7292555,"function_name":"CRYPTO_ocb128_encrypt","code":"int CRYPTO_ocb128_encrypt(OCB128_CONTEXT *ctx,\n                          const unsigned char *in, unsigned char *out,\n                          size_t len)\n{\n    u64 i, all_num_blocks;\n    size_t num_blocks, last_len;\n\n    /*\n     * Calculate the number of blocks of data to be encrypted provided now, and\n     * so far\n     */\n    num_blocks = len / 16;\n    all_num_blocks = num_blocks + ctx-\u003esess.blocks_processed;\n\n    if (num_blocks \u0026\u0026 all_num_blocks == (size_t)all_num_blocks\n        \u0026\u0026 ctx-\u003estream != NULL) {\n        size_t max_idx = 0, top = (size_t)all_num_blocks;\n\n        /*\n         * See how many L_{i} entries we need to process data at hand\n         * and pre-compute missing entries in the table [if any]...\n         */\n        while (top \u003e\u003e= 1)\n            max_idx++;\n        if (ocb_lookup_l(ctx, max_idx) == NULL)\n            return 0;\n\n        ctx-\u003estream(in, out, num_blocks, ctx-\u003ekeyenc,\n                    (size_t)ctx-\u003esess.blocks_processed + 1, ctx-\u003esess.offset.c,\n                    (const unsigned char (*)[16])ctx-\u003el, ctx-\u003esess.checksum.c);\n    } else {\n        /* Loop through all full blocks to be encrypted */\n        for (i = ctx-\u003esess.blocks_processed + 1; i \u003c= all_num_blocks; i++) {\n            OCB_BLOCK *lookup;\n            OCB_BLOCK tmp;\n\n            /* Offset_i = Offset_{i-1} xor L_{ntz(i)} */\n            lookup = ocb_lookup_l(ctx, ocb_ntz(i));\n            if (lookup == NULL)\n                return 0;\n            ocb_block16_xor(\u0026ctx-\u003esess.offset, lookup, \u0026ctx-\u003esess.offset);\n\n            memcpy(tmp.c, in, 16);\n            in += 16;\n\n            /* Checksum_i = Checksum_{i-1} xor P_i */\n            ocb_block16_xor(\u0026tmp, \u0026ctx-\u003esess.checksum, \u0026ctx-\u003esess.checksum);\n\n            /* C_i = Offset_i xor ENCIPHER(K, P_i xor Offset_i) */\n            ocb_block16_xor(\u0026ctx-\u003esess.offset, \u0026tmp, \u0026tmp);\n            ctx-\u003eencrypt(tmp.c, tmp.c, ctx-\u003ekeyenc);\n            ocb_block16_xor(\u0026ctx-\u003esess.offset, \u0026tmp, \u0026tmp);\n\n            memcpy(out, tmp.c, 16);\n            out += 16;\n        }\n    }\n\n    /*\n     * Check if we have any partial blocks left over. This is only valid in the\n     * last call to this function\n     */\n    last_len = len % 16;\n\n    if (last_len \u003e 0) {\n        OCB_BLOCK pad;\n\n        /* Offset_* = Offset_m xor L_* */\n        ocb_block16_xor(\u0026ctx-\u003esess.offset, \u0026ctx-\u003el_star, \u0026ctx-\u003esess.offset);\n\n        /* Pad = ENCIPHER(K, Offset_*) */\n        ctx-\u003eencrypt(ctx-\u003esess.offset.c, pad.c, ctx-\u003ekeyenc);\n\n        /* C_* = P_* xor Pad[1..bitlen(P_*)] */\n        ocb_block_xor(in, pad.c, last_len, out);\n\n        /* Checksum_* = Checksum_m xor (P_* || 1 || zeros(127-bitlen(P_*))) */\n        memset(pad.c, 0, 16);           /* borrow pad */\n        memcpy(pad.c, in, last_len);\n        pad.c[last_len] = 0x80;\n        ocb_block16_xor(\u0026pad, \u0026ctx-\u003esess.checksum, \u0026ctx-\u003esess.checksum);\n    }\n\n    ctx-\u003esess.blocks_processed = all_num_blocks;\n\n    return 1;\n}","filepath":"crypto/modes/ocb128.c","line_number":339,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre8"},"270422432":{"score":0.7880047,"function_name":"CRYPTO_ocb128_init","code":"int CRYPTO_ocb128_init(OCB128_CONTEXT *ctx, void *keyenc, void *keydec,\n                       block128_f encrypt, block128_f decrypt)\n{\n    /* Clear everything to NULLs */\n    memset(ctx, 0, sizeof(*ctx));\n\n    ctx-\u003el_index = 0;\n    ctx-\u003emax_l_index = 1;\n    ctx-\u003el = OPENSSL_malloc(ctx-\u003emax_l_index * 16);\n    if (!ctx-\u003el)\n        return 0;\n\n    /*\n     * We set both the encryption and decryption key schedules - decryption\n     * needs both. Don't really need decryption schedule if only doing\n     * encryption - but it simplifies things to take it anyway\n     */\n    ctx-\u003eencrypt = encrypt;\n    ctx-\u003edecrypt = decrypt;\n    ctx-\u003ekeyenc = keyenc;\n    ctx-\u003ekeydec = keydec;\n\n    /* L_* = ENCIPHER(K, zeros(128)) */\n    ocb_encrypt(ctx, \u0026ctx-\u003el_star, \u0026ctx-\u003el_star, ctx-\u003ekeyenc);\n\n    /* L_$ = double(L_*) */\n    ocb_double(\u0026ctx-\u003el_star, \u0026ctx-\u003el_dollar);\n\n    /* L_0 = double(L_$) */\n    ocb_double(\u0026ctx-\u003el_dollar, ctx-\u003el);\n\n    return 1;\n}","filepath":"crypto/modes/ocb128.c","line_number":223,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"master-pre-reformat"},"270422768":{"score":0.7039715,"function_name":"CRYPTO_ocb128_setiv","code":"int CRYPTO_ocb128_setiv(OCB128_CONTEXT * ctx, const unsigned char *iv,\n                        size_t len, size_t taglen)\n{\n    unsigned char ktop[16], tmp[16], mask;\n    unsigned char stretch[24], nonce[16];\n    size_t bottom, shift;\n    union ublock offset;\n    \n    offset.ocbblk = \u0026ctx-\u003eoffset;\n\n    /*\n     * Spec says IV is 120 bits or fewer - it allows non byte aligned lengths.\n     * We don't support  this at this stage\n     */\n    if ((len \u003e 15) || (len \u003c 1) || (taglen \u003e 16) || (taglen \u003c 1)) {\n        return -1;\n    }\n\n    /* Nonce = num2str(TAGLEN mod 128,7) || zeros(120-bitlen(N)) || 1 || N */\n    nonce[0] = ((taglen * 8) % 128) \u003c\u003c 1;\n    memset(nonce + 1, 0, 15);\n    memcpy(nonce + 16 - len, iv, len);\n    nonce[15 - len] |= 1;\n\n    /* Ktop = ENCIPHER(K, Nonce[1..122] || zeros(6)) */\n    memcpy(tmp, nonce, 16);\n    tmp[15] \u0026= 0xc0;\n    ctx-\u003eencrypt(tmp, ktop, ctx-\u003ekeyenc);\n\n    /* Stretch = Ktop || (Ktop[1..64] xor Ktop[9..72]) */\n    memcpy(stretch, ktop, 16);\n    ocb_block_xor(ktop, ktop + 1, 8, stretch + 16);\n\n    /* bottom = str2num(Nonce[123..128]) */\n    bottom = nonce[15] \u0026 0x3f;\n\n    /* Offset_0 = Stretch[1+bottom..128+bottom] */\n    shift = bottom % 8;\n    ocb_block_lshift((OCB_BLOCK *)(stretch + (bottom / 8)), shift, \u0026ctx-\u003eoffset);\n    mask = 0xff;\n    mask \u003c\u003c= 8 - shift;\n    offset.chrblk[15] |= (*(stretch + (bottom / 8) + 16) \u0026 mask) \u003e\u003e (8 - shift);\n\n    return 1;\n}","filepath":"crypto/modes/ocb128.c","line_number":280,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"master-pre-reformat"},"270423424":{"score":0.6729895,"function_name":"ocb_block_xor","code":"static void ocb_block_xor(const unsigned char *in1,\n                          const unsigned char *in2, size_t len,\n                          unsigned char *out)\n{\n    size_t i;\n    for (i = 0; i \u003c len; i++) {\n        out[i] = in1[i] ^ in2[i];\n    }\n}","filepath":"crypto/modes/ocb128.c","line_number":87,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre8"},"270423712":{"score":0.7408373,"function_name":"ocb_finish","code":"static int ocb_finish(OCB128_CONTEXT *ctx, unsigned char *tag, size_t len,\n                      int write)\n{\n    OCB_BLOCK tmp;\n\n    if (len \u003e 16 || len \u003c 1) {\n        return -1;\n    }\n\n    /*\n     * Tag = ENCIPHER(K, Checksum_* xor Offset_* xor L_$) xor HASH(K,A)\n     */\n    ocb_block16_xor(\u0026ctx-\u003esess.checksum, \u0026ctx-\u003esess.offset, \u0026tmp);\n    ocb_block16_xor(\u0026ctx-\u003el_dollar, \u0026tmp, \u0026tmp);\n    ctx-\u003eencrypt(tmp.c, tmp.c, ctx-\u003ekeyenc);\n    ocb_block16_xor(\u0026tmp, \u0026ctx-\u003esess.sum, \u0026tmp);\n\n    if (write) {\n        memcpy(tag, \u0026tmp, len);\n        return 1;\n    } else {\n        return CRYPTO_memcmp(\u0026tmp, tag, len);\n    }\n}","filepath":"crypto/modes/ocb128.c","line_number":519,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1-pre8"},"270423968":{"score":0.81466675,"function_name":"ocb_lookup_l","code":"static OCB_BLOCK *ocb_lookup_l(OCB128_CONTEXT *ctx, size_t idx)\n{\n    size_t l_index = ctx-\u003el_index;\n\n    if (idx \u003c= l_index) {\n        return ctx-\u003el + idx;\n    }\n\n    /* We don't have it - so calculate it */\n    if (idx \u003e= ctx-\u003emax_l_index) {\n        void *tmp_ptr;\n        /*\n         * Each additional entry allows to process almost double as\n         * much data, so that in linear world the table will need to\n         * be expanded with smaller and smaller increments. Originally\n         * it was doubling in size, which was a waste. Growing it\n         * linearly is not formally optimal, but is simpler to implement.\n         * We grow table by minimally required 4*n that would accommodate\n         * the index.\n         */\n        ctx-\u003emax_l_index += (idx - ctx-\u003emax_l_index + 4) \u0026 ~3;\n        tmp_ptr = OPENSSL_realloc(ctx-\u003el, ctx-\u003emax_l_index * sizeof(OCB_BLOCK));\n        if (tmp_ptr == NULL) /* prevent ctx-\u003el from being clobbered */\n            return NULL;\n        ctx-\u003el = tmp_ptr;\n    }\n    while (l_index \u003c idx) {\n        ocb_double(ctx-\u003el + l_index, ctx-\u003el + l_index + 1);\n        l_index++;\n    }\n    ctx-\u003el_index = l_index;\n\n    return ctx-\u003el + idx;\n}"},"270471344":{"score":0.81434286,"function_name":"BLAKE2s_Final","code":"int BLAKE2s_Final(unsigned char *md, BLAKE2S_CTX *c)\n{\n    int i;\n\n    blake2s_set_lastblock(c);\n    /* Padding */\n    memset(c-\u003ebuf + c-\u003ebuflen, 0, sizeof(c-\u003ebuf) - c-\u003ebuflen);\n    blake2s_compress(c, c-\u003ebuf, c-\u003ebuflen);\n\n    /* Output full hash to temp buffer */\n    for (i = 0; i \u003c 8; ++i) {\n        store32(md + sizeof(c-\u003eh[i]) * i, c-\u003eh[i]);\n    }\n\n    OPENSSL_cleanse(c, sizeof(BLAKE2S_CTX));\n    return 1;\n}","filepath":"crypto/blake2/blake2s.c","line_number":249,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre5"},"270471648":{"score":0.8487538,"function_name":"BLAKE2s_Update","code":"int BLAKE2s_Update(BLAKE2S_CTX *c, const void *data, size_t datalen)\n{\n    const uint8_t *in = data;\n    size_t fill;\n\n    /*\n     * Intuitively one would expect intermediate buffer, c-\u003ebuf, to\n     * store incomplete blocks. But in this case we are interested to\n     * temporarily stash even complete blocks, because last one in the\n     * stream has to be treated in special way, and at this point we\n     * don't know if last block in *this* call is last one \"ever\". This\n     * is the reason for why |datalen| is compared as \u003e, and not \u003e=.\n     */\n    fill = sizeof(c-\u003ebuf) - c-\u003ebuflen;\n    if (datalen \u003e fill) {\n        if (c-\u003ebuflen) {\n            memcpy(c-\u003ebuf + c-\u003ebuflen, in, fill); /* Fill buffer */\n            blake2s_compress(c, c-\u003ebuf, BLAKE2S_BLOCKBYTES);\n            c-\u003ebuflen = 0;\n            in += fill;\n            datalen -= fill;\n        }\n        if (datalen \u003e BLAKE2S_BLOCKBYTES)  {\n            size_t stashlen = datalen % BLAKE2S_BLOCKBYTES;\n            /*\n             * If |datalen| is a multiple of the blocksize, stash\n             * last complete block, it can be final one...\n             */\n            stashlen = stashlen ? stashlen : BLAKE2S_BLOCKBYTES;\n            datalen -= stashlen;\n            blake2s_compress(c, in, datalen);\n            in += datalen;\n            datalen = stashlen;\n        }\n    }\n\n    assert(datalen \u003c= BLAKE2S_BLOCKBYTES);\n\n    memcpy(c-\u003ebuf + c-\u003ebuflen, in, datalen);\n    c-\u003ebuflen += datalen; /* Be lazy, do not compress */\n\n    return 1;\n}"},"270471808":{"score":0.7659626,"function_name":"blake2s_compress","code":"static void blake2s_compress(BLAKE2S_CTX *S,\n                            const uint8_t *blocks,\n                            size_t len)\n{\n    uint32_t m[16];\n    uint32_t v[16];\n    size_t i;\n    size_t increment;\n\n    /*\n     * There are two distinct usage vectors for this function:\n     *\n     * a) BLAKE2s_Update uses it to process complete blocks,\n     *    possibly more than one at a time;\n     *\n     * b) BLAK2s_Final uses it to process last block, always\n     *    single but possibly incomplete, in which case caller\n     *    pads input with zeros.\n     */\n    assert(len \u003c BLAKE2S_BLOCKBYTES || len % BLAKE2S_BLOCKBYTES == 0);\n\n    /*\n     * Since last block is always processed with separate call,\n     * |len| not being multiple of complete blocks can be observed\n     * only with |len| being less than BLAKE2S_BLOCKBYTES (\"less\"\n     * including even zero), which is why following assignment doesn't\n     * have to reside inside the main loop below.\n     */\n    increment = len \u003c BLAKE2S_BLOCKBYTES ? len : BLAKE2S_BLOCKBYTES;\n\n    for (i = 0; i \u003c 8; ++i) {\n        v[i] = S-\u003eh[i];\n    }\n\n    do {\n        for (i = 0; i \u003c 16; ++i) {\n            m[i] = load32(blocks + i * sizeof(m[i]));\n        }\n\n        /* blake2s_increment_counter */\n        S-\u003et[0] += increment;\n        S-\u003et[1] += (S-\u003et[0] \u003c increment);\n\n        v[ 8] = blake2s_IV[0];\n        v[ 9] = blake2s_IV[1];\n        v[10] = blake2s_IV[2];\n        v[11] = blake2s_IV[3];\n        v[12] = S-\u003et[0] ^ blake2s_IV[4];\n        v[13] = S-\u003et[1] ^ blake2s_IV[5];\n        v[14] = S-\u003ef[0] ^ blake2s_IV[6];\n        v[15] = S-\u003ef[1] ^ blake2s_IV[7];\n#define G(r,i,a,b,c,d) \\\n        do { \\\n            a = a + b + m[blake2s_sigma[r][2*i+0]]; \\\n            d = rotr32(d ^ a, 16); \\\n            c = c + d; \\\n            b = rotr32(b ^ c, 12); \\\n            a = a + b + m[blake2s_sigma[r][2*i+1]]; \\\n            d = rotr32(d ^ a, 8); \\\n            c = c + d; \\\n            b = rotr32(b ^ c, 7); \\\n        } while (0)\n#define ROUND(r)  \\\n        do { \\\n            G(r,0,v[ 0],v[ 4],v[ 8],v[12]); \\\n            G(r,1,v[ 1],v[ 5],v[ 9],v[13]); \\\n            G(r,2,v[ 2],v[ 6],v[10],v[14]); \\\n            G(r,3,v[ 3],v[ 7],v[11],v[15]); \\\n            G(r,4,v[ 0],v[ 5],v[10],v[15]); \\\n            G(r,5,v[ 1],v[ 6],v[11],v[12]); \\\n            G(r,6,v[ 2],v[ 7],v[ 8],v[13]); \\\n            G(r,7,v[ 3],v[ 4],v[ 9],v[14]); \\\n        } while (0)\n#if defined(OPENSSL_SMALL_FOOTPRINT)\n        /* almost 3x reduction on x86_64, 4.5x on ARMv8, 4x on ARMv4 */\n        for (i = 0; i \u003c 10; i++) {\n            ROUND(i);\n        }\n#else\n        ROUND(0);\n        ROUND(1);\n        ROUND(2);\n        ROUND(3);\n        ROUND(4);\n        ROUND(5);\n        ROUND(6);\n        ROUND(7);\n        ROUND(8);\n        ROUND(9);\n#endif\n\n        for (i = 0; i \u003c 8; ++i) {\n            S-\u003eh[i] = v[i] ^= v[i + 8] ^ S-\u003eh[i];\n        }\n#undef G\n#undef ROUND\n        blocks += increment;\n        len -= increment;\n    } while (len);\n}","filepath":"crypto/blake2/blake2s.c","line_number":99,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre5"},"270478864":{"score":0.7027314,"function_name":"KeccakF1600","code":"static void KeccakF1600(uint64_t A[5][5])\n{\n    uint64_t T[5][5];\n    size_t i;\n\n#ifdef KECCAK_COMPLEMENTING_TRANSFORM\n    A[0][1] = ~A[0][1];\n    A[0][2] = ~A[0][2];\n    A[1][3] = ~A[1][3];\n    A[2][2] = ~A[2][2];\n    A[3][2] = ~A[3][2];\n    A[4][0] = ~A[4][0];\n#endif\n\n    for (i = 0; i \u003c 24; i += 2) {\n        Round(T, A, i);\n        Round(A, T, i + 1);\n    }\n\n#ifdef KECCAK_COMPLEMENTING_TRANSFORM\n    A[0][1] = ~A[0][1];\n    A[0][2] = ~A[0][2];\n    A[1][3] = ~A[1][3];\n    A[2][2] = ~A[2][2];\n    A[3][2] = ~A[3][2];\n    A[4][0] = ~A[4][0];\n#endif\n}","filepath":"openssl/crypto/sha/keccak1600.c","line_number":647,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.0"},"270479120":{"score":0.744017,"function_name":"ROL64","code":"static uint64_t ROL64(uint64_t val, int offset)\n{\n    if (offset == 0) {\n        return val;\n    } else if (!BIT_INTERLEAVE) {\n        return (val \u003c\u003c offset) | (val \u003e\u003e (64-offset));\n    } else {\n        uint32_t hi = (uint32_t)(val \u003e\u003e 32), lo = (uint32_t)val;\n\n        if (offset \u0026 1) {\n            uint32_t tmp = hi;\n\n            offset \u003e\u003e= 1;\n            hi = ROL32(lo, offset);\n            lo = ROL32(tmp, offset + 1);\n        } else {\n            offset \u003e\u003e= 1;\n            lo = ROL32(lo, offset);\n            hi = ROL32(hi, offset);\n        }\n\n        return ((uint64_t)hi \u003c\u003c 32) | lo;\n    }\n}","filepath":"openssl/crypto/sha/keccak1600.c","line_number":47,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.0"},"270479248":{"score":0.732896,"function_name":"Round","code":"static void Round(uint64_t R[5][5], uint64_t A[5][5], size_t i)\n{\n    uint64_t C[5], D[5];\n\n    assert(i \u003c (sizeof(iotas) / sizeof(iotas[0])));\n\n    C[0] = A[0][0] ^ A[1][0] ^ A[2][0] ^ A[3][0] ^ A[4][0];\n    C[1] = A[0][1] ^ A[1][1] ^ A[2][1] ^ A[3][1] ^ A[4][1];\n    C[2] = A[0][2] ^ A[1][2] ^ A[2][2] ^ A[3][2] ^ A[4][2];\n    C[3] = A[0][3] ^ A[1][3] ^ A[2][3] ^ A[3][3] ^ A[4][3];\n    C[4] = A[0][4] ^ A[1][4] ^ A[2][4] ^ A[3][4] ^ A[4][4];\n\n    D[0] = ROL64(C[1], 1) ^ C[4];\n    D[1] = ROL64(C[2], 1) ^ C[0];\n    D[2] = ROL64(C[3], 1) ^ C[1];\n    D[3] = ROL64(C[4], 1) ^ C[2];\n    D[4] = ROL64(C[0], 1) ^ C[3];\n\n    C[0] =       A[0][0] ^ D[0]; /* rotate by 0 */\n    C[1] = ROL64(A[1][1] ^ D[1], rhotates[1][1]);\n    C[2] = ROL64(A[2][2] ^ D[2], rhotates[2][2]);\n    C[3] = ROL64(A[3][3] ^ D[3], rhotates[3][3]);\n    C[4] = ROL64(A[4][4] ^ D[4], rhotates[4][4]);\n\n#ifdef KECCAK_COMPLEMENTING_TRANSFORM\n    R[0][0] = C[0] ^ ( C[1] | C[2]) ^ iotas[i];\n    R[0][1] = C[1] ^ (~C[2] | C[3]);\n    R[0][2] = C[2] ^ ( C[3] \u0026 C[4]);\n    R[0][3] = C[3] ^ ( C[4] | C[0]);\n    R[0][4] = C[4] ^ ( C[0] \u0026 C[1]);\n#else\n    R[0][0] = C[0] ^ (~C[1] \u0026 C[2]) ^ iotas[i];\n    R[0][1] = C[1] ^ (~C[2] \u0026 C[3]);\n    R[0][2] = C[2] ^ (~C[3] \u0026 C[4]);\n    R[0][3] = C[3] ^ (~C[4] \u0026 C[0]);\n    R[0][4] = C[4] ^ (~C[0] \u0026 C[1]);\n#endif\n\n    C[0] = ROL64(A[0][3] ^ D[3], rhotates[0][3]);\n    C[1] = ROL64(A[1][4] ^ D[4], rhotates[1][4]);\n    C[2] = ROL64(A[2][0] ^ D[0], rhotates[2][0]);\n    C[3] = ROL64(A[3][1] ^ D[1], rhotates[3][1]);\n    C[4] = ROL64(A[4][2] ^ D[2], rhotates[4][2]);\n\n#ifdef KECCAK_COMPLEMENTING_TRANSFORM\n    R[1][0] = C[0] ^ (C[1] |  C[2]);\n    R[1][1] = C[1] ^ (C[2] \u0026  C[3]);\n    R[1][2] = C[2] ^ (C[3] | ~C[4]);\n    R[1][3] = C[3] ^ (C[4] |  C[0]);\n    R[1][4] = C[4] ^ (C[0] \u0026  C[1]);\n#else\n    R[1][0] = C[0] ^ (~C[1] \u0026 C[2]);\n    R[1][1] = C[1] ^ (~C[2] \u0026 C[3]);\n    R[1][2] = C[2] ^ (~C[3] \u0026 C[4]);\n    R[1][3] = C[3] ^ (~C[4] \u0026 C[0]);\n    R[1][4] = C[4] ^ (~C[0] \u0026 C[1]);\n#endif\n\n    C[0] = ROL64(A[0][1] ^ D[1], rhotates[0][1]);\n    C[1] = ROL64(A[1][2] ^ D[2], rhotates[1][2]);\n    C[2] = ROL64(A[2][3] ^ D[3], rhotates[2][3]);\n    C[3] = ROL64(A[3][4] ^ D[4], rhotates[3][4]);\n    C[4] = ROL64(A[4][0] ^ D[0], rhotates[4][0]);\n\n#ifdef KECCAK_COMPLEMENTING_TRANSFORM\n    R[2][0] =  C[0] ^ ( C[1] | C[2]);\n    R[2][1] =  C[1] ^ ( C[2] \u0026 C[3]);\n    R[2][2] =  C[2] ^ (~C[3] \u0026 C[4]);\n    R[2][3] = ~C[3] ^ ( C[4] | C[0]);\n    R[2][4] =  C[4] ^ ( C[0] \u0026 C[1]);\n#else\n    R[2][0] = C[0] ^ (~C[1] \u0026 C[2]);\n    R[2][1] = C[1] ^ (~C[2] \u0026 C[3]);\n    R[2][2] = C[2] ^ (~C[3] \u0026 C[4]);\n    R[2][3] = C[3] ^ (~C[4] \u0026 C[0]);\n    R[2][4] = C[4] ^ (~C[0] \u0026 C[1]);\n#endif\n\n    C[0] = ROL64(A[0][4] ^ D[4], rhotates[0][4]);\n    C[1] = ROL64(A[1][0] ^ D[0], rhotates[1][0]);\n    C[2] = ROL64(A[2][1] ^ D[1], rhotates[2][1]);\n    C[3] = ROL64(A[3][2] ^ D[2], rhotates[3][2]);\n    C[4] = ROL64(A[4][3] ^ D[3], rhotates[4][3]);\n\n#ifdef KECCAK_COMPLEMENTING_TRANSFORM\n    R[3][0] =  C[0] ^ ( C[1] \u0026 C[2]);\n    R[3][1] =  C[1] ^ ( C[2] | C[3]);\n    R[3][2] =  C[2] ^ (~C[3] | C[4]);\n    R[3][3] = ~C[3] ^ ( C[4] \u0026 C[0]);\n    R[3][4] =  C[4] ^ ( C[0] | C[1]);\n#else\n    R[3][0] = C[0] ^ (~C[1] \u0026 C[2]);\n    R[3][1] = C[1] ^ (~C[2] \u0026 C[3]);\n    R[3][2] = C[2] ^ (~C[3] \u0026 C[4]);\n    R[3][3] = C[3] ^ (~C[4] \u0026 C[0]);\n    R[3][4] = C[4] ^ (~C[0] \u0026 C[1]);\n#endif\n\n    C[0] = ROL64(A[0][2] ^ D[2], rhotates[0][2]);\n    C[1] = ROL64(A[1][3] ^ D[3], rhotates[1][3]);\n    C[2] = ROL64(A[2][4] ^ D[4], rhotates[2][4]);\n    C[3] = ROL64(A[3][0] ^ D[0], rhotates[3][0]);\n    C[4] = ROL64(A[4][1] ^ D[1], rhotates[4][1]);\n\n#ifdef KECCAK_COMPLEMENTING_TRANSFORM\n    R[4][0] =  C[0] ^ (~C[1] \u0026 C[2]);\n    R[4][1] = ~C[1] ^ ( C[2] | C[3]);\n    R[4][2] =  C[2] ^ ( C[3] \u0026 C[4]);\n    R[4][3] =  C[3] ^ ( C[4] | C[0]);\n    R[4][4] =  C[4] ^ ( C[0] \u0026 C[1]);\n#else\n    R[4][0] = C[0] ^ (~C[1] \u0026 C[2]);\n    R[4][1] = C[1] ^ (~C[2] \u0026 C[3]);\n    R[4][2] = C[2] ^ (~C[3] \u0026 C[4]);\n    R[4][3] = C[3] ^ (~C[4] \u0026 C[0]);\n    R[4][4] = C[4] ^ (~C[0] \u0026 C[1]);\n#endif\n}","filepath":"openssl/crypto/sha/keccak1600.c","line_number":528,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.0"},"270481312":{"score":0.7666281,"function_name":"SHA3_absorb","code":"size_t SHA3_absorb(uint64_t A[5][5], const unsigned char *inp, size_t len,\n                   size_t r)\n{\n    uint64_t *A_flat = (uint64_t *)A;\n    size_t i, w = r / 8;\n\n    assert(r \u003c (25 * sizeof(A[0][0])) \u0026\u0026 (r % 8) == 0);\n\n    while (len \u003e= r) {\n        for (i = 0; i \u003c w; i++) {\n            uint64_t Ai = (uint64_t)inp[0]       | (uint64_t)inp[1] \u003c\u003c 8  |\n                          (uint64_t)inp[2] \u003c\u003c 16 | (uint64_t)inp[3] \u003c\u003c 24 |\n                          (uint64_t)inp[4] \u003c\u003c 32 | (uint64_t)inp[5] \u003c\u003c 40 |\n                          (uint64_t)inp[6] \u003c\u003c 48 | (uint64_t)inp[7] \u003c\u003c 56;\n            inp += 8;\n\n            A_flat[i] ^= BitInterleave(Ai);\n        }\n        KeccakF1600(A);\n        len -= r;\n    }\n\n    return len;\n}","filepath":"openssl/crypto/sha/keccak1600.c","line_number":1060,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.0"},"270481840":{"score":0.69423443,"function_name":"SHA3_squeeze","code":"void SHA3_squeeze(uint64_t A[5][5], unsigned char *out, size_t len, size_t r)\n{\n    uint64_t *A_flat = (uint64_t *)A;\n    size_t i, w = r / 8;\n\n    assert(r \u003c (25 * sizeof(A[0][0])) \u0026\u0026 (r % 8) == 0);\n\n    while (len != 0) {\n        for (i = 0; i \u003c w \u0026\u0026 len != 0; i++) {\n            uint64_t Ai = BitDeinterleave(A_flat[i]);\n\n            if (len \u003c 8) {\n                for (i = 0; i \u003c len; i++) {\n                    *out++ = (unsigned char)Ai;\n                    Ai \u003e\u003e= 8;\n                }\n                return;\n            }\n\n            out[0] = (unsigned char)(Ai);\n            out[1] = (unsigned char)(Ai \u003e\u003e 8);\n            out[2] = (unsigned char)(Ai \u003e\u003e 16);\n            out[3] = (unsigned char)(Ai \u003e\u003e 24);\n            out[4] = (unsigned char)(Ai \u003e\u003e 32);\n            out[5] = (unsigned char)(Ai \u003e\u003e 40);\n            out[6] = (unsigned char)(Ai \u003e\u003e 48);\n            out[7] = (unsigned char)(Ai \u003e\u003e 56);\n            out += 8;\n            len -= 8;\n        }\n        if (len)\n            KeccakF1600(A);\n    }\n}","filepath":"openssl/crypto/sha/keccak1600.c","line_number":1089,"entry_url":"https://github.com/ipsn/go-libtor.git","slot_name":"v1.0.0"},"270482336":{"score":0.8831809,"function_name":"MDC2_Final","code":"int MDC2_Final(unsigned char *md, MDC2_CTX *c)\n\t{\n\tint i,j;\n\n\ti=c-\u003enum;\n\tj=c-\u003epad_type;\n\tif ((i \u003e 0) || (j == 2))\n\t\t{\n\t\tif (j == 2)\n\t\t\tc-\u003edata[i++]=0x80;\n\t\tmemset(\u0026(c-\u003edata[i]),0,MDC2_BLOCK-i);\n\t\tmdc2_body(c,c-\u003edata,MDC2_BLOCK);\n\t\t}\n\tmemcpy(md,(char *)c-\u003eh,MDC2_BLOCK);\n\tmemcpy(\u0026(md[MDC2_BLOCK]),(char *)c-\u003ehh,MDC2_BLOCK);\n\treturn 1;\n\t}","filepath":"crypto/mdc2/mdc2dgst.c","line_number":163,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_0_9_7f"},"270482512":{"score":0.8697925,"function_name":"MDC2_Update","code":"int MDC2_Update(MDC2_CTX *c, const unsigned char *in, unsigned long len)\n\t{\n\tint i,j;\n\n\ti=c-\u003enum;\n\tif (i != 0)\n\t\t{\n\t\tif (i+len \u003c MDC2_BLOCK)\n\t\t\t{\n\t\t\t/* partial block */\n\t\t\tmemcpy(\u0026(c-\u003edata[i]),in,(int)len);\n\t\t\tc-\u003enum+=(int)len;\n\t\t\treturn 1;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\t/* filled one */\n\t\t\tj=MDC2_BLOCK-i;\n\t\t\tmemcpy(\u0026(c-\u003edata[i]),in,j);\n\t\t\tlen-=j;\n\t\t\tin+=j;\n\t\t\tc-\u003enum=0;\n\t\t\tmdc2_body(c,\u0026(c-\u003edata[0]),MDC2_BLOCK);\n\t\t\t}\n\t\t}\n\ti=(int)(len\u0026(unsigned long)~(MDC2_BLOCK-1));\n\tif (i \u003e 0) mdc2_body(c,in,i);\n\tj=(int)len-i;\n\tif (j \u003e 0)\n\t\t{\n\t\tmemcpy(\u0026(c-\u003edata[0]),\u0026(in[i]),j);\n\t\tc-\u003enum=j;\n\t\t}\n\treturn 1;\n\t}","filepath":"crypto/mdc2/mdc2dgst.c","line_number":89,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_0_9_7f"},"270482672":{"score":0.8920599,"function_name":"mdc2_body","code":"static void mdc2_body(MDC2_CTX *c, const unsigned char *in, unsigned int len)\n\t{\n\tregister DES_LONG tin0,tin1;\n\tregister DES_LONG ttin0,ttin1;\n\tDES_LONG d[2],dd[2];\n\tDES_key_schedule k;\n\tunsigned char *p;\n\tunsigned int i;\n\n\tfor (i=0; i\u003clen; i+=8)\n\t\t{\n\t\tc2l(in,tin0); d[0]=dd[0]=tin0;\n\t\tc2l(in,tin1); d[1]=dd[1]=tin1;\n\t\tc-\u003eh[0]=(c-\u003eh[0]\u00260x9f)|0x40;\n\t\tc-\u003ehh[0]=(c-\u003ehh[0]\u00260x9f)|0x20;\n\n\t\tDES_set_odd_parity(\u0026c-\u003eh);\n\t\tDES_set_key_unchecked(\u0026c-\u003eh,\u0026k);\n\t\tDES_encrypt1(d,\u0026k,1);\n\n\t\tDES_set_odd_parity(\u0026c-\u003ehh);\n\t\tDES_set_key_unchecked(\u0026c-\u003ehh,\u0026k);\n\t\tDES_encrypt1(dd,\u0026k,1);\n\n\t\tttin0=tin0^dd[0];\n\t\tttin1=tin1^dd[1];\n\t\ttin0^=d[0];\n\t\ttin1^=d[1];\n\n\t\tp=c-\u003eh;\n\t\tl2c(tin0,p);\n\t\tl2c(ttin1,p);\n\t\tp=c-\u003ehh;\n\t\tl2c(ttin0,p);\n\t\tl2c(tin1,p);\n\t\t}\n\t}","filepath":"crypto/mdc2/mdc2dgst.c","line_number":125,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_0_9_7f"},"270483664":{"score":0.8308941,"function_name":"WHIRLPOOL_BitUpdate","code":"void WHIRLPOOL_BitUpdate(WHIRLPOOL_CTX *c, const void *_inp, size_t bits)\n{\n    size_t n;\n    unsigned int bitoff = c-\u003ebitoff,\n        bitrem = bitoff % 8, inpgap = (8 - (unsigned int)bits % 8) \u0026 7;\n    const unsigned char *inp = _inp;\n\n    /*\n     * This 256-bit increment procedure relies on the size_t being natural\n     * size of CPU register, so that we don't have to mask the value in order\n     * to detect overflows.\n     */\n    c-\u003ebitlen[0] += bits;\n    if (c-\u003ebitlen[0] \u003c bits) {  /* overflow */\n        n = 1;\n        do {\n            c-\u003ebitlen[n]++;\n        } while (c-\u003ebitlen[n] == 0\n                 \u0026\u0026 ++n \u003c (WHIRLPOOL_COUNTER / sizeof(size_t)));\n    }\n#ifndef OPENSSL_SMALL_FOOTPRINT\n reconsider:\n    if (inpgap == 0 \u0026\u0026 bitrem == 0) { /* byte-oriented loop */\n        while (bits) {\n            if (bitoff == 0 \u0026\u0026 (n = bits / WHIRLPOOL_BBLOCK)) {\n                whirlpool_block(c, inp, n);\n                inp += n * WHIRLPOOL_BBLOCK / 8;\n                bits %= WHIRLPOOL_BBLOCK;\n            } else {\n                unsigned int byteoff = bitoff / 8;\n\n                bitrem = WHIRLPOOL_BBLOCK - bitoff; /* re-use bitrem */\n                if (bits \u003e= bitrem) {\n                    bits -= bitrem;\n                    bitrem /= 8;\n                    memcpy(c-\u003edata + byteoff, inp, bitrem);\n                    inp += bitrem;\n                    whirlpool_block(c, c-\u003edata, 1);\n                    bitoff = 0;\n                } else {\n                    memcpy(c-\u003edata + byteoff, inp, bits / 8);\n                    bitoff += (unsigned int)bits;\n                    bits = 0;\n                }\n                c-\u003ebitoff = bitoff;\n            }\n        }\n    } else                      /* bit-oriented loop */\n#endif\n    {\n        /*-\n                   inp\n                   |\n                   +-------+-------+-------\n                      |||||||||||||||||||||\n                   +-------+-------+-------\n        +-------+-------+-------+-------+-------\n        ||||||||||||||                          c-\u003edata\n        +-------+-------+-------+-------+-------\n                |\n                c-\u003ebitoff/8\n        */\n        while (bits) {\n            unsigned int byteoff = bitoff / 8;\n            unsigned char b;\n\n#ifndef OPENSSL_SMALL_FOOTPRINT\n            if (bitrem == inpgap) {\n                c-\u003edata[byteoff++] |= inp[0] \u0026 (0xff \u003e\u003e inpgap);\n                inpgap = 8 - inpgap;\n                bitoff += inpgap;\n                bitrem = 0;     /* bitoff%8 */\n                bits -= inpgap;\n                inpgap = 0;     /* bits%8 */\n                inp++;\n                if (bitoff == WHIRLPOOL_BBLOCK) {\n                    whirlpool_block(c, c-\u003edata, 1);\n                    bitoff = 0;\n                }\n                c-\u003ebitoff = bitoff;\n                goto reconsider;\n            } else\n#endif\n            if (bits \u003e= 8) {\n                b = ((inp[0] \u003c\u003c inpgap) | (inp[1] \u003e\u003e (8 - inpgap)));\n                b \u0026= 0xff;\n                if (bitrem)\n                    c-\u003edata[byteoff++] |= b \u003e\u003e bitrem;\n                else\n                    c-\u003edata[byteoff++] = b;\n                bitoff += 8;\n                bits -= 8;\n                inp++;\n                if (bitoff \u003e= WHIRLPOOL_BBLOCK) {\n                    whirlpool_block(c, c-\u003edata, 1);\n                    byteoff = 0;\n                    bitoff %= WHIRLPOOL_BBLOCK;\n                }\n                if (bitrem)\n                    c-\u003edata[byteoff] = b \u003c\u003c (8 - bitrem);\n            } else {            /* remaining less than 8 bits */\n\n                b = (inp[0] \u003c\u003c inpgap) \u0026 0xff;\n                if (bitrem)\n                    c-\u003edata[byteoff++] |= b \u003e\u003e bitrem;\n                else\n                    c-\u003edata[byteoff++] = b;\n                bitoff += (unsigned int)bits;\n                if (bitoff == WHIRLPOOL_BBLOCK) {\n                    whirlpool_block(c, c-\u003edata, 1);\n                    byteoff = 0;\n                    bitoff %= WHIRLPOOL_BBLOCK;\n                }\n                if (bitrem)\n                    c-\u003edata[byteoff] = b \u003c\u003c (8 - bitrem);\n                bits = 0;\n            }\n            c-\u003ebitoff = bitoff;\n        }\n    }\n}","filepath":"crypto/whrlpool/wp_dgst.c","line_number":85,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_0_2-post-reformat"},"270484352":{"score":0.8904353,"function_name":"WHIRLPOOL_Final","code":"int WHIRLPOOL_Final(unsigned char *md, WHIRLPOOL_CTX *c)\n{\n    unsigned int bitoff = c-\u003ebitoff, byteoff = bitoff / 8;\n    size_t i, j, v;\n    unsigned char *p;\n\n    bitoff %= 8;\n    if (bitoff)\n        c-\u003edata[byteoff] |= 0x80 \u003e\u003e bitoff;\n    else\n        c-\u003edata[byteoff] = 0x80;\n    byteoff++;\n\n    /* pad with zeros */\n    if (byteoff \u003e (WHIRLPOOL_BBLOCK / 8 - WHIRLPOOL_COUNTER)) {\n        if (byteoff \u003c WHIRLPOOL_BBLOCK / 8)\n            memset(\u0026c-\u003edata[byteoff], 0, WHIRLPOOL_BBLOCK / 8 - byteoff);\n        whirlpool_block(c, c-\u003edata, 1);\n        byteoff = 0;\n    }\n    if (byteoff \u003c (WHIRLPOOL_BBLOCK / 8 - WHIRLPOOL_COUNTER))\n        memset(\u0026c-\u003edata[byteoff], 0,\n               (WHIRLPOOL_BBLOCK / 8 - WHIRLPOOL_COUNTER) - byteoff);\n    /* smash 256-bit c-\u003ebitlen in big-endian order */\n    p = \u0026c-\u003edata[WHIRLPOOL_BBLOCK / 8 - 1]; /* last byte in c-\u003edata */\n    for (i = 0; i \u003c WHIRLPOOL_COUNTER / sizeof(size_t); i++)\n        for (v = c-\u003ebitlen[i], j = 0; j \u003c sizeof(size_t); j++, v \u003e\u003e= 8)\n            *p-- = (unsigned char)(v \u0026 0xff);\n\n    whirlpool_block(c, c-\u003edata, 1);\n\n    if (md) {\n        memcpy(md, c-\u003eH.c, WHIRLPOOL_DIGEST_LENGTH);\n        memset(c, 0, sizeof(*c));\n        return (1);\n    }\n    return (0);\n}","filepath":"crypto/whrlpool/wp_dgst.c","line_number":207,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_0_2-post-reformat"},"270484640":{"score":0.76099944,"function_name":"WHIRLPOOL_Update","code":"int WHIRLPOOL_Update(WHIRLPOOL_CTX *c, const void *_inp, size_t bytes)\n{\n    /*\n     * Well, largest suitable chunk size actually is\n     * (1\u003c\u003c(sizeof(size_t)*8-3))-64, but below number is large enough for not\n     * to care about excessive calls to WHIRLPOOL_BitUpdate...\n     */\n    size_t chunk = ((size_t)1) \u003c\u003c (sizeof(size_t) * 8 - 4);\n    const unsigned char *inp = _inp;\n\n    while (bytes \u003e= chunk) {\n        WHIRLPOOL_BitUpdate(c, inp, chunk * 8);\n        bytes -= chunk;\n        inp += chunk;\n    }\n    if (bytes)\n        WHIRLPOOL_BitUpdate(c, inp, bytes * 8);\n\n    return (1);\n}","filepath":"crypto/whrlpool/wp_dgst.c","line_number":64,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_0_2-post-reformat"},"270494160":{"score":0.92335844,"function_name":"_CONF_add_string","code":"int _CONF_add_string(CONF *conf, CONF_VALUE *section, CONF_VALUE *value)\n{\n    CONF_VALUE *v = NULL;\n    STACK_OF(CONF_VALUE) *ts;\n\n    ts = (STACK_OF(CONF_VALUE) *)section-\u003evalue;\n\n    value-\u003esection = section-\u003esection;\n    if (!sk_CONF_VALUE_push(ts, value))\n        return 0;\n\n    v = lh_CONF_VALUE_insert(conf-\u003edata, value);\n    if (v != NULL) {\n        (void)sk_CONF_VALUE_delete_ptr(ts, v);\n        OPENSSL_free(v-\u003ename);\n        OPENSSL_free(v-\u003evalue);\n        OPENSSL_free(v);\n    }\n    return 1;\n}","filepath":"crypto/conf/conf_api.c","line_number":44,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha7"},"270494288":{"score":0.8662826,"function_name":"_CONF_free_data","code":"void _CONF_free_data(CONF *conf)\n{\n    if (conf == NULL || conf-\u003edata == NULL)\n        return;\n\n    /* evil thing to make sure the 'OPENSSL_free()' works as expected */\n    lh_CONF_VALUE_set_down_load(conf-\u003edata, 0);\n    lh_CONF_VALUE_doall_LH_CONF_VALUE(conf-\u003edata, value_free_hash, conf-\u003edata);\n\n    /*\n     * We now have only 'section' entries in the hash table. Due to problems\n     * with\n     */\n\n    lh_CONF_VALUE_doall(conf-\u003edata, value_free_stack_doall);\n    lh_CONF_VALUE_free(conf-\u003edata);\n}","filepath":"crypto/conf/conf_api.c","line_number":133,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha7"},"270494368":{"score":0.9242198,"function_name":"_CONF_get_section","code":"CONF_VALUE *_CONF_get_section(const CONF *conf, const char *section)\n{\n    CONF_VALUE vv;\n\n    if (conf == NULL || section == NULL)\n        return NULL;\n    vv.name = NULL;\n    vv.section = (char *)section;\n    return lh_CONF_VALUE_retrieve(conf-\u003edata, \u0026vv);\n}","filepath":"crypto/conf/conf_api.c","line_number":22,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha7"},"270494512":{"score":0.77045697,"function_name":"_CONF_get_string","code":"char *_CONF_get_string(const CONF *conf, const char *section,\n                       const char *name)\n{\n    CONF_VALUE *v, vv;\n    char *p;\n\n    if (name == NULL)\n        return NULL;\n    if (conf == NULL)\n        return ossl_safe_getenv(name);\n    if (section != NULL) {\n        vv.name = (char *)name;\n        vv.section = (char *)section;\n        v = lh_CONF_VALUE_retrieve(conf-\u003edata, \u0026vv);\n        if (v != NULL)\n            return v-\u003evalue;\n        if (strcmp(section, \"ENV\") == 0) {\n            p = ossl_safe_getenv(name);\n            if (p != NULL)\n                return p;\n        }\n    }\n    vv.section = \"default\";\n    vv.name = (char *)name;\n    v = lh_CONF_VALUE_retrieve(conf-\u003edata, \u0026vv);\n    if (v == NULL)\n        return NULL;\n    return v-\u003evalue;\n}","filepath":"crypto/conf/conf_api.c","line_number":65,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha7"},"270494720":{"score":0.8941929,"function_name":"_CONF_new_data","code":"int _CONF_new_data(CONF *conf)\n{\n    if (conf == NULL)\n        return 0;\n    if (conf-\u003edata == NULL) {\n        conf-\u003edata = lh_CONF_VALUE_new(conf_value_hash, conf_value_cmp);\n        if (conf-\u003edata == NULL)\n            return 0;\n    }\n    return 1;\n}","filepath":"crypto/conf/conf_api.c","line_number":117,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha7"},"270494784":{"score":0.9127502,"function_name":"_CONF_new_section","code":"CONF_VALUE *_CONF_new_section(CONF *conf, const char *section)\n{\n    STACK_OF(CONF_VALUE) *sk = NULL;\n    int i;\n    CONF_VALUE *v = NULL, *vv;\n\n    if ((sk = sk_CONF_VALUE_new_null()) == NULL)\n        goto err;\n    if ((v = OPENSSL_malloc(sizeof(*v))) == NULL)\n        goto err;\n    i = strlen(section) + 1;\n    if ((v-\u003esection = OPENSSL_malloc(i)) == NULL)\n        goto err;\n\n    memcpy(v-\u003esection, section, i);\n    v-\u003ename = NULL;\n    v-\u003evalue = (char *)sk;\n\n    vv = lh_CONF_VALUE_insert(conf-\u003edata, v);\n    if (vv != NULL || lh_CONF_VALUE_error(conf-\u003edata) \u003e 0)\n        goto err;\n    return v;\n\n err:\n    sk_CONF_VALUE_free(sk);\n    if (v != NULL)\n        OPENSSL_free(v-\u003esection);\n    OPENSSL_free(v);\n    return NULL;\n}","filepath":"crypto/conf/conf_api.c","line_number":178,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"openssl-3.0.0-alpha7"},"270496064":{"score":0.88081074,"function_name":"win32_name_converter","code":"static char *win32_name_converter(DSO *dso, const char *filename)\n\t{\n\tchar *translated;\n\tint len, transform;\n\n\tlen = strlen(filename);\n\ttransform = ((strstr(filename, \"/\") == NULL) \u0026\u0026\n\t\t\t(strstr(filename, \"\\\\\") == NULL) \u0026\u0026\n\t\t\t(strstr(filename, \":\") == NULL));\n\tif(transform)\n\t\t/* We will convert this to \"%s.dll\" */\n\t\ttranslated = OPENSSL_malloc(len + 5);\n\telse\n\t\t/* We will simply duplicate filename */\n\t\ttranslated = OPENSSL_malloc(len + 1);\n\tif(translated == NULL)\n\t\t{\n\t\tDSOerr(DSO_F_WIN32_NAME_CONVERTER,\n\t\t\t\tDSO_R_NAME_TRANSLATION_FAILED); \n\t\treturn(NULL);   \n\t\t}\n\tif(transform)\n\t\tsprintf(translated, \"%s.dll\", filename);\n\telse\n\t\tsprintf(translated, \"%s\", filename);\n\treturn(translated);\n\t}","filepath":"crypto/dso/dso_win32.c","line_number":630,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_0_0-beta3"},"270497168":{"score":0.7577601,"function_name":"win32_globallookup","code":"static void *win32_globallookup(const char *name)\n\t{\n\tHMODULE dll;\n\tHANDLE hModuleSnap = INVALID_HANDLE_VALUE;\n\tMODULEENTRY32 me32;\n\tCREATETOOLHELP32SNAPSHOT create_snap;\n\tCLOSETOOLHELP32SNAPSHOT  close_snap;\n\tMODULE32 module_first, module_next;\n\tFARPROC ret=NULL;\n\n\tdll = LoadLibrary(TEXT(DLLNAME));\n\tif (dll == NULL)\n\t\t{\n\t\tDSOerr(DSO_F_WIN32_GLOBALLOOKUP,DSO_R_UNSUPPORTED);\n\t\treturn NULL;\n\t\t}\n\n\tcreate_snap = (CREATETOOLHELP32SNAPSHOT)\n\t\tGetProcAddress(dll,\"CreateToolhelp32Snapshot\");\n\tif (create_snap == NULL)\n\t\t{\n\t\tFreeLibrary(dll);\n\t\tDSOerr(DSO_F_WIN32_GLOBALLOOKUP,DSO_R_UNSUPPORTED);\n\t\treturn NULL;\n\t\t}\n\t/* We take the rest for granted... */\n#ifdef _WIN32_WCE\n\tclose_snap = (CLOSETOOLHELP32SNAPSHOT)\n\t\tGetProcAddress(dll,\"CloseToolhelp32Snapshot\");\n#else\n\tclose_snap = (CLOSETOOLHELP32SNAPSHOT)CloseHandle;\n#endif\n\tmodule_first = (MODULE32)GetProcAddress(dll,\"Module32First\");\n\tmodule_next  = (MODULE32)GetProcAddress(dll,\"Module32Next\");\n\n\thModuleSnap = (*create_snap)(TH32CS_SNAPMODULE,0);\n\tif( hModuleSnap == INVALID_HANDLE_VALUE )\n\t\t{\n\t\tFreeLibrary(dll);\n\t\tDSOerr(DSO_F_WIN32_GLOBALLOOKUP,DSO_R_UNSUPPORTED);\n\t\treturn NULL;\n\t\t}\n\n\tme32.dwSize = sizeof(me32);\n\n\tif (!(*module_first)(hModuleSnap,\u0026me32))\n\t\t{\n\t\t(*close_snap)(hModuleSnap);\n\t\tFreeLibrary(dll);\n\t\treturn NULL;\n\t\t}\n\n\tdo\t{\n\t\tif ((ret = GetProcAddress(me32.hModule,name)))\n\t\t\t{\n\t\t\t(*close_snap)(hModuleSnap);\n\t\t\tFreeLibrary(dll);\n\t\t\treturn ret;\n\t\t\t}\n\t\t} while((*module_next)(hModuleSnap,\u0026me32));\n\n\t(*close_snap)(hModuleSnap); \n\tFreeLibrary(dll);\n\treturn NULL;\n\t}","filepath":"crypto/dso/dso_win32.c","line_number":779,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_0_0-beta3"},"270497520":{"score":0.90508574,"function_name":"win32_joiner","code":"static char *win32_joiner(DSO *dso, const struct file_st *file_split)\n\t{\n\tint len = 0, offset = 0;\n\tchar *result = NULL;\n\tconst char *start;\n\n\tif(!file_split)\n\t\t{\n\t\tDSOerr(DSO_F_WIN32_JOINER,\n\t\t\t\tERR_R_PASSED_NULL_PARAMETER);\n\t\treturn(NULL);\n\t\t}\n\tif(file_split-\u003enode)\n\t\t{\n\t\tlen += 2 + file_split-\u003enodelen;\t/* 2 for starting \\\\ */\n\t\tif(file_split-\u003epredir || file_split-\u003edir || file_split-\u003efile)\n\t\t\tlen++;\t/* 1 for ending \\ */\n\t\t}\n\telse if(file_split-\u003edevice)\n\t\t{\n\t\tlen += file_split-\u003edevicelen + 1; /* 1 for ending : */\n\t\t}\n\tlen += file_split-\u003epredirlen;\n\tif(file_split-\u003epredir \u0026\u0026 (file_split-\u003edir || file_split-\u003efile))\n\t\t{\n\t\tlen++;\t/* 1 for ending \\ */\n\t\t}\n\tlen += file_split-\u003edirlen;\n\tif(file_split-\u003edir \u0026\u0026 file_split-\u003efile)\n\t\t{\n\t\tlen++;\t/* 1 for ending \\ */\n\t\t}\n\tlen += file_split-\u003efilelen;\n\n\tif(!len)\n\t\t{\n\t\tDSOerr(DSO_F_WIN32_JOINER, DSO_R_EMPTY_FILE_STRUCTURE);\n\t\treturn(NULL);\n\t\t}\n\n\tresult = OPENSSL_malloc(len + 1);\n\tif (!result)\n\t\t{\n\t\tDSOerr(DSO_F_WIN32_JOINER,\n\t\t\tERR_R_MALLOC_FAILURE);\n\t\treturn(NULL);\n\t\t}\n\n\tif(file_split-\u003enode)\n\t\t{\n\t\tstrcpy(\u0026result[offset], \"\\\\\\\\\"); offset += 2;\n\t\tstrncpy(\u0026result[offset], file_split-\u003enode,\n\t\t\tfile_split-\u003enodelen); offset += file_split-\u003enodelen;\n\t\tif(file_split-\u003epredir || file_split-\u003edir || file_split-\u003efile)\n\t\t\t{\n\t\t\tresult[offset] = '\\\\'; offset++;\n\t\t\t}\n\t\t}\n\telse if(file_split-\u003edevice)\n\t\t{\n\t\tstrncpy(\u0026result[offset], file_split-\u003edevice,\n\t\t\tfile_split-\u003edevicelen); offset += file_split-\u003edevicelen;\n\t\tresult[offset] = ':'; offset++;\n\t\t}\n\tstart = file_split-\u003epredir;\n\twhile(file_split-\u003epredirlen \u003e (start - file_split-\u003epredir))\n\t\t{\n\t\tconst char *end = openssl_strnchr(start, '/',\n\t\t\tfile_split-\u003epredirlen - (start - file_split-\u003epredir));\n\t\tif(!end)\n\t\t\tend = start\n\t\t\t\t+ file_split-\u003epredirlen\n\t\t\t\t- (start - file_split-\u003epredir);\n\t\tstrncpy(\u0026result[offset], start,\n\t\t\tend - start); offset += (int)(end - start);\n\t\tresult[offset] = '\\\\'; offset++;\n\t\tstart = end + 1;\n\t\t}\n#if 0 /* Not needed, since the directory converter above already appeneded\n\t a backslash */\n\tif(file_split-\u003epredir \u0026\u0026 (file_split-\u003edir || file_split-\u003efile))\n\t\t{\n\t\tresult[offset] = '\\\\'; offset++;\n\t\t}\n#endif\n\tstart = file_split-\u003edir;\n\twhile(file_split-\u003edirlen \u003e (start - file_split-\u003edir))\n\t\t{\n\t\tconst char *end = openssl_strnchr(start, '/',\n\t\t\tfile_split-\u003edirlen - (start - file_split-\u003edir));\n\t\tif(!end)\n\t\t\tend = start\n\t\t\t\t+ file_split-\u003edirlen\n\t\t\t\t- (start - file_split-\u003edir);\n\t\tstrncpy(\u0026result[offset], start,\n\t\t\tend - start); offset += (int)(end - start);\n\t\tresult[offset] = '\\\\'; offset++;\n\t\tstart = end + 1;\n\t\t}\n#if 0 /* Not needed, since the directory converter above already appeneded\n\t a backslash */\n\tif(file_split-\u003edir \u0026\u0026 file_split-\u003efile)\n\t\t{\n\t\tresult[offset] = '\\\\'; offset++;\n\t\t}\n#endif\n\tstrncpy(\u0026result[offset], file_split-\u003efile,\n\t\tfile_split-\u003efilelen); offset += file_split-\u003efilelen;\n\tresult[offset] = '\\0';\n\treturn(result);\n\t}","filepath":"crypto/dso/dso_win32.c","line_number":434,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_0_0-beta3"},"270498672":{"score":0.91780776,"function_name":"buffer_write","code":"static int buffer_write(BIO *b, const char *in, int inl)\n{\n    int i, num = 0;\n    BIO_F_BUFFER_CTX *ctx;\n\n    if ((in == NULL) || (inl \u003c= 0))\n        return 0;\n    ctx = (BIO_F_BUFFER_CTX *)b-\u003eptr;\n    if ((ctx == NULL) || (b-\u003enext_bio == NULL))\n        return 0;\n\n    BIO_clear_retry_flags(b);\n start:\n    i = ctx-\u003eobuf_size - (ctx-\u003eobuf_len + ctx-\u003eobuf_off);\n    /* add to buffer and return */\n    if (i \u003e= inl) {\n        memcpy(\u0026(ctx-\u003eobuf[ctx-\u003eobuf_off + ctx-\u003eobuf_len]), in, inl);\n        ctx-\u003eobuf_len += inl;\n        return (num + inl);\n    }\n    /* else */\n    /* stuff already in buffer, so add to it first, then flush */\n    if (ctx-\u003eobuf_len != 0) {\n        if (i \u003e 0) {            /* lets fill it up if we can */\n            memcpy(\u0026(ctx-\u003eobuf[ctx-\u003eobuf_off + ctx-\u003eobuf_len]), in, i);\n            in += i;\n            inl -= i;\n            num += i;\n            ctx-\u003eobuf_len += i;\n        }\n        /* we now have a full buffer needing flushing */\n        for (;;) {\n            i = BIO_write(b-\u003enext_bio, \u0026(ctx-\u003eobuf[ctx-\u003eobuf_off]),\n                          ctx-\u003eobuf_len);\n            if (i \u003c= 0) {\n                BIO_copy_next_retry(b);\n\n                if (i \u003c 0)\n                    return ((num \u003e 0) ? num : i);\n                if (i == 0)\n                    return num;\n            }\n            ctx-\u003eobuf_off += i;\n            ctx-\u003eobuf_len -= i;\n            if (ctx-\u003eobuf_len == 0)\n                break;\n        }\n    }\n    /*\n     * we only get here if the buffer has been flushed and we still have\n     * stuff to write\n     */\n    ctx-\u003eobuf_off = 0;\n\n    /* we now have inl bytes to write */\n    while (inl \u003e= ctx-\u003eobuf_size) {\n        i = BIO_write(b-\u003enext_bio, in, inl);\n        if (i \u003c= 0) {\n            BIO_copy_next_retry(b);\n            if (i \u003c 0)\n                return ((num \u003e 0) ? num : i);\n            if (i == 0)\n                return num;\n        }\n        num += i;\n        in += i;\n        inl -= i;\n        if (inl == 0)\n            return num;\n    }\n\n    /*\n     * copy the rest into the buffer since we have only a small amount left\n     */\n    goto start;\n}","filepath":"libs-ext/openssl/crypto/bio/bf_buff.c","line_number":160,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"270499072":{"score":0.87020373,"function_name":"buffer_read","code":"static int buffer_read(BIO *b, char *out, int outl)\n{\n    int i, num = 0;\n    BIO_F_BUFFER_CTX *ctx;\n\n    if (out == NULL)\n        return 0;\n    ctx = (BIO_F_BUFFER_CTX *)b-\u003eptr;\n\n    if ((ctx == NULL) || (b-\u003enext_bio == NULL))\n        return 0;\n    num = 0;\n    BIO_clear_retry_flags(b);\n\n start:\n    i = ctx-\u003eibuf_len;\n    /* If there is stuff left over, grab it */\n    if (i != 0) {\n        if (i \u003e outl)\n            i = outl;\n        memcpy(out, \u0026(ctx-\u003eibuf[ctx-\u003eibuf_off]), i);\n        ctx-\u003eibuf_off += i;\n        ctx-\u003eibuf_len -= i;\n        num += i;\n        if (outl == i)\n            return num;\n        outl -= i;\n        out += i;\n    }\n\n    /*\n     * We may have done a partial read. try to do more. We have nothing in\n     * the buffer. If we get an error and have read some data, just return it\n     * and let them retry to get the error again. copy direct to parent\n     * address space\n     */\n    if (outl \u003e ctx-\u003eibuf_size) {\n        for (;;) {\n            i = BIO_read(b-\u003enext_bio, out, outl);\n            if (i \u003c= 0) {\n                BIO_copy_next_retry(b);\n                if (i \u003c 0)\n                    return ((num \u003e 0) ? num : i);\n                if (i == 0)\n                    return num;\n            }\n            num += i;\n            if (outl == i)\n                return num;\n            out += i;\n            outl -= i;\n        }\n    }\n    /* else */\n\n    /* we are going to be doing some buffering */\n    i = BIO_read(b-\u003enext_bio, ctx-\u003eibuf, ctx-\u003eibuf_size);\n    if (i \u003c= 0) {\n        BIO_copy_next_retry(b);\n        if (i \u003c 0)\n            return ((num \u003e 0) ? num : i);\n        if (i == 0)\n            return num;\n    }\n    ctx-\u003eibuf_off = 0;\n    ctx-\u003eibuf_len = i;\n\n    /* Lets re-read using ourselves :-) */\n    goto start;\n}","filepath":"libs-ext/openssl/crypto/bio/bf_buff.c","line_number":89,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"270499440":{"score":0.91383857,"function_name":"buffer_gets","code":"static int buffer_gets(BIO *b, char *buf, int size)\n{\n    BIO_F_BUFFER_CTX *ctx;\n    int num = 0, i, flag;\n    char *p;\n\n    ctx = (BIO_F_BUFFER_CTX *)b-\u003eptr;\n    size--;                     /* reserve space for a '\\0' */\n    BIO_clear_retry_flags(b);\n\n    for (;;) {\n        if (ctx-\u003eibuf_len \u003e 0) {\n            p = \u0026(ctx-\u003eibuf[ctx-\u003eibuf_off]);\n            flag = 0;\n            for (i = 0; (i \u003c ctx-\u003eibuf_len) \u0026\u0026 (i \u003c size); i++) {\n                *(buf++) = p[i];\n                if (p[i] == '\\n') {\n                    flag = 1;\n                    i++;\n                    break;\n                }\n            }\n            num += i;\n            size -= i;\n            ctx-\u003eibuf_len -= i;\n            ctx-\u003eibuf_off += i;\n            if (flag || size == 0) {\n                *buf = '\\0';\n                return num;\n            }\n        } else {                /* read another chunk */\n\n            i = BIO_read(b-\u003enext_bio, ctx-\u003eibuf, ctx-\u003eibuf_size);\n            if (i \u003c= 0) {\n                BIO_copy_next_retry(b);\n                *buf = '\\0';\n                if (i \u003c 0)\n                    return ((num \u003e 0) ? num : i);\n                if (i == 0)\n                    return num;\n            }\n            ctx-\u003eibuf_len = i;\n            ctx-\u003eibuf_off = 0;\n        }\n    }\n}","filepath":"libs-ext/openssl/crypto/bio/bf_buff.c","line_number":425,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"270499696":{"score":0.8916948,"function_name":"buffer_ctrl","code":"static long buffer_ctrl(BIO *b, int cmd, long num, void *ptr)\n{\n    BIO *dbio;\n    BIO_F_BUFFER_CTX *ctx;\n    long ret = 1;\n    char *p1, *p2;\n    int r, i, *ip;\n    int ibs, obs;\n\n    ctx = (BIO_F_BUFFER_CTX *)b-\u003eptr;\n\n    switch (cmd) {\n    case BIO_CTRL_RESET:\n        ctx-\u003eibuf_off = 0;\n        ctx-\u003eibuf_len = 0;\n        ctx-\u003eobuf_off = 0;\n        ctx-\u003eobuf_len = 0;\n        if (b-\u003enext_bio == NULL)\n            return 0;\n        ret = BIO_ctrl(b-\u003enext_bio, cmd, num, ptr);\n        break;\n    case BIO_CTRL_EOF:\n        if (ctx-\u003eibuf_len \u003e 0)\n            return 0;\n        ret = BIO_ctrl(b-\u003enext_bio, cmd, num, ptr);\n        break;\n    case BIO_CTRL_INFO:\n        ret = (long)ctx-\u003eobuf_len;\n        break;\n    case BIO_C_GET_BUFF_NUM_LINES:\n        ret = 0;\n        p1 = ctx-\u003eibuf;\n        for (i = 0; i \u003c ctx-\u003eibuf_len; i++) {\n            if (p1[ctx-\u003eibuf_off + i] == '\\n')\n                ret++;\n        }\n        break;\n    case BIO_CTRL_WPENDING:\n        ret = (long)ctx-\u003eobuf_len;\n        if (ret == 0) {\n            if (b-\u003enext_bio == NULL)\n                return 0;\n            ret = BIO_ctrl(b-\u003enext_bio, cmd, num, ptr);\n        }\n        break;\n    case BIO_CTRL_PENDING:\n        ret = (long)ctx-\u003eibuf_len;\n        if (ret == 0) {\n            if (b-\u003enext_bio == NULL)\n                return 0;\n            ret = BIO_ctrl(b-\u003enext_bio, cmd, num, ptr);\n        }\n        break;\n    case BIO_C_SET_BUFF_READ_DATA:\n        if (num \u003e ctx-\u003eibuf_size) {\n            p1 = OPENSSL_malloc((int)num);\n            if (p1 == NULL)\n                goto malloc_error;\n            OPENSSL_free(ctx-\u003eibuf);\n            ctx-\u003eibuf = p1;\n        }\n        ctx-\u003eibuf_off = 0;\n        ctx-\u003eibuf_len = (int)num;\n        memcpy(ctx-\u003eibuf, ptr, (int)num);\n        ret = 1;\n        break;\n    case BIO_C_SET_BUFF_SIZE:\n        if (ptr != NULL) {\n            ip = (int *)ptr;\n            if (*ip == 0) {\n                ibs = (int)num;\n                obs = ctx-\u003eobuf_size;\n            } else {            /* if (*ip == 1) */\n\n                ibs = ctx-\u003eibuf_size;\n                obs = (int)num;\n            }\n        } else {\n            ibs = (int)num;\n            obs = (int)num;\n        }\n        p1 = ctx-\u003eibuf;\n        p2 = ctx-\u003eobuf;\n        if ((ibs \u003e DEFAULT_BUFFER_SIZE) \u0026\u0026 (ibs != ctx-\u003eibuf_size)) {\n            p1 = OPENSSL_malloc((int)num);\n            if (p1 == NULL)\n                goto malloc_error;\n        }\n        if ((obs \u003e DEFAULT_BUFFER_SIZE) \u0026\u0026 (obs != ctx-\u003eobuf_size)) {\n            p2 = OPENSSL_malloc((int)num);\n            if (p2 == NULL) {\n                if (p1 != ctx-\u003eibuf)\n                    OPENSSL_free(p1);\n                goto malloc_error;\n            }\n        }\n        if (ctx-\u003eibuf != p1) {\n            OPENSSL_free(ctx-\u003eibuf);\n            ctx-\u003eibuf = p1;\n            ctx-\u003eibuf_off = 0;\n            ctx-\u003eibuf_len = 0;\n            ctx-\u003eibuf_size = ibs;\n        }\n        if (ctx-\u003eobuf != p2) {\n            OPENSSL_free(ctx-\u003eobuf);\n            ctx-\u003eobuf = p2;\n            ctx-\u003eobuf_off = 0;\n            ctx-\u003eobuf_len = 0;\n            ctx-\u003eobuf_size = obs;\n        }\n        break;\n    case BIO_C_DO_STATE_MACHINE:\n        if (b-\u003enext_bio == NULL)\n            return 0;\n        BIO_clear_retry_flags(b);\n        ret = BIO_ctrl(b-\u003enext_bio, cmd, num, ptr);\n        BIO_copy_next_retry(b);\n        break;\n\n    case BIO_CTRL_FLUSH:\n        if (b-\u003enext_bio == NULL)\n            return 0;\n        if (ctx-\u003eobuf_len \u003c= 0) {\n            ret = BIO_ctrl(b-\u003enext_bio, cmd, num, ptr);\n            break;\n        }\n\n        for (;;) {\n            BIO_clear_retry_flags(b);\n            if (ctx-\u003eobuf_len \u003e 0) {\n                r = BIO_write(b-\u003enext_bio,\n                              \u0026(ctx-\u003eobuf[ctx-\u003eobuf_off]), ctx-\u003eobuf_len);\n                BIO_copy_next_retry(b);\n                if (r \u003c= 0)\n                    return (long)r;\n                ctx-\u003eobuf_off += r;\n                ctx-\u003eobuf_len -= r;\n            } else {\n                ctx-\u003eobuf_len = 0;\n                ctx-\u003eobuf_off = 0;\n                break;\n            }\n        }\n        ret = BIO_ctrl(b-\u003enext_bio, cmd, num, ptr);\n        break;\n    case BIO_CTRL_DUP:\n        dbio = (BIO *)ptr;\n        if (!BIO_set_read_buffer_size(dbio, ctx-\u003eibuf_size) ||\n            !BIO_set_write_buffer_size(dbio, ctx-\u003eobuf_size))\n            ret = 0;\n        break;\n    case BIO_CTRL_PEEK:\n        /* Ensure there's stuff in the input buffer */\n        {\n            char fake_buf[1];\n            (void)buffer_read(b, fake_buf, 0);\n        }\n        if (num \u003e ctx-\u003eibuf_len)\n            num = ctx-\u003eibuf_len;\n        memcpy(ptr, \u0026(ctx-\u003eibuf[ctx-\u003eibuf_off]), num);\n        ret = num;\n        break;\n    default:\n        if (b-\u003enext_bio == NULL)\n            return 0;\n        ret = BIO_ctrl(b-\u003enext_bio, cmd, num, ptr);\n        break;\n    }\n    return ret;\n malloc_error:\n    BIOerr(BIO_F_BUFFER_CTRL, ERR_R_MALLOC_FAILURE);\n    return 0;\n}","filepath":"libs-ext/openssl/crypto/bio/bf_buff.c","line_number":237,"entry_url":"https://github.com/FriendUPCloud/friendup.git","slot_name":"release"},"270505456":{"score":0.8059049,"function_name":"CMS_dataFinal","code":"int CMS_dataFinal(CMS_ContentInfo *cms, BIO *cmsbio)\n{\n    ASN1_OCTET_STRING **pos = CMS_get0_content(cms);\n    if (!pos)\n        return 0;\n    /* If embedded content find memory BIO and set content */\n    if (*pos \u0026\u0026 ((*pos)-\u003eflags \u0026 ASN1_STRING_FLAG_CONT)) {\n        BIO *mbio;\n        unsigned char *cont;\n        long contlen;\n        mbio = BIO_find_type(cmsbio, BIO_TYPE_MEM);\n        if (!mbio) {\n            CMSerr(CMS_F_CMS_DATAFINAL, CMS_R_CONTENT_NOT_FOUND);\n            return 0;\n        }\n        contlen = BIO_get_mem_data(mbio, \u0026cont);\n        /* Set bio as read only so its content can't be clobbered */\n        BIO_set_flags(mbio, BIO_FLAGS_MEM_RDONLY);\n        BIO_set_mem_eof_return(mbio, 0);\n        ASN1_STRING_set0(*pos, cont, contlen);\n        (*pos)-\u003eflags \u0026= ~ASN1_STRING_FLAG_CONT;\n    }\n\n    switch (OBJ_obj2nid(cms-\u003econtentType)) {\n\n    case NID_pkcs7_data:\n    case NID_pkcs7_enveloped:\n    case NID_pkcs7_encrypted:\n    case NID_id_smime_ct_compressedData:\n        /* Nothing to do */\n        return 1;\n\n    case NID_pkcs7_signed:\n        return cms_SignedData_final(cms, cmsbio);\n\n    case NID_pkcs7_digest:\n        return cms_DigestedData_do_final(cms, cmsbio, 0);\n\n    default:\n        CMSerr(CMS_F_CMS_DATAFINAL, CMS_R_UNSUPPORTED_TYPE);\n        return 0;\n    }\n}"},"270505760":{"score":0.86522627,"function_name":"CMS_dataInit","code":"BIO *CMS_dataInit(CMS_ContentInfo *cms, BIO *icont)\n{\n    BIO *cmsbio, *cont;\n    if (icont)\n        cont = icont;\n    else\n        cont = cms_content_bio(cms);\n    if (!cont) {\n        CMSerr(CMS_F_CMS_DATAINIT, CMS_R_NO_CONTENT);\n        return NULL;\n    }\n    switch (OBJ_obj2nid(cms-\u003econtentType)) {\n\n    case NID_pkcs7_data:\n        return cont;\n\n    case NID_pkcs7_signed:\n        cmsbio = cms_SignedData_init_bio(cms);\n        break;\n\n    case NID_pkcs7_digest:\n        cmsbio = cms_DigestedData_init_bio(cms);\n        break;\n#ifdef ZLIB\n    case NID_id_smime_ct_compressedData:\n        cmsbio = cms_CompressedData_init_bio(cms);\n        break;\n#endif\n\n    case NID_pkcs7_encrypted:\n        cmsbio = cms_EncryptedData_init_bio(cms);\n        break;\n\n    case NID_pkcs7_enveloped:\n        cmsbio = cms_EnvelopedData_init_bio(cms);\n        break;\n\n    default:\n        CMSerr(CMS_F_CMS_DATAINIT, CMS_R_UNSUPPORTED_TYPE);\n        return NULL;\n    }\n\n    if (cmsbio)\n        return BIO_push(cmsbio, cont);\n\n    if (!icont)\n        BIO_free(cont);\n    return NULL;\n\n}","filepath":"crypto/cms/cms_lib.c","line_number":101,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre2"},"270506048":{"score":0.86608434,"function_name":"CMS_get0_content","code":"ASN1_OCTET_STRING **CMS_get0_content(CMS_ContentInfo *cms)\n{\n    switch (OBJ_obj2nid(cms-\u003econtentType)) {\n\n    case NID_pkcs7_data:\n        return \u0026cms-\u003ed.data;\n\n    case NID_pkcs7_signed:\n        return \u0026cms-\u003ed.signedData-\u003eencapContentInfo-\u003eeContent;\n\n    case NID_pkcs7_enveloped:\n        return \u0026cms-\u003ed.envelopedData-\u003eencryptedContentInfo-\u003eencryptedContent;\n\n    case NID_pkcs7_digest:\n        return \u0026cms-\u003ed.digestedData-\u003eencapContentInfo-\u003eeContent;\n\n    case NID_pkcs7_encrypted:\n        return \u0026cms-\u003ed.encryptedData-\u003eencryptedContentInfo-\u003eencryptedContent;\n\n    case NID_id_smime_ct_authData:\n        return \u0026cms-\u003ed.authenticatedData-\u003eencapContentInfo-\u003eeContent;\n\n    case NID_id_smime_ct_compressedData:\n        return \u0026cms-\u003ed.compressedData-\u003eencapContentInfo-\u003eeContent;\n\n    default:\n        if (cms-\u003ed.other-\u003etype == V_ASN1_OCTET_STRING)\n            return \u0026cms-\u003ed.other-\u003evalue.octet_string;\n        CMSerr(CMS_F_CMS_GET0_CONTENT, CMS_R_UNSUPPORTED_CONTENT_TYPE);\n        return NULL;\n\n    }\n}","filepath":"crypto/cms/cms_lib.c","line_number":201,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre2"},"270506224":{"score":0.7639636,"function_name":"cms_DigestAlgorithm_find_ctx","code":"int cms_DigestAlgorithm_find_ctx(EVP_MD_CTX *mctx, BIO *chain,\n                                 X509_ALGOR *mdalg)\n{\n    int nid;\n    ASN1_OBJECT *mdoid;\n    X509_ALGOR_get0(\u0026mdoid, NULL, NULL, mdalg);\n    nid = OBJ_obj2nid(mdoid);\n    /* Look for digest type to match signature */\n    for (;;) {\n        EVP_MD_CTX *mtmp;\n        chain = BIO_find_type(chain, BIO_TYPE_MD);\n        if (chain == NULL) {\n            CMSerr(CMS_F_CMS_DIGESTALGORITHM_FIND_CTX,\n                   CMS_R_NO_MATCHING_DIGEST);\n            return 0;\n        }\n        BIO_get_md_ctx(chain, \u0026mtmp);\n        if (EVP_MD_CTX_type(mtmp) == nid\n            /*\n             * Workaround for broken implementations that use signature\n             * algorithm OID instead of digest.\n             */\n            || EVP_MD_pkey_type(EVP_MD_CTX_md(mtmp)) == nid)\n            return EVP_MD_CTX_copy_ex(mctx, mtmp);\n        chain = BIO_next(chain);\n    }\n}","filepath":"crypto/cms/cms_lib.c","line_number":356,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre2"},"270506432":{"score":0.76759624,"function_name":"cms_DigestAlgorithm_init_bio","code":"BIO *cms_DigestAlgorithm_init_bio(X509_ALGOR *digestAlgorithm)\n{\n    BIO *mdbio = NULL;\n    ASN1_OBJECT *digestoid;\n    const EVP_MD *digest;\n    X509_ALGOR_get0(\u0026digestoid, NULL, NULL, digestAlgorithm);\n    digest = EVP_get_digestbyobj(digestoid);\n    if (!digest) {\n        CMSerr(CMS_F_CMS_DIGESTALGORITHM_INIT_BIO,\n               CMS_R_UNKNOWN_DIGEST_ALGORIHM);\n        goto err;\n    }\n    mdbio = BIO_new(BIO_f_md());\n    if (mdbio == NULL || !BIO_set_md(mdbio, digest)) {\n        CMSerr(CMS_F_CMS_DIGESTALGORITHM_INIT_BIO, CMS_R_MD_BIO_INIT_ERROR);\n        goto err;\n    }\n    return mdbio;\n err:\n    BIO_free(mdbio);\n    return NULL;\n}","filepath":"crypto/cms/cms_lib.c","line_number":331,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre2"},"270506592":{"score":0.74142885,"function_name":"cms_set1_keyid","code":"int cms_set1_keyid(ASN1_OCTET_STRING **pkeyid, X509 *cert)\n{\n    ASN1_OCTET_STRING *keyid = NULL;\n    const ASN1_OCTET_STRING *cert_keyid;\n    cert_keyid = X509_get0_subject_key_id(cert);\n    if (cert_keyid == NULL) {\n        CMSerr(CMS_F_CMS_SET1_KEYID, CMS_R_CERTIFICATE_HAS_NO_KEYID);\n        return 0;\n    }\n    keyid = ASN1_STRING_dup(cert_keyid);\n    if (!keyid) {\n        CMSerr(CMS_F_CMS_SET1_KEYID, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n    ASN1_OCTET_STRING_free(*pkeyid);\n    *pkeyid = keyid;\n    return 1;\n}","filepath":"crypto/cms/cms_lib.c","line_number":611,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_0-pre2"},"270511760":{"score":0.8490813,"function_name":"d2i_SCT_LIST","code":"STACK_OF(SCT) *d2i_SCT_LIST(STACK_OF(SCT) **a, const unsigned char **pp,\n                            long len)\n{\n    ASN1_OCTET_STRING *oct = NULL;\n    STACK_OF(SCT) *sk = NULL;\n    const unsigned char *p;\n\n    p = *pp;\n    if (d2i_ASN1_OCTET_STRING(\u0026oct, \u0026p, len) == NULL)\n        return NULL;\n\n    p = oct-\u003edata;\n    if ((sk = o2i_SCT_LIST(a, \u0026p, oct-\u003elength)) != NULL)\n        *pp += len;\n\n    ASN1_OCTET_STRING_free(oct);\n    return sk;\n}","filepath":"crypto/ct/ct_oct.c","line_number":376,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270511888":{"score":0.8810227,"function_name":"i2d_SCT_LIST","code":"int i2d_SCT_LIST(const STACK_OF(SCT) *a, unsigned char **out)\n{\n    ASN1_OCTET_STRING oct;\n    int len;\n\n    oct.data = NULL;\n    if ((oct.length = i2o_SCT_LIST(a, \u0026oct.data)) == -1)\n        return -1;\n\n    len = i2d_ASN1_OCTET_STRING(\u0026oct, out);\n    OPENSSL_free(oct.data);\n    return len;\n}","filepath":"crypto/ct/ct_oct.c","line_number":395,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270511984":{"score":0.88558424,"function_name":"i2o_SCT","code":"int i2o_SCT(const SCT *sct, unsigned char **out)\n{\n    size_t len;\n    unsigned char *p = NULL, *pstart = NULL;\n\n    if (!SCT_is_complete(sct)) {\n        CTerr(CT_F_I2O_SCT, CT_R_SCT_NOT_SET);\n        goto err;\n    }\n    /*\n     * Fixed-length header: struct { (1 byte) Version sct_version; (32 bytes)\n     * log_id id; (8 bytes) uint64 timestamp; (2 bytes + ?) CtExtensions\n     * extensions; (1 byte) Hash algorithm (1 byte) Signature algorithm (2\n     * bytes + ?) Signature\n     */\n    if (sct-\u003eversion == SCT_VERSION_V1)\n        len = 43 + sct-\u003eext_len + 4 + sct-\u003esig_len;\n    else\n        len = sct-\u003esct_len;\n\n    if (out == NULL)\n        return len;\n\n    if (*out != NULL) {\n        p = *out;\n        *out += len;\n    } else {\n        pstart = p = OPENSSL_malloc(len);\n        if (p == NULL) {\n            CTerr(CT_F_I2O_SCT, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        *out = p;\n    }\n\n    if (sct-\u003eversion == SCT_VERSION_V1) {\n        *p++ = sct-\u003eversion;\n        memcpy(p, sct-\u003elog_id, CT_V1_HASHLEN);\n        p += CT_V1_HASHLEN;\n        l2n8(sct-\u003etimestamp, p);\n        s2n(sct-\u003eext_len, p);\n        if (sct-\u003eext_len \u003e 0) {\n            memcpy(p, sct-\u003eext, sct-\u003eext_len);\n            p += sct-\u003eext_len;\n        }\n        if (i2o_SCT_signature(sct, \u0026p) \u003c= 0)\n            goto err;\n    } else {\n        memcpy(p, sct-\u003esct, len);\n    }\n\n    return len;\nerr:\n    OPENSSL_free(pstart);\n    return -1;\n}","filepath":"crypto/ct/ct_oct.c","line_number":200,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270512528":{"score":0.84314334,"function_name":"i2o_SCT_LIST","code":"int i2o_SCT_LIST(const STACK_OF(SCT) *a, unsigned char **pp)\n{\n    int len, sct_len, i, is_pp_new = 0;\n    size_t len2;\n    unsigned char *p = NULL, *p2;\n\n    if (pp != NULL) {\n        if (*pp == NULL) {\n            if ((len = i2o_SCT_LIST(a, NULL)) == -1) {\n                CTerr(CT_F_I2O_SCT_LIST, CT_R_SCT_LIST_INVALID);\n                return -1;\n            }\n            if ((*pp = OPENSSL_malloc(len)) == NULL) {\n                CTerr(CT_F_I2O_SCT_LIST, ERR_R_MALLOC_FAILURE);\n                return -1;\n            }\n            is_pp_new = 1;\n        }\n        p = *pp + 2;\n    }\n\n    len2 = 2;\n    for (i = 0; i \u003c sk_SCT_num(a); i++) {\n        if (pp != NULL) {\n            p2 = p;\n            p += 2;\n            if ((sct_len = i2o_SCT(sk_SCT_value(a, i), \u0026p)) == -1)\n                goto err;\n            s2n(sct_len, p2);\n        } else {\n          if ((sct_len = i2o_SCT(sk_SCT_value(a, i), NULL)) == -1)\n              goto err;\n        }\n        len2 += 2 + sct_len;\n    }\n\n    if (len2 \u003e MAX_SCT_LIST_SIZE)\n        goto err;\n\n    if (pp != NULL) {\n        p = *pp;\n        s2n(len2 - 2, p);\n        if (!is_pp_new)\n            *pp += len2;\n    }\n    return len2;\n\n err:\n    if (is_pp_new) {\n        OPENSSL_free(*pp);\n        *pp = NULL;\n    }\n    return -1;\n}","filepath":"crypto/ct/ct_oct.c","line_number":321,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270513008":{"score":0.7896855,"function_name":"o2i_SCT","code":"SCT *o2i_SCT(SCT **psct, const unsigned char **in, size_t len)\n{\n    SCT *sct = NULL;\n    const unsigned char *p;\n\n    if (len == 0 || len \u003e MAX_SCT_SIZE) {\n        CTerr(CT_F_O2I_SCT, CT_R_SCT_INVALID);\n        goto err;\n    }\n\n    if ((sct = SCT_new()) == NULL)\n        goto err;\n\n    p = *in;\n\n    sct-\u003eversion = *p;\n    if (sct-\u003eversion == SCT_VERSION_V1) {\n        int sig_len;\n        size_t len2;\n        /*-\n         * Fixed-length header:\n         *   struct {\n         *     Version sct_version;     (1 byte)\n         *     log_id id;               (32 bytes)\n         *     uint64 timestamp;        (8 bytes)\n         *     CtExtensions extensions; (2 bytes + ?)\n         *   }\n         */\n        if (len \u003c 43) {\n            CTerr(CT_F_O2I_SCT, CT_R_SCT_INVALID);\n            goto err;\n        }\n        len -= 43;\n        p++;\n        sct-\u003elog_id = BUF_memdup(p, CT_V1_HASHLEN);\n        if (sct-\u003elog_id == NULL)\n            goto err;\n        sct-\u003elog_id_len = CT_V1_HASHLEN;\n        p += CT_V1_HASHLEN;\n\n        n2l8(p, sct-\u003etimestamp);\n\n        n2s(p, len2);\n        if (len \u003c len2) {\n            CTerr(CT_F_O2I_SCT, CT_R_SCT_INVALID);\n            goto err;\n        }\n        if (len2 \u003e 0) {\n            sct-\u003eext = BUF_memdup(p, len2);\n            if (sct-\u003eext == NULL)\n                goto err;\n        }\n        sct-\u003eext_len = len2;\n        p += len2;\n        len -= len2;\n\n        sig_len = o2i_SCT_signature(sct, \u0026p, len);\n        if (sig_len \u003c= 0) {\n            CTerr(CT_F_O2I_SCT, CT_R_SCT_INVALID);\n            goto err;\n        }\n        len -= sig_len;\n        *in = p + len;\n    } else {\n        /* If not V1 just cache encoding */\n        sct-\u003esct = BUF_memdup(p, len);\n        if (sct-\u003esct == NULL)\n            goto err;\n        sct-\u003esct_len = len;\n        *in = p + len;\n    }\n\n    if (psct != NULL) {\n        SCT_free(*psct);\n        *psct = sct;\n    }\n\n    return sct;\nerr:\n    SCT_free(sct);\n    return NULL;\n}","filepath":"crypto/ct/ct_oct.c","line_number":70,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270513728":{"score":0.8056109,"function_name":"o2i_SCT_LIST","code":"STACK_OF(SCT) *o2i_SCT_LIST(STACK_OF(SCT) **a, const unsigned char **pp,\n                            size_t len)\n{\n    STACK_OF(SCT) *sk = NULL;\n    size_t list_len, sct_len;\n\n    if (len \u003c 2 || len \u003e MAX_SCT_LIST_SIZE) {\n        CTerr(CT_F_O2I_SCT_LIST, CT_R_SCT_LIST_INVALID);\n        return NULL;\n    }\n\n    n2s(*pp, list_len);\n    if (list_len != len - 2) {\n        CTerr(CT_F_O2I_SCT_LIST, CT_R_SCT_LIST_INVALID);\n        return NULL;\n    }\n\n    if (a == NULL || *a == NULL) {\n        sk = sk_SCT_new_null();\n        if (sk == NULL)\n            return NULL;\n    } else {\n        SCT *sct;\n\n        /* Use the given stack, but empty it first. */\n        sk = *a;\n        while ((sct = sk_SCT_pop(sk)) != NULL)\n            SCT_free(sct);\n    }\n\n    while (list_len \u003e 0) {\n        SCT *sct;\n\n        if (list_len \u003c 2) {\n            CTerr(CT_F_O2I_SCT_LIST, CT_R_SCT_LIST_INVALID);\n            goto err;\n        }\n        n2s(*pp, sct_len);\n        list_len -= 2;\n\n        if (sct_len == 0 || sct_len \u003e list_len) {\n            CTerr(CT_F_O2I_SCT_LIST, CT_R_SCT_LIST_INVALID);\n            goto err;\n        }\n        list_len -= sct_len;\n\n        if ((sct = o2i_SCT(NULL, pp, sct_len)) == NULL)\n            goto err;\n        if (!sk_SCT_push(sk, sct)) {\n            SCT_free(sct);\n            goto err;\n        }\n    }\n\n    if (a != NULL \u0026\u0026 *a == NULL)\n        *a = sk;\n    return sk;\n\n err:\n    if (a == NULL || *a == NULL)\n        SCT_LIST_free(sk);\n    return NULL;\n}","filepath":"crypto/ct/ct_oct.c","line_number":257,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1e"},"270518448":{"score":0.86967003,"function_name":"asn1_bio_write","code":"static int asn1_bio_write(BIO *b, const char *in, int inl)\n{\n    BIO_ASN1_BUF_CTX *ctx;\n    int wrmax, wrlen, ret;\n    unsigned char *p;\n    BIO *next;\n\n    ctx = BIO_get_data(b);\n    next = BIO_next(b);\n    if (in == NULL || inl \u003c 0 || ctx == NULL || next == NULL)\n        return 0;\n\n    wrlen = 0;\n    ret = -1;\n\n    for (;;) {\n        switch (ctx-\u003estate) {\n            /* Setup prefix data, call it */\n        case ASN1_STATE_START:\n            if (!asn1_bio_setup_ex(b, ctx, ctx-\u003eprefix,\n                                   ASN1_STATE_PRE_COPY, ASN1_STATE_HEADER))\n                return 0;\n            break;\n\n            /* Copy any pre data first */\n        case ASN1_STATE_PRE_COPY:\n\n            ret = asn1_bio_flush_ex(b, ctx, ctx-\u003eprefix_free,\n                                    ASN1_STATE_HEADER);\n\n            if (ret \u003c= 0)\n                goto done;\n\n            break;\n\n        case ASN1_STATE_HEADER:\n            ctx-\u003ebuflen = ASN1_object_size(0, inl, ctx-\u003easn1_tag) - inl;\n            if (!ossl_assert(ctx-\u003ebuflen \u003c= ctx-\u003ebufsize))\n                return 0;\n            p = ctx-\u003ebuf;\n            ASN1_put_object(\u0026p, 0, inl, ctx-\u003easn1_tag, ctx-\u003easn1_class);\n            ctx-\u003ecopylen = inl;\n            ctx-\u003estate = ASN1_STATE_HEADER_COPY;\n\n            break;\n\n        case ASN1_STATE_HEADER_COPY:\n            ret = BIO_write(next, ctx-\u003ebuf + ctx-\u003ebufpos, ctx-\u003ebuflen);\n            if (ret \u003c= 0)\n                goto done;\n\n            ctx-\u003ebuflen -= ret;\n            if (ctx-\u003ebuflen)\n                ctx-\u003ebufpos += ret;\n            else {\n                ctx-\u003ebufpos = 0;\n                ctx-\u003estate = ASN1_STATE_DATA_COPY;\n            }\n\n            break;\n\n        case ASN1_STATE_DATA_COPY:\n\n            if (inl \u003e ctx-\u003ecopylen)\n                wrmax = ctx-\u003ecopylen;\n            else\n                wrmax = inl;\n            ret = BIO_write(next, in, wrmax);\n            if (ret \u003c= 0)\n                goto done;\n            wrlen += ret;\n            ctx-\u003ecopylen -= ret;\n            in += ret;\n            inl -= ret;\n\n            if (ctx-\u003ecopylen == 0)\n                ctx-\u003estate = ASN1_STATE_HEADER;\n\n            if (inl == 0)\n                goto done;\n\n            break;\n\n        case ASN1_STATE_POST_COPY:\n        case ASN1_STATE_DONE:\n            BIO_clear_retry_flags(b);\n            return 0;\n\n        }\n\n    }\n\n done:\n    BIO_clear_retry_flags(b);\n    BIO_copy_next_retry(b);\n\n    return (wrlen \u003e 0) ? wrlen : ret;\n\n}","filepath":"crypto/asn1/bio_asn1.c","line_number":154,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1l"},"270519040":{"score":0.8090898,"function_name":"asn1_bio_ctrl","code":"static long asn1_bio_ctrl(BIO *b, int cmd, long arg1, void *arg2)\n{\n    BIO_ASN1_BUF_CTX *ctx;\n    BIO_ASN1_EX_FUNCS *ex_func;\n    long ret = 1;\n    BIO *next;\n\n    ctx = BIO_get_data(b);\n    if (ctx == NULL)\n        return 0;\n    next = BIO_next(b);\n    switch (cmd) {\n\n    case BIO_C_SET_PREFIX:\n        ex_func = arg2;\n        ctx-\u003eprefix = ex_func-\u003eex_func;\n        ctx-\u003eprefix_free = ex_func-\u003eex_free_func;\n        break;\n\n    case BIO_C_GET_PREFIX:\n        ex_func = arg2;\n        ex_func-\u003eex_func = ctx-\u003eprefix;\n        ex_func-\u003eex_free_func = ctx-\u003eprefix_free;\n        break;\n\n    case BIO_C_SET_SUFFIX:\n        ex_func = arg2;\n        ctx-\u003esuffix = ex_func-\u003eex_func;\n        ctx-\u003esuffix_free = ex_func-\u003eex_free_func;\n        break;\n\n    case BIO_C_GET_SUFFIX:\n        ex_func = arg2;\n        ex_func-\u003eex_func = ctx-\u003esuffix;\n        ex_func-\u003eex_free_func = ctx-\u003esuffix_free;\n        break;\n\n    case BIO_C_SET_EX_ARG:\n        ctx-\u003eex_arg = arg2;\n        break;\n\n    case BIO_C_GET_EX_ARG:\n        *(void **)arg2 = ctx-\u003eex_arg;\n        break;\n\n    case BIO_CTRL_FLUSH:\n        if (next == NULL)\n            return 0;\n\n        /* Call post function if possible */\n        if (ctx-\u003estate == ASN1_STATE_HEADER) {\n            if (!asn1_bio_setup_ex(b, ctx, ctx-\u003esuffix,\n                                   ASN1_STATE_POST_COPY, ASN1_STATE_DONE))\n                return 0;\n        }\n\n        if (ctx-\u003estate == ASN1_STATE_POST_COPY) {\n            ret = asn1_bio_flush_ex(b, ctx, ctx-\u003esuffix_free,\n                                    ASN1_STATE_DONE);\n            if (ret \u003c= 0)\n                return ret;\n        }\n\n        if (ctx-\u003estate == ASN1_STATE_DONE)\n            return BIO_ctrl(next, cmd, arg1, arg2);\n        else {\n            BIO_clear_retry_flags(b);\n            return 0;\n        }\n\n    default:\n        if (next == NULL)\n            return 0;\n        return BIO_ctrl(next, cmd, arg1, arg2);\n\n    }\n\n    return ret;\n}","filepath":"crypto/asn1/bio_asn1.c","line_number":324,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1l"},"270519776":{"score":0.89974445,"function_name":"asn1_bio_flush_ex","code":"static int asn1_bio_flush_ex(BIO *b, BIO_ASN1_BUF_CTX *ctx,\n                             asn1_ps_func *cleanup, asn1_bio_state_t next)\n{\n    int ret;\n\n    if (ctx-\u003eex_len \u003c= 0)\n        return 1;\n    for (;;) {\n        ret = BIO_write(BIO_next(b), ctx-\u003eex_buf + ctx-\u003eex_pos, ctx-\u003eex_len);\n        if (ret \u003c= 0)\n            break;\n        ctx-\u003eex_len -= ret;\n        if (ctx-\u003eex_len \u003e 0)\n            ctx-\u003eex_pos += ret;\n        else {\n            if (cleanup)\n                cleanup(b, \u0026ctx-\u003eex_buf, \u0026ctx-\u003eex_len, \u0026ctx-\u003eex_arg);\n            ctx-\u003estate = next;\n            ctx-\u003eex_pos = 0;\n            break;\n        }\n    }\n    return ret;\n}","filepath":"crypto/asn1/bio_asn1.c","line_number":254,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1l"},"270519936":{"score":0.8924111,"function_name":"asn1_bio_setup_ex","code":"static int asn1_bio_setup_ex(BIO *b, BIO_ASN1_BUF_CTX *ctx,\n                             asn1_ps_func *setup,\n                             asn1_bio_state_t ex_state,\n                             asn1_bio_state_t other_state)\n{\n    if (setup \u0026\u0026 !setup(b, \u0026ctx-\u003eex_buf, \u0026ctx-\u003eex_len, \u0026ctx-\u003eex_arg)) {\n        BIO_clear_retry_flags(b);\n        return 0;\n    }\n    if (ctx-\u003eex_len \u003e 0)\n        ctx-\u003estate = ex_state;\n    else\n        ctx-\u003estate = other_state;\n    return 1;\n}","filepath":"crypto/asn1/bio_asn1.c","line_number":279,"entry_url":"https://github.com/openssl/openssl.git","slot_name":"OpenSSL_1_1_1l"},"270533280":{"score":0.7054652,"function_name":"CodedOutputStream::CodedOutputStream","code":"CodedOutputStream::CodedOutputStream(ZeroCopyOutputStream* stream,\n                                     bool do_eager_refresh)\n    : impl_(stream, IsDefaultSerializationDeterministic(), \u0026cur_),\n      start_count_(stream-\u003eByteCount()) {\n  if (do_eager_refresh) {\n    void* data;\n    int size;\n    if (!stream-\u003eNext(\u0026data, \u0026size) || size == 0) return;\n    cur_ = impl_.SetInitialBuffer(data, size);\n  }\n}","filepath":"src/google/protobuf/io/coded_stream.cc","line_number":932,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.15.0-rc1"},"270533440":{"score":0.6750006,"function_name":"CodedInputStream::BackUpInputToCurrentPosition","code":"void CodedInputStream::BackUpInputToCurrentPosition() {\n  int backup_bytes = BufferSize() + buffer_size_after_limit_ + overflow_bytes_;\n  if (backup_bytes \u003e 0) {\n    input_-\u003eBackUp(backup_bytes);\n\n    // total_bytes_read_ doesn't include overflow_bytes_.\n    total_bytes_read_ -= BufferSize() + buffer_size_after_limit_;\n    buffer_end_ = buffer_;\n    buffer_size_after_limit_ = 0;\n    overflow_bytes_ = 0;\n  }\n}","filepath":"src/google/protobuf/io/coded_stream.cc","line_number":92,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.15.0-rc1"},"270533760":{"score":0.65111434,"function_name":"EpsCopyOutputStream::EnsureSpaceFallback","code":"uint8* EpsCopyOutputStream::EnsureSpaceFallback(uint8* ptr) {\n  do {\n    if (PROTOBUF_PREDICT_FALSE(had_error_)) return buffer_;\n    int overrun = ptr - end_;\n    GOOGLE_DCHECK(overrun \u003e= 0);           // NOLINT\n    GOOGLE_DCHECK(overrun \u003c= kSlopBytes);  // NOLINT\n    ptr = Next() + overrun;\n  } while (ptr \u003e= end_);\n  GOOGLE_DCHECK(ptr \u003c end_);  // NOLINT\n  return ptr;\n}","filepath":"src/google/protobuf/io/coded_stream.cc","line_number":825,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.15.0-rc1"},"270533824":{"score":0.69087416,"function_name":"EpsCopyOutputStream::Flush","code":"int EpsCopyOutputStream::Flush(uint8* ptr) {\n  while (buffer_end_ \u0026\u0026 ptr \u003e end_) {\n    int overrun = ptr - end_;\n    GOOGLE_DCHECK(!had_error_);\n    GOOGLE_DCHECK(overrun \u003c= kSlopBytes);  // NOLINT\n    ptr = Next() + overrun;\n    if (had_error_) return 0;\n  }\n  int s;\n  if (buffer_end_) {\n    std::memcpy(buffer_end_, buffer_, ptr - buffer_);\n    buffer_end_ += ptr - buffer_;\n    s = end_ - ptr;\n  } else {\n    // The stream is writing directly in the ZeroCopyOutputStream buffer.\n    s = end_ + kSlopBytes - ptr;\n    buffer_end_ = ptr;\n  }\n  GOOGLE_DCHECK(s \u003e= 0);  // NOLINT\n  return s;\n}","filepath":"src/google/protobuf/io/coded_stream.cc","line_number":682,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.15.0-rc1"},"270534112":{"score":0.71595776,"function_name":"EpsCopyOutputStream::Next","code":"uint8* EpsCopyOutputStream::Next() {\n  GOOGLE_DCHECK(!had_error_);  // NOLINT\n  if (PROTOBUF_PREDICT_FALSE(stream_ == nullptr)) return Error();\n  if (buffer_end_) {\n    // We're in the patch buffer and need to fill up the previous buffer.\n    std::memcpy(buffer_end_, buffer_, end_ - buffer_);\n    uint8* ptr;\n    int size;\n    do {\n      void* data;\n      if (PROTOBUF_PREDICT_FALSE(!stream_-\u003eNext(\u0026data, \u0026size))) {\n        // Stream has an error, we use the patch buffer to continue to be\n        // able to write.\n        return Error();\n      }\n      ptr = static_cast\u003cuint8*\u003e(data);\n    } while (size == 0);\n    if (PROTOBUF_PREDICT_TRUE(size \u003e kSlopBytes)) {\n      std::memcpy(ptr, end_, kSlopBytes);\n      end_ = ptr + size - kSlopBytes;\n      buffer_end_ = nullptr;\n      return ptr;\n    } else {\n      GOOGLE_DCHECK(size \u003e 0);  // NOLINT\n      // Buffer to small\n      std::memmove(buffer_, end_, kSlopBytes);\n      buffer_end_ = ptr;\n      end_ = buffer_ + size;\n      return buffer_;\n    }\n  } else {\n    std::memcpy(buffer_, end_, kSlopBytes);\n    buffer_end_ = end_;\n    end_ = buffer_ + kSlopBytes;\n    return buffer_;\n  }\n}","filepath":"src/google/protobuf/io/coded_stream.cc","line_number":787,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.15.0-rc1"},"270534352":{"score":0.7310986,"function_name":"CodedInputStream::PrintTotalBytesLimitError","code":"void CodedInputStream::PrintTotalBytesLimitError() {\n  GOOGLE_LOG(ERROR)\n      \u003c\u003c \"A protocol message was rejected because it was too \"\n         \"big (more than \"\n      \u003c\u003c total_bytes_limit_\n      \u003c\u003c \" bytes).  To increase the limit (or to disable these \"\n         \"warnings), see CodedInputStream::SetTotalBytesLimit() \"\n         \"in third_party/protobuf/src/google/protobuf/io/coded_stream.h.\";\n}","filepath":"src/google/protobuf/io/coded_stream.cc","line_number":192,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.15.0-rc1"},"270535392":{"score":0.8308367,"function_name":"CodedInputStream::ReadStringFallback","code":"bool CodedInputStream::ReadStringFallback(std::string* buffer, int size) {\n  if (!buffer-\u003eempty()) {\n    buffer-\u003eclear();\n  }\n\n  int closest_limit = std::min(current_limit_, total_bytes_limit_);\n  if (closest_limit != INT_MAX) {\n    int bytes_to_limit = closest_limit - CurrentPosition();\n    if (bytes_to_limit \u003e 0 \u0026\u0026 size \u003e 0 \u0026\u0026 size \u003c= bytes_to_limit) {\n      buffer-\u003ereserve(size);\n    }\n  }\n\n  int current_buffer_size;\n  while ((current_buffer_size = BufferSize()) \u003c size) {\n    // Some STL implementations \"helpfully\" crash on buffer-\u003eappend(NULL, 0).\n    if (current_buffer_size != 0) {\n      // Note:  string1.append(string2) is O(string2.size()) (as opposed to\n      //   O(string1.size() + string2.size()), which would be bad).\n      buffer-\u003eappend(reinterpret_cast\u003cconst char*\u003e(buffer_),\n                     current_buffer_size);\n    }\n    size -= current_buffer_size;\n    Advance(current_buffer_size);\n    if (!Refresh()) return false;\n  }\n\n  buffer-\u003eappend(reinterpret_cast\u003cconst char*\u003e(buffer_), size);\n  Advance(size);\n\n  return true;\n}","filepath":"src/google/protobuf/io/coded_stream.cc","line_number":277,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.15.0-rc1"},"270535584":{"score":0.6441015,"function_name":"CodedInputStream::ReadTagFallback","code":"uint32 CodedInputStream::ReadTagFallback(uint32 first_byte_or_zero) {\n  const int buf_size = BufferSize();\n  if (buf_size \u003e= kMaxVarintBytes ||\n      // Optimization:  We're also safe if the buffer is non-empty and it ends\n      // with a byte that would terminate a varint.\n      (buf_size \u003e 0 \u0026\u0026 !(buffer_end_[-1] \u0026 0x80))) {\n    GOOGLE_DCHECK_EQ(first_byte_or_zero, buffer_[0]);\n    if (first_byte_or_zero == 0) {\n      ++buffer_;\n      return 0;\n    }\n    uint32 tag;\n    ::std::pair\u003cbool, const uint8*\u003e p =\n        ReadVarint32FromArray(first_byte_or_zero, buffer_, \u0026tag);\n    if (!p.first) {\n      return 0;\n    }\n    buffer_ = p.second;\n    return tag;\n  } else {\n    // We are commonly at a limit when attempting to read tags. Try to quickly\n    // detect this case without making another function call.\n    if ((buf_size == 0) \u0026\u0026\n        ((buffer_size_after_limit_ \u003e 0) ||\n         (total_bytes_read_ == current_limit_)) \u0026\u0026\n        // Make sure that the limit we hit is not total_bytes_limit_, since\n        // in that case we still need to call Refresh() so that it prints an\n        // error.\n        total_bytes_read_ - buffer_size_after_limit_ \u003c total_bytes_limit_) {\n      // We hit a byte limit.\n      legitimate_message_end_ = true;\n      return 0;\n    }\n    return ReadTagSlow();\n  }\n}","filepath":"src/google/protobuf/io/coded_stream.cc","line_number":531,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.15.0-rc1"},"270535744":{"score":0.8135228,"function_name":"CodedInputStream::ReadTagSlow","code":"uint32 CodedInputStream::ReadTagSlow() {\n  if (buffer_ == buffer_end_) {\n    // Call refresh.\n    if (!Refresh()) {\n      // Refresh failed.  Make sure that it failed due to EOF, not because\n      // we hit total_bytes_limit_, which, unlike normal limits, is not a\n      // valid place to end a message.\n      int current_position = total_bytes_read_ - buffer_size_after_limit_;\n      if (current_position \u003e= total_bytes_limit_) {\n        // Hit total_bytes_limit_.  But if we also hit the normal limit,\n        // we're still OK.\n        legitimate_message_end_ = current_limit_ == total_bytes_limit_;\n      } else {\n        legitimate_message_end_ = true;\n      }\n      return 0;\n    }\n  }\n\n  // For the slow path, just do a 64-bit read. Try to optimize for one-byte tags\n  // again, since we have now refreshed the buffer.\n  uint64 result = 0;\n  if (!ReadVarint64(\u0026result)) return 0;\n  return static_cast\u003cuint32\u003e(result);\n}","filepath":"src/google/protobuf/io/coded_stream.cc","line_number":505,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.15.0-rc1"},"270535872":{"score":0.6896449,"function_name":"CodedInputStream::ReadVarintSizeAsIntFallback","code":"int CodedInputStream::ReadVarintSizeAsIntFallback() {\n  if (BufferSize() \u003e= kMaxVarintBytes ||\n      // Optimization:  We're also safe if the buffer is non-empty and it ends\n      // with a byte that would terminate a varint.\n      (buffer_end_ \u003e buffer_ \u0026\u0026 !(buffer_end_[-1] \u0026 0x80))) {\n    uint64 temp;\n    ::std::pair\u003cbool, const uint8*\u003e p = ReadVarint64FromArray(buffer_, \u0026temp);\n    if (!p.first || temp \u003e static_cast\u003cuint64\u003e(INT_MAX)) return -1;\n    buffer_ = p.second;\n    return temp;\n  } else {\n    // Really slow case: we will incur the cost of an extra function call here,\n    // but moving this out of line reduces the size of this function, which\n    // improves the common case. In micro benchmarks, this is worth about 10-15%\n    return ReadVarintSizeAsIntSlow();\n  }\n}","filepath":"src/google/protobuf/io/coded_stream.cc","line_number":487,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.15.0-rc1"},"270536176":{"score":0.64903843,"function_name":"CodedInputStream::ReadVarint64Fallback","code":"std::pair\u003cuint64, bool\u003e CodedInputStream::ReadVarint64Fallback() {\n  if (BufferSize() \u003e= kMaxVarintBytes ||\n      // Optimization:  We're also safe if the buffer is non-empty and it ends\n      // with a byte that would terminate a varint.\n      (buffer_end_ \u003e buffer_ \u0026\u0026 !(buffer_end_[-1] \u0026 0x80))) {\n    uint64 temp;\n    ::std::pair\u003cbool, const uint8*\u003e p = ReadVarint64FromArray(buffer_, \u0026temp);\n    if (!p.first) {\n      return std::make_pair(0, false);\n    }\n    buffer_ = p.second;\n    return std::make_pair(temp, true);\n  } else {\n    uint64 temp;\n    bool success = ReadVarint64Slow(\u0026temp);\n    return std::make_pair(temp, success);\n  }\n}","filepath":"src/google/protobuf/io/coded_stream.cc","line_number":597,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.15.0-rc1"},"270537424":{"score":0.88938993,"function_name":"CodedInputStream::RecomputeBufferLimits","code":"inline void CodedInputStream::RecomputeBufferLimits() {\n  buffer_end_ += buffer_size_after_limit_;\n  int closest_limit = std::min(current_limit_, total_bytes_limit_);\n  if (closest_limit \u003c total_bytes_read_) {\n    // The limit position is in the current buffer.  We must adjust\n    // the buffer size accordingly.\n    buffer_size_after_limit_ = total_bytes_read_ - closest_limit;\n    buffer_end_ -= buffer_size_after_limit_;\n  } else {\n    buffer_size_after_limit_ = 0;\n  }\n}","filepath":"src/google/protobuf/io/coded_stream.cc","line_number":105,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.15.0-rc1"},"270537824":{"score":0.89192444,"function_name":"CodedInputStream::SkipFallback","code":"bool CodedInputStream::SkipFallback(int count, int original_buffer_size) {\n  if (buffer_size_after_limit_ \u003e 0) {\n    // We hit a limit inside this buffer.  Advance to the limit and fail.\n    Advance(original_buffer_size);\n    return false;\n  }\n\n  count -= original_buffer_size;\n  buffer_ = NULL;\n  buffer_end_ = buffer_;\n\n  // Make sure this skip doesn't try to skip past the current limit.\n  int closest_limit = std::min(current_limit_, total_bytes_limit_);\n  int bytes_until_limit = closest_limit - total_bytes_read_;\n  if (bytes_until_limit \u003c count) {\n    // We hit the limit.  Skip up to it then fail.\n    if (bytes_until_limit \u003e 0) {\n      total_bytes_read_ = closest_limit;\n      input_-\u003eSkip(bytes_until_limit);\n    }\n    return false;\n  }\n\n  if (!input_-\u003eSkip(count)) {\n    total_bytes_read_ = input_-\u003eByteCount();\n    return false;\n  }\n  total_bytes_read_ += count;\n  return true;\n}","filepath":"src/google/protobuf/io/coded_stream.cc","line_number":202,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.15.0-rc1"},"270537984":{"score":0.70061415,"function_name":"EpsCopyOutputStream::WriteAliasedRaw","code":"uint8* EpsCopyOutputStream::WriteAliasedRaw(const void* data, int size,\n                                            uint8* ptr) {\n  if (size \u003c GetSize(ptr)\n  ) {\n    return WriteRaw(data, size, ptr);\n  } else {\n    ptr = Trim(ptr);\n    if (stream_-\u003eWriteAliasedRaw(data, size)) return ptr;\n    return Error();\n  }\n}","filepath":"src/google/protobuf/io/coded_stream.cc","line_number":851,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.15.0-rc1"},"270538160":{"score":0.5915934,"function_name":"EpsCopyOutputStream::WriteRawFallback","code":"uint8* EpsCopyOutputStream::WriteRawFallback(const void* data, int size,\n                                             uint8* ptr) {\n  int s = GetSize(ptr);\n  while (s \u003c size) {\n    std::memcpy(ptr, data, s);\n    size -= s;\n    data = static_cast\u003cconst uint8*\u003e(data) + s;\n    ptr = EnsureSpaceFallback(ptr + s);\n    s = GetSize(ptr);\n  }\n  std::memcpy(ptr, data, size);\n  return ptr + size;\n}","filepath":"src/google/protobuf/io/coded_stream.cc","line_number":837,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.15.0-rc1"},"270538320":{"score":0.6340656,"function_name":"EpsCopyOutputStream::WriteStringMaybeAliasedOutline","code":"uint8* EpsCopyOutputStream::WriteStringMaybeAliasedOutline(uint32 num,\n                                                           const std::string\u0026 s,\n                                                           uint8* ptr) {\n  ptr = EnsureSpace(ptr);\n  uint32 size = s.size();\n  ptr = WriteLengthDelim(num, size, ptr);\n  return WriteRawMaybeAliased(s.data(), size, ptr);\n}","filepath":"src/google/protobuf/io/coded_stream.cc","line_number":912,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.15.0-rc1"},"270556512":{"score":0.62739587,"function_name":"AddFixed32","code":"void AddFixed32(uint32_t num, uint32_t value) {\n    if (unknown_ == nullptr) return;\n    WriteVarint(num * 8 + 5, unknown_);\n    char buffer[4];\n    io::CodedOutputStream::WriteLittleEndian32ToArray(\n        value, reinterpret_cast\u003cuint8_t*\u003e(buffer));\n    unknown_-\u003eappend(buffer, 4);\n  }","filepath":"src/google/protobuf/parse_context.cc","line_number":526,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270556720":{"score":0.6320428,"function_name":"EpsCopyInputStream::AppendStringFallback","code":"const char* EpsCopyInputStream::AppendStringFallback(const char* ptr, int size,\n                                                     std::string* str) {\n  if (PROTOBUF_PREDICT_TRUE(size \u003c= buffer_end_ - ptr + limit_)) {\n    // Reserve the string up to a static safe size. If strings are bigger than\n    // this we proceed by growing the string as needed. This protects against\n    // malicious payloads making protobuf hold on to a lot of memory.\n    str-\u003ereserve(str-\u003esize() + std::min\u003cint\u003e(size, kSafeStringSize));\n  }\n  return AppendSize(ptr, size,\n                    [str](const char* p, int s) { str-\u003eappend(p, s); });\n}","filepath":"src/google/protobuf/parse_context.cc","line_number":224,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270556848":{"score":0.67585146,"function_name":"EpsCopyInputStream::DoneFallback","code":"std::pair\u003cconst char*, bool\u003e EpsCopyInputStream::DoneFallback(int overrun,\n                                                              int depth) {\n  // Did we exceeded the limit (parse error).\n  if (PROTOBUF_PREDICT_FALSE(overrun \u003e limit_)) return {nullptr, true};\n  GOOGLE_DCHECK(overrun != limit_);  // Guaranteed by caller.\n  GOOGLE_DCHECK(overrun \u003c limit_);   // Follows from above\n  // TODO(gerbens) Instead of this dcheck we could just assign, and remove\n  // updating the limit_end from PopLimit, ie.\n  // limit_end_ = buffer_end_ + (std::min)(0, limit_);\n  // if (ptr \u003c limit_end_) return {ptr, false};\n  GOOGLE_DCHECK(limit_end_ == buffer_end_ + (std::min)(0, limit_));\n  // At this point we know the following assertion holds.\n  GOOGLE_DCHECK(limit_ \u003e 0);\n  GOOGLE_DCHECK(limit_end_ == buffer_end_);  // because limit_ \u003e 0\n  const char* p;\n  do {\n    // We are past the end of buffer_end_, in the slop region.\n    GOOGLE_DCHECK(overrun \u003e= 0);\n    p = NextBuffer(overrun, depth);\n    if (p == nullptr) {\n      // We are at the end of the stream\n      if (PROTOBUF_PREDICT_FALSE(overrun != 0)) return {nullptr, true};\n      GOOGLE_DCHECK(limit_ \u003e 0);\n      limit_end_ = buffer_end_;\n      // Distinguish ending on a pushed limit or ending on end-of-stream.\n      SetEndOfStream();\n      return {buffer_end_, true};\n    }\n    limit_ -= buffer_end_ - p;  // Adjust limit_ relative to new anchor\n    p += overrun;\n    overrun = p - buffer_end_;\n  } while (overrun \u003e= 0);\n  limit_end_ = buffer_end_ + std::min(0, limit_);\n  return {p, false};\n}","filepath":"src/google/protobuf/parse_context.cc","line_number":171,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270557024":{"score":0.77782273,"function_name":"EpsCopyInputStream::InitFrom","code":"const char* EpsCopyInputStream::InitFrom(io::ZeroCopyInputStream* zcis) {\n  zcis_ = zcis;\n  const void* data;\n  int size;\n  limit_ = INT_MAX;\n  if (zcis-\u003eNext(\u0026data, \u0026size)) {\n    overall_limit_ -= size;\n    if (size \u003e kSlopBytes) {\n      auto ptr = static_cast\u003cconst char*\u003e(data);\n      limit_ -= size - kSlopBytes;\n      limit_end_ = buffer_end_ = ptr + size - kSlopBytes;\n      next_chunk_ = buffer_;\n      if (aliasing_ == kOnPatch) aliasing_ = kNoDelta;\n      return ptr;\n    } else {\n      limit_end_ = buffer_end_ = buffer_ + kSlopBytes;\n      next_chunk_ = buffer_;\n      auto ptr = buffer_ + 2 * kSlopBytes - size;\n      std::memcpy(ptr, data, size);\n      return ptr;\n    }\n  }\n  overall_limit_ = 0;\n  next_chunk_ = nullptr;\n  size_ = 0;\n  limit_end_ = buffer_end_ = buffer_;\n  return buffer_;\n}","filepath":"src/google/protobuf/parse_context.cc","line_number":250,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270557424":{"score":0.6834413,"function_name":"EpsCopyInputStream::NextBuffer","code":"const char* EpsCopyInputStream::NextBuffer(int overrun, int depth) {\n  if (next_chunk_ == nullptr) return nullptr;  // We've reached end of stream.\n  if (next_chunk_ != buffer_) {\n    GOOGLE_DCHECK(size_ \u003e kSlopBytes);\n    // The chunk is large enough to be used directly\n    buffer_end_ = next_chunk_ + size_ - kSlopBytes;\n    auto res = next_chunk_;\n    next_chunk_ = buffer_;\n    if (aliasing_ == kOnPatch) aliasing_ = kNoDelta;\n    return res;\n  }\n  // Move the slop bytes of previous buffer to start of the patch buffer.\n  // Note we must use memmove because the previous buffer could be part of\n  // buffer_.\n  std::memmove(buffer_, buffer_end_, kSlopBytes);\n  if (overall_limit_ \u003e 0 \u0026\u0026\n      (depth \u003c 0 || !ParseEndsInSlopRegion(buffer_, overrun, depth))) {\n    const void* data;\n    // ZeroCopyInputStream indicates Next may return 0 size buffers. Hence\n    // we loop.\n    while (StreamNext(\u0026data)) {\n      if (size_ \u003e kSlopBytes) {\n        // We got a large chunk\n        std::memcpy(buffer_ + kSlopBytes, data, kSlopBytes);\n        next_chunk_ = static_cast\u003cconst char*\u003e(data);\n        buffer_end_ = buffer_ + kSlopBytes;\n        if (aliasing_ \u003e= kNoDelta) aliasing_ = kOnPatch;\n        return buffer_;\n      } else if (size_ \u003e 0) {\n        std::memcpy(buffer_ + kSlopBytes, data, size_);\n        next_chunk_ = buffer_;\n        buffer_end_ = buffer_ + size_;\n        if (aliasing_ \u003e= kNoDelta) aliasing_ = kOnPatch;\n        return buffer_;\n      }\n      GOOGLE_DCHECK(size_ == 0) \u003c\u003c size_;\n    }\n    overall_limit_ = 0;  // Next failed, no more needs for next\n  }\n  // End of stream or array\n  if (aliasing_ == kNoDelta) {\n    // If there is no more block and aliasing is true, the previous block\n    // is still valid and we can alias. We have users relying on string_view's\n    // obtained from protos to outlive the proto, when the parse was from an\n    // array. This guarantees string_view's are always aliased if parsed from\n    // an array.\n    aliasing_ = reinterpret_cast\u003cstd::uintptr_t\u003e(buffer_end_) -\n                reinterpret_cast\u003cstd::uintptr_t\u003e(buffer_);\n  }\n  next_chunk_ = nullptr;\n  buffer_end_ = buffer_ + kSlopBytes;\n  size_ = 0;\n  return buffer_;\n}","filepath":"src/google/protobuf/parse_context.cc","line_number":102,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270558768":{"score":0.70700705,"function_name":"ParseContext::ParseMessage","code":"const char* ParseContext::ParseMessage(MessageLite* msg, const char* ptr) {\n  int old;\n  ptr = ReadSizeAndPushLimitAndDepth(ptr, \u0026old);\n  ptr = ptr ? msg-\u003e_InternalParse(ptr, this) : nullptr;\n  depth_++;\n  if (!PopLimit(old)) return nullptr;\n  return ptr;\n}","filepath":"src/google/protobuf/parse_context.cc","line_number":291,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270558880":{"score":0.7210977,"function_name":"ParseContext::ReadSizeAndPushLimitAndDepth","code":"const char* ParseContext::ReadSizeAndPushLimitAndDepth(const char* ptr,\n                                                       int* old_limit) {\n  int size = ReadSize(\u0026ptr);\n  if (PROTOBUF_PREDICT_FALSE(!ptr)) {\n    *old_limit = 0;  // Make sure this isn't uninitialized even on error return\n    return nullptr;\n  }\n  *old_limit = PushLimit(ptr, size);\n  if (--depth_ \u003c 0) return nullptr;\n  return ptr;\n}","filepath":"src/google/protobuf/parse_context.cc","line_number":279,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270559024":{"score":0.5570063,"function_name":"ReadSizeFallback","code":"std::pair\u003cconst char*, int32_t\u003e ReadSizeFallback(const char* p, uint32_t res) {\n  for (std::uint32_t i = 1; i \u003c 4; i++) {\n    uint32_t byte = static_cast\u003cuint8_t\u003e(p[i]);\n    res += (byte - 1) \u003c\u003c (7 * i);\n    if (PROTOBUF_PREDICT_TRUE(byte \u003c 128)) {\n      return {p + i + 1, res};\n    }\n  }\n  std::uint32_t byte = static_cast\u003cuint8_t\u003e(p[4]);\n  if (PROTOBUF_PREDICT_FALSE(byte \u003e= 8)) return {nullptr, 0};  // size \u003e= 2gb\n  res += (byte - 1) \u003c\u003c 28;\n  // Protect against sign integer overflow in PushLimit. Limits are relative\n  // to buffer ends and ptr could potential be kSlopBytes beyond a buffer end.\n  // To protect against overflow we reject limits absurdly close to INT_MAX.\n  if (PROTOBUF_PREDICT_FALSE(res \u003e INT_MAX - ParseContext::kSlopBytes)) {\n    return {nullptr, 0};\n  }\n  return {p + 5, res};\n}","filepath":"src/google/protobuf/parse_context.cc","line_number":363,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270559152":{"score":0.67293406,"function_name":"EpsCopyInputStream::ReadStringFallback","code":"const char* EpsCopyInputStream::ReadStringFallback(const char* ptr, int size,\n                                                   std::string* str) {\n  str-\u003eclear();\n  if (PROTOBUF_PREDICT_TRUE(size \u003c= buffer_end_ - ptr + limit_)) {\n    // Reserve the string up to a static safe size. If strings are bigger than\n    // this we proceed by growing the string as needed. This protects against\n    // malicious payloads making protobuf hold on to a lot of memory.\n    str-\u003ereserve(str-\u003esize() + std::min\u003cint\u003e(size, kSafeStringSize));\n  }\n  return AppendSize(ptr, size,\n                    [str](const char* p, int s) { str-\u003eappend(p, s); });\n}","filepath":"src/google/protobuf/parse_context.cc","line_number":211,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270559456":{"score":0.61182,"function_name":"VarintParseSlow32","code":"std::pair\u003cconst char*, uint32_t\u003e VarintParseSlow32(const char* p,\n                                                   uint32_t res) {\n  for (std::uint32_t i = 2; i \u003c 5; i++) {\n    uint32_t byte = static_cast\u003cuint8_t\u003e(p[i]);\n    res += (byte - 1) \u003c\u003c (7 * i);\n    if (PROTOBUF_PREDICT_TRUE(byte \u003c 128)) {\n      return {p + i + 1, res};\n    }\n  }\n  // Accept \u003e5 bytes\n  for (std::uint32_t i = 5; i \u003c 10; i++) {\n    uint32_t byte = static_cast\u003cuint8_t\u003e(p[i]);\n    if (PROTOBUF_PREDICT_TRUE(byte \u003c 128)) {\n      return {p + i + 1, res};\n    }\n  }\n  return {nullptr, 0};\n}","filepath":"src/google/protobuf/parse_context.cc","line_number":320,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270559728":{"score":0.61114323,"function_name":"WriteVarint","code":"inline void WriteVarint(uint64_t val, std::string* s) {\n  while (val \u003e= 128) {\n    uint8_t c = val | 0x80;\n    s-\u003epush_back(c);\n    val \u003e\u003e= 7;\n  }\n  s-\u003epush_back(val);\n}","filepath":"src/google/protobuf/parse_context.cc","line_number":300,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270564688":{"score":0.6662973,"function_name":"operator()","code":"void operator()(const FieldDescriptor* field, FromType* from, ToType* to) {\n    switch (field-\u003ecpp_type()) {\n      case FieldDescriptor::CPPTYPE_INT32:\n        to-\u003eSetInt32(from-\u003eGetInt32());\n        break;\n      case FieldDescriptor::CPPTYPE_INT64:\n        to-\u003eSetInt64(from-\u003eGetInt64());\n        break;\n      case FieldDescriptor::CPPTYPE_UINT32:\n        to-\u003eSetUint32(from-\u003eGetUint32());\n        break;\n      case FieldDescriptor::CPPTYPE_UINT64:\n        to-\u003eSetUint64(from-\u003eGetUint64());\n        break;\n      case FieldDescriptor::CPPTYPE_FLOAT:\n        to-\u003eSetFloat(from-\u003eGetFloat());\n        break;\n      case FieldDescriptor::CPPTYPE_DOUBLE:\n        to-\u003eSetDouble(from-\u003eGetDouble());\n        break;\n      case FieldDescriptor::CPPTYPE_BOOL:\n        to-\u003eSetBool(from-\u003eGetBool());\n        break;\n      case FieldDescriptor::CPPTYPE_ENUM:\n        to-\u003eSetEnum(from-\u003eGetEnum());\n        break;\n      case FieldDescriptor::CPPTYPE_MESSAGE:\n        if (!unsafe_shallow_swap) {\n          to-\u003eSetMessage(from-\u003eGetMessage());\n        } else {\n          to-\u003eUnsafeSetMessage(from-\u003eUnsafeGetMessage());\n        }\n        break;\n      case FieldDescriptor::CPPTYPE_STRING:\n        if (!unsafe_shallow_swap) {\n          to-\u003eSetString(from-\u003eGetString());\n          break;\n        }\n        switch (field-\u003eoptions().ctype()) {\n          default:\n          case FieldOptions::STRING: {\n            to-\u003eSetArenaStringPtr(from-\u003eGetArenaStringPtr());\n            break;\n          }\n        }\n        break;\n      default:\n        GOOGLE_LOG(FATAL) \u003c\u003c \"unimplemented type: \" \u003c\u003c field-\u003ecpp_type();\n    }\n    if (unsafe_shallow_swap) {\n      // Not clearing oneof case after move may cause unwanted \"ClearOneof\"\n      // where the residual message or string value is deleted and causes\n      // use-after-free (only for unsafe swap).\n      from-\u003eClearOneofCase();\n    }\n  }","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":400,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270569584":{"score":0.5776497,"function_name":"SwapFieldHelper::SwapInlinedStrings","code":"void SwapFieldHelper::SwapInlinedStrings(const Reflection* r, Message* lhs,\n                                         Message* rhs,\n                                         const FieldDescriptor* field) {\n  // Inlined string field.\n  Arena* lhs_arena = lhs-\u003eGetArenaForAllocation();\n  Arena* rhs_arena = rhs-\u003eGetArenaForAllocation();\n  auto* lhs_string = r-\u003eMutableRaw\u003cInlinedStringField\u003e(lhs, field);\n  auto* rhs_string = r-\u003eMutableRaw\u003cInlinedStringField\u003e(rhs, field);\n  const uint32 index = r-\u003eschema_.InlinedStringIndex(field);\n  uint32* lhs_state = \u0026r-\u003eMutableInlinedStringDonatedArray(lhs)[index / 32];\n  uint32* rhs_state = \u0026r-\u003eMutableInlinedStringDonatedArray(rhs)[index / 32];\n  const uint32 mask = ~(static_cast\u003cuint32\u003e(1) \u003c\u003c (index % 32));\n  if (unsafe_shallow_swap || lhs_arena == rhs_arena) {\n    lhs_string-\u003eSwap(rhs_string, /*default_value=*/nullptr, lhs_arena,\n                     r-\u003eIsInlinedStringDonated(*lhs, field),\n                     r-\u003eIsInlinedStringDonated(*rhs, field),\n                     /*donating_states=*/lhs_state, rhs_state, mask);\n  } else {\n    const std::string temp = lhs_string-\u003eGet();\n    lhs_string-\u003eSet(nullptr, rhs_string-\u003eGet(), lhs_arena,\n                    r-\u003eIsInlinedStringDonated(*lhs, field), lhs_state, mask);\n    rhs_string-\u003eSet(nullptr, temp, rhs_arena,\n                    r-\u003eIsInlinedStringDonated(*rhs, field), rhs_state, mask);\n  }\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":519,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270575344":{"score":0.6467447,"function_name":"AddDescriptorsImpl","code":"void AddDescriptorsImpl(const DescriptorTable* table) {\n  // Reflection refers to the default fields so make sure they are initialized.\n  internal::InitProtobufDefaults();\n\n  // Ensure all dependent descriptors are registered to the generated descriptor\n  // pool and message factory.\n  int num_deps = table-\u003enum_deps;\n  for (int i = 0; i \u003c num_deps; i++) {\n    // In case of weak fields deps[i] could be null.\n    if (table-\u003edeps[i]) AddDescriptors(table-\u003edeps[i]);\n  }\n\n  // Register the descriptor of this file.\n  DescriptorPool::InternalAddGeneratedFile(table-\u003edescriptor, table-\u003esize);\n  MessageFactory::InternalRegisterGeneratedFile(table);\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":2957,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270575440":{"score":0.6520672,"function_name":"Reflection::AddString","code":"void Reflection::AddString(Message* message, const FieldDescriptor* field,\n                           std::string value) const {\n  USAGE_CHECK_ALL(AddString, REPEATED, STRING);\n  if (field-\u003eis_extension()) {\n    MutableExtensionSet(message)-\u003eAddString(field-\u003enumber(), field-\u003etype(),\n                                            std::move(value), field);\n  } else {\n    switch (field-\u003eoptions().ctype()) {\n      default:  // TODO(kenton):  Support other string reps.\n      case FieldOptions::STRING:\n        AddField\u003cstd::string\u003e(message, field)-\u003eassign(std::move(value));\n        break;\n    }\n  }\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":1740,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270575792":{"score":0.7825339,"function_name":"Reflection::AddEnumValue","code":"void Reflection::AddEnumValue(Message* message, const FieldDescriptor* field,\n                              int value) const {\n  USAGE_CHECK_ALL(AddEnum, REPEATED, ENUM);\n  if (!CreateUnknownEnumValues(field)) {\n    // Check that the value is valid if we don't support direct storage of\n    // unknown enum values.\n    const EnumValueDescriptor* value_desc =\n        field-\u003eenum_type()-\u003eFindValueByNumber(value);\n    if (value_desc == nullptr) {\n      MutableUnknownFields(message)-\u003eAddVarint(field-\u003enumber(), value);\n      return;\n    }\n  }\n  AddEnumValueInternal(message, field, value);\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":1880,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270576048":{"score":0.5930228,"function_name":"Reflection::AddEnumValueInternal","code":"void Reflection::AddEnumValueInternal(Message* message,\n                                      const FieldDescriptor* field,\n                                      int value) const {\n  if (field-\u003eis_extension()) {\n    MutableExtensionSet(message)-\u003eAddEnum(field-\u003enumber(), field-\u003etype(),\n                                          field-\u003eoptions().packed(), value,\n                                          field);\n  } else {\n    AddField\u003cint\u003e(message, field, value);\n  }\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":1896,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270577008":{"score":0.8173419,"function_name":"Reflection::AddMessage","code":"Message* Reflection::AddMessage(Message* message, const FieldDescriptor* field,\n                                MessageFactory* factory) const {\n  USAGE_CHECK_ALL(AddMessage, REPEATED, MESSAGE);\n  CheckInvalidAccess(schema_, field);\n\n  if (factory == nullptr) factory = message_factory_;\n\n  if (field-\u003eis_extension()) {\n    return static_cast\u003cMessage*\u003e(\n        MutableExtensionSet(message)-\u003eAddMessage(field, factory));\n  } else {\n    Message* result = nullptr;\n\n    // We can't use AddField\u003cMessage\u003e() because RepeatedPtrFieldBase doesn't\n    // know how to allocate one.\n    RepeatedPtrFieldBase* repeated = nullptr;\n    if (IsMapFieldInApi(field)) {\n      repeated =\n          MutableRaw\u003cMapFieldBase\u003e(message, field)-\u003eMutableRepeatedField();\n    } else {\n      repeated = MutableRaw\u003cRepeatedPtrFieldBase\u003e(message, field);\n    }\n    result = repeated-\u003eAddFromCleared\u003cGenericTypeHandler\u003cMessage\u003e \u003e();\n    if (result == nullptr) {\n      // We must allocate a new object.\n      const Message* prototype;\n      if (repeated-\u003esize() == 0) {\n        prototype = factory-\u003eGetPrototype(field-\u003emessage_type());\n      } else {\n        prototype = \u0026repeated-\u003eGet\u003cGenericTypeHandler\u003cMessage\u003e \u003e(0);\n      }\n      result = prototype-\u003eNew(message-\u003eGetArenaForAllocation());\n      // We can guarantee here that repeated and result are either both heap\n      // allocated or arena owned. So it is safe to call the unsafe version\n      // of AddAllocated.\n      repeated-\u003eUnsafeArenaAddAllocated\u003cGenericTypeHandler\u003cMessage\u003e \u003e(result);\n    }\n\n    return result;\n  }\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":2159,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270578672":{"score":0.7964979,"function_name":"AssignDescriptorsImpl","code":"void AssignDescriptorsImpl(const DescriptorTable* table, bool eager) {\n  // Ensure the file descriptor is added to the pool.\n  {\n    // This only happens once per proto file. So a global mutex to serialize\n    // calls to AddDescriptors.\n    static WrappedMutex mu{GOOGLE_PROTOBUF_LINKER_INITIALIZED};\n    mu.Lock();\n    AddDescriptors(table);\n    mu.Unlock();\n  }\n  if (eager) {\n    // Normally we do not want to eagerly build descriptors of our deps.\n    // However if this proto is optimized for code size (ie using reflection)\n    // and it has a message extending a custom option of a descriptor with that\n    // message being optimized for code size as well. Building the descriptors\n    // in this file requires parsing the serialized file descriptor, which now\n    // requires parsing the message extension, which potentially requires\n    // building the descriptor of the message extending one of the options.\n    // However we are already updating descriptor pool under a lock. To prevent\n    // this the compiler statically looks for this case and we just make sure we\n    // first build the descriptors of all our dependencies, preventing the\n    // deadlock.\n    int num_deps = table-\u003enum_deps;\n    for (int i = 0; i \u003c num_deps; i++) {\n      // In case of weak fields deps[i] could be null.\n      if (table-\u003edeps[i]) AssignDescriptors(table-\u003edeps[i], true);\n    }\n  }\n\n  // Fill the arrays with pointers to descriptors and reflection classes.\n  const FileDescriptor* file =\n      DescriptorPool::internal_generated_pool()-\u003eFindFileByName(\n          table-\u003efilename);\n  GOOGLE_CHECK(file != nullptr);\n\n  MessageFactory* factory = MessageFactory::generated_factory();\n\n  AssignDescriptorsHelper helper(\n      factory, table-\u003efile_level_metadata, table-\u003efile_level_enum_descriptors,\n      table-\u003eschemas, table-\u003edefault_instances, table-\u003eoffsets);\n\n  for (int i = 0; i \u003c file-\u003emessage_type_count(); i++) {\n    helper.AssignMessageDescriptor(file-\u003emessage_type(i));\n  }\n\n  for (int i = 0; i \u003c file-\u003eenum_type_count(); i++) {\n    helper.AssignEnumDescriptor(file-\u003eenum_type(i));\n  }\n  if (file-\u003eoptions().cc_generic_services()) {\n    for (int i = 0; i \u003c file-\u003eservice_count(); i++) {\n      table-\u003efile_level_service_descriptors[i] = file-\u003eservice(i);\n    }\n  }\n  MetadataOwner::Instance()-\u003eAddArray(table-\u003efile_level_metadata,\n                                      helper.GetCurrentMetadataPtr());\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":2900,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270581280":{"score":0.62368786,"function_name":"Reflection::ClearOneof","code":"void Reflection::ClearOneof(Message* message,\n                            const OneofDescriptor* oneof_descriptor) const {\n  if (oneof_descriptor-\u003eis_synthetic()) {\n    ClearField(message, oneof_descriptor-\u003efield(0));\n    return;\n  }\n  // TODO(jieluo): Consider to cache the unused object instead of deleting\n  // it. It will be much faster if an application switches a lot from\n  // a few oneof fields.  Time/space tradeoff\n  uint32_t oneof_case = GetOneofCase(*message, oneof_descriptor);\n  if (oneof_case \u003e 0) {\n    const FieldDescriptor* field = descriptor_-\u003eFindFieldByNumber(oneof_case);\n    if (message-\u003eGetArenaForAllocation() == nullptr) {\n      switch (field-\u003ecpp_type()) {\n        case FieldDescriptor::CPPTYPE_STRING: {\n          switch (field-\u003eoptions().ctype()) {\n            default:  // TODO(kenton):  Support other string reps.\n            case FieldOptions::STRING: {\n              // Oneof string fields are never set as a default instance.\n              // We just need to pass some arbitrary default string to make it\n              // work. This allows us to not have the real default accessible\n              // from reflection.\n              MutableField\u003cArenaStringPtr\u003e(message, field)\n                  -\u003eDestroy(nullptr, message-\u003eGetArenaForAllocation());\n              break;\n            }\n          }\n          break;\n        }\n\n        case FieldDescriptor::CPPTYPE_MESSAGE:\n          delete *MutableRaw\u003cMessage*\u003e(message, field);\n          break;\n        default:\n          break;\n      }\n    }\n\n    *MutableOneofCase(message, oneof_descriptor) = 0;\n  }\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":2599,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270581680":{"score":0.7370915,"function_name":"Reflection::FieldSize","code":"int Reflection::FieldSize(const Message\u0026 message,\n                          const FieldDescriptor* field) const {\n  USAGE_CHECK_MESSAGE_TYPE(FieldSize);\n  USAGE_CHECK_REPEATED(FieldSize);\n  CheckInvalidAccess(schema_, field);\n\n  if (field-\u003eis_extension()) {\n    return GetExtensionSet(message).ExtensionSize(field-\u003enumber());\n  } else {\n    switch (field-\u003ecpp_type()) {\n#define HANDLE_TYPE(UPPERCASE, LOWERCASE)    \\\n  case FieldDescriptor::CPPTYPE_##UPPERCASE: \\\n    return GetRaw\u003cRepeatedField\u003cLOWERCASE\u003e \u003e(message, field).size()\n\n      HANDLE_TYPE(INT32, int32_t);\n      HANDLE_TYPE(INT64, int64_t);\n      HANDLE_TYPE(UINT32, uint32_t);\n      HANDLE_TYPE(UINT64, uint64_t);\n      HANDLE_TYPE(DOUBLE, double);\n      HANDLE_TYPE(FLOAT, float);\n      HANDLE_TYPE(BOOL, bool);\n      HANDLE_TYPE(ENUM, int);\n#undef HANDLE_TYPE\n\n      case FieldDescriptor::CPPTYPE_STRING:\n      case FieldDescriptor::CPPTYPE_MESSAGE:\n        if (IsMapFieldInApi(field)) {\n          const internal::MapFieldBase\u0026 map =\n              GetRaw\u003cMapFieldBase\u003e(message, field);\n          if (map.IsRepeatedFieldValid()) {\n            return map.GetRepeatedField().size();\n          } else {\n            // No need to materialize the repeated field if it is out of sync:\n            // its size will be the same as the map's size.\n            return map.size();\n          }\n        } else {\n          return GetRaw\u003cRepeatedPtrFieldBase\u003e(message, field).size();\n        }\n    }\n\n    GOOGLE_LOG(FATAL) \u003c\u003c \"Can't get here.\";\n    return 0;\n  }\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":1123,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270582672":{"score":0.6082907,"function_name":"Reflection::GetDefaultMessageInstance","code":"const Message* Reflection::GetDefaultMessageInstance(\n    const FieldDescriptor* field) const {\n  // If we are using the generated factory, we cache the prototype in the field\n  // descriptor for faster access.\n  // The default instances of generated messages are not cross-linked, which\n  // means they contain null pointers on their message fields and can't be used\n  // to get the default of submessages.\n  if (message_factory_ == MessageFactory::generated_factory()) {\n    auto\u0026 ptr = field-\u003edefault_generated_instance_;\n    auto* res = ptr.load(std::memory_order_acquire);\n    if (res == nullptr) {\n      // First time asking for this field's default. Load it and cache it.\n      res = message_factory_-\u003eGetPrototype(field-\u003emessage_type());\n      ptr.store(res, std::memory_order_release);\n    }\n    return res;\n  }\n\n  // For other factories, we try the default's object field.\n  // In particular, the DynamicMessageFactory will cross link the default\n  // instances to allow for this. But only do this for real fields.\n  // This is an optimization to avoid going to GetPrototype() below, as that\n  // requires a lock and a map lookup.\n  if (!field-\u003eis_extension() \u0026\u0026 !field-\u003eoptions().weak() \u0026\u0026\n      !IsLazyField(field) \u0026\u0026 !schema_.InRealOneof(field)) {\n    auto* res = DefaultRaw\u003cconst Message*\u003e(field);\n    if (res != nullptr) {\n      return res;\n    }\n  }\n  // Otherwise, just go to the factory.\n  return message_factory_-\u003eGetPrototype(field-\u003emessage_type());\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":1910,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270583248":{"score":0.7550479,"function_name":"Reflection::GetEnumValue","code":"int Reflection::GetEnumValue(const Message\u0026 message,\n                             const FieldDescriptor* field) const {\n  USAGE_CHECK_ALL(GetEnumValue, SINGULAR, ENUM);\n\n  int32_t value;\n  if (field-\u003eis_extension()) {\n    value = GetExtensionSet(message).GetEnum(\n        field-\u003enumber(), field-\u003edefault_value_enum()-\u003enumber());\n  } else if (schema_.InRealOneof(field) \u0026\u0026 !HasOneofField(message, field)) {\n    value = field-\u003edefault_value_enum()-\u003enumber();\n  } else {\n    value = GetField\u003cint\u003e(message, field);\n  }\n  return value;\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":1766,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270584912":{"score":0.726804,"function_name":"Reflection::MutableRepeatedMessage","code":"Message* Reflection::MutableRepeatedMessage(Message* message,\n                                            const FieldDescriptor* field,\n                                            int index) const {\n  USAGE_CHECK_ALL(MutableRepeatedMessage, REPEATED, MESSAGE);\n  CheckInvalidAccess(schema_, field);\n\n  if (field-\u003eis_extension()) {\n    return static_cast\u003cMessage*\u003e(\n        MutableExtensionSet(message)-\u003eMutableRepeatedMessage(field-\u003enumber(),\n                                                             index));\n  } else {\n    if (IsMapFieldInApi(field)) {\n      return MutableRaw\u003cMapFieldBase\u003e(message, field)\n          -\u003eMutableRepeatedField()\n          -\u003eMutable\u003cGenericTypeHandler\u003cMessage\u003e \u003e(index);\n    } else {\n      return MutableRaw\u003cRepeatedPtrFieldBase\u003e(message, field)\n          -\u003eMutable\u003cGenericTypeHandler\u003cMessage\u003e \u003e(index);\n    }\n  }\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":2137,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270585264":{"score":0.6029314,"function_name":"Reflection::GetOneofFieldDescriptor","code":"const FieldDescriptor* Reflection::GetOneofFieldDescriptor(\n    const Message\u0026 message, const OneofDescriptor* oneof_descriptor) const {\n  if (oneof_descriptor-\u003eis_synthetic()) {\n    const FieldDescriptor* field = oneof_descriptor-\u003efield(0);\n    return HasField(message, field) ? field : nullptr;\n  }\n  uint32_t field_number = GetOneofCase(message, oneof_descriptor);\n  if (field_number == 0) {\n    return nullptr;\n  }\n  return descriptor_-\u003eFindFieldByNumber(field_number);\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":2301,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270585408":{"score":0.88070786,"function_name":"Reflection::GetRawRepeatedField","code":"const void* Reflection::GetRawRepeatedField(const Message\u0026 message,\n                                            const FieldDescriptor* field,\n                                            FieldDescriptor::CppType cpptype,\n                                            int ctype,\n                                            const Descriptor* desc) const {\n  USAGE_CHECK_REPEATED(\"GetRawRepeatedField\");\n  if (field-\u003ecpp_type() != cpptype)\n    ReportReflectionUsageTypeError(descriptor_, field, \"GetRawRepeatedField\",\n                                   cpptype);\n  if (ctype \u003e= 0)\n    GOOGLE_CHECK_EQ(field-\u003eoptions().ctype(), ctype) \u003c\u003c \"subtype mismatch\";\n  if (desc != nullptr)\n    GOOGLE_CHECK_EQ(field-\u003emessage_type(), desc) \u003c\u003c \"wrong submessage type\";\n  if (field-\u003eis_extension()) {\n    // Should use extension_set::GetRawRepeatedField. However, the required\n    // parameter \"default repeated value\" is not very easy to get here.\n    // Map is not supported in extensions, it is acceptable to use\n    // extension_set::MutableRawRepeatedField which does not change the message.\n    return MutableExtensionSet(const_cast\u003cMessage*\u003e(\u0026message))\n        -\u003eMutableRawRepeatedField(field-\u003enumber(), field-\u003etype(),\n                                  field-\u003eis_packed(), field);\n  } else {\n    // Trigger transform for MapField\n    if (IsMapFieldInApi(field)) {\n      return \u0026(GetRawNonOneof\u003cMapFieldBase\u003e(message, field).GetRepeatedField());\n    }\n    return \u0026GetRawNonOneof\u003cchar\u003e(message, field);\n  }\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":2271,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270586464":{"score":0.84648824,"function_name":"Reflection::GetRepeatedEnumValue","code":"int Reflection::GetRepeatedEnumValue(const Message\u0026 message,\n                                     const FieldDescriptor* field,\n                                     int index) const {\n  USAGE_CHECK_ALL(GetRepeatedEnumValue, REPEATED, ENUM);\n\n  int value;\n  if (field-\u003eis_extension()) {\n    value = GetExtensionSet(message).GetRepeatedEnum(field-\u003enumber(), index);\n  } else {\n    value = GetRepeatedField\u003cint\u003e(message, field, index);\n  }\n  return value;\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":1823,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270587360":{"score":0.8396872,"function_name":"Reflection::GetRepeatedMessage","code":"const Message\u0026 Reflection::GetRepeatedMessage(const Message\u0026 message,\n                                              const FieldDescriptor* field,\n                                              int index) const {\n  USAGE_CHECK_ALL(GetRepeatedMessage, REPEATED, MESSAGE);\n  CheckInvalidAccess(schema_, field);\n\n  if (field-\u003eis_extension()) {\n    return static_cast\u003cconst Message\u0026\u003e(\n        GetExtensionSet(message).GetRepeatedMessage(field-\u003enumber(), index));\n  } else {\n    if (IsMapFieldInApi(field)) {\n      return GetRaw\u003cMapFieldBase\u003e(message, field)\n          .GetRepeatedField()\n          .Get\u003cGenericTypeHandler\u003cMessage\u003e \u003e(index);\n    } else {\n      return GetRaw\u003cRepeatedPtrFieldBase\u003e(message, field)\n          .Get\u003cGenericTypeHandler\u003cMessage\u003e \u003e(index);\n    }\n  }\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":2116,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270587664":{"score":0.6586021,"function_name":"Reflection::GetRepeatedString","code":"std::string Reflection::GetRepeatedString(const Message\u0026 message,\n                                          const FieldDescriptor* field,\n                                          int index) const {\n  USAGE_CHECK_ALL(GetRepeatedString, REPEATED, STRING);\n  if (field-\u003eis_extension()) {\n    return GetExtensionSet(message).GetRepeatedString(field-\u003enumber(), index);\n  } else {\n    switch (field-\u003eoptions().ctype()) {\n      default:  // TODO(kenton):  Support other string reps.\n      case FieldOptions::STRING:\n        return GetRepeatedPtrField\u003cstd::string\u003e(message, field, index);\n    }\n  }\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":1689,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270587952":{"score":0.8394723,"function_name":"Reflection::GetRepeatedStringReference","code":"const std::string\u0026 Reflection::GetRepeatedStringReference(\n    const Message\u0026 message, const FieldDescriptor* field, int index,\n    std::string* scratch) const {\n  (void)scratch;  // Parameter is used by Google-internal code.\n  USAGE_CHECK_ALL(GetRepeatedStringReference, REPEATED, STRING);\n  if (field-\u003eis_extension()) {\n    return GetExtensionSet(message).GetRepeatedString(field-\u003enumber(), index);\n  } else {\n    switch (field-\u003eoptions().ctype()) {\n      default:  // TODO(kenton):  Support other string reps.\n      case FieldOptions::STRING:\n        return GetRepeatedPtrField\u003cstd::string\u003e(message, field, index);\n    }\n  }\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":1704,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270589008":{"score":0.7056118,"function_name":"Reflection::GetStringReference","code":"const std::string\u0026 Reflection::GetStringReference(const Message\u0026 message,\n                                                  const FieldDescriptor* field,\n                                                  std::string* scratch) const {\n  (void)scratch;  // Parameter is used by Google-internal code.\n  USAGE_CHECK_ALL(GetStringReference, SINGULAR, STRING);\n  if (field-\u003eis_extension()) {\n    return GetExtensionSet(message).GetString(field-\u003enumber(),\n                                              field-\u003edefault_value_string());\n  } else {\n    if (schema_.InRealOneof(field) \u0026\u0026 !HasOneofField(message, field)) {\n      return field-\u003edefault_value_string();\n    }\n    switch (field-\u003eoptions().ctype()) {\n      default:  // TODO(kenton):  Support other string reps.\n      case FieldOptions::STRING: {\n        if (IsInlined(field)) {\n          return GetField\u003cInlinedStringField\u003e(message, field).GetNoArena();\n        }\n\n        if (auto* value =\n                GetField\u003cArenaStringPtr\u003e(message, field).GetPointer()) {\n          return *value;\n        }\n        return field-\u003edefault_value_string();\n      }\n    }\n  }\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":1615,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270590592":{"score":0.69092023,"function_name":"Reflection::HasBit","code":"bool Reflection::HasBit(const Message\u0026 message,\n                        const FieldDescriptor* field) const {\n  GOOGLE_DCHECK(!field-\u003eoptions().weak());\n  if (schema_.HasBitIndex(field) != static_cast\u003cuint32_t\u003e(-1)) {\n    return IsIndexInHasBitSet(GetHasBits(message), schema_.HasBitIndex(field));\n  }\n\n  // Intentionally check here because HasBitIndex(field) != -1 means valid.\n  CheckInvalidAccess(schema_, field);\n\n  // proto3: no has-bits. All fields present except messages, which are\n  // present only if their message-field pointer is non-null.\n  if (field-\u003ecpp_type() == FieldDescriptor::CPPTYPE_MESSAGE) {\n    return !schema_.IsDefaultInstance(message) \u0026\u0026\n           GetRaw\u003cconst Message*\u003e(message, field) != nullptr;\n  } else {\n    // Non-message field (and non-oneof, since that was handled in HasField()\n    // before calling us), and singular (again, checked in HasField). So, this\n    // field must be a scalar.\n\n    // Scalar primitive (numeric or string/bytes) fields are present if\n    // their value is non-zero (numeric) or non-empty (string/bytes). N.B.:\n    // we must use this definition here, rather than the \"scalar fields\n    // always present\" in the proto3 docs, because MergeFrom() semantics\n    // require presence as \"present on wire\", and reflection-based merge\n    // (which uses HasField()) needs to be consistent with this.\n    switch (field-\u003ecpp_type()) {\n      case FieldDescriptor::CPPTYPE_STRING:\n        switch (field-\u003eoptions().ctype()) {\n          default: {\n            if (IsInlined(field)) {\n              return !GetField\u003cInlinedStringField\u003e(message, field)\n                          .GetNoArena()\n                          .empty();\n            }\n\n            return GetField\u003cArenaStringPtr\u003e(message, field).Get().size() \u003e 0;\n          }\n        }\n        return false;\n      case FieldDescriptor::CPPTYPE_BOOL:\n        return GetRaw\u003cbool\u003e(message, field) != false;\n      case FieldDescriptor::CPPTYPE_INT32:\n        return GetRaw\u003cint32_t\u003e(message, field) != 0;\n      case FieldDescriptor::CPPTYPE_INT64:\n        return GetRaw\u003cint64_t\u003e(message, field) != 0;\n      case FieldDescriptor::CPPTYPE_UINT32:\n        return GetRaw\u003cuint32_t\u003e(message, field) != 0;\n      case FieldDescriptor::CPPTYPE_UINT64:\n        return GetRaw\u003cuint64_t\u003e(message, field) != 0;\n      case FieldDescriptor::CPPTYPE_FLOAT:\n        static_assert(sizeof(uint32_t) == sizeof(float),\n                      \"Code assumes uint32_t and float are the same size.\");\n        return GetRaw\u003cuint32_t\u003e(message, field) != 0;\n      case FieldDescriptor::CPPTYPE_DOUBLE:\n        static_assert(sizeof(uint64_t) == sizeof(double),\n                      \"Code assumes uint64_t and double are the same size.\");\n        return GetRaw\u003cuint64_t\u003e(message, field) != 0;\n      case FieldDescriptor::CPPTYPE_ENUM:\n        return GetRaw\u003cint\u003e(message, field) != 0;\n      case FieldDescriptor::CPPTYPE_MESSAGE:\n        // handled above; avoid warning\n        break;\n    }\n    GOOGLE_LOG(FATAL) \u003c\u003c \"Reached impossible case in HasBit().\";\n    return false;\n  }\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":2474,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270591456":{"score":0.69642794,"function_name":"Reflection::ListFieldsMayFailOnStripped","code":"void Reflection::ListFieldsMayFailOnStripped(\n    const Message\u0026 message, bool should_fail,\n    std::vector\u003cconst FieldDescriptor*\u003e* output) const {\n  output-\u003eclear();\n\n  // Optimization:  The default instance never has any fields set.\n  if (schema_.IsDefaultInstance(message)) return;\n\n  // Optimization: Avoid calling GetHasBits() and HasOneofField() many times\n  // within the field loop.  We allow this violation of ReflectionSchema\n  // encapsulation because this function takes a noticeable about of CPU\n  // fleetwide and properly allowing this optimization through public interfaces\n  // seems more trouble than it is worth.\n  const uint32_t* const has_bits =\n      schema_.HasHasbits() ? GetHasBits(message) : nullptr;\n  const uint32_t* const has_bits_indices = schema_.has_bit_indices_;\n  output-\u003ereserve(descriptor_-\u003efield_count());\n  const int last_non_weak_field_index = last_non_weak_field_index_;\n  for (int i = 0; i \u003c= last_non_weak_field_index; i++) {\n    const FieldDescriptor* field = descriptor_-\u003efield(i);\n    if (!should_fail \u0026\u0026 schema_.IsFieldStripped(field)) {\n      continue;\n    }\n    if (field-\u003eis_repeated()) {\n      if (FieldSize(message, field) \u003e 0) {\n        output-\u003epush_back(field);\n      }\n    } else {\n      const OneofDescriptor* containing_oneof = field-\u003econtaining_oneof();\n      if (schema_.InRealOneof(field)) {\n        const uint32_t* const oneof_case_array =\n            GetConstPointerAtOffset\u003cuint32_t\u003e(\u0026message,\n                                              schema_.oneof_case_offset_);\n        // Equivalent to: HasOneofField(message, field)\n        if (static_cast\u003cint64_t\u003e(oneof_case_array[containing_oneof-\u003eindex()]) ==\n            field-\u003enumber()) {\n          output-\u003epush_back(field);\n        }\n      } else if (has_bits \u0026\u0026 has_bits_indices[i] != static_cast\u003cuint32_t\u003e(-1)) {\n        CheckInvalidAccess(schema_, field);\n        // Equivalent to: HasBit(message, field)\n        if (IsIndexInHasBitSet(has_bits, has_bits_indices[i])) {\n          output-\u003epush_back(field);\n        }\n      } else if (HasBit(message, field)) {  // Fall back on proto3-style HasBit.\n        output-\u003epush_back(field);\n      }\n    }\n  }\n  if (schema_.HasExtensionSet()) {\n    GetExtensionSet(message).AppendToList(descriptor_, descriptor_pool_,\n                                          output);\n  }\n\n  // ListFields() must sort output by field number.\n  std::sort(output-\u003ebegin(), output-\u003eend(), FieldNumberSorter());\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":1446,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270592032":{"score":0.6525134,"function_name":"Reflection::LookupMapValue","code":"bool Reflection::LookupMapValue(const Message\u0026 message,\n                                const FieldDescriptor* field, const MapKey\u0026 key,\n                                MapValueConstRef* val) const {\n  USAGE_CHECK(IsMapFieldInApi(field), \"LookupMapValue\",\n              \"Field is not a map field.\");\n  val-\u003eSetType(field-\u003emessage_type()-\u003eFindFieldByName(\"value\")-\u003ecpp_type());\n  return GetRaw\u003cMapFieldBase\u003e(message, field).LookupMapValue(key, val);\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":2333,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270592960":{"score":0.7407993,"function_name":"Reflection::MutableMessage","code":"Message* Reflection::MutableMessage(Message* message,\n                                    const FieldDescriptor* field,\n                                    MessageFactory* factory) const {\n  USAGE_CHECK_ALL(MutableMessage, SINGULAR, MESSAGE);\n  CheckInvalidAccess(schema_, field);\n\n  if (factory == nullptr) factory = message_factory_;\n\n  if (field-\u003eis_extension()) {\n    return static_cast\u003cMessage*\u003e(\n        MutableExtensionSet(message)-\u003eMutableMessage(field, factory));\n  } else {\n    Message* result;\n\n    Message** result_holder = MutableRaw\u003cMessage*\u003e(message, field);\n\n    if (schema_.InRealOneof(field)) {\n      if (!HasOneofField(*message, field)) {\n        ClearOneof(message, field-\u003econtaining_oneof());\n        result_holder = MutableField\u003cMessage*\u003e(message, field);\n        const Message* default_message = GetDefaultMessageInstance(field);\n        *result_holder = default_message-\u003eNew(message-\u003eGetArenaForAllocation());\n      }\n    } else {\n      SetBit(message, field);\n    }\n\n    if (*result_holder == nullptr) {\n      const Message* default_message = GetDefaultMessageInstance(field);\n      *result_holder = default_message-\u003eNew(message-\u003eGetArenaForAllocation());\n    }\n    result = *result_holder;\n    return result;\n  }\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":1967,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270593408":{"score":0.8471083,"function_name":"Reflection::MutableRawRepeatedField","code":"void* Reflection::MutableRawRepeatedField(Message* message,\n                                          const FieldDescriptor* field,\n                                          FieldDescriptor::CppType cpptype,\n                                          int ctype,\n                                          const Descriptor* desc) const {\n  (void)ctype;  // Parameter is used by Google-internal code.\n  USAGE_CHECK_REPEATED(\"MutableRawRepeatedField\");\n  CheckInvalidAccess(schema_, field);\n\n  if (field-\u003ecpp_type() != cpptype \u0026\u0026\n      (field-\u003ecpp_type() != FieldDescriptor::CPPTYPE_ENUM ||\n       cpptype != FieldDescriptor::CPPTYPE_INT32))\n    ReportReflectionUsageTypeError(descriptor_, field,\n                                   \"MutableRawRepeatedField\", cpptype);\n  if (desc != nullptr)\n    GOOGLE_CHECK_EQ(field-\u003emessage_type(), desc) \u003c\u003c \"wrong submessage type\";\n  if (field-\u003eis_extension()) {\n    return MutableExtensionSet(message)-\u003eMutableRawRepeatedField(\n        field-\u003enumber(), field-\u003etype(), field-\u003eis_packed(), field);\n  } else {\n    // Trigger transform for MapField\n    if (IsMapFieldInApi(field)) {\n      return MutableRawNonOneof\u003cMapFieldBase\u003e(message, field)\n          -\u003eMutableRepeatedField();\n    }\n    return MutableRawNonOneof\u003cvoid\u003e(message, field);\n  }\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":2242,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270594224":{"score":0.79123425,"function_name":"Reflection::RepeatedFieldData","code":"void* Reflection::RepeatedFieldData(Message* message,\n                                    const FieldDescriptor* field,\n                                    FieldDescriptor::CppType cpp_type,\n                                    const Descriptor* message_type) const {\n  GOOGLE_CHECK(field-\u003eis_repeated());\n  GOOGLE_CHECK(field-\u003ecpp_type() == cpp_type ||\n        (field-\u003ecpp_type() == FieldDescriptor::CPPTYPE_ENUM \u0026\u0026\n         cpp_type == FieldDescriptor::CPPTYPE_INT32))\n      \u003c\u003c \"The type parameter T in RepeatedFieldRef\u003cT\u003e API doesn't match \"\n      \u003c\u003c \"the actual field type (for enums T should be the generated enum \"\n      \u003c\u003c \"type or int32_t).\";\n  if (message_type != nullptr) {\n    GOOGLE_CHECK_EQ(message_type, field-\u003emessage_type());\n  }\n  if (field-\u003eis_extension()) {\n    return MutableExtensionSet(message)-\u003eMutableRawRepeatedField(\n        field-\u003enumber(), field-\u003etype(), field-\u003eis_packed(), field);\n  } else {\n    return MutableRawNonOneof\u003cchar\u003e(message, field);\n  }\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":2752,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270594816":{"score":0.82730734,"function_name":"ReportReflectionUsageEnumTypeError","code":"static void ReportReflectionUsageEnumTypeError(\n    const Descriptor* descriptor, const FieldDescriptor* field,\n    const char* method, const EnumValueDescriptor* value) {\n  GOOGLE_LOG(FATAL) \u003c\u003c \"Protocol Buffer reflection usage error:\\n\"\n                \"  Method      : google::protobuf::Reflection::\"\n             \u003c\u003c method\n             \u003c\u003c \"\\n\"\n                \"  Message type: \"\n             \u003c\u003c descriptor-\u003efull_name()\n             \u003c\u003c \"\\n\"\n                \"  Field       : \"\n             \u003c\u003c field-\u003efull_name()\n             \u003c\u003c \"\\n\"\n                \"  Problem     : Enum value did not match field type:\\n\"\n                \"    Expected  : \"\n             \u003c\u003c field-\u003eenum_type()-\u003efull_name()\n             \u003c\u003c \"\\n\"\n                \"    Actual    : \"\n             \u003c\u003c value-\u003efull_name();\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":168,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270595088":{"score":0.81042874,"function_name":"ReportReflectionUsageTypeError","code":"static void ReportReflectionUsageTypeError(\n    const Descriptor* descriptor, const FieldDescriptor* field,\n    const char* method, FieldDescriptor::CppType expected_type) {\n  GOOGLE_LOG(FATAL)\n      \u003c\u003c \"Protocol Buffer reflection usage error:\\n\"\n         \"  Method      : google::protobuf::Reflection::\"\n      \u003c\u003c method\n      \u003c\u003c \"\\n\"\n         \"  Message type: \"\n      \u003c\u003c descriptor-\u003efull_name()\n      \u003c\u003c \"\\n\"\n         \"  Field       : \"\n      \u003c\u003c field-\u003efull_name()\n      \u003c\u003c \"\\n\"\n         \"  Problem     : Field is not the right type for this message:\\n\"\n         \"    Expected  : \"\n      \u003c\u003c cpptype_names_[expected_type]\n      \u003c\u003c \"\\n\"\n         \"    Field type: \"\n      \u003c\u003c cpptype_names_[field-\u003ecpp_type()];\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":146,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270596656":{"score":0.7279758,"function_name":"Reflection::SetEnumValue","code":"void Reflection::SetEnumValue(Message* message, const FieldDescriptor* field,\n                              int value) const {\n  USAGE_CHECK_ALL(SetEnumValue, SINGULAR, ENUM);\n  if (!CreateUnknownEnumValues(field)) {\n    // Check that the value is valid if we don't support direct storage of\n    // unknown enum values.\n    const EnumValueDescriptor* value_desc =\n        field-\u003eenum_type()-\u003eFindValueByNumber(value);\n    if (value_desc == nullptr) {\n      MutableUnknownFields(message)-\u003eAddVarint(field-\u003enumber(), value);\n      return;\n    }\n  }\n  SetEnumValueInternal(message, field, value);\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":1789,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270597504":{"score":0.6409759,"function_name":"Reflection::SwapElements","code":"void Reflection::SwapElements(Message* message, const FieldDescriptor* field,\n                              int index1, int index2) const {\n  USAGE_CHECK_MESSAGE_TYPE(Swap);\n  USAGE_CHECK_REPEATED(Swap);\n  CheckInvalidAccess(schema_, field);\n\n  if (field-\u003eis_extension()) {\n    MutableExtensionSet(message)-\u003eSwapElements(field-\u003enumber(), index1, index2);\n  } else {\n    switch (field-\u003ecpp_type()) {\n#define HANDLE_TYPE(UPPERCASE, LOWERCASE)                 \\\n  case FieldDescriptor::CPPTYPE_##UPPERCASE:              \\\n    MutableRaw\u003cRepeatedField\u003cLOWERCASE\u003e \u003e(message, field) \\\n        -\u003eSwapElements(index1, index2);                   \\\n    break\n\n      HANDLE_TYPE(INT32, int32_t);\n      HANDLE_TYPE(INT64, int64_t);\n      HANDLE_TYPE(UINT32, uint32_t);\n      HANDLE_TYPE(UINT64, uint64_t);\n      HANDLE_TYPE(DOUBLE, double);\n      HANDLE_TYPE(FLOAT, float);\n      HANDLE_TYPE(BOOL, bool);\n      HANDLE_TYPE(ENUM, int);\n#undef HANDLE_TYPE\n\n      case FieldDescriptor::CPPTYPE_STRING:\n      case FieldDescriptor::CPPTYPE_MESSAGE:\n        if (IsMapFieldInApi(field)) {\n          MutableRaw\u003cMapFieldBase\u003e(message, field)\n              -\u003eMutableRepeatedField()\n              -\u003eSwapElements(index1, index2);\n        } else {\n          MutableRaw\u003cRepeatedPtrFieldBase\u003e(message, field)\n              -\u003eSwapElements(index1, index2);\n        }\n        break;\n    }\n  }\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":1377,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270600144":{"score":0.791613,"function_name":"Reflection::Swap","code":"void Reflection::Swap(Message* message1, Message* message2) const {\n  if (message1 == message2) return;\n\n  // TODO(kenton):  Other Reflection methods should probably check this too.\n  GOOGLE_CHECK_EQ(message1-\u003eGetReflection(), this)\n      \u003c\u003c \"First argument to Swap() (of type \\\"\"\n      \u003c\u003c message1-\u003eGetDescriptor()-\u003efull_name()\n      \u003c\u003c \"\\\") is not compatible with this reflection object (which is for type \"\n         \"\\\"\"\n      \u003c\u003c descriptor_-\u003efull_name()\n      \u003c\u003c \"\\\").  Note that the exact same class is required; not just the same \"\n         \"descriptor.\";\n  GOOGLE_CHECK_EQ(message2-\u003eGetReflection(), this)\n      \u003c\u003c \"Second argument to Swap() (of type \\\"\"\n      \u003c\u003c message2-\u003eGetDescriptor()-\u003efull_name()\n      \u003c\u003c \"\\\") is not compatible with this reflection object (which is for type \"\n         \"\\\"\"\n      \u003c\u003c descriptor_-\u003efull_name()\n      \u003c\u003c \"\\\").  Note that the exact same class is required; not just the same \"\n         \"descriptor.\";\n\n  // Check that both messages are in the same arena (or both on the heap). We\n  // need to copy all data if not, due to ownership semantics.\n#ifdef PROTOBUF_FORCE_COPY_IN_SWAP\n  if (message1-\u003eGetOwningArena() == nullptr ||\n      message1-\u003eGetOwningArena() != message2-\u003eGetOwningArena()) {\n#else   // PROTOBUF_FORCE_COPY_IN_SWAP\n  if (message1-\u003eGetOwningArena() != message2-\u003eGetOwningArena()) {\n#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP\n    // One of the two is guaranteed to have an arena.  Switch things around\n    // to guarantee that message1 has an arena.\n    Arena* arena = message1-\u003eGetOwningArena();\n    if (arena == nullptr) {\n      arena = message2-\u003eGetOwningArena();\n      std::swap(message1, message2);  // Swapping names for pointers!\n    }\n\n    Message* temp = message1-\u003eNew(arena);\n    temp-\u003eMergeFrom(*message2);\n    message2-\u003eCopyFrom(*message1);\n#ifdef PROTOBUF_FORCE_COPY_IN_SWAP\n    message1-\u003eCopyFrom(*temp);\n    if (arena == nullptr) delete temp;\n#else   // PROTOBUF_FORCE_COPY_IN_SWAP\n    Swap(message1, temp);\n#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP\n    return;\n  }\n\n  GOOGLE_DCHECK_EQ(message1-\u003eGetOwningArena(), message2-\u003eGetOwningArena());\n\n  UnsafeArenaSwap(message1, message2);\n}\n\ntemplate \u003cbool unsafe_shallow_swap\u003e\nvoid Reflection::SwapFieldsImpl(\n    Message* message1, Message* message2,\n    const std::vector\u003cconst FieldDescriptor*\u003e\u0026 fields) const {\n  if (message1 == message2) return;\n\n  // TODO(kenton):  Other Reflection methods should probably check this too.\n  GOOGLE_CHECK_EQ(message1-\u003eGetReflection(), this)\n      \u003c\u003c \"First argument to SwapFields() (of type \\\"\"\n      \u003c\u003c message1-\u003eGetDescriptor()-\u003efull_name()\n      \u003c\u003c \"\\\") is not compatible with this reflection object (which is for type \"\n         \"\\\"\"\n      \u003c\u003c descriptor_-\u003efull_name()\n      \u003c\u003c \"\\\").  Note that the exact same class is required; not just the same \"\n         \"descriptor.\";\n  GOOGLE_CHECK_EQ(message2-\u003eGetReflection(), this)\n      \u003c\u003c \"Second argument to SwapFields() (of type \\\"\"\n      \u003c\u003c message2-\u003eGetDescriptor()-\u003efull_name()\n      \u003c\u003c \"\\\") is not compatible with this reflection object (which is for type \"\n         \"\\\"\"\n      \u003c\u003c descriptor_-\u003efull_name()\n      \u003c\u003c \"\\\").  Note that the exact same class is required; not just the same \"\n         \"descriptor.\";\n\n  std::set\u003cint\u003e swapped_oneof;\n\n  GOOGLE_DCHECK(!unsafe_shallow_swap || message1-\u003eGetArenaForAllocation() ==\n                                     message2-\u003eGetArenaForAllocation());\n\n  const Message* prototype =\n      message_factory_-\u003eGetPrototype(message1-\u003eGetDescriptor());\n  for (const auto* field : fields) {\n    CheckInvalidAccess(schema_, field);\n    if (field-\u003eis_extension()) {\n      if (unsafe_shallow_swap) {\n        MutableExtensionSet(message1)-\u003eUnsafeShallowSwapExtension(\n            MutableExtensionSet(message2), field-\u003enumber());\n      } else {\n        MutableExtensionSet(message1)-\u003eSwapExtension(\n            prototype, MutableExtensionSet(message2), field-\u003enumber());\n      }\n    } else {\n      if (schema_.InRealOneof(field)) {\n        int oneof_index = field-\u003econtaining_oneof()-\u003eindex();\n        // Only swap the oneof field once.\n        if (swapped_oneof.find(oneof_index) != swapped_oneof.end()) {\n          continue;\n        }\n        swapped_oneof.insert(oneof_index);\n        SwapOneofField\u003cunsafe_shallow_swap\u003e(message1, message2,\n                                            field-\u003econtaining_oneof());\n      } else {\n        // Swap field.\n        if (unsafe_shallow_swap) {\n          UnsafeShallowSwapField(message1, message2, field);\n        } else {\n          SwapField(message1, message2, field);\n        }\n        // Swap has bit for non-repeated fields.  We have already checked for\n        // oneof already. This has to be done after SwapField, because SwapField\n        // may depend on the information in has bits.\n        if (!field-\u003eis_repeated()) {\n          SwapBit(message1, message2, field);\n        }\n      }\n    }\n  }\n}\n\nvoid Reflection::SwapFields(\n    Message* message1, Message* message2,\n    const std::vector\u003cconst FieldDescriptor*\u003e\u0026 fields) const {\n  SwapFieldsImpl\u003cfalse\u003e(message1, message2, fields);\n}\n\nvoid Reflection::UnsafeShallowSwapFields(\n    Message* message1, Message* message2,\n    const std::vector\u003cconst FieldDescriptor*\u003e\u0026 fields) const {\n  SwapFieldsImpl\u003ctrue\u003e(message1, message2, fields);\n}\n\nvoid Reflection::UnsafeArenaSwapFields(\n    Message* lhs, Message* rhs,\n    const std::vector\u003cconst FieldDescriptor*\u003e\u0026 fields) const {\n  GOOGLE_DCHECK_EQ(lhs-\u003eGetArenaForAllocation(), rhs-\u003eGetArenaForAllocation());\n  UnsafeShallowSwapFields(lhs, rhs, fields);\n}\n\n// -------------------------------------------------------------------\n\nbool Reflection::HasField(const Message\u0026 message,\n                          const FieldDescriptor* field) const {\n  USAGE_CHECK_MESSAGE_TYPE(HasField);\n  USAGE_CHECK_SINGULAR(HasField);\n  CheckInvalidAccess(schema_, field);\n\n  if (field-\u003eis_extension()) {\n    return GetExtensionSet(message).Has(field-\u003enumber());\n  } else {\n    if (schema_.InRealOneof(field)) {\n      return HasOneofField(message, field);\n    } else {\n      return HasBit(message, field);\n    }\n  }\n}\n\nvoid Reflection::UnsafeArenaSwap(Message* lhs, Message* rhs) const {\n  if (lhs == rhs) return;\n\n  MutableInternalMetadata(lhs)-\u003eInternalSwap(MutableInternalMetadata(rhs));\n\n  for (int i = 0; i \u003c= last_non_weak_field_index_; i++) {\n    const FieldDescriptor* field = descriptor_-\u003efield(i);\n    if (schema_.InRealOneof(field)) continue;\n    if (schema_.IsFieldStripped(field)) continue;\n    UnsafeShallowSwapField(lhs, rhs, field);\n  }\n  const int oneof_decl_count = descriptor_-\u003eoneof_decl_count();\n  for (int i = 0; i \u003c oneof_decl_count; i++) {\n    const OneofDescriptor* oneof = descriptor_-\u003eoneof_decl(i);\n    if (!oneof-\u003eis_synthetic()) {\n      SwapOneofField\u003ctrue\u003e(lhs, rhs, oneof);\n    }\n  }\n\n  // Swapping bits need to happen after swapping fields, because the latter may\n  // depend on the has bit information.\n  if (schema_.HasHasbits()) {\n    uint32* lhs_has_bits = MutableHasBits(lhs);\n    uint32* rhs_has_bits = MutableHasBits(rhs);\n\n    int fields_with_has_bits = 0;\n    for (int i = 0; i \u003c descriptor_-\u003efield_count(); i++) {\n      const FieldDescriptor* field = descriptor_-\u003efield(i);\n      if (field-\u003eis_repeated() || schema_.InRealOneof(field)) {\n        continue;\n      }\n      fields_with_has_bits++;\n    }\n\n    int has_bits_size = (fields_with_has_bits + 31) / 32;\n\n    for (int i = 0; i \u003c has_bits_size; i++) {\n      std::swap(lhs_has_bits[i], rhs_has_bits[i]);\n    }\n  }\n\n  if (schema_.HasExtensionSet()) {\n    MutableExtensionSet(lhs)-\u003eInternalSwap(MutableExtensionSet(rhs));\n  }\n}\n\nint Reflection::FieldSize(const Message\u0026 message,\n                          const FieldDescriptor* field) const {\n  USAGE_CHECK_MESSAGE_TYPE(FieldSize);\n  USAGE_CHECK_REPEATED(FieldSize);\n  CheckInvalidAccess(schema_, field);\n\n  if (field-\u003eis_extension()) {\n    return GetExtensionSet(message).ExtensionSize(field-\u003enumber());\n  } else {\n    switch (field-\u003ecpp_type()) {\n#define HANDLE_TYPE(UPPERCASE, LOWERCASE)    \\\n  case FieldDescriptor::CPPTYPE_##UPPERCASE: \\\n    return GetRaw\u003cRepeatedField\u003cLOWERCASE\u003e \u003e(message, field).size()\n\n      HANDLE_TYPE(INT32, int32_t);\n      HANDLE_TYPE(INT64, int64_t);\n      HANDLE_TYPE(UINT32, uint32_t);\n      HANDLE_TYPE(UINT64, uint64_t);\n      HANDLE_TYPE(DOUBLE, double);\n      HANDLE_TYPE(FLOAT, float);\n      HANDLE_TYPE(BOOL, bool);\n      HANDLE_TYPE(ENUM, int);\n#undef HANDLE_TYPE\n\n      case FieldDescriptor::CPPTYPE_STRING:\n      case FieldDescriptor::CPPTYPE_MESSAGE:\n        if (IsMapFieldInApi(field)) {\n          const internal::MapFieldBase\u0026 map =\n              GetRaw\u003cMapFieldBase\u003e(message, field);\n          if (map.IsRepeatedFieldValid()) {\n            return map.GetRepeatedField().size();\n          } else {\n            // No need to materialize the repeated field if it is out of sync:\n            // its size will be the same as the map's size.\n            return map.size();\n          }\n        } else {\n          return GetRaw\u003cRepeatedPtrFieldBase\u003e(message, field).size();\n        }\n    }\n\n    GOOGLE_LOG(FATAL) \u003c\u003c \"Can't get here.\";\n    return 0;\n  }\n}\n\nvoid Reflection::ClearField(Message* message,\n                            const FieldDescriptor* field) const {\n  USAGE_CHECK_MESSAGE_TYPE(ClearField);\n  CheckInvalidAccess(schema_, field);\n\n  if (field-\u003eis_extension()) {\n    MutableExtensionSet(message)-\u003eClearExtension(field-\u003enumber());\n  } else if (!field-\u003eis_repeated()) {\n    if (schema_.InRealOneof(field)) {\n      ClearOneofField(message, field);\n      return;\n    }\n    if (HasBit(*message, field)) {\n      ClearBit(message, field);\n\n      // We need to set the field back to its default value.\n      switch (field-\u003ecpp_type()) {\n#define CLEAR_TYPE(CPPTYPE, TYPE)                                      \\\n  case FieldDescriptor::CPPTYPE_##CPPTYPE:                             \\\n    *MutableRaw\u003cTYPE\u003e(message, field) = field-\u003edefault_value_##TYPE(); \\\n    break;\n\n        CLEAR_TYPE(INT32, int32_t);\n        CLEAR_TYPE(INT64, int64_t);\n        CLEAR_TYPE(UINT32, uint32_t);\n        CLEAR_TYPE(UINT64, uint64_t);\n        CLEAR_TYPE(FLOAT, float);\n        CLEAR_TYPE(DOUBLE, double);\n        CLEAR_TYPE(BOOL, bool);\n#undef CLEAR_TYPE\n\n        case FieldDescriptor::CPPTYPE_ENUM:\n          *MutableRaw\u003cint\u003e(message, field) =\n              field-\u003edefault_value_enum()-\u003enumber();\n          break;\n\n        case FieldDescriptor::CPPTYPE_STRING: {\n          switch (field-\u003eoptions().ctype()) {\n            default:  // TODO(kenton):  Support other string reps.\n            case FieldOptions::STRING: {\n              if (IsInlined(field)) {\n                // Currently, string with default value can't be inlined. So we\n                // don't have to handle default value here.\n                MutableRaw\u003cInlinedStringField\u003e(message, field)-\u003eClearToEmpty();\n                break;\n              }\n              const std::string* default_ptr =\n                  DefaultRaw\u003cArenaStringPtr\u003e(field).GetPointer();\n              MutableRaw\u003cArenaStringPtr\u003e(message, field)\n                  -\u003eSetAllocated(default_ptr, nullptr,\n                                 message-\u003eGetArenaForAllocation());\n              break;\n            }\n          }\n          break;\n        }\n\n        case FieldDescriptor::CPPTYPE_MESSAGE:\n          if (schema_.HasBitIndex(field) == static_cast\u003cuint32_t\u003e(-1)) {\n            // Proto3 does not have has-bits and we need to set a message field\n            // to nullptr in order to indicate its un-presence.\n            if (message-\u003eGetArenaForAllocation() == nullptr) {\n              delete *MutableRaw\u003cMessage*\u003e(message, field);\n            }\n            *MutableRaw\u003cMessage*\u003e(message, field) = nullptr;\n          } else {\n            (*MutableRaw\u003cMessage*\u003e(message, field))-\u003eClear();\n          }\n          break;\n      }\n    }\n  } else {\n    switch (field-\u003ecpp_type()) {\n#define HANDLE_TYPE(UPPERCASE, LOWERCASE)                           \\\n  case FieldDescriptor::CPPTYPE_##UPPERCASE:                        \\\n    MutableRaw\u003cRepeatedField\u003cLOWERCASE\u003e \u003e(message, field)-\u003eClear(); \\\n    break\n\n      HANDLE_TYPE(INT32, int32_t);\n      HANDLE_TYPE(INT64, int64_t);\n      HANDLE_TYPE(UINT32, uint32_t);\n      HANDLE_TYPE(UINT64, uint64_t);\n      HANDLE_TYPE(DOUBLE, double);\n      HANDLE_TYPE(FLOAT, float);\n      HANDLE_TYPE(BOOL, bool);\n      HANDLE_TYPE(ENUM, int);\n#undef HANDLE_TYPE\n\n      case FieldDescriptor::CPPTYPE_STRING: {\n        switch (field-\u003eoptions().ctype()) {\n          default:  // TODO(kenton):  Support other string reps.\n          case FieldOptions::STRING:\n            MutableRaw\u003cRepeatedPtrField\u003cstd::string\u003e \u003e(message, field)-\u003eClear();\n            break;\n        }\n        break;\n      }\n\n      case FieldDescriptor::CPPTYPE_MESSAGE: {\n        if (IsMapFieldInApi(field)) {\n          MutableRaw\u003cMapFieldBase\u003e(message, field)-\u003eClear();\n        } else {\n          // We don't know which subclass of RepeatedPtrFieldBase the type is,\n          // so we use RepeatedPtrFieldBase directly.\n          MutableRaw\u003cRepeatedPtrFieldBase\u003e(message, field)\n              -\u003eClear\u003cGenericTypeHandler\u003cMessage\u003e \u003e();\n        }\n        break;\n      }\n    }\n  }\n}\n\nvoid Reflection::RemoveLast(Message* message,\n                            const FieldDescriptor* field) const {\n  USAGE_CHECK_MESSAGE_TYPE(RemoveLast);\n  USAGE_CHECK_REPEATED(RemoveLast);\n  CheckInvalidAccess(schema_, field);\n\n  if (field-\u003eis_extension()) {\n    MutableExtensionSet(message)-\u003eRemoveLast(field-\u003enumber());\n  } else {\n    switch (field-\u003ecpp_type()) {\n#define HANDLE_TYPE(UPPERCASE, LOWERCASE)                                \\\n  case FieldDescriptor::CPPTYPE_##UPPERCASE:                             \\\n    MutableRaw\u003cRepeatedField\u003cLOWERCASE\u003e \u003e(message, field)-\u003eRemoveLast(); \\\n    break\n\n      HANDLE_TYPE(INT32, int32_t);\n      HANDLE_TYPE(INT64, int64_t);\n      HANDLE_TYPE(UINT32, uint32_t);\n      HANDLE_TYPE(UINT64, uint64_t);\n      HANDLE_TYPE(DOUBLE, double);\n      HANDLE_TYPE(FLOAT, float);\n      HANDLE_TYPE(BOOL, bool);\n      HANDLE_TYPE(ENUM, int);\n#undef HANDLE_TYPE\n\n      case FieldDescriptor::CPPTYPE_STRING:\n        switch (field-\u003eoptions().ctype()) {\n          default:  // TODO(kenton):  Support other string reps.\n          case FieldOptions::STRING:\n            MutableRaw\u003cRepeatedPtrField\u003cstd::string\u003e \u003e(message, field)\n                -\u003eRemoveLast();\n            break;\n        }\n        break;\n\n      case FieldDescriptor::CPPTYPE_MESSAGE:\n        if (IsMapFieldInApi(field)) {\n          MutableRaw\u003cMapFieldBase\u003e(message, field)\n              -\u003eMutableRepeatedField()\n              -\u003eRemoveLast\u003cGenericTypeHandler\u003cMessage\u003e \u003e();\n        } else {\n          MutableRaw\u003cRepeatedPtrFieldBase\u003e(message, field)\n              -\u003eRemoveLast\u003cGenericTypeHandler\u003cMessage\u003e \u003e();\n        }\n        break;\n    }\n  }\n}\n\nMessage* Reflection::ReleaseLast(Message* message,\n                                 const FieldDescriptor* field) const {\n  USAGE_CHECK_ALL(ReleaseLast, REPEATED, MESSAGE);\n  CheckInvalidAccess(schema_, field);\n\n  Message* released;\n  if (field-\u003eis_extension()) {\n    released = static_cast\u003cMessage*\u003e(\n        MutableExtensionSet(message)-\u003eReleaseLast(field-\u003enumber()));\n  } else {\n    if (IsMapFieldInApi(field)) {\n      released = MutableRaw\u003cMapFieldBase\u003e(message, field)\n                     -\u003eMutableRepeatedField()\n                     -\u003eReleaseLast\u003cGenericTypeHandler\u003cMessage\u003e\u003e();\n    } else {\n      released = MutableRaw\u003cRepeatedPtrFieldBase\u003e(message, field)\n                     -\u003eReleaseLast\u003cGenericTypeHandler\u003cMessage\u003e\u003e();\n    }\n  }\n#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE\n  return MaybeForceCopy(message-\u003eGetArenaForAllocation(), released);\n#else   // PROTOBUF_FORCE_COPY_IN_RELEASE\n  return released;\n#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE\n}\n\nMessage* Reflection::UnsafeArenaReleaseLast(\n    Message* message, const FieldDescriptor* field) const {\n  USAGE_CHECK_ALL(UnsafeArenaReleaseLast, REPEATED, MESSAGE);\n  CheckInvalidAccess(schema_, field);\n\n  if (field-\u003eis_extension()) {\n    return static_cast\u003cMessage*\u003e(\n        MutableExtensionSet(message)-\u003eUnsafeArenaReleaseLast(field-\u003enumber()));\n  } else {\n    if (IsMapFieldInApi(field)) {\n      return MutableRaw\u003cMapFieldBase\u003e(message, field)\n          -\u003eMutableRepeatedField()\n          -\u003eUnsafeArenaReleaseLast\u003cGenericTypeHandler\u003cMessage\u003e\u003e();\n    } else {\n      return MutableRaw\u003cRepeatedPtrFieldBase\u003e(message, field)\n          -\u003eUnsafeArenaReleaseLast\u003cGenericTypeHandler\u003cMessage\u003e\u003e();\n    }\n  }\n}\n\nvoid Reflection::SwapElements(Message* message, const FieldDescriptor* field,\n                              int index1, int index2) const {\n  USAGE_CHECK_MESSAGE_TYPE(Swap);\n  USAGE_CHECK_REPEATED(Swap);\n  CheckInvalidAccess(schema_, field);\n\n  if (field-\u003eis_extension()) {\n    MutableExtensionSet(message)-\u003eSwapElements(field-\u003enumber(), index1, index2);\n  } else {\n    switch (field-\u003ecpp_type()) {\n#define HANDLE_TYPE(UPPERCASE, LOWERCASE)                 \\\n  case FieldDescriptor::CPPTYPE_##UPPERCASE:              \\\n    MutableRaw\u003cRepeatedField\u003cLOWERCASE\u003e \u003e(message, field) \\\n        -\u003eSwapElements(index1, index2);                   \\\n    break\n\n      HANDLE_TYPE(INT32, int32_t);\n      HANDLE_TYPE(INT64, int64_t);\n      HANDLE_TYPE(UINT32, uint32_t);\n      HANDLE_TYPE(UINT64, uint64_t);\n      HANDLE_TYPE(DOUBLE, double);\n      HANDLE_TYPE(FLOAT, float);\n      HANDLE_TYPE(BOOL, bool);\n      HANDLE_TYPE(ENUM, int);\n#undef HANDLE_TYPE\n\n      case FieldDescriptor::CPPTYPE_STRING:\n      case FieldDescriptor::CPPTYPE_MESSAGE:\n        if (IsMapFieldInApi(field)) {\n          MutableRaw\u003cMapFieldBase\u003e(message, field)\n              -\u003eMutableRepeatedField()\n              -\u003eSwapElements(index1, index2);\n        } else {\n          MutableRaw\u003cRepeatedPtrFieldBase\u003e(message, field)\n              -\u003eSwapElements(index1, index2);\n        }\n        break;\n    }\n  }\n}\n\nnamespace {\n// Comparison functor for sorting FieldDescriptors by field number.\nstruct FieldNumberSorter {\n  bool operator()(const FieldDescriptor* left,\n                  const FieldDescriptor* right) const {\n    return left-\u003enumber() \u003c right-\u003enumber();\n  }\n};\n\nbool IsIndexInHasBitSet(const uint32_t* has_bit_set, uint32_t has_bit_index) {\n  GOOGLE_DCHECK_NE(has_bit_index, ~0u);\n  return ((has_bit_set[has_bit_index / 32] \u003e\u003e (has_bit_index % 32)) \u0026\n          static_cast\u003cuint32_t\u003e(1)) != 0;\n}\n\nbool CreateUnknownEnumValues(const FileDescriptor* file) {\n  return file-\u003esyntax() == FileDescriptor::SYNTAX_PROTO3;\n}\n}  // namespace\n\nnamespace internal {\nbool CreateUnknownEnumValues(const FieldDescriptor* field) {\n  bool open_enum = false;\n  return field-\u003efile()-\u003esyntax() == FileDescriptor::SYNTAX_PROTO3 || open_enum;\n}\n}  // namespace internal\nusing internal::CreateUnknownEnumValues;\n\nvoid Reflection::ListFieldsMayFailOnStripped(\n    const Message\u0026 message, bool should_fail,\n    std::vector\u003cconst FieldDescriptor*\u003e* output) const {\n  output-\u003eclear();\n\n  // Optimization:  The default instance never has any fields set.\n  if (schema_.IsDefaultInstance(message)) return;\n\n  // Optimization: Avoid calling GetHasBits() and HasOneofField() many times\n  // within the field loop.  We allow this violation of ReflectionSchema\n  // encapsulation because this function takes a noticeable about of CPU\n  // fleetwide and properly allowing this optimization through public interfaces\n  // seems more trouble than it is worth.\n  const uint32_t* const has_bits =\n      schema_.HasHasbits() ? GetHasBits(message) : nullptr;\n  const uint32_t* const has_bits_indices = schema_.has_bit_indices_;\n  output-\u003ereserve(descriptor_-\u003efield_count());\n  const int last_non_weak_field_index = last_non_weak_field_index_;\n  for (int i = 0; i \u003c= last_non_weak_field_index; i++) {\n    const FieldDescriptor* field = descriptor_-\u003efield(i);\n    if (!should_fail \u0026\u0026 schema_.IsFieldStripped(field)) {\n      continue;\n    }\n    if (field-\u003eis_repeated()) {\n      if (FieldSize(message, field) \u003e 0) {\n        output-\u003epush_back(field);\n      }\n    } else {\n      const OneofDescriptor* containing_oneof = field-\u003econtaining_oneof();\n      if (schema_.InRealOneof(field)) {\n        const uint32_t* const oneof_case_array =\n            GetConstPointerAtOffset\u003cuint32_t\u003e(\u0026message,\n                                              schema_.oneof_case_offset_);\n        // Equivalent to: HasOneofField(message, field)\n        if (static_cast\u003cint64_t\u003e(oneof_case_array[containing_oneof-\u003eindex()]) ==\n            field-\u003enumber()) {\n          output-\u003epush_back(field);\n        }\n      } else if (has_bits \u0026\u0026 has_bits_indices[i] != static_cast\u003cuint32_t\u003e(-1)) {\n        CheckInvalidAccess(schema_, field);\n        // Equivalent to: HasBit(message, field)\n        if (IsIndexInHasBitSet(has_bits, has_bits_indices[i])) {\n          output-\u003epush_back(field);\n        }\n      } else if (HasBit(message, field)) {  // Fall back on proto3-style HasBit.\n        output-\u003epush_back(field);\n      }\n    }\n  }\n  if (schema_.HasExtensionSet()) {\n    GetExtensionSet(message).AppendToList(descriptor_, descriptor_pool_,\n                                          output);\n  }\n\n  // ListFields() must sort output by field number.\n  std::sort(output-\u003ebegin(), output-\u003eend(), FieldNumberSorter());\n}\n\nvoid Reflection::ListFields(const Message\u0026 message,\n                            std::vector\u003cconst FieldDescriptor*\u003e* output) const {\n  ListFieldsMayFailOnStripped(message, true, output);\n}\n\nvoid Reflection::ListFieldsOmitStripped(\n    const Message\u0026 message, std::vector\u003cconst FieldDescriptor*\u003e* output) const {\n  ListFieldsMayFailOnStripped(message, false, output);\n}\n\n// -------------------------------------------------------------------\n\n#undef DEFINE_PRIMITIVE_ACCESSORS\n#define DEFINE_PRIMITIVE_ACCESSORS(TYPENAME, TYPE, PASSTYPE, CPPTYPE)          \\\n  PASSTYPE Reflection::Get##TYPENAME(const Message\u0026 message,                   \\\n                                     const FieldDescriptor* field) const {     \\\n    USAGE_CHECK_ALL(Get##TYPENAME, SINGULAR, CPPTYPE);                         \\\n    if (field-\u003eis_extension()) {                                               \\\n      return GetExtensionSet(message).Get##TYPENAME(                           \\\n          field-\u003enumber(), field-\u003edefault_value_##PASSTYPE());                 \\\n    } else if (schema_.InRealOneof(field) \u0026\u0026 !HasOneofField(message, field)) { \\\n      return field-\u003edefault_value_##PASSTYPE();                                \\\n    } else {                                                                   \\\n      return GetField\u003cTYPE\u003e(message, field);                                   \\\n    }                                                                          \\\n  }                                                                            \\\n                                                                               \\\n  void Reflection::Set##TYPENAME(                                              \\\n      Message* message, const FieldDescriptor* field, PASSTYPE value) const {  \\\n    USAGE_CHECK_ALL(Set##TYPENAME, SINGULAR, CPPTYPE);                         \\\n    if (field-\u003eis_extension()) {                                               \\\n      return MutableExtensionSet(message)-\u003eSet##TYPENAME(                      \\\n          field-\u003enumber(), field-\u003etype(), value, field);                       \\\n    } else {                                                                   \\\n      SetField\u003cTYPE\u003e(message, field, value);                                   \\\n    }                                                                          \\\n  }                                                                            \\\n                                                                               \\\n  PASSTYPE Reflection::GetRepeated##TYPENAME(                                  \\\n      const Message\u0026 message, const FieldDescriptor* field, int index) const { \\\n    USAGE_CHECK_ALL(GetRepeated##TYPENAME, REPEATED, CPPTYPE);                 \\\n    if (field-\u003eis_extension()) {                                               \\\n      return GetExtensionSet(message).GetRepeated##TYPENAME(field-\u003enumber(),   \\\n                                                            index);            \\\n    } else {                                                                   \\\n      return GetRepeatedField\u003cTYPE\u003e(message, field, index);                    \\\n    }                                                                          \\\n  }                                                                            \\\n                                                                               \\\n  void Reflection::SetRepeated##TYPENAME(Message* message,                     \\\n                                         const FieldDescriptor* field,         \\\n                                         int index, PASSTYPE value) const {    \\\n    USAGE_CHECK_ALL(SetRepeated##TYPENAME, REPEATED, CPPTYPE);                 \\\n    if (field-\u003eis_extension()) {                                               \\\n      MutableExtensionSet(message)-\u003eSetRepeated##TYPENAME(field-\u003enumber(),     \\\n                                                          index, value);       \\\n    } else {                                                                   \\\n      SetRepeatedField\u003cTYPE\u003e(message, field, index, value);                    \\\n    }                                                                          \\\n  }                                                                            \\\n                                                                               \\\n  void Reflection::Add##TYPENAME(                                              \\\n      Message* message, const FieldDescriptor* field, PASSTYPE value) const {  \\\n    USAGE_CHECK_ALL(Add##TYPENAME, REPEATED, CPPTYPE);                         \\\n    if (field-\u003eis_extension()) {                                               \\\n      MutableExtensionSet(message)-\u003eAdd##TYPENAME(                             \\\n          field-\u003enumber(), field-\u003etype(), field-\u003eoptions().packed(), value,    \\\n          field);                                                              \\\n    } else {                                                                   \\\n      AddField\u003cTYPE\u003e(message, field, value);                                   \\\n    }                                                                          \\\n  }\n\nDEFINE_PRIMITIVE_ACCESSORS(Int32, int32_t, int32_t, INT32)\nDEFINE_PRIMITIVE_ACCESSORS(Int64, int64_t, int64_t, INT64)\nDEFINE_PRIMITIVE_ACCESSORS(UInt32, uint32_t, uint32_t, UINT32)\nDEFINE_PRIMITIVE_ACCESSORS(UInt64, uint64_t, uint64_t, UINT64)\nDEFINE_PRIMITIVE_ACCESSORS(Float, float, float, FLOAT)\nDEFINE_PRIMITIVE_ACCESSORS(Double, double, double, DOUBLE)\nDEFINE_PRIMITIVE_ACCESSORS(Bool, bool, bool, BOOL)\n#undef DEFINE_PRIMITIVE_ACCESSORS\n\n// -------------------------------------------------------------------\n\nstd::string Reflection::GetString(const Message\u0026 message,\n                                  const FieldDescriptor* field) const {\n  USAGE_CHECK_ALL(GetString, SINGULAR, STRING);\n  if (field-\u003eis_extension()) {\n    return GetExtensionSet(message).GetString(field-\u003enumber(),\n                                              field-\u003edefault_value_string());\n  } else {\n    if (schema_.InRealOneof(field) \u0026\u0026 !HasOneofField(message, field)) {\n      return field-\u003edefault_value_string();\n    }\n    switch (field-\u003eoptions().ctype()) {\n      default:  // TODO(kenton):  Support other string reps.\n      case FieldOptions::STRING: {\n        if (IsInlined(field)) {\n          return GetField\u003cInlinedStringField\u003e(message, field).GetNoArena();\n        }\n\n        if (auto* value =\n                GetField\u003cArenaStringPtr\u003e(message, field).GetPointer()) {\n          return *value;\n        }\n        return field-\u003edefault_value_string();\n      }\n    }\n  }\n}\n\nconst std::string\u0026 Reflection::GetStringReference(const Message\u0026 message,\n                                                  const FieldDescriptor* field,\n                                                  std::string* scratch) const {\n  (void)scratch;  // Parameter is used by Google-internal code.\n  USAGE_CHECK_ALL(GetStringReference, SINGULAR, STRING);\n  if (field-\u003eis_extension()) {\n    return GetExtensionSet(message).GetString(field-\u003enumber(),\n                                              field-\u003edefault_value_string());\n  } else {\n    if (schema_.InRealOneof(field) \u0026\u0026 !HasOneofField(message, field)) {\n      return field-\u003edefault_value_string();\n    }\n    switch (field-\u003eoptions().ctype()) {\n      default:  // TODO(kenton):  Support other string reps.\n      case FieldOptions::STRING: {\n        if (IsInlined(field)) {\n          return GetField\u003cInlinedStringField\u003e(message, field).GetNoArena();\n        }\n\n        if (auto* value =\n                GetField\u003cArenaStringPtr\u003e(message, field).GetPointer()) {\n          return *value;\n        }\n        return field-\u003edefault_value_string();\n      }\n    }\n  }\n}\n\n\nvoid Reflection::SetString(Message* message, const FieldDescriptor* field,\n                           std::string value) const {\n  USAGE_CHECK_ALL(SetString, SINGULAR, STRING);\n  if (field-\u003eis_extension()) {\n    return MutableExtensionSet(message)-\u003eSetString(\n        field-\u003enumber(), field-\u003etype(), std::move(value), field);\n  } else {\n    switch (field-\u003eoptions().ctype()) {\n      default:  // TODO(kenton):  Support other string reps.\n      case FieldOptions::STRING: {\n        if (IsInlined(field)) {\n          const uint32_t index = schema_.InlinedStringIndex(field);\n          uint32_t* states =\n              \u0026MutableInlinedStringDonatedArray(message)[index / 32];\n          uint32_t mask = ~(static_cast\u003cuint32_t\u003e(1) \u003c\u003c (index % 32));\n          MutableField\u003cInlinedStringField\u003e(message, field)\n              -\u003eSet(nullptr, value, message-\u003eGetArenaForAllocation(),\n                    IsInlinedStringDonated(*message, field), states, mask);\n          break;\n        }\n\n        // Oneof string fields are never set as a default instance.\n        // We just need to pass some arbitrary default string to make it work.\n        // This allows us to not have the real default accessible from\n        // reflection.\n        const std::string* default_ptr =\n            schema_.InRealOneof(field)\n                ? nullptr\n                : DefaultRaw\u003cArenaStringPtr\u003e(field).GetPointer();\n        if (schema_.InRealOneof(field) \u0026\u0026 !HasOneofField(*message, field)) {\n          ClearOneof(message, field-\u003econtaining_oneof());\n          MutableField\u003cArenaStringPtr\u003e(message, field)\n              -\u003eUnsafeSetDefault(default_ptr);\n        }\n        MutableField\u003cArenaStringPtr\u003e(message, field)\n            -\u003eSet(default_ptr, std::move(value),\n                  message-\u003eGetArenaForAllocation());\n        break;\n      }\n    }\n  }\n}\n\n\nstd::string Reflection::GetRepeatedString(const Message\u0026 message,\n                                          const FieldDescriptor* field,\n                                          int index) const {\n  USAGE_CHECK_ALL(GetRepeatedString, REPEATED, STRING);\n  if (field-\u003eis_extension()) {\n    return GetExtensionSet(message).GetRepeatedString(field-\u003enumber(), index);\n  } else {\n    switch (field-\u003eoptions().ctype()) {\n      default:  // TODO(kenton):  Support other string reps.\n      case FieldOptions::STRING:\n        return GetRepeatedPtrField\u003cstd::string\u003e(message, field, index);\n    }\n  }\n}\n\nconst std::string\u0026 Reflection::GetRepeatedStringReference(\n    const Message\u0026 message, const FieldDescriptor* field, int index,\n    std::string* scratch) const {\n  (void)scratch;  // Parameter is used by Google-internal code.\n  USAGE_CHECK_ALL(GetRepeatedStringReference, REPEATED, STRING);\n  if (field-\u003eis_extension()) {\n    return GetExtensionSet(message).GetRepeatedString(field-\u003enumber(), index);\n  } else {\n    switch (field-\u003eoptions().ctype()) {\n      default:  // TODO(kenton):  Support other string reps.\n      case FieldOptions::STRING:\n        return GetRepeatedPtrField\u003cstd::string\u003e(message, field, index);\n    }\n  }\n}\n\n\nvoid Reflection::SetRepeatedString(Message* message,\n                                   const FieldDescriptor* field, int index,\n                                   std::string value) const {\n  USAGE_CHECK_ALL(SetRepeatedString, REPEATED, STRING);\n  if (field-\u003eis_extension()) {\n    MutableExtensionSet(message)-\u003eSetRepeatedString(field-\u003enumber(), index,\n                                                    std::move(value));\n  } else {\n    switch (field-\u003eoptions().ctype()) {\n      default:  // TODO(kenton):  Support other string reps.\n      case FieldOptions::STRING:\n        MutableRepeatedField\u003cstd::string\u003e(message, field, index)\n            -\u003eassign(std::move(value));\n        break;\n    }\n  }\n}\n\n\nvoid Reflection::AddString(Message* message, const FieldDescriptor* field,\n                           std::string value) const {\n  USAGE_CHECK_ALL(AddString, REPEATED, STRING);\n  if (field-\u003eis_extension()) {\n    MutableExtensionSet(message)-\u003eAddString(field-\u003enumber(), field-\u003etype(),\n                                            std::move(value), field);\n  } else {\n    switch (field-\u003eoptions().ctype()) {\n      default:  // TODO(kenton):  Support other string reps.\n      case FieldOptions::STRING:\n        AddField\u003cstd::string\u003e(message, field)-\u003eassign(std::move(value));\n        break;\n    }\n  }\n}\n\n\n// -------------------------------------------------------------------\n\nconst EnumValueDescriptor* Reflection::GetEnum(\n    const Message\u0026 message, const FieldDescriptor* field) const {\n  // Usage checked by GetEnumValue.\n  int value = GetEnumValue(message, field);\n  return field-\u003eenum_type()-\u003eFindValueByNumberCreatingIfUnknown(value);\n}\n\nint Reflection::GetEnumValue(const Message\u0026 message,\n                             const FieldDescriptor* field) const {\n  USAGE_CHECK_ALL(GetEnumValue, SINGULAR, ENUM);\n\n  int32_t value;\n  if (field-\u003eis_extension()) {\n    value = GetExtensionSet(message).GetEnum(\n        field-\u003enumber(), field-\u003edefault_value_enum()-\u003enumber());\n  } else if (schema_.InRealOneof(field) \u0026\u0026 !HasOneofField(message, field)) {\n    value = field-\u003edefault_value_enum()-\u003enumber();\n  } else {\n    value = GetField\u003cint\u003e(message, field);\n  }\n  return value;\n}\n\nvoid Reflection::SetEnum(Message* message, const FieldDescriptor* field,\n                         const EnumValueDescriptor* value) const {\n  // Usage checked by SetEnumValue.\n  USAGE_CHECK_ENUM_VALUE(SetEnum);\n  SetEnumValueInternal(message, field, value-\u003enumber());\n}\n\nvoid Reflection::SetEnumValue(Message* message, const FieldDescriptor* field,\n                              int value) const {\n  USAGE_CHECK_ALL(SetEnumValue, SINGULAR, ENUM);\n  if (!CreateUnknownEnumValues(field)) {\n    // Check that the value is valid if we don't support direct storage of\n    // unknown enum values.\n    const EnumValueDescriptor* value_desc =\n        field-\u003eenum_type()-\u003eFindValueByNumber(value);\n    if (value_desc == nullptr) {\n      MutableUnknownFields(message)-\u003eAddVarint(field-\u003enumber(), value);\n      return;\n    }\n  }\n  SetEnumValueInternal(message, field, value);\n}\n\nvoid Reflection::SetEnumValueInternal(Message* message,\n                                      const FieldDescriptor* field,\n                                      int value) const {\n  if (field-\u003eis_extension()) {\n    MutableExtensionSet(message)-\u003eSetEnum(field-\u003enumber(), field-\u003etype(), value,\n                                          field);\n  } else {\n    SetField\u003cint\u003e(message, field, value);\n  }\n}\n\nconst EnumValueDescriptor* Reflection::GetRepeatedEnum(\n    const Message\u0026 message, const FieldDescriptor* field, int index) const {\n  // Usage checked by GetRepeatedEnumValue.\n  int value = GetRepeatedEnumValue(message, field, index);\n  return field-\u003eenum_type()-\u003eFindValueByNumberCreatingIfUnknown(value);\n}\n\nint Reflection::GetRepeatedEnumValue(const Message\u0026 message,\n                                     const FieldDescriptor* field,\n                                     int index) const {\n  USAGE_CHECK_ALL(GetRepeatedEnumValue, REPEATED, ENUM);\n\n  int value;\n  if (field-\u003eis_extension()) {\n    value = GetExtensionSet(message).GetRepeatedEnum(field-\u003enumber(), index);\n  } else {\n    value = GetRepeatedField\u003cint\u003e(message, field, index);\n  }\n  return value;\n}\n\nvoid Reflection::SetRepeatedEnum(Message* message, const FieldDescriptor* field,\n                                 int index,\n                                 const EnumValueDescriptor* value) const {\n  // Usage checked by SetRepeatedEnumValue.\n  USAGE_CHECK_ENUM_VALUE(SetRepeatedEnum);\n  SetRepeatedEnumValueInternal(message, field, index, value-\u003enumber());\n}\n\nvoid Reflection::SetRepeatedEnumValue(Message* message,\n                                      const FieldDescriptor* field, int index,\n                                      int value) const {\n  USAGE_CHECK_ALL(SetRepeatedEnum, REPEATED, ENUM);\n  if (!CreateUnknownEnumValues(field)) {\n    // Check that the value is valid if we don't support direct storage of\n    // unknown enum values.\n    const EnumValueDescriptor* value_desc =\n        field-\u003eenum_type()-\u003eFindValueByNumber(value);\n    if (value_desc == nullptr) {\n      MutableUnknownFields(message)-\u003eAddVarint(field-\u003enumber(), value);\n      return;\n    }\n  }\n  SetRepeatedEnumValueInternal(message, field, index, value);\n}\n\nvoid Reflection::SetRepeatedEnumValueInternal(Message* message,\n                                              const FieldDescriptor* field,\n                                              int index, int value) const {\n  if (field-\u003eis_extension()) {\n    MutableExtensionSet(message)-\u003eSetRepeatedEnum(field-\u003enumber(), index,\n                                                  value);\n  } else {\n    SetRepeatedField\u003cint\u003e(message, field, index, value);\n  }\n}\n\nvoid Reflection::AddEnum(Message* message, const FieldDescriptor* field,\n                         const EnumValueDescriptor* value) const {\n  // Usage checked by AddEnumValue.\n  USAGE_CHECK_ENUM_VALUE(AddEnum);\n  AddEnumValueInternal(message, field, value-\u003enumber());\n}\n\nvoid Reflection::AddEnumValue(Message* message, const FieldDescriptor* field,\n                              int value) const {\n  USAGE_CHECK_ALL(AddEnum, REPEATED, ENUM);\n  if (!CreateUnknownEnumValues(field)) {\n    // Check that the value is valid if we don't support direct storage of\n    // unknown enum values.\n    const EnumValueDescriptor* value_desc =\n        field-\u003eenum_type()-\u003eFindValueByNumber(value);\n    if (value_desc == nullptr) {\n      MutableUnknownFields(message)-\u003eAddVarint(field-\u003enumber(), value);\n      return;\n    }\n  }\n  AddEnumValueInternal(message, field, value);\n}\n\nvoid Reflection::AddEnumValueInternal(Message* message,\n                                      const FieldDescriptor* field,\n                                      int value) const {\n  if (field-\u003eis_extension()) {\n    MutableExtensionSet(message)-\u003eAddEnum(field-\u003enumber(), field-\u003etype(),\n                                          field-\u003eoptions().packed(), value,\n                                          field);\n  } else {\n    AddField\u003cint\u003e(message, field, value);\n  }\n}\n\n// -------------------------------------------------------------------\n\nconst Message* Reflection::GetDefaultMessageInstance(\n    const FieldDescriptor* field) const {\n  // If we are using the generated factory, we cache the prototype in the field\n  // descriptor for faster access.\n  // The default instances of generated messages are not cross-linked, which\n  // means they contain null pointers on their message fields and can't be used\n  // to get the default of submessages.\n  if (message_factory_ == MessageFactory::generated_factory()) {\n    auto\u0026 ptr = field-\u003edefault_generated_instance_;\n    auto* res = ptr.load(std::memory_order_acquire);\n    if (res == nullptr) {\n      // First time asking for this field's default. Load it and cache it.\n      res = message_factory_-\u003eGetPrototype(field-\u003emessage_type());\n      ptr.store(res, std::memory_order_release);\n    }\n    return res;\n  }\n\n  // For other factories, we try the default's object field.\n  // In particular, the DynamicMessageFactory will cross link the default\n  // instances to allow for this. But only do this for real fields.\n  // This is an optimization to avoid going to GetPrototype() below, as that\n  // requires a lock and a map lookup.\n  if (!field-\u003eis_extension() \u0026\u0026 !field-\u003eoptions().weak() \u0026\u0026\n      !IsLazyField(field) \u0026\u0026 !schema_.InRealOneof(field)) {\n    auto* res = DefaultRaw\u003cconst Message*\u003e(field);\n    if (res != nullptr) {\n      return res;\n    }\n  }\n  // Otherwise, just go to the factory.\n  return message_factory_-\u003eGetPrototype(field-\u003emessage_type());\n}\n\nconst Message\u0026 Reflection::GetMessage(const Message\u0026 message,\n                                      const FieldDescriptor* field,\n                                      MessageFactory* factory) const {\n  USAGE_CHECK_ALL(GetMessage, SINGULAR, MESSAGE);\n  CheckInvalidAccess(schema_, field);\n\n  if (factory == nullptr) factory = message_factory_;\n\n  if (field-\u003eis_extension()) {\n    return static_cast\u003cconst Message\u0026\u003e(GetExtensionSet(message).GetMessage(\n        field-\u003enumber(), field-\u003emessage_type(), factory));\n  } else {\n    if (schema_.InRealOneof(field) \u0026\u0026 !HasOneofField(message, field)) {\n      return *GetDefaultMessageInstance(field);\n    }\n    const Message* result = GetRaw\u003cconst Message*\u003e(message, field);\n    if (result == nullptr) {\n      result = GetDefaultMessageInstance(field);\n    }\n    return *result;\n  }\n}\n\nMessage* Reflection::MutableMessage(Message* message,\n                                    const FieldDescriptor* field,\n                                    MessageFactory* factory) const {\n  USAGE_CHECK_ALL(MutableMessage, SINGULAR, MESSAGE);\n  CheckInvalidAccess(schema_, field);\n\n  if (factory == nullptr) factory = message_factory_;\n\n  if (field-\u003eis_extension()) {\n    return static_cast\u003cMessage*\u003e(\n        MutableExtensionSet(message)-\u003eMutableMessage(field, factory));\n  } else {\n    Message* result;\n\n    Message** result_holder = MutableRaw\u003cMessage*\u003e(message, field);\n\n    if (schema_.InRealOneof(field)) {\n      if (!HasOneofField(*message, field)) {\n        ClearOneof(message, field-\u003econtaining_oneof());\n        result_holder = MutableField\u003cMessage*\u003e(message, field);\n        const Message* default_message = GetDefaultMessageInstance(field);\n        *result_holder = default_message-\u003eNew(message-\u003eGetArenaForAllocation());\n      }\n    } else {\n      SetBit(message, field);\n    }\n\n    if (*result_holder == nullptr) {\n      const Message* default_message = GetDefaultMessageInstance(field);\n      *result_holder = default_message-\u003eNew(message-\u003eGetArenaForAllocation());\n    }\n    result = *result_holder;\n    return result;\n  }\n}\n\nvoid Reflection::UnsafeArenaSetAllocatedMessage(\n    Message* message, Message* sub_message,\n    const FieldDescriptor* field) const {\n  USAGE_CHECK_ALL(SetAllocatedMessage, SINGULAR, MESSAGE);\n  CheckInvalidAccess(schema_, field);\n\n\n  if (field-\u003eis_extension()) {\n    MutableExtensionSet(message)-\u003eUnsafeArenaSetAllocatedMessage(\n        field-\u003enumber(), field-\u003etype(), field, sub_message);\n  } else {\n    if (schema_.InRealOneof(field)) {\n      if (sub_message == nullptr) {\n        ClearOneof(message, field-\u003econtaining_oneof());\n        return;\n      }\n        ClearOneof(message, field-\u003econtaining_oneof());\n        *MutableRaw\u003cMessage*\u003e(message, field) = sub_message;\n      SetOneofCase(message, field);\n      return;\n    }\n\n    if (sub_message == nullptr) {\n      ClearBit(message, field);\n    } else {\n      SetBit(message, field);\n    }\n    Message** sub_message_holder = MutableRaw\u003cMessage*\u003e(message, field);\n    if (message-\u003eGetArenaForAllocation() == nullptr) {\n      delete *sub_message_holder;\n    }\n    *sub_message_holder = sub_message;\n  }\n}\n\nvoid Reflection::SetAllocatedMessage(Message* message, Message* sub_message,\n                                     const FieldDescriptor* field) const {\n  GOOGLE_DCHECK(sub_message == nullptr || sub_message-\u003eGetOwningArena() == nullptr ||\n         sub_message-\u003eGetOwningArena() == message-\u003eGetArenaForAllocation());\n  CheckInvalidAccess(schema_, field);\n\n  // If message and sub-message are in different memory ownership domains\n  // (different arenas, or one is on heap and one is not), then we may need to\n  // do a copy.\n  if (sub_message != nullptr \u0026\u0026\n      sub_message-\u003eGetOwningArena() != message-\u003eGetArenaForAllocation()) {\n    if (sub_message-\u003eGetOwningArena() == nullptr \u0026\u0026\n        message-\u003eGetArenaForAllocation() != nullptr) {\n      // Case 1: parent is on an arena and child is heap-allocated. We can add\n      // the child to the arena's Own() list to free on arena destruction, then\n      // set our pointer.\n      message-\u003eGetArenaForAllocation()-\u003eOwn(sub_message);\n      UnsafeArenaSetAllocatedMessage(message, sub_message, field);\n    } else {\n      // Case 2: all other cases. We need to make a copy. MutableMessage() will\n      // either get the existing message object, or instantiate a new one as\n      // appropriate w.r.t. our arena.\n      Message* sub_message_copy = MutableMessage(message, field);\n      sub_message_copy-\u003eCopyFrom(*sub_message);\n    }\n  } else {\n    // Same memory ownership domains.\n    UnsafeArenaSetAllocatedMessage(message, sub_message, field);\n  }\n}\n\nMessage* Reflection::UnsafeArenaReleaseMessage(Message* message,\n                                               const FieldDescriptor* field,\n                                               MessageFactory* factory) const {\n  USAGE_CHECK_ALL(ReleaseMessage, SINGULAR, MESSAGE);\n  CheckInvalidAccess(schema_, field);\n\n  if (factory == nullptr) factory = message_factory_;\n\n  if (field-\u003eis_extension()) {\n    return static_cast\u003cMessage*\u003e(\n        MutableExtensionSet(message)-\u003eUnsafeArenaReleaseMessage(field,\n                                                                factory));\n  } else {\n    if (!(field-\u003eis_repeated() || schema_.InRealOneof(field))) {\n      ClearBit(message, field);\n    }\n    if (schema_.InRealOneof(field)) {\n      if (HasOneofField(*message, field)) {\n        *MutableOneofCase(message, field-\u003econtaining_oneof()) = 0;\n      } else {\n        return nullptr;\n      }\n    }\n    Message** result = MutableRaw\u003cMessage*\u003e(message, field);\n    Message* ret = *result;\n    *result = nullptr;\n    return ret;\n  }\n}\n\nMessage* Reflection::ReleaseMessage(Message* message,\n                                    const FieldDescriptor* field,\n                                    MessageFactory* factory) const {\n  CheckInvalidAccess(schema_, field);\n\n  Message* released = UnsafeArenaReleaseMessage(message, field, factory);\n#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE\n  released = MaybeForceCopy(message-\u003eGetArenaForAllocation(), released);\n#endif  // PROTOBUF_FORCE_COPY_IN_RELEASE\n  if (message-\u003eGetArenaForAllocation() != nullptr \u0026\u0026 released != nullptr) {\n    Message* copy_from_arena = released-\u003eNew();\n    copy_from_arena-\u003eCopyFrom(*released);\n    released = copy_from_arena;\n  }\n  return released;\n}\n\nconst Message\u0026 Reflection::GetRepeatedMessage(const Message\u0026 message,\n                                              const FieldDescriptor* field,\n                                              int index) const {\n  USAGE_CHECK_ALL(GetRepeatedMessage, REPEATED, MESSAGE);\n  CheckInvalidAccess(schema_, field);\n\n  if (field-\u003eis_extension()) {\n    return static_cast\u003cconst Message\u0026\u003e(\n        GetExtensionSet(message).GetRepeatedMessage(field-\u003enumber(), index));\n  } else {\n    if (IsMapFieldInApi(field)) {\n      return GetRaw\u003cMapFieldBase\u003e(message, field)\n          .GetRepeatedField()\n          .Get\u003cGenericTypeHandler\u003cMessage\u003e \u003e(index);\n    } else {\n      return GetRaw\u003cRepeatedPtrFieldBase\u003e(message, field)\n          .Get\u003cGenericTypeHandler\u003cMessage\u003e \u003e(index);\n    }\n  }\n}\n\nMessage* Reflection::MutableRepeatedMessage(Message* message,\n                                            const FieldDescriptor* field,\n                                            int index) const {\n  USAGE_CHECK_ALL(MutableRepeatedMessage, REPEATED, MESSAGE);\n  CheckInvalidAccess(schema_, field);\n\n  if (field-\u003eis_extension()) {\n    return static_cast\u003cMessage*\u003e(\n        MutableExtensionSet(message)-\u003eMutableRepeatedMessage(field-\u003enumber(),\n                                                             index));\n  } else {\n    if (IsMapFieldInApi(field)) {\n      return MutableRaw\u003cMapFieldBase\u003e(message, field)\n          -\u003eMutableRepeatedField()\n          -\u003eMutable\u003cGenericTypeHandler\u003cMessage\u003e \u003e(index);\n    } else {\n      return MutableRaw\u003cRepeatedPtrFieldBase\u003e(message, field)\n          -\u003eMutable\u003cGenericTypeHandler\u003cMessage\u003e \u003e(index);\n    }\n  }\n}\n\nMessage* Reflection::AddMessage(Message* message, const FieldDescriptor* field,\n                                MessageFactory* factory) const {\n  USAGE_CHECK_ALL(AddMessage, REPEATED, MESSAGE);\n  CheckInvalidAccess(schema_, field);\n\n  if (factory == nullptr) factory = message_factory_;\n\n  if (field-\u003eis_extension()) {\n    return static_cast\u003cMessage*\u003e(\n        MutableExtensionSet(message)-\u003eAddMessage(field, factory));\n  } else {\n    Message* result = nullptr;\n\n    // We can't use AddField\u003cMessage\u003e() because RepeatedPtrFieldBase doesn't\n    // know how to allocate one.\n    RepeatedPtrFieldBase* repeated = nullptr;\n    if (IsMapFieldInApi(field)) {\n      repeated =\n          MutableRaw\u003cMapFieldBase\u003e(message, field)-\u003eMutableRepeatedField();\n    } else {\n      repeated = MutableRaw\u003cRepeatedPtrFieldBase\u003e(message, field);\n    }\n    result = repeated-\u003eAddFromCleared\u003cGenericTypeHandler\u003cMessage\u003e \u003e();\n    if (result == nullptr) {\n      // We must allocate a new object.\n      const Message* prototype;\n      if (repeated-\u003esize() == 0) {\n        prototype = factory-\u003eGetPrototype(field-\u003emessage_type());\n      } else {\n        prototype = \u0026repeated-\u003eGet\u003cGenericTypeHandler\u003cMessage\u003e \u003e(0);\n      }\n      result = prototype-\u003eNew(message-\u003eGetArenaForAllocation());\n      // We can guarantee here that repeated and result are either both heap\n      // allocated or arena owned. So it is safe to call the unsafe version\n      // of AddAllocated.\n      repeated-\u003eUnsafeArenaAddAllocated\u003cGenericTypeHandler\u003cMessage\u003e \u003e(result);\n    }\n\n    return result;\n  }\n}\n\nvoid Reflection::AddAllocatedMessage(Message* message,\n                                     const FieldDescriptor* field,\n                                     Message* new_entry) const {\n  USAGE_CHECK_ALL(AddAllocatedMessage, REPEATED, MESSAGE);\n  CheckInvalidAccess(schema_, field);\n\n  if (field-\u003eis_extension()) {\n    MutableExtensionSet(message)-\u003eAddAllocatedMessage(field, new_entry);\n  } else {\n    RepeatedPtrFieldBase* repeated = nullptr;\n    if (IsMapFieldInApi(field)) {\n      repeated =\n          MutableRaw\u003cMapFieldBase\u003e(message, field)-\u003eMutableRepeatedField();\n    } else {\n      repeated = MutableRaw\u003cRepeatedPtrFieldBase\u003e(message, field);\n    }\n    repeated-\u003eAddAllocated\u003cGenericTypeHandler\u003cMessage\u003e \u003e(new_entry);\n  }\n}\n\nvoid Reflection::UnsafeArenaAddAllocatedMessage(Message* message,\n                                                const FieldDescriptor* field,\n                                                Message* new_entry) const {\n  USAGE_CHECK_ALL(UnsafeArenaAddAllocatedMessage, REPEATED, MESSAGE);\n  CheckInvalidAccess(schema_, field);\n\n  if (field-\u003eis_extension()) {\n    MutableExtensionSet(message)-\u003eUnsafeArenaAddAllocatedMessage(field,\n                                                                 new_entry);\n  } else {\n    RepeatedPtrFieldBase* repeated = nullptr;\n    if (IsMapFieldInApi(field)) {\n      repeated =\n          MutableRaw\u003cMapFieldBase\u003e(message, field)-\u003eMutableRepeatedField();\n    } else {\n      repeated = MutableRaw\u003cRepeatedPtrFieldBase\u003e(message, field);\n    }\n    repeated-\u003eUnsafeArenaAddAllocated\u003cGenericTypeHandler\u003cMessage\u003e\u003e(new_entry);\n  }\n}\n\nvoid* Reflection::MutableRawRepeatedField(Message* message,\n                                          const FieldDescriptor* field,\n                                          FieldDescriptor::CppType cpptype,\n                                          int ctype,\n                                          const Descriptor* desc) const {\n  (void)ctype;  // Parameter is used by Google-internal code.\n  USAGE_CHECK_REPEATED(\"MutableRawRepeatedField\");\n  CheckInvalidAccess(schema_, field);\n\n  if (field-\u003ecpp_type() != cpptype \u0026\u0026\n      (field-\u003ecpp_type() != FieldDescriptor::CPPTYPE_ENUM ||\n       cpptype != FieldDescriptor::CPPTYPE_INT32))\n    ReportReflectionUsageTypeError(descriptor_, field,\n                                   \"MutableRawRepeatedField\", cpptype);\n  if (desc != nullptr)\n    GOOGLE_CHECK_EQ(field-\u003emessage_type(), desc) \u003c\u003c \"wrong submessage type\";\n  if (field-\u003eis_extension()) {\n    return MutableExtensionSet(message)-\u003eMutableRawRepeatedField(\n        field-\u003enumber(), field-\u003etype(), field-\u003eis_packed(), field);\n  } else {\n    // Trigger transform for MapField\n    if (IsMapFieldInApi(field)) {\n      return MutableRawNonOneof\u003cMapFieldBase\u003e(message, field)\n          -\u003eMutableRepeatedField();\n    }\n    return MutableRawNonOneof\u003cvoid\u003e(message, field);\n  }\n}\n\nconst void* Reflection::GetRawRepeatedField(const Message\u0026 message,\n                                            const FieldDescriptor* field,\n                                            FieldDescriptor::CppType cpptype,\n                                            int ctype,\n                                            const Descriptor* desc) const {\n  USAGE_CHECK_REPEATED(\"GetRawRepeatedField\");\n  if (field-\u003ecpp_type() != cpptype)\n    ReportReflectionUsageTypeError(descriptor_, field, \"GetRawRepeatedField\",\n                                   cpptype);\n  if (ctype \u003e= 0)\n    GOOGLE_CHECK_EQ(field-\u003eoptions().ctype(), ctype) \u003c\u003c \"subtype mismatch\";\n  if (desc != nullptr)\n    GOOGLE_CHECK_EQ(field-\u003emessage_type(), desc) \u003c\u003c \"wrong submessage type\";\n  if (field-\u003eis_extension()) {\n    // Should use extension_set::GetRawRepeatedField. However, the required\n    // parameter \"default repeated value\" is not very easy to get here.\n    // Map is not supported in extensions, it is acceptable to use\n    // extension_set::MutableRawRepeatedField which does not change the message.\n    return MutableExtensionSet(const_cast\u003cMessage*\u003e(\u0026message))\n        -\u003eMutableRawRepeatedField(field-\u003enumber(), field-\u003etype(),\n                                  field-\u003eis_packed(), field);\n  } else {\n    // Trigger transform for MapField\n    if (IsMapFieldInApi(field)) {\n      return \u0026(GetRawNonOneof\u003cMapFieldBase\u003e(message, field).GetRepeatedField());\n    }\n    return \u0026GetRawNonOneof\u003cchar\u003e(message, field);\n  }\n}\n\nconst FieldDescriptor* Reflection::GetOneofFieldDescriptor(\n    const Message\u0026 message, const OneofDescriptor* oneof_descriptor) const {\n  if (oneof_descriptor-\u003eis_synthetic()) {\n    const FieldDescriptor* field = oneof_descriptor-\u003efield(0);\n    return HasField(message, field) ? field : nullptr;\n  }\n  uint32_t field_number = GetOneofCase(message, oneof_descriptor);\n  if (field_number == 0) {\n    return nullptr;\n  }\n  return descriptor_-\u003eFindFieldByNumber(field_number);\n}\n\nbool Reflection::ContainsMapKey(const Message\u0026 message,\n                                const FieldDescriptor* field,\n                                const MapKey\u0026 key) const {\n  USAGE_CHECK(IsMapFieldInApi(field), \"LookupMapValue\",\n              \"Field is not a map field.\");\n  return GetRaw\u003cMapFieldBase\u003e(message, field).ContainsMapKey(key);\n}\n\nbool Reflection::InsertOrLookupMapValue(Message* message,\n                                        const FieldDescriptor* field,\n                                        const MapKey\u0026 key,\n                                        MapValueRef* val) const {\n  USAGE_CHECK(IsMapFieldInApi(field), \"InsertOrLookupMapValue\",\n              \"Field is not a map field.\");\n  val-\u003eSetType(field-\u003emessage_type()-\u003eFindFieldByName(\"value\")-\u003ecpp_type());\n  return MutableRaw\u003cMapFieldBase\u003e(message, field)\n      -\u003eInsertOrLookupMapValue(key, val);\n}\n\nbool Reflection::LookupMapValue(const Message\u0026 message,\n                                const FieldDescriptor* field, const MapKey\u0026 key,\n                                MapValueConstRef* val) const {\n  USAGE_CHECK(IsMapFieldInApi(field), \"LookupMapValue\",\n              \"Field is not a map field.\");\n  val-\u003eSetType(field-\u003emessage_type()-\u003eFindFieldByName(\"value\")-\u003ecpp_type());\n  return GetRaw\u003cMapFieldBase\u003e(message, field).LookupMapValue(key, val);\n}\n\nbool Reflection::DeleteMapValue(Message* message, const FieldDescriptor* field,\n                                const MapKey\u0026 key) const {\n  USAGE_CHECK(IsMapFieldInApi(field), \"DeleteMapValue\",\n              \"Field is not a map field.\");\n  return MutableRaw\u003cMapFieldBase\u003e(message, field)-\u003eDeleteMapValue(key);\n}\n\nMapIterator Reflection::MapBegin(Message* message,\n                                 const FieldDescriptor* field) const {\n  USAGE_CHECK(IsMapFieldInApi(field), \"MapBegin\", \"Field is not a map field.\");\n  MapIterator iter(message, field);\n  GetRaw\u003cMapFieldBase\u003e(*message, field).MapBegin(\u0026iter);\n  return iter;\n}\n\nMapIterator Reflection::MapEnd(Message* message,\n                               const FieldDescriptor* field) const {\n  USAGE_CHECK(IsMapFieldInApi(field), \"MapEnd\", \"Field is not a map field.\");\n  MapIterator iter(message, field);\n  GetRaw\u003cMapFieldBase\u003e(*message, field).MapEnd(\u0026iter);\n  return iter;\n}\n\nint Reflection::MapSize(const Message\u0026 message,\n                        const FieldDescriptor* field) const {\n  USAGE_CHECK(IsMapFieldInApi(field), \"MapSize\", \"Field is not a map field.\");\n  return GetRaw\u003cMapFieldBase\u003e(message, field).size();\n}\n\n// -----------------------------------------------------------------------------\n\nconst FieldDescriptor* Reflection::FindKnownExtensionByName(\n    const std::string\u0026 name) const {\n  if (!schema_.HasExtensionSet()) return nullptr;\n  return descriptor_pool_-\u003eFindExtensionByPrintableName(descriptor_, name);\n}\n\nconst FieldDescriptor* Reflection::FindKnownExtensionByNumber(\n    int number) const {\n  if (!schema_.HasExtensionSet()) return nullptr;\n  return descriptor_pool_-\u003eFindExtensionByNumber(descriptor_, number);\n}\n\nbool Reflection::SupportsUnknownEnumValues() const {\n  return CreateUnknownEnumValues(descriptor_-\u003efile());\n}\n\n// ===================================================================\n// Some private helpers.\n\n// These simple template accessors obtain pointers (or references) to\n// the given field.\n\ntemplate \u003cclass Type\u003e\nconst Type\u0026 Reflection::GetRawNonOneof(const Message\u0026 message,\n                                       const FieldDescriptor* field) const {\n  return GetConstRefAtOffset\u003cType\u003e(message,\n                                   schema_.GetFieldOffsetNonOneof(field));\n}\n\ntemplate \u003cclass Type\u003e\nType* Reflection::MutableRawNonOneof(Message* message,\n                                     const FieldDescriptor* field) const {\n  return GetPointerAtOffset\u003cType\u003e(message,\n                                  schema_.GetFieldOffsetNonOneof(field));\n}\n\ntemplate \u003ctypename Type\u003e\nType* Reflection::MutableRaw(Message* message,\n                             const FieldDescriptor* field) const {\n  return GetPointerAtOffset\u003cType\u003e(message, schema_.GetFieldOffset(field));\n}\n\nconst uint32_t* Reflection::GetHasBits(const Message\u0026 message) const {\n  GOOGLE_DCHECK(schema_.HasHasbits());\n  return \u0026GetConstRefAtOffset\u003cuint32_t\u003e(message, schema_.HasBitsOffset());\n}\n\nuint32_t* Reflection::MutableHasBits(Message* message) const {\n  GOOGLE_DCHECK(schema_.HasHasbits());\n  return GetPointerAtOffset\u003cuint32_t\u003e(message, schema_.HasBitsOffset());\n}\n\nuint32_t* Reflection::MutableOneofCase(\n    Message* message, const OneofDescriptor* oneof_descriptor) const {\n  GOOGLE_DCHECK(!oneof_descriptor-\u003eis_synthetic());\n  return GetPointerAtOffset\u003cuint32_t\u003e(\n      message, schema_.GetOneofCaseOffset(oneof_descriptor));\n}\n\nconst ExtensionSet\u0026 Reflection::GetExtensionSet(const Message\u0026 message) const {\n  return GetConstRefAtOffset\u003cExtensionSet\u003e(message,\n                                           schema_.GetExtensionSetOffset());\n}\n\nExtensionSet* Reflection::MutableExtensionSet(Message* message) const {\n  return GetPointerAtOffset\u003cExtensionSet\u003e(message,\n                                          schema_.GetExtensionSetOffset());\n}\n\nconst InternalMetadata\u0026 Reflection::GetInternalMetadata(\n    const Message\u0026 message) const {\n  return GetConstRefAtOffset\u003cInternalMetadata\u003e(message,\n                                               schema_.GetMetadataOffset());\n}\n\nInternalMetadata* Reflection::MutableInternalMetadata(Message* message) const {\n  return GetPointerAtOffset\u003cInternalMetadata\u003e(message,\n                                              schema_.GetMetadataOffset());\n}\n\nconst uint32_t* Reflection::GetInlinedStringDonatedArray(\n    const Message\u0026 message) const {\n  GOOGLE_DCHECK(schema_.HasInlinedString());\n  return \u0026GetConstRefAtOffset\u003cuint32_t\u003e(message,\n                                        schema_.InlinedStringDonatedOffset());\n}\n\nuint32_t* Reflection::MutableInlinedStringDonatedArray(Message* message) const {\n  GOOGLE_DCHECK(schema_.HasHasbits());\n  return GetPointerAtOffset\u003cuint32_t\u003e(message,\n                                      schema_.InlinedStringDonatedOffset());\n}\n\n// Simple accessors for manipulating _inlined_string_donated_;\nbool Reflection::IsInlinedStringDonated(const Message\u0026 message,\n                                        const FieldDescriptor* field) const {\n  return IsIndexInHasBitSet(GetInlinedStringDonatedArray(message),\n                            schema_.InlinedStringIndex(field));\n}\n\n// Simple accessors for manipulating has_bits_.\nbool Reflection::HasBit(const Message\u0026 message,\n                        const FieldDescriptor* field) const {\n  GOOGLE_DCHECK(!field-\u003eoptions().weak());\n  if (schema_.HasBitIndex(field) != static_cast\u003cuint32_t\u003e(-1)) {\n    return IsIndexInHasBitSet(GetHasBits(message), schema_.HasBitIndex(field));\n  }\n\n  // Intentionally check here because HasBitIndex(field) != -1 means valid.\n  CheckInvalidAccess(schema_, field);\n\n  // proto3: no has-bits. All fields present except messages, which are\n  // present only if their message-field pointer is non-null.\n  if (field-\u003ecpp_type() == FieldDescriptor::CPPTYPE_MESSAGE) {\n    return !schema_.IsDefaultInstance(message) \u0026\u0026\n           GetRaw\u003cconst Message*\u003e(message, field) != nullptr;\n  } else {\n    // Non-message field (and non-oneof, since that was handled in HasField()\n    // before calling us), and singular (again, checked in HasField). So, this\n    // field must be a scalar.\n\n    // Scalar primitive (numeric or string/bytes) fields are present if\n    // their value is non-zero (numeric) or non-empty (string/bytes). N.B.:\n    // we must use this definition here, rather than the \"scalar fields\n    // always present\" in the proto3 docs, because MergeFrom() semantics\n    // require presence as \"present on wire\", and reflection-based merge\n    // (which uses HasField()) needs to be consistent with this.\n    switch (field-\u003ecpp_type()) {\n      case FieldDescriptor::CPPTYPE_STRING:\n        switch (field-\u003eoptions().ctype()) {\n          default: {\n            if (IsInlined(field)) {\n              return !GetField\u003cInlinedStringField\u003e(message, field)\n                          .GetNoArena()\n                          .empty();\n            }\n\n            return GetField\u003cArenaStringPtr\u003e(message, field).Get().size() \u003e 0;\n          }\n        }\n        return false;\n      case FieldDescriptor::CPPTYPE_BOOL:\n        return GetRaw\u003cbool\u003e(message, field) != false;\n      case FieldDescriptor::CPPTYPE_INT32:\n        return GetRaw\u003cint32_t\u003e(message, field) != 0;\n      case FieldDescriptor::CPPTYPE_INT64:\n        return GetRaw\u003cint64_t\u003e(message, field) != 0;\n      case FieldDescriptor::CPPTYPE_UINT32:\n        return GetRaw\u003cuint32_t\u003e(message, field) != 0;\n      case FieldDescriptor::CPPTYPE_UINT64:\n        return GetRaw\u003cuint64_t\u003e(message, field) != 0;\n      case FieldDescriptor::CPPTYPE_FLOAT:\n        static_assert(sizeof(uint32_t) == sizeof(float),\n                      \"Code assumes uint32_t and float are the same size.\");\n        return GetRaw\u003cuint32_t\u003e(message, field) != 0;\n      case FieldDescriptor::CPPTYPE_DOUBLE:\n        static_assert(sizeof(uint64_t) == sizeof(double),\n                      \"Code assumes uint64_t and double are the same size.\");\n        return GetRaw\u003cuint64_t\u003e(message, field) != 0;\n      case FieldDescriptor::CPPTYPE_ENUM:\n        return GetRaw\u003cint\u003e(message, field) != 0;\n      case FieldDescriptor::CPPTYPE_MESSAGE:\n        // handled above; avoid warning\n        break;\n    }\n    GOOGLE_LOG(FATAL) \u003c\u003c \"Reached impossible case in HasBit().\";\n    return false;\n  }\n}\n\nvoid Reflection::SetBit(Message* message, const FieldDescriptor* field) const {\n  GOOGLE_DCHECK(!field-\u003eoptions().weak());\n  const uint32_t index = schema_.HasBitIndex(field);\n  if (index == static_cast\u003cuint32_t\u003e(-1)) return;\n  MutableHasBits(message)[index / 32] |=\n      (static_cast\u003cuint32_t\u003e(1) \u003c\u003c (index % 32));\n}\n\nvoid Reflection::ClearBit(Message* message,\n                          const FieldDescriptor* field) const {\n  GOOGLE_DCHECK(!field-\u003eoptions().weak());\n  const uint32_t index = schema_.HasBitIndex(field);\n  if (index == static_cast\u003cuint32_t\u003e(-1)) return;\n  MutableHasBits(message)[index / 32] \u0026=\n      ~(static_cast\u003cuint32_t\u003e(1) \u003c\u003c (index % 32));\n}\n\nvoid Reflection::SwapBit(Message* message1, Message* message2,\n                         const FieldDescriptor* field) const {\n  GOOGLE_DCHECK(!field-\u003eoptions().weak());\n  if (!schema_.HasHasbits()) {\n    return;\n  }\n  bool temp_has_bit = HasBit(*message1, field);\n  if (HasBit(*message2, field)) {\n    SetBit(message1, field);\n  } else {\n    ClearBit(message1, field);\n  }\n  if (temp_has_bit) {\n    SetBit(message2, field);\n  } else {\n    ClearBit(message2, field);\n  }\n}\n\nbool Reflection::HasOneof(const Message\u0026 message,\n                          const OneofDescriptor* oneof_descriptor) const {\n  if (oneof_descriptor-\u003eis_synthetic()) {\n    return HasField(message, oneof_descriptor-\u003efield(0));\n  }\n  return (GetOneofCase(message, oneof_descriptor) \u003e 0);\n}\n\nvoid Reflection::SetOneofCase(Message* message,\n                              const FieldDescriptor* field) const {\n  *MutableOneofCase(message, field-\u003econtaining_oneof()) = field-\u003enumber();\n}\n\nvoid Reflection::ClearOneofField(Message* message,\n                                 const FieldDescriptor* field) const {\n  if (HasOneofField(*message, field)) {\n    ClearOneof(message, field-\u003econtaining_oneof());\n  }\n}\n\nvoid Reflection::ClearOneof(Message* message,\n                            const OneofDescriptor* oneof_descriptor) const {\n  if (oneof_descriptor-\u003eis_synthetic()) {\n    ClearField(message, oneof_descriptor-\u003efield(0));\n    return;\n  }\n  // TODO(jieluo): Consider to cache the unused object instead of deleting\n  // it. It will be much faster if an application switches a lot from\n  // a few oneof fields.  Time/space tradeoff\n  uint32_t oneof_case = GetOneofCase(*message, oneof_descriptor);\n  if (oneof_case \u003e 0) {\n    const FieldDescriptor* field = descriptor_-\u003eFindFieldByNumber(oneof_case);\n    if (message-\u003eGetArenaForAllocation() == nullptr) {\n      switch (field-\u003ecpp_type()) {\n        case FieldDescriptor::CPPTYPE_STRING: {\n          switch (field-\u003eoptions().ctype()) {\n            default:  // TODO(kenton):  Support other string reps.\n            case FieldOptions::STRING: {\n              // Oneof string fields are never set as a default instance.\n              // We just need to pass some arbitrary default string to make it\n              // work. This allows us to not have the real default accessible\n              // from reflection.\n              MutableField\u003cArenaStringPtr\u003e(message, field)\n                  -\u003eDestroy(nullptr, message-\u003eGetArenaForAllocation());\n              break;\n            }\n          }\n          break;\n        }\n\n        case FieldDescriptor::CPPTYPE_MESSAGE:\n          delete *MutableRaw\u003cMessage*\u003e(message, field);\n          break;\n        default:\n          break;\n      }\n    }\n\n    *MutableOneofCase(message, oneof_descriptor) = 0;\n  }\n}\n\n#define HANDLE_TYPE(TYPE, CPPTYPE, CTYPE)                                  \\\n  template \u003c\u003e                                                              \\\n  const RepeatedField\u003cTYPE\u003e\u0026 Reflection::GetRepeatedFieldInternal\u003cTYPE\u003e(   \\\n      const Message\u0026 message, const FieldDescriptor* field) const {        \\\n    return *static_cast\u003cRepeatedField\u003cTYPE\u003e*\u003e(MutableRawRepeatedField(     \\\n        const_cast\u003cMessage*\u003e(\u0026message), field, CPPTYPE, CTYPE, nullptr));  \\\n  }                                                                        \\\n                                                                           \\\n  template \u003c\u003e                                                              \\\n  RepeatedField\u003cTYPE\u003e* Reflection::MutableRepeatedFieldInternal\u003cTYPE\u003e(     \\\n      Message * message, const FieldDescriptor* field) const {             \\\n    return static_cast\u003cRepeatedField\u003cTYPE\u003e*\u003e(                              \\\n        MutableRawRepeatedField(message, field, CPPTYPE, CTYPE, nullptr)); \\\n  }\n\nHANDLE_TYPE(int32_t, FieldDescriptor::CPPTYPE_INT32, -1);\nHANDLE_TYPE(int64_t, FieldDescriptor::CPPTYPE_INT64, -1);\nHANDLE_TYPE(uint32_t, FieldDescriptor::CPPTYPE_UINT32, -1);\nHANDLE_TYPE(uint64_t, FieldDescriptor::CPPTYPE_UINT64, -1);\nHANDLE_TYPE(float, FieldDescriptor::CPPTYPE_FLOAT, -1);\nHANDLE_TYPE(double, FieldDescriptor::CPPTYPE_DOUBLE, -1);\nHANDLE_TYPE(bool, FieldDescriptor::CPPTYPE_BOOL, -1);\n\n\n#undef HANDLE_TYPE\n\nvoid* Reflection::MutableRawRepeatedString(Message* message,\n                                           const FieldDescriptor* field,\n                                           bool is_string) const {\n  (void)is_string;  // Parameter is used by Google-internal code.\n  return MutableRawRepeatedField(message, field,\n                                 FieldDescriptor::CPPTYPE_STRING,\n                                 FieldOptions::STRING, nullptr);\n}\n\n// Template implementations of basic accessors.  Inline because each\n// template instance is only called from one location.  These are\n// used for all types except messages.\ntemplate \u003ctypename Type\u003e\nconst Type\u0026 Reflection::GetField(const Message\u0026 message,\n                                 const FieldDescriptor* field) const {\n  return GetRaw\u003cType\u003e(message, field);\n}\n\ntemplate \u003ctypename Type\u003e\nvoid Reflection::SetField(Message* message, const FieldDescriptor* field,\n                          const Type\u0026 value) const {\n  bool real_oneof = schema_.InRealOneof(field);\n  if (real_oneof \u0026\u0026 !HasOneofField(*message, field)) {\n    ClearOneof(message, field-\u003econtaining_oneof());\n  }\n  *MutableRaw\u003cType\u003e(message, field) = value;\n  real_oneof ? SetOneofCase(message, field) : SetBit(message, field);\n}\n\ntemplate \u003ctypename Type\u003e\nType* Reflection::MutableField(Message* message,\n                               const FieldDescriptor* field) const {\n  schema_.InRealOneof(field) ? SetOneofCase(message, field)\n                             : SetBit(message, field);\n  return MutableRaw\u003cType\u003e(message, field);\n}\n\ntemplate \u003ctypename Type\u003e\nconst Type\u0026 Reflection::GetRepeatedField(const Message\u0026 message,\n                                         const FieldDescriptor* field,\n                                         int index) const {\n  return GetRaw\u003cRepeatedField\u003cType\u003e \u003e(message, field).Get(index);\n}\n\ntemplate \u003ctypename Type\u003e\nconst Type\u0026 Reflection::GetRepeatedPtrField(const Message\u0026 message,\n                                            const FieldDescriptor* field,\n                                            int index) const {\n  return GetRaw\u003cRepeatedPtrField\u003cType\u003e \u003e(message, field).Get(index);\n}\n\ntemplate \u003ctypename Type\u003e\nvoid Reflection::SetRepeatedField(Message* message,\n                                  const FieldDescriptor* field, int index,\n                                  Type value) const {\n  MutableRaw\u003cRepeatedField\u003cType\u003e \u003e(message, field)-\u003eSet(index, value);\n}\n\ntemplate \u003ctypename Type\u003e\nType* Reflection::MutableRepeatedField(Message* message,\n                                       const FieldDescriptor* field,\n                                       int index) const {\n  RepeatedPtrField\u003cType\u003e* repeated =\n      MutableRaw\u003cRepeatedPtrField\u003cType\u003e \u003e(message, field);\n  return repeated-\u003eMutable(index);\n}\n\ntemplate \u003ctypename Type\u003e\nvoid Reflection::AddField(Message* message, const FieldDescriptor* field,\n                          const Type\u0026 value) const {\n  MutableRaw\u003cRepeatedField\u003cType\u003e \u003e(message, field)-\u003eAdd(value);\n}\n\ntemplate \u003ctypename Type\u003e\nType* Reflection::AddField(Message* message,\n                           const FieldDescriptor* field) const {\n  RepeatedPtrField\u003cType\u003e* repeated =\n      MutableRaw\u003cRepeatedPtrField\u003cType\u003e \u003e(message, field);\n  return repeated-\u003eAdd();\n}\n\nMessageFactory* Reflection::GetMessageFactory() const {\n  return message_factory_;\n}\n\nvoid* Reflection::RepeatedFieldData(Message* message,\n                                    const FieldDescriptor* field,\n                                    FieldDescriptor::CppType cpp_type,\n                                    const Descriptor* message_type) const {\n  GOOGLE_CHECK(field-\u003eis_repeated());\n  GOOGLE_CHECK(field-\u003ecpp_type() == cpp_type ||\n        (field-\u003ecpp_type() == FieldDescriptor::CPPTYPE_ENUM \u0026\u0026\n         cpp_type == FieldDescriptor::CPPTYPE_INT32))\n      \u003c\u003c \"The type parameter T in RepeatedFieldRef\u003cT\u003e API doesn't match \"\n      \u003c\u003c \"the actual field type (for enums T should be the generated enum \"\n      \u003c\u003c \"type or int32_t).\";\n  if (message_type != nullptr) {\n    GOOGLE_CHECK_EQ(message_type, field-\u003emessage_type());\n  }\n  if (field-\u003eis_extension()) {\n    return MutableExtensionSet(message)-\u003eMutableRawRepeatedField(\n        field-\u003enumber(), field-\u003etype(), field-\u003eis_packed(), field);\n  } else {\n    return MutableRawNonOneof\u003cchar\u003e(message, field);\n  }\n}\n\nMapFieldBase* Reflection::MutableMapData(Message* message,\n                                         const FieldDescriptor* field) const {\n  USAGE_CHECK(IsMapFieldInApi(field), \"GetMapData\",\n              \"Field is not a map field.\");\n  return MutableRaw\u003cMapFieldBase\u003e(message, field);\n}\n\nconst MapFieldBase* Reflection::GetMapData(const Message\u0026 message,\n                                           const FieldDescriptor* field) const {\n  USAGE_CHECK(IsMapFieldInApi(field), \"GetMapData\",\n              \"Field is not a map field.\");\n  return \u0026(GetRaw\u003cMapFieldBase\u003e(message, field));\n}\n\nnamespace {\n\n// Helper function to transform migration schema into reflection schema.\nReflectionSchema MigrationToReflectionSchema(\n    const Message* const* default_instance, const uint32_t* offsets,\n    MigrationSchema migration_schema) {\n  ReflectionSchema result;\n  result.default_instance_ = *default_instance;\n  // First 7 offsets are offsets to the special fields. The following offsets\n  // are the proto fields.\n  result.offsets_ = offsets + migration_schema.offsets_index + 6;\n  result.has_bit_indices_ = offsets + migration_schema.has_bit_indices_index;\n  result.has_bits_offset_ = offsets[migration_schema.offsets_index + 0];\n  result.metadata_offset_ = offsets[migration_schema.offsets_index + 1];\n  result.extensions_offset_ = offsets[migration_schema.offsets_index + 2];\n  result.oneof_case_offset_ = offsets[migration_schema.offsets_index + 3];\n  result.object_size_ = migration_schema.object_size;\n  result.weak_field_map_offset_ = offsets[migration_schema.offsets_index + 4];\n  result.inlined_string_donated_offset_ =\n      offsets[migration_schema.offsets_index + 5];\n  result.inlined_string_indices_ =\n      offsets + migration_schema.inlined_string_indices_index;\n  return result;\n}\n\n}  // namespace\n\nclass AssignDescriptorsHelper {\n public:\n  AssignDescriptorsHelper(MessageFactory* factory,\n                          Metadata* file_level_metadata,\n                          const EnumDescriptor** file_level_enum_descriptors,\n                          const MigrationSchema* schemas,\n                          const Message* const* default_instance_data,\n                          const uint32_t* offsets)\n      : factory_(factory),\n        file_level_metadata_(file_level_metadata),\n        file_level_enum_descriptors_(file_level_enum_descriptors),\n        schemas_(schemas),\n        default_instance_data_(default_instance_data),\n        offsets_(offsets) {}\n\n  void AssignMessageDescriptor(const Descriptor* descriptor) {\n    for (int i = 0; i \u003c descriptor-\u003enested_type_count(); i++) {\n      AssignMessageDescriptor(descriptor-\u003enested_type(i));\n    }\n\n    file_level_metadata_-\u003edescriptor = descriptor;\n\n    file_level_metadata_-\u003ereflection =\n        new Reflection(descriptor,\n                       MigrationToReflectionSchema(default_instance_data_,\n                                                   offsets_, *schemas_),\n                       DescriptorPool::internal_generated_pool(), factory_);\n    for (int i = 0; i \u003c descriptor-\u003eenum_type_count(); i++) {\n      AssignEnumDescriptor(descriptor-\u003eenum_type(i));\n    }\n    schemas_++;\n    default_instance_data_++;\n    file_level_metadata_++;\n  }\n\n  void AssignEnumDescriptor(const EnumDescriptor* descriptor) {\n    *file_level_enum_descriptors_ = descriptor;\n    file_level_enum_descriptors_++;\n  }\n\n  const Metadata* GetCurrentMetadataPtr() const { return file_level_metadata_; }\n\n private:\n  MessageFactory* factory_;\n  Metadata* file_level_metadata_;\n  const EnumDescriptor** file_level_enum_descriptors_;\n  const MigrationSchema* schemas_;\n  const Message* const* default_instance_data_;\n  const uint32_t* offsets_;\n};\n\nnamespace {\n\n// We have the routines that assign descriptors and build reflection\n// automatically delete the allocated reflection. MetadataOwner owns\n// all the allocated reflection instances.\nstruct MetadataOwner {\n  ~MetadataOwner() {\n    for (auto range : metadata_arrays_) {\n      for (const Metadata* m = range.first; m \u003c range.second; m++) {\n        delete m-\u003ereflection;\n      }\n    }\n  }\n\n  void AddArray(const Metadata* begin, const Metadata* end) {\n    mu_.Lock();\n    metadata_arrays_.push_back(std::make_pair(begin, end));\n    mu_.Unlock();\n  }\n\n  static MetadataOwner* Instance() {\n    static MetadataOwner* res = OnShutdownDelete(new MetadataOwner);\n    return res;\n  }\n\n private:\n  MetadataOwner() = default;  // private because singleton\n\n  WrappedMutex mu_;\n  std::vector\u003cstd::pair\u003cconst Metadata*, const Metadata*\u003e \u003e metadata_arrays_;\n};\n\nvoid AddDescriptors(const DescriptorTable* table);\n\nvoid AssignDescriptorsImpl(const DescriptorTable* table, bool eager) {\n  // Ensure the file descriptor is added to the pool.\n  {\n    // This only happens once per proto file. So a global mutex to serialize\n    // calls to AddDescriptors.\n    static WrappedMutex mu{GOOGLE_PROTOBUF_LINKER_INITIALIZED};\n    mu.Lock();\n    AddDescriptors(table);\n    mu.Unlock();\n  }\n  if (eager) {\n    // Normally we do not want to eagerly build descriptors of our deps.\n    // However if this proto is optimized for code size (ie using reflection)\n    // and it has a message extending a custom option of a descriptor with that\n    // message being optimized for code size as well. Building the descriptors\n    // in this file requires parsing the serialized file descriptor, which now\n    // requires parsing the message extension, which potentially requires\n    // building the descriptor of the message extending one of the options.\n    // However we are already updating descriptor pool under a lock. To prevent\n    // this the compiler statically looks for this case and we just make sure we\n    // first build the descriptors of all our dependencies, preventing the\n    // deadlock.\n    int num_deps = table-\u003enum_deps;\n    for (int i = 0; i \u003c num_deps; i++) {\n      // In case of weak fields deps[i] could be null.\n      if (table-\u003edeps[i]) AssignDescriptors(table-\u003edeps[i], true);\n    }\n  }\n\n  // Fill the arrays with pointers to descriptors and reflection classes.\n  const FileDescriptor* file =\n      DescriptorPool::internal_generated_pool()-\u003eFindFileByName(\n          table-\u003efilename);\n  GOOGLE_CHECK(file != nullptr);\n\n  MessageFactory* factory = MessageFactory::generated_factory();\n\n  AssignDescriptorsHelper helper(\n      factory, table-\u003efile_level_metadata, table-\u003efile_level_enum_descriptors,\n      table-\u003eschemas, table-\u003edefault_instances, table-\u003eoffsets);\n\n  for (int i = 0; i \u003c file-\u003emessage_type_count(); i++) {\n    helper.AssignMessageDescriptor(file-\u003emessage_type(i));\n  }\n\n  for (int i = 0; i \u003c file-\u003eenum_type_count(); i++) {\n    helper.AssignEnumDescriptor(file-\u003eenum_type(i));\n  }\n  if (file-\u003eoptions().cc_generic_services()) {\n    for (int i = 0; i \u003c file-\u003eservice_count(); i++) {\n      table-\u003efile_level_service_descriptors[i] = file-\u003eservice(i);\n    }\n  }\n  MetadataOwner::Instance()-\u003eAddArray(table-\u003efile_level_metadata,\n                                      helper.GetCurrentMetadataPtr());\n}\n\nvoid AddDescriptorsImpl(const DescriptorTable* table) {\n  // Reflection refers to the default fields so make sure they are initialized.\n  internal::InitProtobufDefaults();\n\n  // Ensure all dependent descriptors are registered to the generated descriptor\n  // pool and message factory.\n  int num_deps = table-\u003enum_deps;\n  for (int i = 0; i \u003c num_deps; i++) {\n    // In case of weak fields deps[i] could be null.\n    if (table-\u003edeps[i]) AddDescriptors(table-\u003edeps[i]);\n  }\n\n  // Register the descriptor of this file.\n  DescriptorPool::InternalAddGeneratedFile(table-\u003edescriptor, table-\u003esize);\n  MessageFactory::InternalRegisterGeneratedFile(table);\n}\n\nvoid AddDescriptors(const DescriptorTable* table) {\n  // AddDescriptors is not thread safe. Callers need to ensure calls are\n  // properly serialized. This function is only called pre-main by global\n  // descriptors and we can assume single threaded access or it's called\n  // by AssignDescriptorImpl which uses a mutex to sequence calls.\n  if (table-\u003eis_initialized) return;\n  table-\u003eis_initialized = true;\n  AddDescriptorsImpl(table);\n}\n\n}  // namespace\n\n// Separate function because it needs to be a friend of\n// Reflection\nvoid RegisterAllTypesInternal(const Metadata* file_level_metadata, int size) {\n  for (int i = 0; i \u003c size; i++) {\n    const Reflection* reflection = file_level_metadata[i].reflection;\n    MessageFactory::InternalRegisterGeneratedMessage(\n        file_level_metadata[i].descriptor,\n        reflection-\u003eschema_.default_instance_);\n  }\n}\n\nnamespace internal {\n\nMetadata AssignDescriptors(const DescriptorTable* (*table)(),\n                           internal::once_flag* once,\n                           const Metadata\u0026 metadata) {\n  call_once(*once, [=] {\n    auto* t = table();\n    AssignDescriptorsImpl(t, t-\u003eis_eager);\n  });\n\n  return metadata;\n}\n\nvoid AssignDescriptors(const DescriptorTable* table, bool eager) {\n  if (!eager) eager = table-\u003eis_eager;\n  call_once(*table-\u003eonce, AssignDescriptorsImpl, table, eager);\n}\n\nAddDescriptorsRunner::AddDescriptorsRunner(const DescriptorTable* table) {\n  AddDescriptors(table);\n}\n\nvoid RegisterFileLevelMetadata(const DescriptorTable* table) {\n  AssignDescriptors(table);\n  RegisterAllTypesInternal(table-\u003efile_level_metadata, table-\u003enum_messages);\n}\n\nvoid UnknownFieldSetSerializer(const uint8_t* base, uint32_t offset,\n                               uint32_t /*tag*/, uint32_t /*has_offset*/,\n                               io::CodedOutputStream* output) {\n  const void* ptr = base + offset;\n  const InternalMetadata* metadata = static_cast\u003cconst InternalMetadata*\u003e(ptr);\n  if (metadata-\u003ehave_unknown_fields()) {\n    internal::WireFormat::SerializeUnknownFields(\n        metadata-\u003eunknown_fields\u003cUnknownFieldSet\u003e(\n            UnknownFieldSet::default_instance),\n        output);\n  }\n}\n\n}  // namespace internal\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":916,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270602208":{"score":0.7072489,"function_name":"SwapFieldHelper::SwapMessage","code":"void SwapFieldHelper::SwapMessage(const Reflection* r, Message* lhs,\n                                  Arena* lhs_arena, Message* rhs,\n                                  Arena* rhs_arena,\n                                  const FieldDescriptor* field) {\n  Message** lhs_sub = r-\u003eMutableRaw\u003cMessage*\u003e(lhs, field);\n  Message** rhs_sub = r-\u003eMutableRaw\u003cMessage*\u003e(rhs, field);\n\n  if (*lhs_sub == *rhs_sub) return;\n\n#ifdef PROTOBUF_FORCE_COPY_IN_SWAP\n  if (lhs_arena != nullptr \u0026\u0026 lhs_arena == rhs_arena) {\n#else   // PROTOBUF_FORCE_COPY_IN_SWAP\n  if (lhs_arena == rhs_arena) {\n#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP\n    std::swap(*lhs_sub, *rhs_sub);\n    return;\n  }\n\n  if (*lhs_sub != nullptr \u0026\u0026 *rhs_sub != nullptr) {\n    (*lhs_sub)-\u003eGetReflection()-\u003eSwap(*lhs_sub, *rhs_sub);\n  } else if (*lhs_sub == nullptr \u0026\u0026 r-\u003eHasBit(*rhs, field)) {\n    *lhs_sub = (*rhs_sub)-\u003eNew(lhs_arena);\n    (*lhs_sub)-\u003eCopyFrom(**rhs_sub);\n    r-\u003eClearField(rhs, field);\n    // Ensures has bit is unchanged after ClearField.\n    r-\u003eSetBit(rhs, field);\n  } else if (*rhs_sub == nullptr \u0026\u0026 r-\u003eHasBit(*lhs, field)) {\n    *rhs_sub = (*lhs_sub)-\u003eNew(rhs_arena);\n    (*rhs_sub)-\u003eCopyFrom(**lhs_sub);\n    r-\u003eClearField(lhs, field);\n    // Ensures has bit is unchanged after ClearField.\n    r-\u003eSetBit(lhs, field);\n  }\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":641,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270602448":{"score":0.67438596,"function_name":"Reflection::UnsafeArenaReleaseMessage","code":"Message* Reflection::UnsafeArenaReleaseMessage(Message* message,\n                                               const FieldDescriptor* field,\n                                               MessageFactory* factory) const {\n  USAGE_CHECK_ALL(ReleaseMessage, SINGULAR, MESSAGE);\n  CheckInvalidAccess(schema_, field);\n\n  if (factory == nullptr) factory = message_factory_;\n\n  if (field-\u003eis_extension()) {\n    return static_cast\u003cMessage*\u003e(\n        MutableExtensionSet(message)-\u003eUnsafeArenaReleaseMessage(field,\n                                                                factory));\n  } else {\n    if (!(field-\u003eis_repeated() || schema_.InRealOneof(field))) {\n      ClearBit(message, field);\n    }\n    if (schema_.InRealOneof(field)) {\n      if (HasOneofField(*message, field)) {\n        *MutableOneofCase(message, field-\u003econtaining_oneof()) = 0;\n      } else {\n        return nullptr;\n      }\n    }\n    Message** result = MutableRaw\u003cMessage*\u003e(message, field);\n    Message* ret = *result;\n    *result = nullptr;\n    return ret;\n  }\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":2069,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270603248":{"score":0.69006383,"function_name":"Reflection::UnsafeArenaSwap","code":"void Reflection::UnsafeArenaSwap(Message* lhs, Message* rhs) const {\n  if (lhs == rhs) return;\n\n  MutableInternalMetadata(lhs)-\u003eInternalSwap(MutableInternalMetadata(rhs));\n\n  for (int i = 0; i \u003c= last_non_weak_field_index_; i++) {\n    const FieldDescriptor* field = descriptor_-\u003efield(i);\n    if (schema_.InRealOneof(field)) continue;\n    if (schema_.IsFieldStripped(field)) continue;\n    UnsafeShallowSwapField(lhs, rhs, field);\n  }\n  const int oneof_decl_count = descriptor_-\u003eoneof_decl_count();\n  for (int i = 0; i \u003c oneof_decl_count; i++) {\n    const OneofDescriptor* oneof = descriptor_-\u003eoneof_decl(i);\n    if (!oneof-\u003eis_synthetic()) {\n      SwapOneofField\u003ctrue\u003e(lhs, rhs, oneof);\n    }\n  }\n\n  // Swapping bits need to happen after swapping fields, because the latter may\n  // depend on the has bit information.\n  if (schema_.HasHasbits()) {\n    uint32* lhs_has_bits = MutableHasBits(lhs);\n    uint32* rhs_has_bits = MutableHasBits(rhs);\n\n    int fields_with_has_bits = 0;\n    for (int i = 0; i \u003c descriptor_-\u003efield_count(); i++) {\n      const FieldDescriptor* field = descriptor_-\u003efield(i);\n      if (field-\u003eis_repeated() || schema_.InRealOneof(field)) {\n        continue;\n      }\n      fields_with_has_bits++;\n    }\n\n    int has_bits_size = (fields_with_has_bits + 31) / 32;\n\n    for (int i = 0; i \u003c has_bits_size; i++) {\n      std::swap(lhs_has_bits[i], rhs_has_bits[i]);\n    }\n  }\n\n  if (schema_.HasExtensionSet()) {\n    MutableExtensionSet(lhs)-\u003eInternalSwap(MutableExtensionSet(rhs));\n  }\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":1077,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270603616":{"score":0.60729706,"function_name":"Reflection::UnsafeShallowSwapField","code":"void Reflection::UnsafeShallowSwapField(Message* message1, Message* message2,\n                                        const FieldDescriptor* field) const {\n  if (!field-\u003eis_repeated()) {\n    if (field-\u003ecpp_type() == FieldDescriptor::CPPTYPE_MESSAGE) {\n      internal::SwapFieldHelper::SwapMessageField\u003ctrue\u003e(this, message1,\n                                                        message2, field);\n    } else if (field-\u003ecpp_type() == FieldDescriptor::CPPTYPE_STRING) {\n      internal::SwapFieldHelper::SwapStringField\u003ctrue\u003e(this, message1, message2,\n                                                       field);\n    } else {\n      SwapField(message1, message2, field);\n    }\n    return;\n  }\n\n  switch (field-\u003ecpp_type()) {\n#define SHALLOW_SWAP_ARRAYS(CPPTYPE, TYPE)                                \\\n  case FieldDescriptor::CPPTYPE_##CPPTYPE:                                \\\n    MutableRaw\u003cRepeatedField\u003cTYPE\u003e\u003e(message1, field)                      \\\n        -\u003eInternalSwap(MutableRaw\u003cRepeatedField\u003cTYPE\u003e\u003e(message2, field)); \\\n    break;\n\n    SHALLOW_SWAP_ARRAYS(INT32, int32_t);\n    SHALLOW_SWAP_ARRAYS(INT64, int64_t);\n    SHALLOW_SWAP_ARRAYS(UINT32, uint32_t);\n    SHALLOW_SWAP_ARRAYS(UINT64, uint64_t);\n    SHALLOW_SWAP_ARRAYS(FLOAT, float);\n    SHALLOW_SWAP_ARRAYS(DOUBLE, double);\n    SHALLOW_SWAP_ARRAYS(BOOL, bool);\n    SHALLOW_SWAP_ARRAYS(ENUM, int);\n#undef SHALLOW_SWAP_ARRAYS\n\n    case FieldDescriptor::CPPTYPE_STRING:\n      internal::SwapFieldHelper::SwapRepeatedStringField\u003ctrue\u003e(this, message1,\n                                                               message2, field);\n      break;\n    case FieldDescriptor::CPPTYPE_MESSAGE:\n      internal::SwapFieldHelper::SwapRepeatedMessageField\u003ctrue\u003e(\n          this, message1, message2, field);\n      break;\n\n    default:\n      GOOGLE_LOG(FATAL) \u003c\u003c \"Unimplemented type: \" \u003c\u003c field-\u003ecpp_type();\n  }\n}","filepath":"src/google/protobuf/generated_message_reflection.cc","line_number":743,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.19.0-rc1"},"270624784":{"score":0.5801462,"function_name":"WireFormat::InternalSerializeField","code":"uint8* WireFormat::InternalSerializeField(const FieldDescriptor* field,\n                                          const Message\u0026 message, uint8* target,\n                                          io::EpsCopyOutputStream* stream) {\n  const Reflection* message_reflection = message.GetReflection();\n\n  if (field-\u003eis_extension() \u0026\u0026\n      field-\u003econtaining_type()-\u003eoptions().message_set_wire_format() \u0026\u0026\n      field-\u003ecpp_type() == FieldDescriptor::CPPTYPE_MESSAGE \u0026\u0026\n      !field-\u003eis_repeated()) {\n    return InternalSerializeMessageSetItem(field, message, target, stream);\n  }\n\n  // For map fields, we can use either repeated field reflection or map\n  // reflection.  Our choice has some subtle effects.  If we use repeated field\n  // reflection here, then the repeated field representation becomes\n  // authoritative for this field: any existing references that came from map\n  // reflection remain valid for reading, but mutations to them are lost and\n  // will be overwritten next time we call map reflection!\n  //\n  // So far this mainly affects Python, which keeps long-term references to map\n  // values around, and always uses map reflection.  See: b/35918691\n  //\n  // Here we choose to use map reflection API as long as the internal\n  // map is valid. In this way, the serialization doesn't change map field's\n  // internal state and existing references that came from map reflection remain\n  // valid for both reading and writing.\n  if (field-\u003eis_map()) {\n    const MapFieldBase* map_field =\n        message_reflection-\u003eGetMapData(message, field);\n    if (map_field-\u003eIsMapValid()) {\n      if (stream-\u003eIsSerializationDeterministic()) {\n        std::vector\u003cMapKey\u003e sorted_key_list =\n            MapKeySorter::SortKey(message, message_reflection, field);\n        for (std::vector\u003cMapKey\u003e::iterator it = sorted_key_list.begin();\n             it != sorted_key_list.end(); ++it) {\n          MapValueRef map_value;\n          message_reflection-\u003eInsertOrLookupMapValue(\n              const_cast\u003cMessage*\u003e(\u0026message), field, *it, \u0026map_value);\n          target =\n              InternalSerializeMapEntry(field, *it, map_value, target, stream);\n        }\n      } else {\n        for (MapIterator it = message_reflection-\u003eMapBegin(\n                 const_cast\u003cMessage*\u003e(\u0026message), field);\n             it !=\n             message_reflection-\u003eMapEnd(const_cast\u003cMessage*\u003e(\u0026message), field);\n             ++it) {\n          target = InternalSerializeMapEntry(field, it.GetKey(),\n                                             it.GetValueRef(), target, stream);\n        }\n      }\n\n      return target;\n    }\n  }\n  int count = 0;\n\n  if (field-\u003eis_repeated()) {\n    count = message_reflection-\u003eFieldSize(message, field);\n  } else if (field-\u003econtaining_type()-\u003eoptions().map_entry()) {\n    // Map entry fields always need to be serialized.\n    count = 1;\n  } else if (message_reflection-\u003eHasField(message, field)) {\n    count = 1;\n  }\n\n  // map_entries is for maps that'll be deterministically serialized.\n  std::vector\u003cconst Message*\u003e map_entries;\n  if (count \u003e 1 \u0026\u0026 field-\u003eis_map() \u0026\u0026 stream-\u003eIsSerializationDeterministic()) {\n    map_entries =\n        DynamicMapSorter::Sort(message, count, message_reflection, field);\n  }\n\n  if (field-\u003eis_packed()) {\n    if (count == 0) return target;\n    stream-\u003eEnsureSpace(\u0026target);\n    switch (field-\u003etype()) {\n#define HANDLE_PRIMITIVE_TYPE(TYPE, CPPTYPE, TYPE_METHOD, CPPTYPE_METHOD)   \\\n  case FieldDescriptor::TYPE_##TYPE: {                                      \\\n    auto r = message_reflection-\u003eGetRepeatedField\u003cCPPTYPE\u003e(message, field); \\\n    target = stream-\u003eWrite##TYPE_METHOD##Packed(                            \\\n        field-\u003enumber(), r, FieldDataOnlyByteSize(field, message), target); \\\n    break;                                                                  \\\n  }\n\n      HANDLE_PRIMITIVE_TYPE(INT32, int32, Int32, Int32)\n      HANDLE_PRIMITIVE_TYPE(INT64, int64, Int64, Int64)\n      HANDLE_PRIMITIVE_TYPE(SINT32, int32, SInt32, Int32)\n      HANDLE_PRIMITIVE_TYPE(SINT64, int64, SInt64, Int64)\n      HANDLE_PRIMITIVE_TYPE(UINT32, uint32, UInt32, UInt32)\n      HANDLE_PRIMITIVE_TYPE(UINT64, uint64, UInt64, UInt64)\n      HANDLE_PRIMITIVE_TYPE(ENUM, int, Enum, Enum)\n\n#undef HANDLE_PRIMITIVE_TYPE\n#define HANDLE_PRIMITIVE_TYPE(TYPE, CPPTYPE, TYPE_METHOD, CPPTYPE_METHOD)   \\\n  case FieldDescriptor::TYPE_##TYPE: {                                      \\\n    auto r = message_reflection-\u003eGetRepeatedField\u003cCPPTYPE\u003e(message, field); \\\n    target = stream-\u003eWriteFixedPacked(field-\u003enumber(), r, target);          \\\n    break;                                                                  \\\n  }\n\n      HANDLE_PRIMITIVE_TYPE(FIXED32, uint32, Fixed32, UInt32)\n      HANDLE_PRIMITIVE_TYPE(FIXED64, uint64, Fixed64, UInt64)\n      HANDLE_PRIMITIVE_TYPE(SFIXED32, int32, SFixed32, Int32)\n      HANDLE_PRIMITIVE_TYPE(SFIXED64, int64, SFixed64, Int64)\n\n      HANDLE_PRIMITIVE_TYPE(FLOAT, float, Float, Float)\n      HANDLE_PRIMITIVE_TYPE(DOUBLE, double, Double, Double)\n\n      HANDLE_PRIMITIVE_TYPE(BOOL, bool, Bool, Bool)\n#undef HANDLE_PRIMITIVE_TYPE\n      default:\n        GOOGLE_LOG(FATAL) \u003c\u003c \"Invalid descriptor\";\n    }\n    return target;\n  }\n\n  for (int j = 0; j \u003c count; j++) {\n    stream-\u003eEnsureSpace(\u0026target);\n    switch (field-\u003etype()) {\n#define HANDLE_PRIMITIVE_TYPE(TYPE, CPPTYPE, TYPE_METHOD, CPPTYPE_METHOD)     \\\n  case FieldDescriptor::TYPE_##TYPE: {                                        \\\n    const CPPTYPE value =                                                     \\\n        field-\u003eis_repeated()                                                  \\\n            ? message_reflection-\u003eGetRepeated##CPPTYPE_METHOD(message, field, \\\n                                                              j)              \\\n            : message_reflection-\u003eGet##CPPTYPE_METHOD(message, field);        \\\n    target = WireFormatLite::Write##TYPE_METHOD##ToArray(field-\u003enumber(),     \\\n                                                         value, target);      \\\n    break;                                                                    \\\n  }\n\n      HANDLE_PRIMITIVE_TYPE(INT32, int32, Int32, Int32)\n      HANDLE_PRIMITIVE_TYPE(INT64, int64, Int64, Int64)\n      HANDLE_PRIMITIVE_TYPE(SINT32, int32, SInt32, Int32)\n      HANDLE_PRIMITIVE_TYPE(SINT64, int64, SInt64, Int64)\n      HANDLE_PRIMITIVE_TYPE(UINT32, uint32, UInt32, UInt32)\n      HANDLE_PRIMITIVE_TYPE(UINT64, uint64, UInt64, UInt64)\n\n      HANDLE_PRIMITIVE_TYPE(FIXED32, uint32, Fixed32, UInt32)\n      HANDLE_PRIMITIVE_TYPE(FIXED64, uint64, Fixed64, UInt64)\n      HANDLE_PRIMITIVE_TYPE(SFIXED32, int32, SFixed32, Int32)\n      HANDLE_PRIMITIVE_TYPE(SFIXED64, int64, SFixed64, Int64)\n\n      HANDLE_PRIMITIVE_TYPE(FLOAT, float, Float, Float)\n      HANDLE_PRIMITIVE_TYPE(DOUBLE, double, Double, Double)\n\n      HANDLE_PRIMITIVE_TYPE(BOOL, bool, Bool, Bool)\n#undef HANDLE_PRIMITIVE_TYPE\n\n#define HANDLE_TYPE(TYPE, TYPE_METHOD, CPPTYPE_METHOD)                         \\\n  case FieldDescriptor::TYPE_##TYPE:                                           \\\n    target = WireFormatLite::InternalWrite##TYPE_METHOD##ToArray(              \\\n        field-\u003enumber(),                                                       \\\n        field-\u003eis_repeated()                                                   \\\n            ? (map_entries.empty()                                             \\\n                   ? message_reflection-\u003eGetRepeated##CPPTYPE_METHOD(message,  \\\n                                                                     field, j) \\\n                   : *map_entries[j])                                          \\\n            : message_reflection-\u003eGet##CPPTYPE_METHOD(message, field),         \\\n        target, stream);                                                       \\\n    break;\n\n      HANDLE_TYPE(GROUP, Group, Message)\n      HANDLE_TYPE(MESSAGE, Message, Message)\n#undef HANDLE_TYPE\n\n      case FieldDescriptor::TYPE_ENUM: {\n        const EnumValueDescriptor* value =\n            field-\u003eis_repeated()\n                ? message_reflection-\u003eGetRepeatedEnum(message, field, j)\n                : message_reflection-\u003eGetEnum(message, field);\n        target = WireFormatLite::WriteEnumToArray(field-\u003enumber(),\n                                                  value-\u003enumber(), target);\n        break;\n      }\n\n      // Handle strings separately so that we can get string references\n      // instead of copying.\n      case FieldDescriptor::TYPE_STRING: {\n        bool strict_utf8_check = StrictUtf8Check(field);\n        std::string scratch;\n        const std::string\u0026 value =\n            field-\u003eis_repeated()\n                ? message_reflection-\u003eGetRepeatedStringReference(message, field,\n                                                                 j, \u0026scratch)\n                : message_reflection-\u003eGetStringReference(message, field,\n                                                         \u0026scratch);\n        if (strict_utf8_check) {\n          WireFormatLite::VerifyUtf8String(value.data(), value.length(),\n                                           WireFormatLite::SERIALIZE,\n                                           field-\u003efull_name().c_str());\n        } else {\n          VerifyUTF8StringNamedField(value.data(), value.length(), SERIALIZE,\n                                     field-\u003efull_name().c_str());\n        }\n        target = stream-\u003eWriteString(field-\u003enumber(), value, target);\n        break;\n      }\n\n      case FieldDescriptor::TYPE_BYTES: {\n        std::string scratch;\n        const std::string\u0026 value =\n            field-\u003eis_repeated()\n                ? message_reflection-\u003eGetRepeatedStringReference(message, field,\n                                                                 j, \u0026scratch)\n                : message_reflection-\u003eGetStringReference(message, field,\n                                                         \u0026scratch);\n        target = stream-\u003eWriteString(field-\u003enumber(), value, target);\n        break;\n      }\n    }\n  }\n  return target;\n}","filepath":"src/google/protobuf/wire_format.cc","line_number":828,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.10.0-rc1"},"270632032":{"score":0.57687545,"function_name":"InternalSerializeMapEntry","code":"static uint8* InternalSerializeMapEntry(const FieldDescriptor* field,\n                                        const MapKey\u0026 key,\n                                        const MapValueRef\u0026 value, uint8* target,\n                                        io::EpsCopyOutputStream* stream) {\n  const FieldDescriptor* key_field = field-\u003emessage_type()-\u003efield(0);\n  const FieldDescriptor* value_field = field-\u003emessage_type()-\u003efield(1);\n\n  size_t size = kMapEntryTagByteSize;\n  size += MapKeyDataOnlyByteSize(key_field, key);\n  size += MapValueRefDataOnlyByteSize(value_field, value);\n  stream-\u003eEnsureSpace(\u0026target);\n  target = WireFormatLite::WriteTagToArray(\n      field-\u003enumber(), WireFormatLite::WIRETYPE_LENGTH_DELIMITED, target);\n  target = io::CodedOutputStream::WriteVarint32ToArray(size, target);\n  target = SerializeMapKeyWithCachedSizes(key_field, key, target, stream);\n  target =\n      SerializeMapValueRefWithCachedSizes(value_field, value, target, stream);\n  return target;\n}","filepath":"src/google/protobuf/wire_format.cc","line_number":808,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.10.0-rc1"},"270632288":{"score":0.6932994,"function_name":"WireFormat::InternalSerializeMessageSetItem","code":"uint8* WireFormat::InternalSerializeMessageSetItem(\n    const FieldDescriptor* field, const Message\u0026 message, uint8* target,\n    io::EpsCopyOutputStream* stream) {\n  const Reflection* message_reflection = message.GetReflection();\n\n  stream-\u003eEnsureSpace(\u0026target);\n  // Start group.\n  target = io::CodedOutputStream::WriteTagToArray(\n      WireFormatLite::kMessageSetItemStartTag, target);\n  // Write type ID.\n  target = WireFormatLite::WriteUInt32ToArray(\n      WireFormatLite::kMessageSetTypeIdNumber, field-\u003enumber(), target);\n  // Write message.\n  target = WireFormatLite::InternalWriteMessageToArray(\n      WireFormatLite::kMessageSetMessageNumber,\n      message_reflection-\u003eGetMessage(message, field), target, stream);\n  // End group.\n  stream-\u003eEnsureSpace(\u0026target);\n  target = io::CodedOutputStream::WriteTagToArray(\n      WireFormatLite::kMessageSetItemEndTag, target);\n  return target;\n}","filepath":"src/google/protobuf/wire_format.cc","line_number":1044,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.10.0-rc1"},"270632464":{"score":0.74429524,"function_name":"WireFormat::InternalSerializeUnknownFieldsToArray","code":"uint8* WireFormat::InternalSerializeUnknownFieldsToArray(\n    const UnknownFieldSet\u0026 unknown_fields, uint8* target,\n    io::EpsCopyOutputStream* stream) {\n  for (int i = 0; i \u003c unknown_fields.field_count(); i++) {\n    const UnknownField\u0026 field = unknown_fields.field(i);\n\n    stream-\u003eEnsureSpace(\u0026target);\n    switch (field.type()) {\n      case UnknownField::TYPE_VARINT:\n        target = WireFormatLite::WriteUInt64ToArray(field.number(),\n                                                    field.varint(), target);\n        break;\n      case UnknownField::TYPE_FIXED32:\n        target = WireFormatLite::WriteFixed32ToArray(field.number(),\n                                                     field.fixed32(), target);\n        break;\n      case UnknownField::TYPE_FIXED64:\n        target = WireFormatLite::WriteFixed64ToArray(field.number(),\n                                                     field.fixed64(), target);\n        break;\n      case UnknownField::TYPE_LENGTH_DELIMITED:\n        target = stream-\u003eWriteString(field.number(), field.length_delimited(),\n                                     target);\n        break;\n      case UnknownField::TYPE_GROUP:\n        target = WireFormatLite::WriteTagToArray(\n            field.number(), WireFormatLite::WIRETYPE_START_GROUP, target);\n        target = InternalSerializeUnknownFieldsToArray(field.group(), target,\n                                                       stream);\n        stream-\u003eEnsureSpace(\u0026target);\n        target = WireFormatLite::WriteTagToArray(\n            field.number(), WireFormatLite::WIRETYPE_END_GROUP, target);\n        break;\n    }\n  }\n  return target;\n}","filepath":"src/google/protobuf/wire_format.cc","line_number":192,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.10.0-rc1"},"270633280":{"score":0.7868295,"function_name":"WireFormat::InternalSerializeUnknownMessageSetItemsToArray","code":"uint8* WireFormat::InternalSerializeUnknownMessageSetItemsToArray(\n    const UnknownFieldSet\u0026 unknown_fields, uint8* target,\n    io::EpsCopyOutputStream* stream) {\n  for (int i = 0; i \u003c unknown_fields.field_count(); i++) {\n    const UnknownField\u0026 field = unknown_fields.field(i);\n\n    // The only unknown fields that are allowed to exist in a MessageSet are\n    // messages, which are length-delimited.\n    if (field.type() == UnknownField::TYPE_LENGTH_DELIMITED) {\n      stream-\u003eEnsureSpace(\u0026target);\n      // Start group.\n      target = io::CodedOutputStream::WriteTagToArray(\n          WireFormatLite::kMessageSetItemStartTag, target);\n\n      // Write type ID.\n      target = io::CodedOutputStream::WriteTagToArray(\n          WireFormatLite::kMessageSetTypeIdTag, target);\n      target =\n          io::CodedOutputStream::WriteVarint32ToArray(field.number(), target);\n\n      // Write message.\n      target = io::CodedOutputStream::WriteTagToArray(\n          WireFormatLite::kMessageSetMessageTag, target);\n\n      target = field.InternalSerializeLengthDelimitedNoTag(target, stream);\n\n      stream-\u003eEnsureSpace(\u0026target);\n      // End group.\n      target = io::CodedOutputStream::WriteTagToArray(\n          WireFormatLite::kMessageSetItemEndTag, target);\n    }\n  }\n\n  return target;\n}","filepath":"src/google/protobuf/wire_format.cc","line_number":230,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.10.0-rc1"},"270634032":{"score":0.58398163,"function_name":"MapValueRefDataOnlyByteSize","code":"static size_t MapValueRefDataOnlyByteSize(const FieldDescriptor* field,\n                                          const MapValueRef\u0026 value) {\n  switch (field-\u003etype()) {\n    case FieldDescriptor::TYPE_GROUP:\n      GOOGLE_LOG(FATAL) \u003c\u003c \"Unsupported\";\n      return 0;\n#define CASE_TYPE(FieldType, CamelFieldType, CamelCppType) \\\n  case FieldDescriptor::TYPE_##FieldType:                  \\\n    return WireFormatLite::CamelFieldType##Size(           \\\n        value.Get##CamelCppType##Value());\n\n#define FIXED_CASE_TYPE(FieldType, CamelFieldType) \\\n  case FieldDescriptor::TYPE_##FieldType:          \\\n    return WireFormatLite::k##CamelFieldType##Size;\n\n      CASE_TYPE(INT32, Int32, Int32);\n      CASE_TYPE(INT64, Int64, Int64);\n      CASE_TYPE(UINT32, UInt32, UInt32);\n      CASE_TYPE(UINT64, UInt64, UInt64);\n      CASE_TYPE(SINT32, SInt32, Int32);\n      CASE_TYPE(SINT64, SInt64, Int64);\n      CASE_TYPE(STRING, String, String);\n      CASE_TYPE(BYTES, Bytes, String);\n      CASE_TYPE(ENUM, Enum, Enum);\n      CASE_TYPE(MESSAGE, Message, Message);\n      FIXED_CASE_TYPE(FIXED32, Fixed32);\n      FIXED_CASE_TYPE(FIXED64, Fixed64);\n      FIXED_CASE_TYPE(SFIXED32, SFixed32);\n      FIXED_CASE_TYPE(SFIXED64, SFixed64);\n      FIXED_CASE_TYPE(DOUBLE, Double);\n      FIXED_CASE_TYPE(FLOAT, Float);\n      FIXED_CASE_TYPE(BOOL, Bool);\n\n#undef CASE_TYPE\n#undef FIXED_CASE_TYPE\n  }\n  GOOGLE_LOG(FATAL) \u003c\u003c \"Cannot get here\";\n  return 0;\n}","filepath":"src/google/protobuf/wire_format.cc","line_number":1179,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.10.0-rc1"},"270634592":{"score":0.7264291,"function_name":"WireFormat::MessageSetItemByteSize","code":"size_t WireFormat::MessageSetItemByteSize(const FieldDescriptor* field,\n                                          const Message\u0026 message) {\n  const Reflection* message_reflection = message.GetReflection();\n\n  size_t our_size = WireFormatLite::kMessageSetItemTagsSize;\n\n  // type_id\n  our_size += io::CodedOutputStream::VarintSize32(field-\u003enumber());\n\n  // message\n  const Message\u0026 sub_message = message_reflection-\u003eGetMessage(message, field);\n  size_t message_size = sub_message.ByteSizeLong();\n\n  our_size += io::CodedOutputStream::VarintSize32(message_size);\n  our_size += message_size;\n\n  return our_size;\n}","filepath":"src/google/protobuf/wire_format.cc","line_number":1330,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.10.0-rc1"},"270635936":{"score":0.6157968,"function_name":"SerializeMapKeyWithCachedSizes","code":"static uint8* SerializeMapKeyWithCachedSizes(const FieldDescriptor* field,\n                                             const MapKey\u0026 value, uint8* target,\n                                             io::EpsCopyOutputStream* stream) {\n  stream-\u003eEnsureSpace(\u0026target);\n  switch (field-\u003etype()) {\n    case FieldDescriptor::TYPE_DOUBLE:\n    case FieldDescriptor::TYPE_FLOAT:\n    case FieldDescriptor::TYPE_GROUP:\n    case FieldDescriptor::TYPE_MESSAGE:\n    case FieldDescriptor::TYPE_BYTES:\n    case FieldDescriptor::TYPE_ENUM:\n      GOOGLE_LOG(FATAL) \u003c\u003c \"Unsupported\";\n      break;\n#define CASE_TYPE(FieldType, CamelFieldType, CamelCppType)   \\\n  case FieldDescriptor::TYPE_##FieldType:                    \\\n    target = WireFormatLite::Write##CamelFieldType##ToArray( \\\n        1, value.Get##CamelCppType##Value(), target);        \\\n    break;\n      CASE_TYPE(INT64, Int64, Int64)\n      CASE_TYPE(UINT64, UInt64, UInt64)\n      CASE_TYPE(INT32, Int32, Int32)\n      CASE_TYPE(FIXED64, Fixed64, UInt64)\n      CASE_TYPE(FIXED32, Fixed32, UInt32)\n      CASE_TYPE(BOOL, Bool, Bool)\n      CASE_TYPE(UINT32, UInt32, UInt32)\n      CASE_TYPE(SFIXED32, SFixed32, Int32)\n      CASE_TYPE(SFIXED64, SFixed64, Int64)\n      CASE_TYPE(SINT32, SInt32, Int32)\n      CASE_TYPE(SINT64, SInt64, Int64)\n#undef CASE_TYPE\n    case FieldDescriptor::TYPE_STRING:\n      target = stream-\u003eWriteString(1, value.GetStringValue(), target);\n      break;\n  }\n  return target;\n}","filepath":"src/google/protobuf/wire_format.cc","line_number":687,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.10.0-rc1"},"270636784":{"score":0.7176374,"function_name":"SerializeMapValueRefWithCachedSizes","code":"static uint8* SerializeMapValueRefWithCachedSizes(\n    const FieldDescriptor* field, const MapValueRef\u0026 value, uint8* target,\n    io::EpsCopyOutputStream* stream) {\n  stream-\u003eEnsureSpace(\u0026target);\n  switch (field-\u003etype()) {\n#define CASE_TYPE(FieldType, CamelFieldType, CamelCppType)   \\\n  case FieldDescriptor::TYPE_##FieldType:                    \\\n    target = WireFormatLite::Write##CamelFieldType##ToArray( \\\n        2, value.Get##CamelCppType##Value(), target);        \\\n    break;\n    CASE_TYPE(INT64, Int64, Int64)\n    CASE_TYPE(UINT64, UInt64, UInt64)\n    CASE_TYPE(INT32, Int32, Int32)\n    CASE_TYPE(FIXED64, Fixed64, UInt64)\n    CASE_TYPE(FIXED32, Fixed32, UInt32)\n    CASE_TYPE(BOOL, Bool, Bool)\n    CASE_TYPE(UINT32, UInt32, UInt32)\n    CASE_TYPE(SFIXED32, SFixed32, Int32)\n    CASE_TYPE(SFIXED64, SFixed64, Int64)\n    CASE_TYPE(SINT32, SInt32, Int32)\n    CASE_TYPE(SINT64, SInt64, Int64)\n    CASE_TYPE(ENUM, Enum, Enum)\n    CASE_TYPE(DOUBLE, Double, Double)\n    CASE_TYPE(FLOAT, Float, Float)\n#undef CASE_TYPE\n    case FieldDescriptor::TYPE_STRING:\n    case FieldDescriptor::TYPE_BYTES:\n      target = stream-\u003eWriteString(2, value.GetStringValue(), target);\n      break;\n    case FieldDescriptor::TYPE_MESSAGE:\n      target = WireFormatLite::InternalWriteMessageToArray(\n          2, value.GetMessageValue(), target, stream);\n      break;\n    case FieldDescriptor::TYPE_GROUP:\n      target = WireFormatLite::InternalWriteGroupToArray(\n          2, value.GetMessageValue(), target, stream);\n      break;\n  }\n  return target;\n}","filepath":"src/google/protobuf/wire_format.cc","line_number":724,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.10.0-rc1"},"270637744":{"score":0.7414328,"function_name":"WireFormat::SkipField","code":"bool WireFormat::SkipField(io::CodedInputStream* input, uint32 tag,\n                           UnknownFieldSet* unknown_fields) {\n  int number = WireFormatLite::GetTagFieldNumber(tag);\n  // Field number 0 is illegal.\n  if (number == 0) return false;\n\n  switch (WireFormatLite::GetTagWireType(tag)) {\n    case WireFormatLite::WIRETYPE_VARINT: {\n      uint64 value;\n      if (!input-\u003eReadVarint64(\u0026value)) return false;\n      if (unknown_fields != NULL) unknown_fields-\u003eAddVarint(number, value);\n      return true;\n    }\n    case WireFormatLite::WIRETYPE_FIXED64: {\n      uint64 value;\n      if (!input-\u003eReadLittleEndian64(\u0026value)) return false;\n      if (unknown_fields != NULL) unknown_fields-\u003eAddFixed64(number, value);\n      return true;\n    }\n    case WireFormatLite::WIRETYPE_LENGTH_DELIMITED: {\n      uint32 length;\n      if (!input-\u003eReadVarint32(\u0026length)) return false;\n      if (unknown_fields == NULL) {\n        if (!input-\u003eSkip(length)) return false;\n      } else {\n        if (!input-\u003eReadString(unknown_fields-\u003eAddLengthDelimited(number),\n                               length)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    case WireFormatLite::WIRETYPE_START_GROUP: {\n      if (!input-\u003eIncrementRecursionDepth()) return false;\n      if (!SkipMessage(input, (unknown_fields == NULL)\n                                  ? NULL\n                                  : unknown_fields-\u003eAddGroup(number))) {\n        return false;\n      }\n      input-\u003eDecrementRecursionDepth();\n      // Check that the ending tag matched the starting tag.\n      if (!input-\u003eLastTagWas(\n              WireFormatLite::MakeTag(WireFormatLite::GetTagFieldNumber(tag),\n                                      WireFormatLite::WIRETYPE_END_GROUP))) {\n        return false;\n      }\n      return true;\n    }\n    case WireFormatLite::WIRETYPE_END_GROUP: {\n      return false;\n    }\n    case WireFormatLite::WIRETYPE_FIXED32: {\n      uint32 value;\n      if (!input-\u003eReadLittleEndian32(\u0026value)) return false;\n      if (unknown_fields != NULL) unknown_fields-\u003eAddFixed32(number, value);\n      return true;\n    }\n    default: {\n      return false;\n    }\n  }\n}","filepath":"src/google/protobuf/wire_format.cc","line_number":85,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.10.0-rc1"},"270638112":{"score":0.6609589,"function_name":"WireFormat::SkipMessage","code":"bool WireFormat::SkipMessage(io::CodedInputStream* input,\n                             UnknownFieldSet* unknown_fields) {\n  while (true) {\n    uint32 tag = input-\u003eReadTag();\n    if (tag == 0) {\n      // End of input.  This is a valid place to end, so return true.\n      return true;\n    }\n\n    WireFormatLite::WireType wire_type = WireFormatLite::GetTagWireType(tag);\n\n    if (wire_type == WireFormatLite::WIRETYPE_END_GROUP) {\n      // Must be the end of the message.\n      return true;\n    }\n\n    if (!SkipField(input, tag, unknown_fields)) return false;\n  }\n}","filepath":"src/google/protobuf/wire_format.cc","line_number":148,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.10.0-rc1"},"270817472":{"score":0.8096758,"function_name":"safe_parse_positive_int","code":"inline bool safe_parse_positive_int(\n    string text, int32* value_p) {\n  int base = 10;\n  int32 value = 0;\n  const int32 vmax = std::numeric_limits\u003cint32\u003e::max();\n  assert(vmax \u003e 0);\n  assert(vmax \u003e= base);\n  const int32 vmax_over_base = vmax / base;\n  const char* start = text.data();\n  const char* end = start + text.size();\n  // loop over digits\n  for (; start \u003c end; ++start) {\n    unsigned char c = static_cast\u003cunsigned char\u003e(start[0]);\n    int digit = c - '0';\n    if (digit \u003e= base || digit \u003c 0) {\n      *value_p = value;\n      return false;\n    }\n    if (value \u003e vmax_over_base) {\n      *value_p = vmax;\n      return false;\n    }\n    value *= base;\n    if (value \u003e vmax - digit) {\n      *value_p = vmax;\n      return false;\n    }\n    value += digit;\n  }\n  *value_p = value;\n  return true;\n}","filepath":"src/google/protobuf/stubs/strutil.cc","line_number":655,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-alpha-3"},"270817808":{"score":0.6458776,"function_name":"AlphaNum::AlphaNum","code":"AlphaNum::AlphaNum(strings::Hex hex) {\n  char *const end = \u0026digits[kFastToBufferSize];\n  char *writer = end;\n  uint64 value = hex.value;\n  uint64 width = hex.spec;\n  // We accomplish minimum width by OR'ing in 0x10000 to the user's value,\n  // where 0x10000 is the smallest hex number that is as wide as the user\n  // asked for.\n  uint64 mask = ((static_cast\u003cuint64\u003e(1) \u003c\u003c (width - 1) * 4)) | value;\n  static const char hexdigits[] = \"0123456789abcdef\";\n  do {\n    *--writer = hexdigits[value \u0026 0xF];\n    value \u003e\u003e= 4;\n    mask \u003e\u003e= 4;\n  } while (mask != 0);\n  piece_data_ = writer;\n  piece_size_ = end - writer;\n}","filepath":"src/google/protobuf/stubs/strutil.cc","line_number":1290,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-alpha-3"},"270817968":{"score":0.77176154,"function_name":"Append4","code":"static char *Append4(char *out,\n                     const AlphaNum \u0026x1, const AlphaNum \u0026x2,\n                     const AlphaNum \u0026x3, const AlphaNum \u0026x4) {\n  memcpy(out, x1.data(), x1.size());\n  out += x1.size();\n\n  memcpy(out, x2.data(), x2.size());\n  out += x2.size();\n\n  memcpy(out, x3.data(), x3.size());\n  out += x3.size();\n\n  memcpy(out, x4.data(), x4.size());\n  return out + x4.size();\n}","filepath":"src/google/protobuf/stubs/strutil.cc","line_number":1334,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-alpha-3"},"270818688":{"score":0.93250114,"function_name":"DelocalizeRadix","code":"void DelocalizeRadix(char* buffer) {\n  // Fast check:  if the buffer has a normal decimal point, assume no\n  // translation is needed.\n  if (strchr(buffer, '.') != NULL) return;\n\n  // Find the first unknown character.\n  while (IsValidFloatChar(*buffer)) ++buffer;\n\n  if (*buffer == '\\0') {\n    // No radix character found.\n    return;\n  }\n\n  // We are now pointing at the locale-specific radix character.  Replace it\n  // with '.'.\n  *buffer = '.';\n  ++buffer;\n\n  if (!IsValidFloatChar(*buffer) \u0026\u0026 *buffer != '\\0') {\n    // It appears the radix was a multi-byte character.  We need to remove the\n    // extra bytes.\n    char* target = buffer;\n    do { ++buffer; } while (!IsValidFloatChar(*buffer) \u0026\u0026 *buffer != '\\0');\n    memmove(target, buffer, strlen(buffer) + 1);\n  }\n}","filepath":"src/google/protobuf/stubs/strutil.cc","line_number":1168,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-alpha-3"},"270818864":{"score":0.7863963,"function_name":"DoubleToBuffer","code":"char* DoubleToBuffer(double value, char* buffer) {\n  // DBL_DIG is 15 for IEEE-754 doubles, which are used on almost all\n  // platforms these days.  Just in case some system exists where DBL_DIG\n  // is significantly larger -- and risks overflowing our buffer -- we have\n  // this assert.\n  GOOGLE_COMPILE_ASSERT(DBL_DIG \u003c 20, DBL_DIG_is_too_big);\n\n  if (value == numeric_limits\u003cdouble\u003e::infinity()) {\n    strcpy(buffer, \"inf\");\n    return buffer;\n  } else if (value == -numeric_limits\u003cdouble\u003e::infinity()) {\n    strcpy(buffer, \"-inf\");\n    return buffer;\n  } else if (IsNaN(value)) {\n    strcpy(buffer, \"nan\");\n    return buffer;\n  }\n\n  int snprintf_result =\n    snprintf(buffer, kDoubleToBufferSize, \"%.*g\", DBL_DIG, value);\n\n  // The snprintf should never overflow because the buffer is significantly\n  // larger than the precision we asked for.\n  GOOGLE_DCHECK(snprintf_result \u003e 0 \u0026\u0026 snprintf_result \u003c kDoubleToBufferSize);\n\n  // We need to make parsed_value volatile in order to force the compiler to\n  // write it out to the stack.  Otherwise, it may keep the value in a\n  // register, and if it does that, it may keep it as a long double instead\n  // of a double.  This long double may have extra bits that make it compare\n  // unequal to \"value\" even though it would be exactly equal if it were\n  // truncated to a double.\n  volatile double parsed_value = strtod(buffer, NULL);\n  if (parsed_value != value) {\n    int snprintf_result =\n      snprintf(buffer, kDoubleToBufferSize, \"%.*g\", DBL_DIG+2, value);\n\n    // Should never overflow; see above.\n    GOOGLE_DCHECK(snprintf_result \u003e 0 \u0026\u0026 snprintf_result \u003c kDoubleToBufferSize);\n  }\n\n  DelocalizeRadix(buffer);\n  return buffer;\n}","filepath":"src/google/protobuf/stubs/strutil.cc","line_number":1195,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-alpha-3"},"270819104":{"score":0.96180636,"function_name":"FastInt32ToBuffer","code":"char *FastInt32ToBuffer(int32 i, char* buffer) {\n  // We could collapse the positive and negative sections, but that\n  // would be slightly slower for positive numbers...\n  // 12 bytes is enough to store -2**32, -4294967296.\n  char* p = buffer + kFastInt32ToBufferOffset;\n  *p-- = '\\0';\n  if (i \u003e= 0) {\n    do {\n      *p-- = '0' + i % 10;\n      i /= 10;\n    } while (i \u003e 0);\n    return p + 1;\n  } else {\n    // On different platforms, % and / have different behaviors for\n    // negative numbers, so we need to jump through hoops to make sure\n    // we don't divide negative numbers.\n    if (i \u003e -10) {\n      i = -i;\n      *p-- = '0' + i;\n      *p = '-';\n      return p;\n    } else {\n      // Make sure we aren't at MIN_INT, in which case we can't say i = -i\n      i = i + 10;\n      i = -i;\n      *p-- = '0' + i % 10;\n      // Undo what we did a moment ago\n      i = i / 10 + 1;\n      do {\n        *p-- = '0' + i % 10;\n        i /= 10;\n      } while (i \u003e 0);\n      *p = '-';\n      return p;\n    }\n  }\n}","filepath":"src/google/protobuf/stubs/strutil.cc","line_number":798,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-alpha-3"},"270819312":{"score":0.8663142,"function_name":"FastInt32ToBufferLeft","code":"char* FastInt32ToBufferLeft(int32 i, char* buffer) {\n  uint32 u = i;\n  if (i \u003c 0) {\n    *buffer++ = '-';\n    u = -i;\n  }\n  return FastUInt32ToBufferLeft(u, buffer);\n}","filepath":"src/google/protobuf/stubs/strutil.cc","line_number":1002,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-alpha-3"},"270819344":{"score":0.88843864,"function_name":"FastInt64ToBuffer","code":"char *FastInt64ToBuffer(int64 i, char* buffer) {\n  // We could collapse the positive and negative sections, but that\n  // would be slightly slower for positive numbers...\n  // 22 bytes is enough to store -2**64, -18446744073709551616.\n  char* p = buffer + kFastInt64ToBufferOffset;\n  *p-- = '\\0';\n  if (i \u003e= 0) {\n    do {\n      *p-- = '0' + i % 10;\n      i /= 10;\n    } while (i \u003e 0);\n    return p + 1;\n  } else {\n    // On different platforms, % and / have different behaviors for\n    // negative numbers, so we need to jump through hoops to make sure\n    // we don't divide negative numbers.\n    if (i \u003e -10) {\n      i = -i;\n      *p-- = '0' + i;\n      *p = '-';\n      return p;\n    } else {\n      // Make sure we aren't at MIN_INT, in which case we can't say i = -i\n      i = i + 10;\n      i = -i;\n      *p-- = '0' + i % 10;\n      // Undo what we did a moment ago\n      i = i / 10 + 1;\n      do {\n        *p-- = '0' + i % 10;\n        i /= 10;\n      } while (i \u003e 0);\n      *p = '-';\n      return p;\n    }\n  }\n}","filepath":"src/google/protobuf/stubs/strutil.cc","line_number":753,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-alpha-3"},"270819584":{"score":0.7064182,"function_name":"FastInt64ToBufferLeft","code":"char* FastInt64ToBufferLeft(int64 i, char* buffer) {\n  uint64 u = i;\n  if (i \u003c 0) {\n    *buffer++ = '-';\n    u = -i;\n  }\n  return FastUInt64ToBufferLeft(u, buffer);\n}","filepath":"src/google/protobuf/stubs/strutil.cc","line_number":1053,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-alpha-3"},"270819648":{"score":0.9295175,"function_name":"FastUInt32ToBufferLeft","code":"char* FastUInt32ToBufferLeft(uint32 u, char* buffer) {\n  int digits;\n  const char *ASCII_digits = NULL;\n  // The idea of this implementation is to trim the number of divides to as few\n  // as possible by using multiplication and subtraction rather than mod (%),\n  // and by outputting two digits at a time rather than one.\n  // The huge-number case is first, in the hopes that the compiler will output\n  // that case in one branch-free block of code, and only output conditional\n  // branches into it from below.\n  if (u \u003e= 1000000000) {  // \u003e= 1,000,000,000\n    digits = u / 100000000;  // 100,000,000\n    ASCII_digits = two_ASCII_digits[digits];\n    buffer[0] = ASCII_digits[0];\n    buffer[1] = ASCII_digits[1];\n    buffer += 2;\nsublt100_000_000:\n    u -= digits * 100000000;  // 100,000,000\nlt100_000_000:\n    digits = u / 1000000;  // 1,000,000\n    ASCII_digits = two_ASCII_digits[digits];\n    buffer[0] = ASCII_digits[0];\n    buffer[1] = ASCII_digits[1];\n    buffer += 2;\nsublt1_000_000:\n    u -= digits * 1000000;  // 1,000,000\nlt1_000_000:\n    digits = u / 10000;  // 10,000\n    ASCII_digits = two_ASCII_digits[digits];\n    buffer[0] = ASCII_digits[0];\n    buffer[1] = ASCII_digits[1];\n    buffer += 2;\nsublt10_000:\n    u -= digits * 10000;  // 10,000\nlt10_000:\n    digits = u / 100;\n    ASCII_digits = two_ASCII_digits[digits];\n    buffer[0] = ASCII_digits[0];\n    buffer[1] = ASCII_digits[1];\n    buffer += 2;\nsublt100:\n    u -= digits * 100;\nlt100:\n    digits = u;\n    ASCII_digits = two_ASCII_digits[digits];\n    buffer[0] = ASCII_digits[0];\n    buffer[1] = ASCII_digits[1];\n    buffer += 2;\ndone:\n    *buffer = 0;\n    return buffer;\n  }\n\n  if (u \u003c 100) {\n    digits = u;\n    if (u \u003e= 10) goto lt100;\n    *buffer++ = '0' + digits;\n    goto done;\n  }\n  if (u  \u003c  10000) {   // 10,000\n    if (u \u003e= 1000) goto lt10_000;\n    digits = u / 100;\n    *buffer++ = '0' + digits;\n    goto sublt100;\n  }\n  if (u  \u003c  1000000) {   // 1,000,000\n    if (u \u003e= 100000) goto lt1_000_000;\n    digits = u / 10000;  //    10,000\n    *buffer++ = '0' + digits;\n    goto sublt10_000;\n  }\n  if (u  \u003c  100000000) {   // 100,000,000\n    if (u \u003e= 10000000) goto lt100_000_000;\n    digits = u / 1000000;  //   1,000,000\n    *buffer++ = '0' + digits;\n    goto sublt1_000_000;\n  }\n  // we already know that u \u003c 1,000,000,000\n  digits = u / 100000000;   // 100,000,000\n  *buffer++ = '0' + digits;\n  goto sublt100_000_000;\n}","filepath":"src/google/protobuf/stubs/strutil.cc","line_number":920,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-alpha-3"},"270820048":{"score":0.62701476,"function_name":"FastUInt64ToBufferLeft","code":"char* FastUInt64ToBufferLeft(uint64 u64, char* buffer) {\n  int digits;\n  const char *ASCII_digits = NULL;\n\n  uint32 u = static_cast\u003cuint32\u003e(u64);\n  if (u == u64) return FastUInt32ToBufferLeft(u, buffer);\n\n  uint64 top_11_digits = u64 / 1000000000;\n  buffer = FastUInt64ToBufferLeft(top_11_digits, buffer);\n  u = u64 - (top_11_digits * 1000000000);\n\n  digits = u / 10000000;  // 10,000,000\n  GOOGLE_DCHECK_LT(digits, 100);\n  ASCII_digits = two_ASCII_digits[digits];\n  buffer[0] = ASCII_digits[0];\n  buffer[1] = ASCII_digits[1];\n  buffer += 2;\n  u -= digits * 10000000;  // 10,000,000\n  digits = u / 100000;  // 100,000\n  ASCII_digits = two_ASCII_digits[digits];\n  buffer[0] = ASCII_digits[0];\n  buffer[1] = ASCII_digits[1];\n  buffer += 2;\n  u -= digits * 100000;  // 100,000\n  digits = u / 1000;  // 1,000\n  ASCII_digits = two_ASCII_digits[digits];\n  buffer[0] = ASCII_digits[0];\n  buffer[1] = ASCII_digits[1];\n  buffer += 2;\n  u -= digits * 1000;  // 1,000\n  digits = u / 10;\n  ASCII_digits = two_ASCII_digits[digits];\n  buffer[0] = ASCII_digits[0];\n  buffer[1] = ASCII_digits[1];\n  buffer += 2;\n  u -= digits * 10;\n  digits = u;\n  *buffer++ = '0' + digits;\n  *buffer = 0;\n  return buffer;\n}","filepath":"src/google/protobuf/stubs/strutil.cc","line_number":1011,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-alpha-3"},"270820320":{"score":0.7764324,"function_name":"FloatToBuffer","code":"char* FloatToBuffer(float value, char* buffer) {\n  // FLT_DIG is 6 for IEEE-754 floats, which are used on almost all\n  // platforms these days.  Just in case some system exists where FLT_DIG\n  // is significantly larger -- and risks overflowing our buffer -- we have\n  // this assert.\n  GOOGLE_COMPILE_ASSERT(FLT_DIG \u003c 10, FLT_DIG_is_too_big);\n\n  if (value == numeric_limits\u003cdouble\u003e::infinity()) {\n    strcpy(buffer, \"inf\");\n    return buffer;\n  } else if (value == -numeric_limits\u003cdouble\u003e::infinity()) {\n    strcpy(buffer, \"-inf\");\n    return buffer;\n  } else if (IsNaN(value)) {\n    strcpy(buffer, \"nan\");\n    return buffer;\n  }\n\n  int snprintf_result =\n    snprintf(buffer, kFloatToBufferSize, \"%.*g\", FLT_DIG, value);\n\n  // The snprintf should never overflow because the buffer is significantly\n  // larger than the precision we asked for.\n  GOOGLE_DCHECK(snprintf_result \u003e 0 \u0026\u0026 snprintf_result \u003c kFloatToBufferSize);\n\n  float parsed_value;\n  if (!safe_strtof(buffer, \u0026parsed_value) || parsed_value != value) {\n    int snprintf_result =\n      snprintf(buffer, kFloatToBufferSize, \"%.*g\", FLT_DIG+2, value);\n\n    // Should never overflow; see above.\n    GOOGLE_DCHECK(snprintf_result \u003e 0 \u0026\u0026 snprintf_result \u003c kFloatToBufferSize);\n  }\n\n  DelocalizeRadix(buffer);\n  return buffer;\n}","filepath":"src/google/protobuf/stubs/strutil.cc","line_number":1250,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-alpha-3"},"270821744":{"score":0.6679646,"function_name":"StrCat","code":"string StrCat(const AlphaNum \u0026a, const AlphaNum \u0026b, const AlphaNum \u0026c,\n              const AlphaNum \u0026d, const AlphaNum \u0026e, const AlphaNum \u0026f,\n              const AlphaNum \u0026g) {\n  string result;\n  result.resize(a.size() + b.size() + c.size() + d.size() + e.size() +\n                f.size() + g.size());\n  char *const begin = \u0026*result.begin();\n  char *out = Append4(begin, a, b, c, d);\n  out = Append2(out, e, f);\n  out = Append1(out, g);\n  GOOGLE_DCHECK_EQ(out, begin + result.size());\n  return result;\n}","filepath":"src/google/protobuf/stubs/strutil.cc","line_number":1402,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-alpha-3"},"270822064":{"score":0.6220472,"function_name":"StrCat","code":"string StrCat(const AlphaNum \u0026a, const AlphaNum \u0026b, const AlphaNum \u0026c) {\n  string result;\n  result.resize(a.size() + b.size() + c.size());\n  char *const begin = \u0026*result.begin();\n  char *out = Append2(begin, a, b);\n  out = Append1(out, c);\n  GOOGLE_DCHECK_EQ(out, begin + result.size());\n  return result;\n}","filepath":"src/google/protobuf/stubs/strutil.cc","line_number":1359,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-alpha-3"},"270822352":{"score":0.6041257,"function_name":"StrCat","code":"string StrCat(const AlphaNum \u0026a, const AlphaNum \u0026b) {\n  string result;\n  result.resize(a.size() + b.size());\n  char *const begin = \u0026*result.begin();\n  char *out = Append2(begin, a, b);\n  GOOGLE_DCHECK_EQ(out, begin + result.size());\n  return result;\n}","filepath":"src/google/protobuf/stubs/strutil.cc","line_number":1350,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-alpha-3"},"270822608":{"score":0.7977743,"function_name":"StripWhitespace","code":"void StripWhitespace(string* str) {\n  int str_length = str-\u003elength();\n\n  // Strip off leading whitespace.\n  int first = 0;\n  while (first \u003c str_length \u0026\u0026 ascii_isspace(str-\u003eat(first))) {\n    ++first;\n  }\n  // If entire string is white space.\n  if (first == str_length) {\n    str-\u003eclear();\n    return;\n  }\n  if (first \u003e 0) {\n    str-\u003eerase(0, first);\n    str_length -= first;\n  }\n\n  // Strip off trailing whitespace.\n  int last = str_length - 1;\n  while (last \u003e= 0 \u0026\u0026 ascii_isspace(str-\u003eat(last))) {\n    --last;\n  }\n  if (last != (str_length - 1) \u0026\u0026 last \u003e= 0) {\n    str-\u003eerase(last + 1, string::npos);\n  }\n}","filepath":"src/google/protobuf/stubs/strutil.cc","line_number":97,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-alpha-3"},"270823568":{"score":0.66675806,"function_name":"Utf8SafeCEscape","code":"string Utf8SafeCEscape(const string\u0026 src) {\n  const int dest_length = src.size() * 4 + 1; // Maximum possible expansion\n  scoped_array\u003cchar\u003e dest(new char[dest_length]);\n  const int len = CEscapeInternal(src.data(), src.size(),\n                                  dest.get(), dest_length, false, true);\n  GOOGLE_DCHECK_GE(len, 0);\n  return string(dest.get(), len);\n}","filepath":"src/google/protobuf/stubs/strutil.cc","line_number":564,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-alpha-3"},"270824144":{"score":0.89654267,"function_name":"safe_strtof","code":"bool safe_strtof(const char* str, float* value) {\n  char* endptr;\n  errno = 0;  // errno only gets set on errors\n#if defined(_WIN32) || defined (__hpux)  // has no strtof()\n  *value = strtod(str, \u0026endptr);\n#else\n  *value = strtof(str, \u0026endptr);\n#endif\n  return *str != 0 \u0026\u0026 *endptr == 0 \u0026\u0026 errno == 0;\n}","filepath":"src/google/protobuf/stubs/strutil.cc","line_number":1239,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-alpha-3"},"270883392":{"score":0.744798,"function_name":"ExtensionSet::FindExtension","code":"bool ExtensionSet::FindExtension(int wire_type, uint32_t field,\n                                 const Message* containing_type,\n                                 const internal::ParseContext* ctx,\n                                 ExtensionInfo* extension,\n                                 bool* was_packed_on_wire) {\n  if (ctx-\u003edata().pool == nullptr) {\n    GeneratedExtensionFinder finder(containing_type);\n    if (!FindExtensionInfoFromFieldNumber(wire_type, field, \u0026finder, extension,\n                                          was_packed_on_wire)) {\n      return false;\n    }\n  } else {\n    DescriptorPoolExtensionFinder finder(ctx-\u003edata().pool, ctx-\u003edata().factory,\n                                         containing_type-\u003eGetDescriptor());\n    if (!FindExtensionInfoFromFieldNumber(wire_type, field, \u0026finder, extension,\n                                          was_packed_on_wire)) {\n      return false;\n    }\n  }\n  return true;\n}","filepath":"src/google/protobuf/extension_set_heavy.cc","line_number":305,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v21.0-rc1"},"270883664":{"score":0.55005217,"function_name":"ExtensionSet::GetMessage","code":"const MessageLite\u0026 ExtensionSet::GetMessage(int number,\n                                            const Descriptor* message_type,\n                                            MessageFactory* factory) const {\n  const Extension* extension = FindOrNull(number);\n  if (extension == nullptr || extension-\u003eis_cleared) {\n    // Not present.  Return the default value.\n    return *factory-\u003eGetPrototype(message_type);\n  } else {\n    GOOGLE_DCHECK_TYPE(*extension, OPTIONAL, MESSAGE);\n    if (extension-\u003eis_lazy) {\n      return extension-\u003elazymessage_value-\u003eGetMessage(\n          *factory-\u003eGetPrototype(message_type), arena_);\n    } else {\n      return *extension-\u003emessage_value;\n    }\n  }\n}","filepath":"src/google/protobuf/extension_set_heavy.cc","line_number":126,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v21.0-rc1"},"270884256":{"score":0.7311468,"function_name":"ExtensionSet::ParseField","code":"const char* ExtensionSet::ParseField(uint64_t tag, const char* ptr,\n                                     const Message* containing_type,\n                                     internal::InternalMetadata* metadata,\n                                     internal::ParseContext* ctx) {\n  int number = tag \u003e\u003e 3;\n  bool was_packed_on_wire;\n  ExtensionInfo extension;\n  if (!FindExtension(tag \u0026 7, number, containing_type, ctx, \u0026extension,\n                     \u0026was_packed_on_wire)) {\n    return UnknownFieldParse(\n        tag, metadata-\u003emutable_unknown_fields\u003cUnknownFieldSet\u003e(), ptr, ctx);\n  }\n  return ParseFieldWithExtensionInfo\u003cUnknownFieldSet\u003e(\n      number, was_packed_on_wire, extension, metadata, ptr, ctx);\n}","filepath":"src/google/protobuf/extension_set_heavy.cc","line_number":327,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v21.0-rc1"},"270884528":{"score":0.76727515,"function_name":"ExtensionSet::Extension::SpaceUsedExcludingSelfLong","code":"size_t ExtensionSet::Extension::SpaceUsedExcludingSelfLong() const {\n  size_t total_size = 0;\n  if (is_repeated) {\n    switch (cpp_type(type)) {\n#define HANDLE_TYPE(UPPERCASE, LOWERCASE)                                     \\\n  case FieldDescriptor::CPPTYPE_##UPPERCASE:                                  \\\n    total_size += sizeof(*repeated_##LOWERCASE##_value) +                     \\\n                  repeated_##LOWERCASE##_value-\u003eSpaceUsedExcludingSelfLong(); \\\n    break\n\n      HANDLE_TYPE(INT32, int32_t);\n      HANDLE_TYPE(INT64, int64_t);\n      HANDLE_TYPE(UINT32, uint32_t);\n      HANDLE_TYPE(UINT64, uint64_t);\n      HANDLE_TYPE(FLOAT, float);\n      HANDLE_TYPE(DOUBLE, double);\n      HANDLE_TYPE(BOOL, bool);\n      HANDLE_TYPE(ENUM, enum);\n      HANDLE_TYPE(STRING, string);\n#undef HANDLE_TYPE\n\n      case FieldDescriptor::CPPTYPE_MESSAGE:\n        // repeated_message_value is actually a RepeatedPtrField\u003cMessageLite\u003e,\n        // but MessageLite has no SpaceUsedLong(), so we must directly call\n        // RepeatedPtrFieldBase::SpaceUsedExcludingSelfLong() with a different\n        // type handler.\n        total_size += sizeof(*repeated_message_value) +\n                      RepeatedMessage_SpaceUsedExcludingSelfLong(\n                          reinterpret_cast\u003cinternal::RepeatedPtrFieldBase*\u003e(\n                              repeated_message_value));\n        break;\n    }\n  } else {\n    switch (cpp_type(type)) {\n      case FieldDescriptor::CPPTYPE_STRING:\n        total_size += sizeof(*string_value) +\n                      StringSpaceUsedExcludingSelfLong(*string_value);\n        break;\n      case FieldDescriptor::CPPTYPE_MESSAGE:\n        if (is_lazy) {\n          total_size += lazymessage_value-\u003eSpaceUsedLong();\n        } else {\n          total_size += down_cast\u003cMessage*\u003e(message_value)-\u003eSpaceUsedLong();\n        }\n        break;\n      default:\n        // No extra storage costs for primitive types.\n        break;\n    }\n  }\n  return total_size;\n}","filepath":"src/google/protobuf/extension_set_heavy.cc","line_number":374,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v21.0-rc1"},"270884832":{"score":0.58634865,"function_name":"ExtensionSet::UnsafeArenaReleaseMessage","code":"MessageLite* ExtensionSet::UnsafeArenaReleaseMessage(\n    const FieldDescriptor* descriptor, MessageFactory* factory) {\n  Extension* extension = FindOrNull(descriptor-\u003enumber());\n  if (extension == nullptr) {\n    // Not present.  Return nullptr.\n    return nullptr;\n  } else {\n    GOOGLE_DCHECK_TYPE(*extension, OPTIONAL, MESSAGE);\n    MessageLite* ret = nullptr;\n    if (extension-\u003eis_lazy) {\n      ret = extension-\u003elazymessage_value-\u003eUnsafeArenaReleaseMessage(\n          *factory-\u003eGetPrototype(descriptor-\u003emessage_type()), arena_);\n      if (arena_ == nullptr) {\n        delete extension-\u003elazymessage_value;\n      }\n    } else {\n      ret = extension-\u003emessage_value;\n    }\n    Erase(descriptor-\u003enumber());\n    return ret;\n  }\n}","filepath":"src/google/protobuf/extension_set_heavy.cc","line_number":198,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v21.0-rc1"},"271011712":{"score":0.64812946,"function_name":"Tokenizer::TryConsumeOne","code":"inline bool Tokenizer::TryConsumeOne() {\n  if (CharacterClass::InClass(current_char_)) {\n    NextChar();\n    return true;\n  } else {\n    return false;\n  }\n}","filepath":"src/google/protobuf/io/tokenizer.cc","line_number":313,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-beta-3-pre-1"},"271012304":{"score":0.8907424,"function_name":"AppendUTF8","code":"static void AppendUTF8(uint32 code_point, string* output) {\n  uint32 tmp = 0;\n  int len = 0;\n  if (code_point \u003c= 0x7f) {\n    tmp = code_point;\n    len = 1;\n  } else if (code_point \u003c= 0x07ff) {\n    tmp = 0x0000c080 |\n        ((code_point \u0026 0x07c0) \u003c\u003c 2) |\n        (code_point \u0026 0x003f);\n    len = 2;\n  } else if (code_point \u003c= 0xffff) {\n    tmp = 0x00e08080 |\n        ((code_point \u0026 0xf000) \u003c\u003c 4) |\n        ((code_point \u0026 0x0fc0) \u003c\u003c 2) |\n        (code_point \u0026 0x003f);\n    len = 3;\n  } else if (code_point \u003c= 0x1fffff) {\n    tmp = 0xf0808080 |\n        ((code_point \u0026 0x1c0000) \u003c\u003c 6) |\n        ((code_point \u0026 0x03f000) \u003c\u003c 4) |\n        ((code_point \u0026 0x000fc0) \u003c\u003c 2) |\n        (code_point \u0026 0x003f);\n    len = 4;\n  } else {\n    // UTF-16 is only defined for code points up to 0x10FFFF, and UTF-8 is\n    // normally only defined up to there as well.\n    StringAppendF(output, \"\\\\U%08x\", code_point);\n    return;\n  }\n  tmp = ghtonl(tmp);\n  output-\u003eappend(reinterpret_cast\u003cconst char*\u003e(\u0026tmp) + sizeof(tmp) - len, len);\n}","filepath":"src/google/protobuf/io/tokenizer.cc","line_number":927,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-beta-3-pre-1"},"271012512":{"score":0.7112274,"function_name":"Tokenizer::ConsumeBlockComment","code":"void Tokenizer::ConsumeBlockComment(string* content) {\n  int start_line = line_;\n  int start_column = column_ - 2;\n\n  if (content != NULL) RecordTo(content);\n\n  while (true) {\n    while (current_char_ != '\\0' \u0026\u0026\n           current_char_ != '*' \u0026\u0026\n           current_char_ != '/' \u0026\u0026\n           current_char_ != '\\n') {\n      NextChar();\n    }\n\n    if (TryConsume('\\n')) {\n      if (content != NULL) StopRecording();\n\n      // Consume leading whitespace and asterisk;\n      ConsumeZeroOrMore\u003cWhitespaceNoNewline\u003e();\n      if (TryConsume('*')) {\n        if (TryConsume('/')) {\n          // End of comment.\n          break;\n        }\n      }\n\n      if (content != NULL) RecordTo(content);\n    } else if (TryConsume('*') \u0026\u0026 TryConsume('/')) {\n      // End of comment.\n      if (content != NULL) {\n        StopRecording();\n        // Strip trailing \"*/\".\n        content-\u003eerase(content-\u003esize() - 2);\n      }\n      break;\n    } else if (TryConsume('/') \u0026\u0026 current_char_ == '*') {\n      // Note:  We didn't consume the '*' because if there is a '/' after it\n      //   we want to interpret that as the end of the comment.\n      AddError(\n        \"\\\"/*\\\" inside block comment.  Block comments cannot be nested.\");\n    } else if (current_char_ == '\\0') {\n      AddError(\"End-of-file inside block comment.\");\n      error_collector_-\u003eAddError(\n        start_line, start_column, \"  Comment started here.\");\n      if (content != NULL) StopRecording();\n      break;\n    }\n  }\n}","filepath":"src/google/protobuf/io/tokenizer.cc","line_number":488,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-beta-3-pre-1"},"271013520":{"score":0.7271257,"function_name":"Tokenizer::ConsumeLineComment","code":"void Tokenizer::ConsumeLineComment(string* content) {\n  if (content != NULL) RecordTo(content);\n\n  while (current_char_ != '\\0' \u0026\u0026 current_char_ != '\\n') {\n    NextChar();\n  }\n  TryConsume('\\n');\n\n  if (content != NULL) StopRecording();\n}","filepath":"src/google/protobuf/io/tokenizer.cc","line_number":477,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-beta-3-pre-1"},"271013696":{"score":0.6842226,"function_name":"Tokenizer::ConsumeNumber","code":"Tokenizer::TokenType Tokenizer::ConsumeNumber(bool started_with_zero,\n                                              bool started_with_dot) {\n  bool is_float = false;\n\n  if (started_with_zero \u0026\u0026 (TryConsume('x') || TryConsume('X'))) {\n    // A hex number (started with \"0x\").\n    ConsumeOneOrMore\u003cHexDigit\u003e(\"\\\"0x\\\" must be followed by hex digits.\");\n\n  } else if (started_with_zero \u0026\u0026 LookingAt\u003cDigit\u003e()) {\n    // An octal number (had a leading zero).\n    ConsumeZeroOrMore\u003cOctalDigit\u003e();\n    if (LookingAt\u003cDigit\u003e()) {\n      AddError(\"Numbers starting with leading zero must be in octal.\");\n      ConsumeZeroOrMore\u003cDigit\u003e();\n    }\n\n  } else {\n    // A decimal number.\n    if (started_with_dot) {\n      is_float = true;\n      ConsumeZeroOrMore\u003cDigit\u003e();\n    } else {\n      ConsumeZeroOrMore\u003cDigit\u003e();\n\n      if (TryConsume('.')) {\n        is_float = true;\n        ConsumeZeroOrMore\u003cDigit\u003e();\n      }\n    }\n\n    if (TryConsume('e') || TryConsume('E')) {\n      is_float = true;\n      TryConsume('-') || TryConsume('+');\n      ConsumeOneOrMore\u003cDigit\u003e(\"\\\"e\\\" must be followed by exponent.\");\n    }\n\n    if (allow_f_after_float_ \u0026\u0026 (TryConsume('f') || TryConsume('F'))) {\n      is_float = true;\n    }\n  }\n\n  if (LookingAt\u003cLetter\u003e() \u0026\u0026 require_space_after_number_) {\n    AddError(\"Need space between number and identifier.\");\n  } else if (current_char_ == '.') {\n    if (is_float) {\n      AddError(\n        \"Already saw decimal point or exponent; can't have another one.\");\n    } else {\n      AddError(\"Hex and octal numbers must be integers.\");\n    }\n  }\n\n  return is_float ? TYPE_FLOAT : TYPE_INTEGER;\n}","filepath":"src/google/protobuf/io/tokenizer.cc","line_number":422,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-beta-3-pre-1"},"271014192":{"score":0.6997511,"function_name":"Tokenizer::ConsumeString","code":"void Tokenizer::ConsumeString(char delimiter) {\n  while (true) {\n    switch (current_char_) {\n      case '\\0':\n        AddError(\"Unexpected end of string.\");\n        return;\n\n      case '\\n': {\n        if (!allow_multiline_strings_) {\n          AddError(\"String literals cannot cross line boundaries.\");\n          return;\n        }\n        NextChar();\n        break;\n      }\n\n      case '\\\\': {\n        // An escape sequence.\n        NextChar();\n        if (TryConsumeOne\u003cEscape\u003e()) {\n          // Valid escape sequence.\n        } else if (TryConsumeOne\u003cOctalDigit\u003e()) {\n          // Possibly followed by two more octal digits, but these will\n          // just be consumed by the main loop anyway so we don't need\n          // to do so explicitly here.\n        } else if (TryConsume('x')) {\n          if (!TryConsumeOne\u003cHexDigit\u003e()) {\n            AddError(\"Expected hex digits for escape sequence.\");\n          }\n          // Possibly followed by another hex digit, but again we don't care.\n        } else if (TryConsume('u')) {\n          if (!TryConsumeOne\u003cHexDigit\u003e() ||\n              !TryConsumeOne\u003cHexDigit\u003e() ||\n              !TryConsumeOne\u003cHexDigit\u003e() ||\n              !TryConsumeOne\u003cHexDigit\u003e()) {\n            AddError(\"Expected four hex digits for \\\\u escape sequence.\");\n          }\n        } else if (TryConsume('U')) {\n          // We expect 8 hex digits; but only the range up to 0x10ffff is\n          // legal.\n          if (!TryConsume('0') ||\n              !TryConsume('0') ||\n              !(TryConsume('0') || TryConsume('1')) ||\n              !TryConsumeOne\u003cHexDigit\u003e() ||\n              !TryConsumeOne\u003cHexDigit\u003e() ||\n              !TryConsumeOne\u003cHexDigit\u003e() ||\n              !TryConsumeOne\u003cHexDigit\u003e() ||\n              !TryConsumeOne\u003cHexDigit\u003e()) {\n            AddError(\"Expected eight hex digits up to 10ffff for \\\\U escape \"\n                     \"sequence\");\n          }\n        } else {\n          AddError(\"Invalid escape sequence in string literal.\");\n        }\n        break;\n      }\n\n      default: {\n        if (current_char_ == delimiter) {\n          NextChar();\n          return;\n        }\n        NextChar();\n        break;\n      }\n    }\n  }\n}","filepath":"src/google/protobuf/io/tokenizer.cc","line_number":353,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-beta-3-pre-1"},"271015216":{"score":0.8761368,"function_name":"FetchUnicodePoint","code":"static const char* FetchUnicodePoint(const char* ptr, uint32* code_point) {\n  const char* p = ptr;\n  // Fetch the code point.\n  const int len = UnicodeLength(*p++);\n  if (!ReadHexDigits(p, len, code_point))\n    return ptr;\n  p += len;\n\n  // Check if the code point we read is a \"head surrogate.\" If so, then we\n  // expect it to be immediately followed by another code point which is a valid\n  // \"trail surrogate,\" and together they form a UTF-16 pair which decodes into\n  // a single Unicode point. Trail surrogates may only use \\u, not \\U.\n  if (IsHeadSurrogate(*code_point) \u0026\u0026 *p == '\\\\' \u0026\u0026 *(p + 1) == 'u') {\n    uint32 trail_surrogate;\n    if (ReadHexDigits(p + 2, 4, \u0026trail_surrogate) \u0026\u0026\n        IsTrailSurrogate(trail_surrogate)) {\n      *code_point = AssembleUTF16(*code_point, trail_surrogate);\n      p += 6;\n    }\n    // If this failed, then we just emit the head surrogate as a code point.\n    // It's bogus, but so is the string.\n  }\n\n  return p;\n}","filepath":"src/google/protobuf/io/tokenizer.cc","line_number":1011,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-beta-3-pre-1"},"271017120":{"score":0.8584248,"function_name":"Tokenizer::NextChar","code":"void Tokenizer::NextChar() {\n  // Update our line and column counters based on the character being\n  // consumed.\n  if (current_char_ == '\\n') {\n    ++line_;\n    column_ = 0;\n  } else if (current_char_ == '\\t') {\n    column_ += kTabWidth - column_ % kTabWidth;\n  } else {\n    ++column_;\n  }\n\n  // Advance to the next character.\n  ++buffer_pos_;\n  if (buffer_pos_ \u003c buffer_size_) {\n    current_char_ = buffer_[buffer_pos_];\n  } else {\n    Refresh();\n  }\n}","filepath":"src/google/protobuf/io/tokenizer.cc","line_number":223,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-beta-3-pre-1"},"271017216":{"score":0.82276624,"function_name":"Tokenizer::ParseFloat","code":"double Tokenizer::ParseFloat(const string\u0026 text) {\n  const char* start = text.c_str();\n  char* end;\n  double result = NoLocaleStrtod(start, \u0026end);\n\n  // \"1e\" is not a valid float, but if the tokenizer reads it, it will\n  // report an error but still return it as a valid token.  We need to\n  // accept anything the tokenizer could possibly return, error or not.\n  if (*end == 'e' || *end == 'E') {\n    ++end;\n    if (*end == '-' || *end == '+') ++end;\n  }\n\n  // If the Tokenizer had allow_f_after_float_ enabled, the float may be\n  // suffixed with the letter 'f'.\n  if (*end == 'f' || *end == 'F') {\n    ++end;\n  }\n\n  GOOGLE_LOG_IF(DFATAL, end - start != text.size() || *start == '-')\n    \u003c\u003c \" Tokenizer::ParseFloat() passed text that could not have been\"\n       \" tokenized as a float: \" \u003c\u003c CEscape(text);\n  return result;\n}","filepath":"src/google/protobuf/io/tokenizer.cc","line_number":900,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-beta-3-pre-1"},"271017536":{"score":0.8016536,"function_name":"Tokenizer::ParseInteger","code":"bool Tokenizer::ParseInteger(const string\u0026 text, uint64 max_value,\n                             uint64* output) {\n  // Sadly, we can't just use strtoul() since it is only 32-bit and strtoull()\n  // is non-standard.  I hate the C standard library.  :(\n\n//  return strtoull(text.c_str(), NULL, 0);\n\n  const char* ptr = text.c_str();\n  int base = 10;\n  if (ptr[0] == '0') {\n    if (ptr[1] == 'x' || ptr[1] == 'X') {\n      // This is hex.\n      base = 16;\n      ptr += 2;\n    } else {\n      // This is octal.\n      base = 8;\n    }\n  }\n\n  uint64 result = 0;\n  for (; *ptr != '\\0'; ptr++) {\n    int digit = DigitValue(*ptr);\n    if (digit \u003c 0 || digit \u003e= base) {\n      // The token provided by Tokenizer is invalid. i.e., 099 is an invalid\n      // token, but Tokenizer still think it's integer.\n      return false;\n    }\n    if (digit \u003e max_value || result \u003e (max_value - digit) / base) {\n      // Overflow.\n      return false;\n    }\n    result = result * base + digit;\n  }\n\n  *output = result;\n  return true;\n}","filepath":"src/google/protobuf/io/tokenizer.cc","line_number":861,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-beta-3-pre-1"},"271017824":{"score":0.8126652,"function_name":"Tokenizer::ParseStringAppend","code":"void Tokenizer::ParseStringAppend(const string\u0026 text, string* output) {\n  // Reminder: text[0] is always a quote character.  (If text is\n  // empty, it's invalid, so we'll just return).\n  const size_t text_size = text.size();\n  if (text_size == 0) {\n    GOOGLE_LOG(DFATAL)\n      \u003c\u003c \" Tokenizer::ParseStringAppend() passed text that could not\"\n         \" have been tokenized as a string: \" \u003c\u003c CEscape(text);\n    return;\n  }\n\n  // Reserve room for new string. The branch is necessary because if\n  // there is already space available the reserve() call might\n  // downsize the output.\n  const size_t new_len = text_size + output-\u003esize();\n  if (new_len \u003e output-\u003ecapacity()) {\n    output-\u003ereserve(new_len);\n  }\n\n  // Loop through the string copying characters to \"output\" and\n  // interpreting escape sequences.  Note that any invalid escape\n  // sequences or other errors were already reported while tokenizing.\n  // In this case we do not need to produce valid results.\n  for (const char* ptr = text.c_str() + 1; *ptr != '\\0'; ptr++) {\n    if (*ptr == '\\\\' \u0026\u0026 ptr[1] != '\\0') {\n      // An escape sequence.\n      ++ptr;\n\n      if (OctalDigit::InClass(*ptr)) {\n        // An octal escape.  May one, two, or three digits.\n        int code = DigitValue(*ptr);\n        if (OctalDigit::InClass(ptr[1])) {\n          ++ptr;\n          code = code * 8 + DigitValue(*ptr);\n        }\n        if (OctalDigit::InClass(ptr[1])) {\n          ++ptr;\n          code = code * 8 + DigitValue(*ptr);\n        }\n        output-\u003epush_back(static_cast\u003cchar\u003e(code));\n\n      } else if (*ptr == 'x') {\n        // A hex escape.  May zero, one, or two digits.  (The zero case\n        // will have been caught as an error earlier.)\n        int code = 0;\n        if (HexDigit::InClass(ptr[1])) {\n          ++ptr;\n          code = DigitValue(*ptr);\n        }\n        if (HexDigit::InClass(ptr[1])) {\n          ++ptr;\n          code = code * 16 + DigitValue(*ptr);\n        }\n        output-\u003epush_back(static_cast\u003cchar\u003e(code));\n\n      } else if (*ptr == 'u' || *ptr == 'U') {\n        uint32 unicode;\n        const char* end = FetchUnicodePoint(ptr, \u0026unicode);\n        if (end == ptr) {\n          // Failure: Just dump out what we saw, don't try to parse it.\n          output-\u003epush_back(*ptr);\n        } else {\n          AppendUTF8(unicode, output);\n          ptr = end - 1;  // Because we're about to ++ptr.\n        }\n      } else {\n        // Some other escape code.\n        output-\u003epush_back(TranslateEscape(*ptr));\n      }\n\n    } else if (*ptr == text[0] \u0026\u0026 ptr[1] == '\\0') {\n      // Ignore final quote matching the starting quote.\n    } else {\n      output-\u003epush_back(*ptr);\n    }\n  }\n}","filepath":"src/google/protobuf/io/tokenizer.cc","line_number":1039,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-beta-3-pre-1"},"271018464":{"score":0.9477642,"function_name":"ReadHexDigits","code":"static bool ReadHexDigits(const char* ptr, int len, uint32* result) {\n  *result = 0;\n  if (len == 0) return false;\n  for (const char* end = ptr + len; ptr \u003c end; ++ptr) {\n    if (*ptr == '\\0') return false;\n    *result = (*result \u003c\u003c 4) + DigitValue(*ptr);\n  }\n  return true;\n}","filepath":"src/google/protobuf/io/tokenizer.cc","line_number":963,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-beta-3-pre-1"},"271018592":{"score":0.8886712,"function_name":"Tokenizer::Refresh","code":"void Tokenizer::Refresh() {\n  if (read_error_) {\n    current_char_ = '\\0';\n    return;\n  }\n\n  // If we're in a token, append the rest of the buffer to it.\n  if (record_target_ != NULL \u0026\u0026 record_start_ \u003c buffer_size_) {\n    record_target_-\u003eappend(buffer_ + record_start_, buffer_size_ - record_start_);\n    record_start_ = 0;\n  }\n\n  const void* data = NULL;\n  buffer_ = NULL;\n  buffer_pos_ = 0;\n  do {\n    if (!input_-\u003eNext(\u0026data, \u0026buffer_size_)) {\n      // end of stream (or read error)\n      buffer_size_ = 0;\n      read_error_ = true;\n      current_char_ = '\\0';\n      return;\n    }\n  } while (buffer_size_ == 0);\n\n  buffer_ = static_cast\u003cconst char*\u003e(data);\n\n  current_char_ = buffer_[0];\n}","filepath":"src/google/protobuf/io/tokenizer.cc","line_number":244,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-beta-3-pre-1"},"271018752":{"score":0.9383513,"function_name":"TranslateEscape","code":"inline char TranslateEscape(char c) {\n  switch (c) {\n    case 'a':  return '\\a';\n    case 'b':  return '\\b';\n    case 'f':  return '\\f';\n    case 'n':  return '\\n';\n    case 'r':  return '\\r';\n    case 't':  return '\\t';\n    case 'v':  return '\\v';\n    case '\\\\': return '\\\\';\n    case '?':  return '\\?';    // Trigraphs = :(\n    case '\\'': return '\\'';\n    case '\"':  return '\\\"';\n\n    // We expect escape sequences to have been validated separately.\n    default:   return '?';\n  }\n}","filepath":"src/google/protobuf/io/tokenizer.cc","line_number":162,"entry_url":"https://github.com/protocolbuffers/protobuf.git","slot_name":"v3.0.0-beta-3-pre-1"}}}